
Clean.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001bc  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000033ec  080001bc  080001bc  000101bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000a0  080035a8  080035a8  000135a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08003648  08003648  00013648  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800364c  0800364c  0001364c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000154  20000000  08003650  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000008f8  20000154  080037a4  00020154  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000a4c  080037a4  00020a4c  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00020154  2**0
                  CONTENTS, READONLY
  9 .debug_info   00015d6a  00000000  00000000  00020184  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003467  00000000  00000000  00035eee  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007214  00000000  00000000  00039355  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000bf0  00000000  00000000  00040570  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000c58  00000000  00000000  00041160  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000063ff  00000000  00000000  00041db8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000481d  00000000  00000000  000481b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007c  00000000  00000000  0004c9d4  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00001d04  00000000  00000000  0004ca50  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001bc <__do_global_dtors_aux>:
 80001bc:	b510      	push	{r4, lr}
 80001be:	4c05      	ldr	r4, [pc, #20]	; (80001d4 <__do_global_dtors_aux+0x18>)
 80001c0:	7823      	ldrb	r3, [r4, #0]
 80001c2:	b933      	cbnz	r3, 80001d2 <__do_global_dtors_aux+0x16>
 80001c4:	4b04      	ldr	r3, [pc, #16]	; (80001d8 <__do_global_dtors_aux+0x1c>)
 80001c6:	b113      	cbz	r3, 80001ce <__do_global_dtors_aux+0x12>
 80001c8:	4804      	ldr	r0, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x20>)
 80001ca:	f3af 8000 	nop.w
 80001ce:	2301      	movs	r3, #1
 80001d0:	7023      	strb	r3, [r4, #0]
 80001d2:	bd10      	pop	{r4, pc}
 80001d4:	20000154 	.word	0x20000154
 80001d8:	00000000 	.word	0x00000000
 80001dc:	08003590 	.word	0x08003590

080001e0 <frame_dummy>:
 80001e0:	b508      	push	{r3, lr}
 80001e2:	4b03      	ldr	r3, [pc, #12]	; (80001f0 <frame_dummy+0x10>)
 80001e4:	b11b      	cbz	r3, 80001ee <frame_dummy+0xe>
 80001e6:	4903      	ldr	r1, [pc, #12]	; (80001f4 <frame_dummy+0x14>)
 80001e8:	4803      	ldr	r0, [pc, #12]	; (80001f8 <frame_dummy+0x18>)
 80001ea:	f3af 8000 	nop.w
 80001ee:	bd08      	pop	{r3, pc}
 80001f0:	00000000 	.word	0x00000000
 80001f4:	20000158 	.word	0x20000158
 80001f8:	08003590 	.word	0x08003590

080001fc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80001fc:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 80001fe:	4b0a      	ldr	r3, [pc, #40]	; (8000228 <HAL_InitTick+0x2c>)
{
 8000200:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 8000202:	6818      	ldr	r0, [r3, #0]
 8000204:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000208:	fbb0 f0f3 	udiv	r0, r0, r3
 800020c:	f000 f88c 	bl	8000328 <HAL_SYSTICK_Config>
 8000210:	4604      	mov	r4, r0
 8000212:	b938      	cbnz	r0, 8000224 <HAL_InitTick+0x28>
    status = HAL_ERROR;
  }
  else
  {
    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
 8000214:	4602      	mov	r2, r0
 8000216:	4629      	mov	r1, r5
 8000218:	f04f 30ff 	mov.w	r0, #4294967295
 800021c:	f000 f844 	bl	80002a8 <HAL_NVIC_SetPriority>
 8000220:	4620      	mov	r0, r4
 8000222:	bd38      	pop	{r3, r4, r5, pc}
    status = HAL_ERROR;
 8000224:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8000226:	bd38      	pop	{r3, r4, r5, pc}
 8000228:	200000d8 	.word	0x200000d8

0800022c <HAL_Init>:
{
 800022c:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800022e:	2003      	movs	r0, #3
 8000230:	f000 f828 	bl	8000284 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000234:	2000      	movs	r0, #0
 8000236:	f7ff ffe1 	bl	80001fc <HAL_InitTick>
 800023a:	4604      	mov	r4, r0
 800023c:	b918      	cbnz	r0, 8000246 <HAL_Init+0x1a>
    HAL_MspInit();
 800023e:	f002 fed9 	bl	8002ff4 <HAL_MspInit>
}
 8000242:	4620      	mov	r0, r4
 8000244:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8000246:	2401      	movs	r4, #1
 8000248:	e7fb      	b.n	8000242 <HAL_Init+0x16>
	...

0800024c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 800024c:	4a02      	ldr	r2, [pc, #8]	; (8000258 <HAL_IncTick+0xc>)
 800024e:	6813      	ldr	r3, [r2, #0]
 8000250:	3301      	adds	r3, #1
 8000252:	6013      	str	r3, [r2, #0]
 8000254:	4770      	bx	lr
 8000256:	bf00      	nop
 8000258:	200001a4 	.word	0x200001a4

0800025c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800025c:	4b01      	ldr	r3, [pc, #4]	; (8000264 <HAL_GetTick+0x8>)
 800025e:	6818      	ldr	r0, [r3, #0]
}
 8000260:	4770      	bx	lr
 8000262:	bf00      	nop
 8000264:	200001a4 	.word	0x200001a4

08000268 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000268:	b538      	push	{r3, r4, r5, lr}
 800026a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800026c:	f7ff fff6 	bl	800025c <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000270:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000272:	4605      	mov	r5, r0
  {
    wait++;
 8000274:	bf18      	it	ne
 8000276:	3401      	addne	r4, #1
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000278:	f7ff fff0 	bl	800025c <HAL_GetTick>
 800027c:	1b40      	subs	r0, r0, r5
 800027e:	4284      	cmp	r4, r0
 8000280:	d8fa      	bhi.n	8000278 <HAL_Delay+0x10>
  {
  }
}
 8000282:	bd38      	pop	{r3, r4, r5, pc}

08000284 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000284:	4a07      	ldr	r2, [pc, #28]	; (80002a4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000286:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000288:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800028c:	041b      	lsls	r3, r3, #16
 800028e:	0c1b      	lsrs	r3, r3, #16
 8000290:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000294:	0200      	lsls	r0, r0, #8
 8000296:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800029a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 800029e:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80002a0:	60d3      	str	r3, [r2, #12]
 80002a2:	4770      	bx	lr
 80002a4:	e000ed00 	.word	0xe000ed00

080002a8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80002a8:	4b17      	ldr	r3, [pc, #92]	; (8000308 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80002aa:	b530      	push	{r4, r5, lr}
 80002ac:	68dc      	ldr	r4, [r3, #12]
 80002ae:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80002b2:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80002b6:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80002b8:	2b04      	cmp	r3, #4
 80002ba:	bf28      	it	cs
 80002bc:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80002be:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80002c0:	f04f 0501 	mov.w	r5, #1
 80002c4:	fa05 f303 	lsl.w	r3, r5, r3
 80002c8:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80002cc:	bf8c      	ite	hi
 80002ce:	3c03      	subhi	r4, #3
 80002d0:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80002d2:	4019      	ands	r1, r3
 80002d4:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80002d6:	fa05 f404 	lsl.w	r4, r5, r4
 80002da:	3c01      	subs	r4, #1
 80002dc:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 80002de:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80002e0:	ea42 0201 	orr.w	r2, r2, r1
 80002e4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002e8:	bfaf      	iteee	ge
 80002ea:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002ee:	f000 000f 	andlt.w	r0, r0, #15
 80002f2:	4b06      	ldrlt	r3, [pc, #24]	; (800030c <HAL_NVIC_SetPriority+0x64>)
 80002f4:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002f6:	bfa5      	ittet	ge
 80002f8:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 80002fc:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002fe:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000300:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000304:	bd30      	pop	{r4, r5, pc}
 8000306:	bf00      	nop
 8000308:	e000ed00 	.word	0xe000ed00
 800030c:	e000ed14 	.word	0xe000ed14

08000310 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000310:	0942      	lsrs	r2, r0, #5
 8000312:	2301      	movs	r3, #1
 8000314:	f000 001f 	and.w	r0, r0, #31
 8000318:	fa03 f000 	lsl.w	r0, r3, r0
 800031c:	4b01      	ldr	r3, [pc, #4]	; (8000324 <HAL_NVIC_EnableIRQ+0x14>)
 800031e:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8000322:	4770      	bx	lr
 8000324:	e000e100 	.word	0xe000e100

08000328 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000328:	3801      	subs	r0, #1
 800032a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800032e:	d20a      	bcs.n	8000346 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000330:	4b06      	ldr	r3, [pc, #24]	; (800034c <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000332:	4a07      	ldr	r2, [pc, #28]	; (8000350 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000334:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000336:	21f0      	movs	r1, #240	; 0xf0
 8000338:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800033c:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800033e:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000340:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000346:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000348:	4770      	bx	lr
 800034a:	bf00      	nop
 800034c:	e000e010 	.word	0xe000e010
 8000350:	e000ed00 	.word	0xe000ed00

08000354 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000354:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000358:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800035c:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8000500 <HAL_GPIO_Init+0x1ac>
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000360:	4a65      	ldr	r2, [pc, #404]	; (80004f8 <HAL_GPIO_Init+0x1a4>)
  uint32_t position = 0x00u;
 8000362:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000364:	fa38 f403 	lsrs.w	r4, r8, r3
 8000368:	d102      	bne.n	8000370 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 800036a:	b003      	add	sp, #12
 800036c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8000370:	f04f 0e01 	mov.w	lr, #1
 8000374:	fa0e fe03 	lsl.w	lr, lr, r3
    if (iocurrent != 0x00u)
 8000378:	ea18 060e 	ands.w	r6, r8, lr
 800037c:	f000 80ab 	beq.w	80004d6 <HAL_GPIO_Init+0x182>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000380:	684c      	ldr	r4, [r1, #4]
 8000382:	f024 0710 	bic.w	r7, r4, #16
 8000386:	2f02      	cmp	r7, #2
 8000388:	d116      	bne.n	80003b8 <HAL_GPIO_Init+0x64>
        temp = GPIOx->AFR[position >> 3u];
 800038a:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 800038e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8000392:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3u];
 8000396:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800039a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800039e:	f04f 0c0f 	mov.w	ip, #15
 80003a2:	fa0c fc0b 	lsl.w	ip, ip, fp
 80003a6:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80003aa:	690d      	ldr	r5, [r1, #16]
 80003ac:	fa05 f50b 	lsl.w	r5, r5, fp
 80003b0:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3u] = temp;
 80003b4:	f8ca 5020 	str.w	r5, [sl, #32]
 80003b8:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80003bc:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 80003be:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80003c2:	fa05 f50a 	lsl.w	r5, r5, sl
 80003c6:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80003c8:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80003cc:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80003d0:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003d4:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80003d6:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003da:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 80003dc:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003e0:	d811      	bhi.n	8000406 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
 80003e2:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 80003e4:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2u));
 80003e8:	68cf      	ldr	r7, [r1, #12]
 80003ea:	fa07 fc0a 	lsl.w	ip, r7, sl
 80003ee:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 80003f2:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 80003f4:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80003f6:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 80003fa:	f3c4 1700 	ubfx	r7, r4, #4, #1
 80003fe:	409f      	lsls	r7, r3
 8000400:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000404:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000406:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8000408:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800040a:	688f      	ldr	r7, [r1, #8]
 800040c:	fa07 f70a 	lsl.w	r7, r7, sl
 8000410:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8000412:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000414:	00e5      	lsls	r5, r4, #3
 8000416:	d55e      	bpl.n	80004d6 <HAL_GPIO_Init+0x182>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000418:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 800041c:	f045 0501 	orr.w	r5, r5, #1
 8000420:	f8c9 5060 	str.w	r5, [r9, #96]	; 0x60
 8000424:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 8000428:	f023 0703 	bic.w	r7, r3, #3
 800042c:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8000430:	f005 0501 	and.w	r5, r5, #1
 8000434:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 8000438:	9501      	str	r5, [sp, #4]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800043a:	f003 0e03 	and.w	lr, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800043e:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 8000440:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8000444:	f04f 0c0f 	mov.w	ip, #15
 8000448:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800044c:	fa0c f50e 	lsl.w	r5, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8000450:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8000454:	ea2a 0c05 	bic.w	ip, sl, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8000458:	d03f      	beq.n	80004da <HAL_GPIO_Init+0x186>
 800045a:	4d28      	ldr	r5, [pc, #160]	; (80004fc <HAL_GPIO_Init+0x1a8>)
 800045c:	42a8      	cmp	r0, r5
 800045e:	d03e      	beq.n	80004de <HAL_GPIO_Init+0x18a>
 8000460:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000464:	42a8      	cmp	r0, r5
 8000466:	d03c      	beq.n	80004e2 <HAL_GPIO_Init+0x18e>
 8000468:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800046c:	42a8      	cmp	r0, r5
 800046e:	d03a      	beq.n	80004e6 <HAL_GPIO_Init+0x192>
 8000470:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000474:	42a8      	cmp	r0, r5
 8000476:	d038      	beq.n	80004ea <HAL_GPIO_Init+0x196>
 8000478:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800047c:	42a8      	cmp	r0, r5
 800047e:	d036      	beq.n	80004ee <HAL_GPIO_Init+0x19a>
 8000480:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000484:	42a8      	cmp	r0, r5
 8000486:	d034      	beq.n	80004f2 <HAL_GPIO_Init+0x19e>
 8000488:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800048c:	42a8      	cmp	r0, r5
 800048e:	bf14      	ite	ne
 8000490:	2508      	movne	r5, #8
 8000492:	2507      	moveq	r5, #7
 8000494:	fa05 f50e 	lsl.w	r5, r5, lr
 8000498:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2u] = temp;
 800049c:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 800049e:	6815      	ldr	r5, [r2, #0]
        temp &= ~(iocurrent);
 80004a0:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80004a2:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 80004a6:	bf0c      	ite	eq
 80004a8:	403d      	andeq	r5, r7
          temp |= iocurrent;
 80004aa:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 80004ac:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR1;
 80004ae:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80004b0:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 80004b4:	bf0c      	ite	eq
 80004b6:	403d      	andeq	r5, r7
          temp |= iocurrent;
 80004b8:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 80004ba:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR1;
 80004bc:	6895      	ldr	r5, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80004be:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 80004c2:	bf0c      	ite	eq
 80004c4:	403d      	andeq	r5, r7
          temp |= iocurrent;
 80004c6:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 80004c8:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR1;
 80004ca:	68d5      	ldr	r5, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80004cc:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 80004ce:	bf54      	ite	pl
 80004d0:	403d      	andpl	r5, r7
          temp |= iocurrent;
 80004d2:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 80004d4:	60d5      	str	r5, [r2, #12]
    position++;
 80004d6:	3301      	adds	r3, #1
 80004d8:	e744      	b.n	8000364 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80004da:	2500      	movs	r5, #0
 80004dc:	e7da      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004de:	2501      	movs	r5, #1
 80004e0:	e7d8      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004e2:	2502      	movs	r5, #2
 80004e4:	e7d6      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004e6:	2503      	movs	r5, #3
 80004e8:	e7d4      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004ea:	2504      	movs	r5, #4
 80004ec:	e7d2      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004ee:	2505      	movs	r5, #5
 80004f0:	e7d0      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004f2:	2506      	movs	r5, #6
 80004f4:	e7ce      	b.n	8000494 <HAL_GPIO_Init+0x140>
 80004f6:	bf00      	nop
 80004f8:	40010400 	.word	0x40010400
 80004fc:	48000400 	.word	0x48000400
 8000500:	40021000 	.word	0x40021000

08000504 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8000504:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8000508:	4604      	mov	r4, r0
{
 800050a:	b08a      	sub	sp, #40	; 0x28
  if (hpcd == NULL)
 800050c:	2800      	cmp	r0, #0
 800050e:	d074      	beq.n	80005fa <HAL_PCD_Init+0xf6>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8000510:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
 8000514:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000518:	b91b      	cbnz	r3, 8000522 <HAL_PCD_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800051a:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800051e:	f002 fdd5 	bl	80030cc <HAL_PCD_MspInit>
  }

  hpcd->State = HAL_PCD_STATE_BUSY;

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8000522:	4625      	mov	r5, r4
  hpcd->State = HAL_PCD_STATE_BUSY;
 8000524:	2303      	movs	r3, #3
  __HAL_PCD_DISABLE(hpcd);
 8000526:	f855 0b10 	ldr.w	r0, [r5], #16
  hpcd->State = HAL_PCD_STATE_BUSY;
 800052a:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
  __HAL_PCD_DISABLE(hpcd);
 800052e:	f001 fcae 	bl	8001e8e <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  (void)USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000532:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000534:	466e      	mov	r6, sp
 8000536:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000538:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800053a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800053c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000540:	e886 0003 	stmia.w	r6, {r0, r1}
 8000544:	f104 0804 	add.w	r8, r4, #4
 8000548:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 800054c:	6820      	ldr	r0, [r4, #0]
 800054e:	f001 fc69 	bl	8001e24 <USB_CoreInit>

  /* Force Device Mode*/
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 8000552:	2100      	movs	r1, #0
 8000554:	6820      	ldr	r0, [r4, #0]
 8000556:	f001 fca0 	bl	8001e9a <USB_SetCurrentMode>
 800055a:	2100      	movs	r1, #0
 800055c:	4622      	mov	r2, r4
 800055e:	4623      	mov	r3, r4
 8000560:	f104 0510 	add.w	r5, r4, #16

  /* Init endpoints structures */
  for (i = 0U; i < 15U; i++)
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8000564:	2601      	movs	r6, #1
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000566:	4608      	mov	r0, r1
    hpcd->IN_ep[i].num = i;
 8000568:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 800056c:	f8a3 1042 	strh.w	r1, [r3, #66]	; 0x42
 8000570:	3101      	adds	r1, #1
  for (i = 0U; i < 15U; i++)
 8000572:	290f      	cmp	r1, #15
    hpcd->IN_ep[i].is_in = 1U;
 8000574:	f883 603d 	strb.w	r6, [r3, #61]	; 0x3d
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000578:	f883 003f 	strb.w	r0, [r3, #63]	; 0x3f
    hpcd->IN_ep[i].maxpacket = 0U;
 800057c:	6458      	str	r0, [r3, #68]	; 0x44
    hpcd->IN_ep[i].xfer_buff = 0U;
 800057e:	6498      	str	r0, [r3, #72]	; 0x48
    hpcd->IN_ep[i].xfer_len = 0U;
 8000580:	6518      	str	r0, [r3, #80]	; 0x50
 8000582:	f103 031c 	add.w	r3, r3, #28
  for (i = 0U; i < 15U; i++)
 8000586:	d1ef      	bne.n	8000568 <HAL_PCD_Init+0x64>
 8000588:	2300      	movs	r3, #0
  }

  for (i = 0U; i < 15U; i++)
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800058a:	461f      	mov	r7, r3
    hpcd->OUT_ep[i].num = i;
 800058c:	f882 31fc 	strb.w	r3, [r2, #508]	; 0x1fc
 8000590:	3301      	adds	r3, #1
  for (i = 0U; i < 15U; i++)
 8000592:	2b0f      	cmp	r3, #15
    hpcd->OUT_ep[i].is_in = 0U;
 8000594:	f882 71fd 	strb.w	r7, [r2, #509]	; 0x1fd
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000598:	f882 71ff 	strb.w	r7, [r2, #511]	; 0x1ff
    hpcd->OUT_ep[i].maxpacket = 0U;
 800059c:	f8c2 7204 	str.w	r7, [r2, #516]	; 0x204
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80005a0:	f8c2 7208 	str.w	r7, [r2, #520]	; 0x208
    hpcd->OUT_ep[i].xfer_len = 0U;
 80005a4:	f8c2 7210 	str.w	r7, [r2, #528]	; 0x210
 80005a8:	f102 021c 	add.w	r2, r2, #28
  for (i = 0U; i < 15U; i++)
 80005ac:	d1ee      	bne.n	800058c <HAL_PCD_Init+0x88>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 80005ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80005b0:	466e      	mov	r6, sp
 80005b2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80005b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80005b6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80005b8:	e895 0003 	ldmia.w	r5, {r0, r1}
 80005bc:	e886 0003 	stmia.w	r6, {r0, r1}
 80005c0:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 80005c4:	6820      	ldr	r0, [r4, #0]
 80005c6:	f001 fca9 	bl	8001f1c <USB_DevInit>

  hpcd->USB_Address = 0U;
  hpcd->State = HAL_PCD_STATE_READY;
 80005ca:	2301      	movs	r3, #1
  hpcd->USB_Address = 0U;
 80005cc:	f884 7038 	strb.w	r7, [r4, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 80005d0:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 80005d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80005d6:	2b01      	cmp	r3, #1
 80005d8:	d102      	bne.n	80005e0 <HAL_PCD_Init+0xdc>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80005da:	4620      	mov	r0, r4
 80005dc:	f000 fc26 	bl	8000e2c <HAL_PCDEx_ActivateLPM>
  }

  /* Activate Battery charging */
  if (hpcd->Init.battery_charging_enable == 1U)
 80005e0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80005e2:	2b01      	cmp	r3, #1
 80005e4:	d102      	bne.n	80005ec <HAL_PCD_Init+0xe8>
  {
    (void)HAL_PCDEx_ActivateBCD(hpcd);
 80005e6:	4620      	mov	r0, r4
 80005e8:	f000 fc33 	bl	8000e52 <HAL_PCDEx_ActivateBCD>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 80005ec:	6820      	ldr	r0, [r4, #0]
 80005ee:	f001 ff6f 	bl	80024d0 <USB_DevDisconnect>

  return HAL_OK;
 80005f2:	2000      	movs	r0, #0
}
 80005f4:	b00a      	add	sp, #40	; 0x28
 80005f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 80005fa:	2001      	movs	r0, #1
 80005fc:	e7fa      	b.n	80005f4 <HAL_PCD_Init+0xf0>

080005fe <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 80005fe:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8000602:	2b01      	cmp	r3, #1
{
 8000604:	b510      	push	{r4, lr}
 8000606:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8000608:	d00c      	beq.n	8000624 <HAL_PCD_Start+0x26>
 800060a:	2301      	movs	r3, #1
 800060c:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  (void)USB_DevConnect(hpcd->Instance);
 8000610:	6800      	ldr	r0, [r0, #0]
 8000612:	f001 ff51 	bl	80024b8 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8000616:	6820      	ldr	r0, [r4, #0]
 8000618:	f001 fc33 	bl	8001e82 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 800061c:	2000      	movs	r0, #0
 800061e:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8000622:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8000624:	2002      	movs	r0, #2
}
 8000626:	bd10      	pop	{r4, pc}

08000628 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000628:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800062c:	f8d0 9000 	ldr.w	r9, [r0]
{
 8000630:	b085      	sub	sp, #20
 8000632:	4604      	mov	r4, r0
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000634:	4648      	mov	r0, r9
  uint32_t gSNPSiD = *(uint32_t *) TempReg;
 8000636:	f8d9 8040 	ldr.w	r8, [r9, #64]	; 0x40
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800063a:	f001 ff84 	bl	8002546 <USB_GetMode>
 800063e:	9000      	str	r0, [sp, #0]
 8000640:	2800      	cmp	r0, #0
 8000642:	f040 8154 	bne.w	80008ee <HAL_PCD_IRQHandler+0x2c6>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8000646:	6820      	ldr	r0, [r4, #0]
 8000648:	f001 ff4e 	bl	80024e8 <USB_ReadInterrupts>
 800064c:	2800      	cmp	r0, #0
 800064e:	f000 814e 	beq.w	80008ee <HAL_PCD_IRQHandler+0x2c6>
    {
      return;
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000652:	6820      	ldr	r0, [r4, #0]
 8000654:	f001 ff48 	bl	80024e8 <USB_ReadInterrupts>
 8000658:	0780      	lsls	r0, r0, #30
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800065a:	bf48      	it	mi
 800065c:	6822      	ldrmi	r2, [r4, #0]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800065e:	6820      	ldr	r0, [r4, #0]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000660:	bf42      	ittt	mi
 8000662:	6953      	ldrmi	r3, [r2, #20]
 8000664:	f003 0302 	andmi.w	r3, r3, #2
 8000668:	6153      	strmi	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800066a:	f001 ff3d 	bl	80024e8 <USB_ReadInterrupts>
 800066e:	f410 2b00 	ands.w	fp, r0, #524288	; 0x80000
 8000672:	d00b      	beq.n	800068c <HAL_PCD_IRQHandler+0x64>
    {
      epnum = 0U;

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000674:	6820      	ldr	r0, [r4, #0]
 8000676:	f001 ff3b 	bl	80024f0 <USB_ReadDevAllOutEpInterrupt>
 800067a:	f509 6630 	add.w	r6, r9, #2816	; 0xb00
 800067e:	4605      	mov	r5, r0

      while (ep_intr != 0U)
 8000680:	46b2      	mov	sl, r6
      epnum = 0U;
 8000682:	f04f 0b00 	mov.w	fp, #0
      while (ep_intr != 0U)
 8000686:	2d00      	cmp	r5, #0
 8000688:	f040 8134 	bne.w	80008f4 <HAL_PCD_IRQHandler+0x2cc>
        epnum++;
        ep_intr >>= 1U;
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800068c:	6820      	ldr	r0, [r4, #0]
 800068e:	f001 ff2b 	bl	80024e8 <USB_ReadInterrupts>
 8000692:	0347      	lsls	r7, r0, #13
 8000694:	d50c      	bpl.n	80006b0 <HAL_PCD_IRQHandler+0x88>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8000696:	6820      	ldr	r0, [r4, #0]
 8000698:	f001 ff32 	bl	8002500 <USB_ReadDevAllInEpInterrupt>
 800069c:	4625      	mov	r5, r4
 800069e:	9001      	str	r0, [sp, #4]
 80006a0:	f509 6810 	add.w	r8, r9, #2304	; 0x900

      epnum = 0U;
 80006a4:	f04f 0b00 	mov.w	fp, #0

      while (ep_intr != 0U)
 80006a8:	9b01      	ldr	r3, [sp, #4]
 80006aa:	2b00      	cmp	r3, #0
 80006ac:	f040 8164 	bne.w	8000978 <HAL_PCD_IRQHandler+0x350>
        ep_intr >>= 1U;
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80006b0:	6820      	ldr	r0, [r4, #0]
 80006b2:	f001 ff19 	bl	80024e8 <USB_ReadInterrupts>
 80006b6:	2800      	cmp	r0, #0
 80006b8:	da15      	bge.n	80006e6 <HAL_PCD_IRQHandler+0xbe>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80006ba:	f8d9 3804 	ldr.w	r3, [r9, #2052]	; 0x804
 80006be:	f023 0301 	bic.w	r3, r3, #1
 80006c2:	f8c9 3804 	str.w	r3, [r9, #2052]	; 0x804

      if (hpcd->LPM_State == LPM_L1)
 80006c6:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 80006ca:	2b01      	cmp	r3, #1
 80006cc:	f040 81cf 	bne.w	8000a6e <HAL_PCD_IRQHandler+0x446>
      {
        hpcd->LPM_State = LPM_L0;
 80006d0:	2100      	movs	r1, #0
 80006d2:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 80006d6:	4620      	mov	r0, r4
 80006d8:	f002 fe58 	bl	800338c <HAL_PCDEx_LPM_Callback>
#else
        HAL_PCD_ResumeCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 80006dc:	6822      	ldr	r2, [r4, #0]
 80006de:	6953      	ldr	r3, [r2, #20]
 80006e0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80006e4:	6153      	str	r3, [r2, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80006e6:	6820      	ldr	r0, [r4, #0]
 80006e8:	f001 fefe 	bl	80024e8 <USB_ReadInterrupts>
 80006ec:	0505      	lsls	r5, r0, #20
 80006ee:	d50b      	bpl.n	8000708 <HAL_PCD_IRQHandler+0xe0>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80006f0:	f8d9 3808 	ldr.w	r3, [r9, #2056]	; 0x808
 80006f4:	07d8      	lsls	r0, r3, #31
 80006f6:	d502      	bpl.n	80006fe <HAL_PCD_IRQHandler+0xd6>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 80006f8:	4620      	mov	r0, r4
 80006fa:	f002 fd51 	bl	80031a0 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80006fe:	6822      	ldr	r2, [r4, #0]
 8000700:	6953      	ldr	r3, [r2, #20]
 8000702:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000706:	6153      	str	r3, [r2, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 8000708:	6820      	ldr	r0, [r4, #0]
 800070a:	f001 feed 	bl	80024e8 <USB_ReadInterrupts>
 800070e:	0101      	lsls	r1, r0, #4
 8000710:	d514      	bpl.n	800073c <HAL_PCD_IRQHandler+0x114>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8000712:	6823      	ldr	r3, [r4, #0]
 8000714:	695a      	ldr	r2, [r3, #20]
 8000716:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 800071a:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
 800071c:	f894 23f4 	ldrb.w	r2, [r4, #1012]	; 0x3f4
 8000720:	2a00      	cmp	r2, #0
 8000722:	f040 81a8 	bne.w	8000a76 <HAL_PCD_IRQHandler+0x44e>
      {
        hpcd->LPM_State = LPM_L1;
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8000726:	6d5b      	ldr	r3, [r3, #84]	; 0x54
        hpcd->LPM_State = LPM_L1;
 8000728:	2101      	movs	r1, #1
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 800072a:	f3c3 0383 	ubfx	r3, r3, #2, #4
        hpcd->LPM_State = LPM_L1;
 800072e:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8000732:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8000736:	4620      	mov	r0, r4
 8000738:	f002 fe28 	bl	800338c <HAL_PCDEx_LPM_Callback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 800073c:	6820      	ldr	r0, [r4, #0]
 800073e:	f001 fed3 	bl	80024e8 <USB_ReadInterrupts>
 8000742:	04c2      	lsls	r2, r0, #19
 8000744:	d534      	bpl.n	80007b0 <HAL_PCD_IRQHandler+0x188>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000746:	f509 6500 	add.w	r5, r9, #2048	; 0x800
 800074a:	686b      	ldr	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800074c:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800074e:	f023 0301 	bic.w	r3, r3, #1
 8000752:	606b      	str	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8000754:	2110      	movs	r1, #16
 8000756:	f001 fbb7 	bl	8001ec8 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800075a:	6860      	ldr	r0, [r4, #4]
 800075c:	f509 6310 	add.w	r3, r9, #2304	; 0x900
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8000760:	f64f 317f 	movw	r1, #64383	; 0xfb7f
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000764:	9a00      	ldr	r2, [sp, #0]
 8000766:	4282      	cmp	r2, r0
 8000768:	f040 8189 	bne.w	8000a7e <HAL_PCD_IRQHandler+0x456>
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800076c:	69eb      	ldr	r3, [r5, #28]
 800076e:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8000772:	61eb      	str	r3, [r5, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8000774:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000776:	2b00      	cmp	r3, #0
 8000778:	f000 819a 	beq.w	8000ab0 <HAL_PCD_IRQHandler+0x488>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 800077c:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8000780:	f043 030b 	orr.w	r3, r3, #11
 8000784:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8000788:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800078a:	f043 030b 	orr.w	r3, r3, #11
 800078e:	646b      	str	r3, [r5, #68]	; 0x44
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000790:	f8d9 3800 	ldr.w	r3, [r9, #2048]	; 0x800

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8000794:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000796:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800079a:	f8c9 3800 	str.w	r3, [r9, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 800079e:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 80007a2:	f001 feef 	bl	8002584 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80007a6:	6822      	ldr	r2, [r4, #0]
 80007a8:	6953      	ldr	r3, [r2, #20]
 80007aa:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80007ae:	6153      	str	r3, [r2, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80007b0:	6820      	ldr	r0, [r4, #0]
 80007b2:	f001 fe99 	bl	80024e8 <USB_ReadInterrupts>
 80007b6:	0483      	lsls	r3, r0, #18
 80007b8:	d520      	bpl.n	80007fc <HAL_PCD_IRQHandler+0x1d4>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 80007ba:	6820      	ldr	r0, [r4, #0]
 80007bc:	f001 fec7 	bl	800254e <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80007c0:	6822      	ldr	r2, [r4, #0]
 80007c2:	68d3      	ldr	r3, [r2, #12]
 80007c4:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80007c8:	60d3      	str	r3, [r2, #12]
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 80007ca:	2303      	movs	r3, #3
 80007cc:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE;
 80007ce:	2340      	movs	r3, #64	; 0x40
 80007d0:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
        latency to the Data FIFO */

        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 80007d2:	f000 ff95 	bl	8001700 <HAL_RCC_GetHCLKFreq>

        if ((hclk >= 14200000U) && (hclk < 15000000U))
 80007d6:	4bb3      	ldr	r3, [pc, #716]	; (8000aa4 <HAL_PCD_IRQHandler+0x47c>)
 80007d8:	4ab3      	ldr	r2, [pc, #716]	; (8000aa8 <HAL_PCD_IRQHandler+0x480>)
 80007da:	4403      	add	r3, r0
 80007dc:	4293      	cmp	r3, r2
 80007de:	6823      	ldr	r3, [r4, #0]
 80007e0:	f200 816f 	bhi.w	8000ac2 <HAL_PCD_IRQHandler+0x49a>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10) & USB_OTG_GUSBCFG_TRDT);
 80007e4:	68da      	ldr	r2, [r3, #12]
 80007e6:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
        }

        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-200 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10) & USB_OTG_GUSBCFG_TRDT);
 80007ea:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 80007ec:	4620      	mov	r0, r4
 80007ee:	f002 fcca 	bl	8003186 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 80007f2:	6822      	ldr	r2, [r4, #0]
 80007f4:	6953      	ldr	r3, [r2, #20]
 80007f6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80007fa:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80007fc:	6820      	ldr	r0, [r4, #0]
 80007fe:	f001 fe73 	bl	80024e8 <USB_ReadInterrupts>
 8000802:	06c7      	lsls	r7, r0, #27
 8000804:	d52b      	bpl.n	800085e <HAL_PCD_IRQHandler+0x236>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000806:	6822      	ldr	r2, [r4, #0]
 8000808:	6993      	ldr	r3, [r2, #24]
 800080a:	f023 0310 	bic.w	r3, r3, #16
 800080e:	6193      	str	r3, [r2, #24]

      temp = USBx->GRXSTSP;
 8000810:	f8d9 5020 	ldr.w	r5, [r9, #32]

      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];

      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8000814:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8000818:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 800081a:	f005 070f 	and.w	r7, r5, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800081e:	f040 81a0 	bne.w	8000b62 <HAL_PCD_IRQHandler+0x53a>
      {
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000822:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000826:	421d      	tst	r5, r3
 8000828:	d014      	beq.n	8000854 <HAL_PCD_IRQHandler+0x22c>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff, (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));
 800082a:	261c      	movs	r6, #28
 800082c:	fb06 4607 	mla	r6, r6, r7, r4
 8000830:	f3c5 150a 	ubfx	r5, r5, #4, #11
 8000834:	462a      	mov	r2, r5
 8000836:	f8d6 1208 	ldr.w	r1, [r6, #520]	; 0x208
 800083a:	4648      	mov	r0, r9
 800083c:	f001 fdc6 	bl	80023cc <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000840:	f8d6 3208 	ldr.w	r3, [r6, #520]	; 0x208
 8000844:	442b      	add	r3, r5
 8000846:	f8c6 3208 	str.w	r3, [r6, #520]	; 0x208
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 800084a:	f8d6 3214 	ldr.w	r3, [r6, #532]	; 0x214
 800084e:	441d      	add	r5, r3
 8000850:	f8c6 5214 	str.w	r5, [r6, #532]	; 0x214
      }
      else
      {
        /* ... */
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000854:	6822      	ldr	r2, [r4, #0]
 8000856:	6993      	ldr	r3, [r2, #24]
 8000858:	f043 0310 	orr.w	r3, r3, #16
 800085c:	6193      	str	r3, [r2, #24]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800085e:	6820      	ldr	r0, [r4, #0]
 8000860:	f001 fe42 	bl	80024e8 <USB_ReadInterrupts>
 8000864:	0706      	lsls	r6, r0, #28
 8000866:	d507      	bpl.n	8000878 <HAL_PCD_IRQHandler+0x250>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8000868:	4620      	mov	r0, r4
 800086a:	f002 fc88 	bl	800317e <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800086e:	6822      	ldr	r2, [r4, #0]
 8000870:	6953      	ldr	r3, [r2, #20]
 8000872:	f003 0308 	and.w	r3, r3, #8
 8000876:	6153      	str	r3, [r2, #20]
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8000878:	6820      	ldr	r0, [r4, #0]
 800087a:	f001 fe35 	bl	80024e8 <USB_ReadInterrupts>
 800087e:	02c5      	lsls	r5, r0, #11
 8000880:	d509      	bpl.n	8000896 <HAL_PCD_IRQHandler+0x26e>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8000882:	fa5f f18b 	uxtb.w	r1, fp
 8000886:	4620      	mov	r0, r4
 8000888:	f002 fcc0 	bl	800320c <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 800088c:	6822      	ldr	r2, [r4, #0]
 800088e:	6953      	ldr	r3, [r2, #20]
 8000890:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000894:	6153      	str	r3, [r2, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000896:	6820      	ldr	r0, [r4, #0]
 8000898:	f001 fe26 	bl	80024e8 <USB_ReadInterrupts>
 800089c:	0280      	lsls	r0, r0, #10
 800089e:	d509      	bpl.n	80008b4 <HAL_PCD_IRQHandler+0x28c>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 80008a0:	fa5f f18b 	uxtb.w	r1, fp
 80008a4:	4620      	mov	r0, r4
 80008a6:	f002 fcad 	bl	8003204 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80008aa:	6822      	ldr	r2, [r4, #0]
 80008ac:	6953      	ldr	r3, [r2, #20]
 80008ae:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80008b2:	6153      	str	r3, [r2, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80008b4:	6820      	ldr	r0, [r4, #0]
 80008b6:	f001 fe17 	bl	80024e8 <USB_ReadInterrupts>
 80008ba:	0041      	lsls	r1, r0, #1
 80008bc:	d507      	bpl.n	80008ce <HAL_PCD_IRQHandler+0x2a6>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 80008be:	4620      	mov	r0, r4
 80008c0:	f002 fca8 	bl	8003214 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 80008c4:	6822      	ldr	r2, [r4, #0]
 80008c6:	6953      	ldr	r3, [r2, #20]
 80008c8:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80008cc:	6153      	str	r3, [r2, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 80008ce:	6820      	ldr	r0, [r4, #0]
 80008d0:	f001 fe0a 	bl	80024e8 <USB_ReadInterrupts>
 80008d4:	0742      	lsls	r2, r0, #29
 80008d6:	d50a      	bpl.n	80008ee <HAL_PCD_IRQHandler+0x2c6>
    {
      temp = hpcd->Instance->GOTGINT;
 80008d8:	6823      	ldr	r3, [r4, #0]
 80008da:	685d      	ldr	r5, [r3, #4]

      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 80008dc:	076b      	lsls	r3, r5, #29
 80008de:	d502      	bpl.n	80008e6 <HAL_PCD_IRQHandler+0x2be>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 80008e0:	4620      	mov	r0, r4
 80008e2:	f002 fc9b 	bl	800321c <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
 80008e6:	6823      	ldr	r3, [r4, #0]
 80008e8:	685a      	ldr	r2, [r3, #4]
 80008ea:	4315      	orrs	r5, r2
 80008ec:	605d      	str	r5, [r3, #4]
    }
  }
}
 80008ee:	b005      	add	sp, #20
 80008f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((ep_intr & 0x1U) != 0U)
 80008f4:	07e9      	lsls	r1, r5, #31
 80008f6:	d52e      	bpl.n	8000956 <HAL_PCD_IRQHandler+0x32e>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80008f8:	fa5f f28b 	uxtb.w	r2, fp
 80008fc:	4611      	mov	r1, r2
 80008fe:	6820      	ldr	r0, [r4, #0]
 8000900:	9201      	str	r2, [sp, #4]
 8000902:	f001 fe05 	bl	8002510 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000906:	07c2      	lsls	r2, r0, #31
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000908:	4607      	mov	r7, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800090a:	d50d      	bpl.n	8000928 <HAL_PCD_IRQHandler+0x300>
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800090c:	4b67      	ldr	r3, [pc, #412]	; (8000aac <HAL_PCD_IRQHandler+0x484>)
 800090e:	9a01      	ldr	r2, [sp, #4]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000910:	2101      	movs	r1, #1
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8000912:	4598      	cmp	r8, r3
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000914:	f8ca 1008 	str.w	r1, [sl, #8]
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8000918:	d129      	bne.n	800096e <HAL_PCD_IRQHandler+0x346>
              if ((USBx_OUTEP(0U)->DOEPINT & (1U << 15)) != 0U)
 800091a:	68b1      	ldr	r1, [r6, #8]
 800091c:	040b      	lsls	r3, r1, #16
 800091e:	d520      	bpl.n	8000962 <HAL_PCD_IRQHandler+0x33a>
                CLEAR_OUT_EP_INTR(epnum, (1U << 15));
 8000920:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000924:	f8ca 2008 	str.w	r2, [sl, #8]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8000928:	0739      	lsls	r1, r7, #28
 800092a:	d50f      	bpl.n	800094c <HAL_PCD_IRQHandler+0x324>
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800092c:	4b5f      	ldr	r3, [pc, #380]	; (8000aac <HAL_PCD_IRQHandler+0x484>)
 800092e:	4598      	cmp	r8, r3
 8000930:	d106      	bne.n	8000940 <HAL_PCD_IRQHandler+0x318>
              if ((USBx_OUTEP(0U)->DOEPINT & (1U << 15)) != 0U)
 8000932:	68b2      	ldr	r2, [r6, #8]
 8000934:	0412      	lsls	r2, r2, #16
                CLEAR_OUT_EP_INTR(epnum, (1U << 15));
 8000936:	bf44      	itt	mi
 8000938:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
 800093c:	f8ca 2008 	strmi.w	r2, [sl, #8]
            HAL_PCD_SetupStageCallback(hpcd);
 8000940:	4620      	mov	r0, r4
 8000942:	f002 fc05 	bl	8003150 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8000946:	2308      	movs	r3, #8
 8000948:	f8ca 3008 	str.w	r3, [sl, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 800094c:	06fb      	lsls	r3, r7, #27
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800094e:	bf44      	itt	mi
 8000950:	2310      	movmi	r3, #16
 8000952:	f8ca 3008 	strmi.w	r3, [sl, #8]
        epnum++;
 8000956:	f10b 0b01 	add.w	fp, fp, #1
        ep_intr >>= 1U;
 800095a:	086d      	lsrs	r5, r5, #1
 800095c:	f10a 0a20 	add.w	sl, sl, #32
 8000960:	e691      	b.n	8000686 <HAL_PCD_IRQHandler+0x5e>
                if ((USBx_OUTEP(0U)->DOEPINT & (1U << 5)) != 0U)
 8000962:	68b1      	ldr	r1, [r6, #8]
 8000964:	0688      	lsls	r0, r1, #26
                  CLEAR_OUT_EP_INTR(epnum, (1U << 5));
 8000966:	bf44      	itt	mi
 8000968:	2120      	movmi	r1, #32
 800096a:	f8ca 1008 	strmi.w	r1, [sl, #8]
              HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800096e:	4611      	mov	r1, r2
 8000970:	4620      	mov	r0, r4
 8000972:	f002 fbf3 	bl	800315c <HAL_PCD_DataOutStageCallback>
 8000976:	e7d7      	b.n	8000928 <HAL_PCD_IRQHandler+0x300>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8000978:	9b01      	ldr	r3, [sp, #4]
 800097a:	07de      	lsls	r6, r3, #31
 800097c:	d56e      	bpl.n	8000a5c <HAL_PCD_IRQHandler+0x434>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800097e:	fa5f fa8b 	uxtb.w	sl, fp
 8000982:	4651      	mov	r1, sl
 8000984:	6820      	ldr	r0, [r4, #0]
 8000986:	f001 fdcc 	bl	8002522 <USB_ReadDevInEPInterrupt>
 800098a:	4606      	mov	r6, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800098c:	07f0      	lsls	r0, r6, #31
 800098e:	d510      	bpl.n	80009b2 <HAL_PCD_IRQHandler+0x38a>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000990:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & 0xFU));
 8000994:	2001      	movs	r0, #1
 8000996:	f00b 020f 	and.w	r2, fp, #15
 800099a:	fa00 f202 	lsl.w	r2, r0, r2
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800099e:	ea23 0302 	bic.w	r3, r3, r2
 80009a2:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80009a6:	4651      	mov	r1, sl
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80009a8:	f8c8 0008 	str.w	r0, [r8, #8]
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80009ac:	4620      	mov	r0, r4
 80009ae:	f002 fbde 	bl	800316e <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80009b2:	0731      	lsls	r1, r6, #28
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 80009b4:	bf44      	itt	mi
 80009b6:	2308      	movmi	r3, #8
 80009b8:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 80009bc:	06f2      	lsls	r2, r6, #27
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 80009be:	bf44      	itt	mi
 80009c0:	2310      	movmi	r3, #16
 80009c2:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80009c6:	0673      	lsls	r3, r6, #25
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80009c8:	bf44      	itt	mi
 80009ca:	2340      	movmi	r3, #64	; 0x40
 80009cc:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80009d0:	07b7      	lsls	r7, r6, #30
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80009d2:	bf44      	itt	mi
 80009d4:	2302      	movmi	r3, #2
 80009d6:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80009da:	0636      	lsls	r6, r6, #24
 80009dc:	d53e      	bpl.n	8000a5c <HAL_PCD_IRQHandler+0x434>
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 80009de:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 80009e0:	6d2e      	ldr	r6, [r5, #80]	; 0x50
 80009e2:	42b3      	cmp	r3, r6
 80009e4:	d83a      	bhi.n	8000a5c <HAL_PCD_IRQHandler+0x434>
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 80009e6:	1af6      	subs	r6, r6, r3
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;
 80009e8:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80009ea:	6822      	ldr	r2, [r4, #0]
 80009ec:	9202      	str	r2, [sp, #8]
  len32b = (len + 3U) / 4U;
 80009ee:	429e      	cmp	r6, r3
 80009f0:	bf28      	it	cs
 80009f2:	461e      	movcs	r6, r3

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80009f4:	f502 6310 	add.w	r3, r2, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 80009f8:	3603      	adds	r6, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80009fa:	eb03 134b 	add.w	r3, r3, fp, lsl #5
  len32b = (len + 3U) / 4U;
 80009fe:	08b6      	lsrs	r6, r6, #2
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000a00:	9303      	str	r3, [sp, #12]
 8000a02:	9b03      	ldr	r3, [sp, #12]
 8000a04:	6d2f      	ldr	r7, [r5, #80]	; 0x50
 8000a06:	699b      	ldr	r3, [r3, #24]
 8000a08:	b29b      	uxth	r3, r3
 8000a0a:	42b3      	cmp	r3, r6
 8000a0c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8000a0e:	d923      	bls.n	8000a58 <HAL_PCD_IRQHandler+0x430>
 8000a10:	429f      	cmp	r7, r3
 8000a12:	d921      	bls.n	8000a58 <HAL_PCD_IRQHandler+0x430>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8000a14:	b967      	cbnz	r7, 8000a30 <HAL_PCD_IRQHandler+0x408>
  }

  if (ep->xfer_len <= ep->xfer_count)
  {
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000a16:	9b02      	ldr	r3, [sp, #8]
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
 8000a18:	2201      	movs	r2, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000a1a:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
 8000a1e:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
 8000a22:	fa02 f20b 	lsl.w	r2, r2, fp
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000a26:	ea23 0302 	bic.w	r3, r3, r2
 8000a2a:	f8ca 3034 	str.w	r3, [sl, #52]	; 0x34
 8000a2e:	e015      	b.n	8000a5c <HAL_PCD_IRQHandler+0x434>
    len = ep->xfer_len - ep->xfer_count;
 8000a30:	1aff      	subs	r7, r7, r3
 8000a32:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len);
 8000a34:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 8000a36:	9802      	ldr	r0, [sp, #8]
 8000a38:	429f      	cmp	r7, r3
 8000a3a:	bf28      	it	cs
 8000a3c:	461f      	movcs	r7, r3
 8000a3e:	b2bb      	uxth	r3, r7
 8000a40:	4652      	mov	r2, sl
 8000a42:	f001 fbed 	bl	8002220 <USB_WritePacket>
    ep->xfer_buff  += len;
 8000a46:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000a48:	443b      	add	r3, r7
 8000a4a:	64ab      	str	r3, [r5, #72]	; 0x48
    ep->xfer_count += len;
 8000a4c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    len32b = (len + 3U) / 4U;
 8000a4e:	1cfe      	adds	r6, r7, #3
    ep->xfer_count += len;
 8000a50:	441f      	add	r7, r3
    len32b = (len + 3U) / 4U;
 8000a52:	08b6      	lsrs	r6, r6, #2
    ep->xfer_count += len;
 8000a54:	656f      	str	r7, [r5, #84]	; 0x54
 8000a56:	e7d4      	b.n	8000a02 <HAL_PCD_IRQHandler+0x3da>
  if (ep->xfer_len <= ep->xfer_count)
 8000a58:	429f      	cmp	r7, r3
 8000a5a:	d9dc      	bls.n	8000a16 <HAL_PCD_IRQHandler+0x3ee>
        ep_intr >>= 1U;
 8000a5c:	9b01      	ldr	r3, [sp, #4]
 8000a5e:	085b      	lsrs	r3, r3, #1
        epnum++;
 8000a60:	f10b 0b01 	add.w	fp, fp, #1
        ep_intr >>= 1U;
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	351c      	adds	r5, #28
 8000a68:	f108 0820 	add.w	r8, r8, #32
 8000a6c:	e61c      	b.n	80006a8 <HAL_PCD_IRQHandler+0x80>
        HAL_PCD_ResumeCallback(hpcd);
 8000a6e:	4620      	mov	r0, r4
 8000a70:	f002 fbae 	bl	80031d0 <HAL_PCD_ResumeCallback>
 8000a74:	e632      	b.n	80006dc <HAL_PCD_IRQHandler+0xb4>
        HAL_PCD_SuspendCallback(hpcd);
 8000a76:	4620      	mov	r0, r4
 8000a78:	f002 fb92 	bl	80031a0 <HAL_PCD_SuspendCallback>
 8000a7c:	e65e      	b.n	800073c <HAL_PCD_IRQHandler+0x114>
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8000a7e:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8000a80:	681a      	ldr	r2, [r3, #0]
 8000a82:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8000a86:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8000a88:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8000a8c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000a90:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8000a94:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000a98:	9a00      	ldr	r2, [sp, #0]
 8000a9a:	3201      	adds	r2, #1
 8000a9c:	9200      	str	r2, [sp, #0]
 8000a9e:	3320      	adds	r3, #32
 8000aa0:	e660      	b.n	8000764 <HAL_PCD_IRQHandler+0x13c>
 8000aa2:	bf00      	nop
 8000aa4:	ff275340 	.word	0xff275340
 8000aa8:	000c34ff 	.word	0x000c34ff
 8000aac:	4f54310a 	.word	0x4f54310a
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8000ab0:	696b      	ldr	r3, [r5, #20]
 8000ab2:	f043 030b 	orr.w	r3, r3, #11
 8000ab6:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8000ab8:	692b      	ldr	r3, [r5, #16]
 8000aba:	f043 030b 	orr.w	r3, r3, #11
 8000abe:	612b      	str	r3, [r5, #16]
 8000ac0:	e666      	b.n	8000790 <HAL_PCD_IRQHandler+0x168>
        else if ((hclk >= 15000000U) && (hclk < 16000000U))
 8000ac2:	4a2f      	ldr	r2, [pc, #188]	; (8000b80 <HAL_PCD_IRQHandler+0x558>)
 8000ac4:	492f      	ldr	r1, [pc, #188]	; (8000b84 <HAL_PCD_IRQHandler+0x55c>)
 8000ac6:	4402      	add	r2, r0
 8000ac8:	428a      	cmp	r2, r1
 8000aca:	d803      	bhi.n	8000ad4 <HAL_PCD_IRQHandler+0x4ac>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10) & USB_OTG_GUSBCFG_TRDT);
 8000acc:	68da      	ldr	r2, [r3, #12]
 8000ace:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 8000ad2:	e68a      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8000ad4:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 8000ad8:	492b      	ldr	r1, [pc, #172]	; (8000b88 <HAL_PCD_IRQHandler+0x560>)
 8000ada:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 8000ade:	428a      	cmp	r2, r1
 8000ae0:	d803      	bhi.n	8000aea <HAL_PCD_IRQHandler+0x4c2>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10) & USB_OTG_GUSBCFG_TRDT);
 8000ae2:	68da      	ldr	r2, [r3, #12]
 8000ae4:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 8000ae8:	e67f      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8000aea:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 8000aee:	4927      	ldr	r1, [pc, #156]	; (8000b8c <HAL_PCD_IRQHandler+0x564>)
 8000af0:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 8000af4:	428a      	cmp	r2, r1
 8000af6:	d803      	bhi.n	8000b00 <HAL_PCD_IRQHandler+0x4d8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10) & USB_OTG_GUSBCFG_TRDT);
 8000af8:	68da      	ldr	r2, [r3, #12]
 8000afa:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 8000afe:	e674      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8000b00:	4a23      	ldr	r2, [pc, #140]	; (8000b90 <HAL_PCD_IRQHandler+0x568>)
 8000b02:	4924      	ldr	r1, [pc, #144]	; (8000b94 <HAL_PCD_IRQHandler+0x56c>)
 8000b04:	4402      	add	r2, r0
 8000b06:	428a      	cmp	r2, r1
 8000b08:	d803      	bhi.n	8000b12 <HAL_PCD_IRQHandler+0x4ea>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b0a:	68da      	ldr	r2, [r3, #12]
 8000b0c:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 8000b10:	e66b      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8000b12:	4a21      	ldr	r2, [pc, #132]	; (8000b98 <HAL_PCD_IRQHandler+0x570>)
 8000b14:	4921      	ldr	r1, [pc, #132]	; (8000b9c <HAL_PCD_IRQHandler+0x574>)
 8000b16:	4402      	add	r2, r0
 8000b18:	428a      	cmp	r2, r1
 8000b1a:	d803      	bhi.n	8000b24 <HAL_PCD_IRQHandler+0x4fc>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b1c:	68da      	ldr	r2, [r3, #12]
 8000b1e:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 8000b22:	e662      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8000b24:	4a1e      	ldr	r2, [pc, #120]	; (8000ba0 <HAL_PCD_IRQHandler+0x578>)
 8000b26:	491f      	ldr	r1, [pc, #124]	; (8000ba4 <HAL_PCD_IRQHandler+0x57c>)
 8000b28:	4402      	add	r2, r0
 8000b2a:	428a      	cmp	r2, r1
 8000b2c:	d803      	bhi.n	8000b36 <HAL_PCD_IRQHandler+0x50e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b2e:	68da      	ldr	r2, [r3, #12]
 8000b30:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8000b34:	e659      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8000b36:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 8000b3a:	491b      	ldr	r1, [pc, #108]	; (8000ba8 <HAL_PCD_IRQHandler+0x580>)
 8000b3c:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8000b40:	428a      	cmp	r2, r1
 8000b42:	d803      	bhi.n	8000b4c <HAL_PCD_IRQHandler+0x524>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b44:	68da      	ldr	r2, [r3, #12]
 8000b46:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000b4a:	e64e      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8000b4c:	4a17      	ldr	r2, [pc, #92]	; (8000bac <HAL_PCD_IRQHandler+0x584>)
 8000b4e:	4918      	ldr	r1, [pc, #96]	; (8000bb0 <HAL_PCD_IRQHandler+0x588>)
 8000b50:	4402      	add	r2, r0
 8000b52:	428a      	cmp	r2, r1
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b54:	68da      	ldr	r2, [r3, #12]
 8000b56:	bf94      	ite	ls
 8000b58:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10) & USB_OTG_GUSBCFG_TRDT);
 8000b5c:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 8000b60:	e643      	b.n	80007ea <HAL_PCD_IRQHandler+0x1c2>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8000b62:	2b06      	cmp	r3, #6
 8000b64:	f47f ae76 	bne.w	8000854 <HAL_PCD_IRQHandler+0x22c>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000b68:	2208      	movs	r2, #8
 8000b6a:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8000b6e:	4648      	mov	r0, r9
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000b70:	261c      	movs	r6, #28
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000b72:	f001 fc2b 	bl	80023cc <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000b76:	fb06 4607 	mla	r6, r6, r7, r4
 8000b7a:	f3c5 150a 	ubfx	r5, r5, #4, #11
 8000b7e:	e664      	b.n	800084a <HAL_PCD_IRQHandler+0x222>
 8000b80:	ff1b1e40 	.word	0xff1b1e40
 8000b84:	000f423f 	.word	0x000f423f
 8000b88:	00124f7f 	.word	0x00124f7f
 8000b8c:	0013d61f 	.word	0x0013d61f
 8000b90:	fee5b660 	.word	0xfee5b660
 8000b94:	0016e35f 	.word	0x0016e35f
 8000b98:	feced300 	.word	0xfeced300
 8000b9c:	001b773f 	.word	0x001b773f
 8000ba0:	feb35bc0 	.word	0xfeb35bc0
 8000ba4:	002191bf 	.word	0x002191bf
 8000ba8:	0038751f 	.word	0x0038751f
 8000bac:	fe5954e0 	.word	0xfe5954e0
 8000bb0:	00419cdf 	.word	0x00419cdf

08000bb4 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8000bb4:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8000bb8:	2a01      	cmp	r2, #1
{
 8000bba:	b510      	push	{r4, lr}
 8000bbc:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8000bbe:	d00b      	beq.n	8000bd8 <HAL_PCD_SetAddress+0x24>
 8000bc0:	2201      	movs	r2, #1
 8000bc2:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc
  hpcd->USB_Address = address;
 8000bc6:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8000bca:	6800      	ldr	r0, [r0, #0]
 8000bcc:	f001 fc64 	bl	8002498 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8000bd0:	2000      	movs	r0, #0
 8000bd2:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8000bd6:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8000bd8:	2002      	movs	r0, #2
}
 8000bda:	bd10      	pop	{r4, pc}

08000bdc <HAL_PCD_EP_Open>:
{
 8000bdc:	b570      	push	{r4, r5, r6, lr}
 8000bde:	4604      	mov	r4, r0
 8000be0:	f001 000f 	and.w	r0, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8000be4:	f011 0f80 	tst.w	r1, #128	; 0x80
 8000be8:	f04f 061c 	mov.w	r6, #28
 8000bec:	b2c5      	uxtb	r5, r0
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000bee:	fb06 4105 	mla	r1, r6, r5, r4
    ep->is_in = 1U;
 8000bf2:	bf15      	itete	ne
 8000bf4:	fb06 4505 	mlane	r5, r6, r5, r4
    ep->is_in = 0U;
 8000bf8:	fb06 4505 	mlaeq	r5, r6, r5, r4
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000bfc:	313c      	addne	r1, #60	; 0x3c
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8000bfe:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 1U;
 8000c02:	bf15      	itete	ne
 8000c04:	2601      	movne	r6, #1
    ep->is_in = 0U;
 8000c06:	2600      	moveq	r6, #0
    ep->is_in = 1U;
 8000c08:	f885 603d 	strbne.w	r6, [r5, #61]	; 0x3d
    ep->is_in = 0U;
 8000c0c:	f885 61fd 	strbeq.w	r6, [r5, #509]	; 0x1fd
  ep->maxpacket = ep_mps;
 8000c10:	608a      	str	r2, [r1, #8]
  if (ep->is_in != 0U)
 8000c12:	784a      	ldrb	r2, [r1, #1]
  ep->type = ep_type;
 8000c14:	70cb      	strb	r3, [r1, #3]
  ep->num = ep_addr & 0xFU;
 8000c16:	b2c0      	uxtb	r0, r0
 8000c18:	7008      	strb	r0, [r1, #0]
  if (ep->is_in != 0U)
 8000c1a:	b102      	cbz	r2, 8000c1e <HAL_PCD_EP_Open+0x42>
    ep->tx_fifo_num = ep->num;
 8000c1c:	80c8      	strh	r0, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8000c1e:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8000c20:	bf04      	itt	eq
 8000c22:	2300      	moveq	r3, #0
 8000c24:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8000c26:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8000c2a:	2b01      	cmp	r3, #1
 8000c2c:	d009      	beq.n	8000c42 <HAL_PCD_EP_Open+0x66>
 8000c2e:	2301      	movs	r3, #1
 8000c30:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8000c34:	6820      	ldr	r0, [r4, #0]
 8000c36:	f001 fa0d 	bl	8002054 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8000c3a:	2000      	movs	r0, #0
 8000c3c:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return ret;
 8000c40:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hpcd);
 8000c42:	2002      	movs	r0, #2
}
 8000c44:	bd70      	pop	{r4, r5, r6, pc}

08000c46 <HAL_PCD_EP_Close>:
{
 8000c46:	f001 030f 	and.w	r3, r1, #15
 8000c4a:	b2da      	uxtb	r2, r3
 8000c4c:	b510      	push	{r4, lr}
 8000c4e:	4604      	mov	r4, r0
 8000c50:	201c      	movs	r0, #28
  if ((ep_addr & 0x80U) == 0x80U)
 8000c52:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000c56:	fb00 4102 	mla	r1, r0, r2, r4
 8000c5a:	bf19      	ittee	ne
 8000c5c:	313c      	addne	r1, #60	; 0x3c
    ep->is_in = 1U;
 8000c5e:	fb00 4202 	mlane	r2, r0, r2, r4
    ep->is_in = 0U;
 8000c62:	fb00 4202 	mlaeq	r2, r0, r2, r4
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8000c66:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 1U;
 8000c6a:	bf15      	itete	ne
 8000c6c:	2001      	movne	r0, #1
    ep->is_in = 0U;
 8000c6e:	2000      	moveq	r0, #0
    ep->is_in = 1U;
 8000c70:	f882 003d 	strbne.w	r0, [r2, #61]	; 0x3d
    ep->is_in = 0U;
 8000c74:	f882 01fd 	strbeq.w	r0, [r2, #509]	; 0x1fd
  ep->num   = ep_addr & 0xFU;
 8000c78:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8000c7a:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8000c7e:	2b01      	cmp	r3, #1
 8000c80:	d009      	beq.n	8000c96 <HAL_PCD_EP_Close+0x50>
 8000c82:	2301      	movs	r3, #1
 8000c84:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8000c88:	6820      	ldr	r0, [r4, #0]
 8000c8a:	f001 fa25 	bl	80020d8 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8000c8e:	2000      	movs	r0, #0
 8000c90:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8000c94:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8000c96:	2002      	movs	r0, #2
}
 8000c98:	bd10      	pop	{r4, pc}

08000c9a <HAL_PCD_EP_Receive>:
{
 8000c9a:	b538      	push	{r3, r4, r5, lr}
 8000c9c:	f001 050f 	and.w	r5, r1, #15
  ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8000ca0:	241c      	movs	r4, #28
 8000ca2:	fb04 0105 	mla	r1, r4, r5, r0
  ep->xfer_buff = pBuf;
 8000ca6:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8000caa:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
  ep->xfer_len = len;
 8000cae:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->xfer_count = 0U;
 8000cb2:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 8000cb4:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
  ep->xfer_count = 0U;
 8000cb8:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
  ep->is_in = 0U;
 8000cbc:	f884 31fd 	strb.w	r3, [r4, #509]	; 0x1fd
  ep->num = ep_addr & 0xFU;
 8000cc0:	f884 51fc 	strb.w	r5, [r4, #508]	; 0x1fc
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000cc4:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0xFU) == 0U)
 8000cc6:	b91d      	cbnz	r5, 8000cd0 <HAL_PCD_EP_Receive+0x36>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000cc8:	f001 fa38 	bl	800213c <USB_EP0StartXfer>
}
 8000ccc:	2000      	movs	r0, #0
 8000cce:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8000cd0:	f001 fab6 	bl	8002240 <USB_EPStartXfer>
 8000cd4:	e7fa      	b.n	8000ccc <HAL_PCD_EP_Receive+0x32>

08000cd6 <HAL_PCD_EP_Transmit>:
{
 8000cd6:	b538      	push	{r3, r4, r5, lr}
 8000cd8:	f001 050f 	and.w	r5, r1, #15
  ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000cdc:	241c      	movs	r4, #28
 8000cde:	fb04 0105 	mla	r1, r4, r5, r0
  ep->xfer_buff = pBuf;
 8000ce2:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000ce6:	313c      	adds	r1, #60	; 0x3c
  ep->xfer_len = len;
 8000ce8:	6523      	str	r3, [r4, #80]	; 0x50
  ep->xfer_count = 0U;
 8000cea:	2300      	movs	r3, #0
 8000cec:	6563      	str	r3, [r4, #84]	; 0x54
  ep->is_in = 1U;
 8000cee:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 8000cf0:	64a2      	str	r2, [r4, #72]	; 0x48
  ep->is_in = 1U;
 8000cf2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  ep->num = ep_addr & 0xFU;
 8000cf6:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000cfa:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0xFU) == 0U)
 8000cfc:	b91d      	cbnz	r5, 8000d06 <HAL_PCD_EP_Transmit+0x30>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000cfe:	f001 fa1d 	bl	800213c <USB_EP0StartXfer>
}
 8000d02:	2000      	movs	r0, #0
 8000d04:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8000d06:	f001 fa9b 	bl	8002240 <USB_EPStartXfer>
 8000d0a:	e7fa      	b.n	8000d02 <HAL_PCD_EP_Transmit+0x2c>

08000d0c <HAL_PCD_EP_SetStall>:
{
 8000d0c:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0xFU) > hpcd->Init.dev_endpoints)
 8000d0e:	6843      	ldr	r3, [r0, #4]
 8000d10:	f001 050f 	and.w	r5, r1, #15
 8000d14:	429d      	cmp	r5, r3
{
 8000d16:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & 0xFU) > hpcd->Init.dev_endpoints)
 8000d18:	d82d      	bhi.n	8000d76 <HAL_PCD_EP_SetStall+0x6a>
  if ((0x80U & ep_addr) == 0x80U)
 8000d1a:	f011 0f80 	tst.w	r1, #128	; 0x80
 8000d1e:	f04f 021c 	mov.w	r2, #28
 8000d22:	d01e      	beq.n	8000d62 <HAL_PCD_EP_SetStall+0x56>
    ep->is_in = 1U;
 8000d24:	fb02 0105 	mla	r1, r2, r5, r0
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000d28:	fb02 0305 	mla	r3, r2, r5, r0
    ep->is_in = 1U;
 8000d2c:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000d2e:	333c      	adds	r3, #60	; 0x3c
    ep->is_in = 1U;
 8000d30:	f881 203d 	strb.w	r2, [r1, #61]	; 0x3d
  ep->is_stall = 1U;
 8000d34:	2201      	movs	r2, #1
 8000d36:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & 0xFU;
 8000d38:	701d      	strb	r5, [r3, #0]
  __HAL_LOCK(hpcd);
 8000d3a:	f894 13bc 	ldrb.w	r1, [r4, #956]	; 0x3bc
 8000d3e:	4291      	cmp	r1, r2
 8000d40:	d01b      	beq.n	8000d7a <HAL_PCD_EP_SetStall+0x6e>
 8000d42:	f884 23bc 	strb.w	r2, [r4, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8000d46:	4619      	mov	r1, r3
 8000d48:	6820      	ldr	r0, [r4, #0]
 8000d4a:	f001 fb4d 	bl	80023e8 <USB_EPSetStall>
  if ((ep_addr & 0xFU) == 0U)
 8000d4e:	b925      	cbnz	r5, 8000d5a <HAL_PCD_EP_SetStall+0x4e>
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8000d50:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8000d54:	6820      	ldr	r0, [r4, #0]
 8000d56:	f001 fc15 	bl	8002584 <USB_EP0_OutStart>
  __HAL_UNLOCK(hpcd);
 8000d5a:	2000      	movs	r0, #0
 8000d5c:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8000d60:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->OUT_ep[ep_addr];
 8000d62:	fb02 0301 	mla	r3, r2, r1, r0
    ep->is_in = 0U;
 8000d66:	fb02 0101 	mla	r1, r2, r1, r0
 8000d6a:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 8000d6c:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
    ep->is_in = 0U;
 8000d70:	f881 21fd 	strb.w	r2, [r1, #509]	; 0x1fd
 8000d74:	e7de      	b.n	8000d34 <HAL_PCD_EP_SetStall+0x28>
    return HAL_ERROR;
 8000d76:	2001      	movs	r0, #1
 8000d78:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd);
 8000d7a:	2002      	movs	r0, #2
}
 8000d7c:	bd38      	pop	{r3, r4, r5, pc}

08000d7e <HAL_PCD_EP_ClrStall>:
{
 8000d7e:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8000d80:	6843      	ldr	r3, [r0, #4]
 8000d82:	f001 020f 	and.w	r2, r1, #15
 8000d86:	429a      	cmp	r2, r3
{
 8000d88:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8000d8a:	d826      	bhi.n	8000dda <HAL_PCD_EP_ClrStall+0x5c>
 8000d8c:	231c      	movs	r3, #28
  if ((0x80U & ep_addr) == 0x80U)
 8000d8e:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8000d92:	fb03 0102 	mla	r1, r3, r2, r0
 8000d96:	bf19      	ittee	ne
 8000d98:	313c      	addne	r1, #60	; 0x3c
    ep->is_in = 1U;
 8000d9a:	fb03 0302 	mlane	r3, r3, r2, r0
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8000d9e:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8000da2:	fb03 4302 	mlaeq	r3, r3, r2, r4
    ep->is_in = 1U;
 8000da6:	bf14      	ite	ne
 8000da8:	2001      	movne	r0, #1
    ep->is_in = 0U;
 8000daa:	2000      	moveq	r0, #0
  ep->is_stall = 0U;
 8000dac:	f04f 0500 	mov.w	r5, #0
    ep->is_in = 1U;
 8000db0:	bf14      	ite	ne
 8000db2:	f883 003d 	strbne.w	r0, [r3, #61]	; 0x3d
    ep->is_in = 0U;
 8000db6:	f883 01fd 	strbeq.w	r0, [r3, #509]	; 0x1fd
  ep->is_stall = 0U;
 8000dba:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & 0xFU;
 8000dbc:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 8000dbe:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8000dc2:	2b01      	cmp	r3, #1
 8000dc4:	d00b      	beq.n	8000dde <HAL_PCD_EP_ClrStall+0x60>
 8000dc6:	2301      	movs	r3, #1
 8000dc8:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8000dcc:	6820      	ldr	r0, [r4, #0]
 8000dce:	f001 fb38 	bl	8002442 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8000dd2:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  return HAL_OK;
 8000dd6:	4628      	mov	r0, r5
 8000dd8:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8000dda:	2001      	movs	r0, #1
 8000ddc:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd);
 8000dde:	2002      	movs	r0, #2
}
 8000de0:	bd38      	pop	{r3, r4, r5, pc}

08000de2 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8000de2:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8000de4:	6804      	ldr	r4, [r0, #0]
 8000de6:	6a63      	ldr	r3, [r4, #36]	; 0x24

  if (fifo == 0U)
 8000de8:	b921      	cbnz	r1, 8000df4 <HAL_PCDEx_SetTxFiFo+0x12>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8000dea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000dee:	62a3      	str	r3, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 8000df0:	2000      	movs	r0, #0
 8000df2:	bd70      	pop	{r4, r5, r6, pc}
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8000df4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 8000df6:	1e4d      	subs	r5, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8000df8:	eb03 4310 	add.w	r3, r3, r0, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8000dfc:	2000      	movs	r0, #0
 8000dfe:	1c46      	adds	r6, r0, #1
 8000e00:	b2c0      	uxtb	r0, r0
 8000e02:	4285      	cmp	r5, r0
 8000e04:	d806      	bhi.n	8000e14 <HAL_PCDEx_SetTxFiFo+0x32>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8000e06:	313f      	adds	r1, #63	; 0x3f
 8000e08:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8000e0c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000e10:	6063      	str	r3, [r4, #4]
 8000e12:	e7ed      	b.n	8000df0 <HAL_PCDEx_SetTxFiFo+0xe>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8000e14:	3040      	adds	r0, #64	; 0x40
 8000e16:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8000e1a:	6840      	ldr	r0, [r0, #4]
 8000e1c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 8000e20:	4630      	mov	r0, r6
 8000e22:	e7ec      	b.n	8000dfe <HAL_PCDEx_SetTxFiFo+0x1c>

08000e24 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8000e24:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 8000e26:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 8000e28:	6259      	str	r1, [r3, #36]	; 0x24
}
 8000e2a:	4770      	bx	lr

08000e2c <HAL_PCDEx_ActivateLPM>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000e2c:	6802      	ldr	r2, [r0, #0]
{
 8000e2e:	4603      	mov	r3, r0

  hpcd->lpm_active = 1U;
 8000e30:	2101      	movs	r1, #1
 8000e32:	f8c0 13fc 	str.w	r1, [r0, #1020]	; 0x3fc
  hpcd->LPM_State = LPM_L0;
 8000e36:	2000      	movs	r0, #0
 8000e38:	f883 03f4 	strb.w	r0, [r3, #1012]	; 0x3f4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8000e3c:	6993      	ldr	r3, [r2, #24]
 8000e3e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8000e42:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8000e44:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8000e46:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000e4a:	f043 0303 	orr.w	r3, r3, #3
 8000e4e:	6553      	str	r3, [r2, #84]	; 0x54

  return HAL_OK;
}
 8000e50:	4770      	bx	lr

08000e52 <HAL_PCDEx_ActivateBCD>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateBCD(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000e52:	6802      	ldr	r2, [r0, #0]

  hpcd->battery_charging_active = 1U;
 8000e54:	2301      	movs	r3, #1
 8000e56:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  USBx->GCCFG |= (USB_OTG_GCCFG_BCDEN);
 8000e5a:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8000e5c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e60:	6393      	str	r3, [r2, #56]	; 0x38

  return HAL_OK;
}
 8000e62:	2000      	movs	r0, #0
 8000e64:	4770      	bx	lr
	...

08000e68 <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000e68:	4b07      	ldr	r3, [pc, #28]	; (8000e88 <HAL_PWREx_GetVoltageRange+0x20>)
 8000e6a:	6818      	ldr	r0, [r3, #0]
 8000e6c:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8000e70:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8000e74:	d007      	beq.n	8000e86 <HAL_PWREx_GetVoltageRange+0x1e>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8000e76:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000e7a:	f413 7f80 	tst.w	r3, #256	; 0x100
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
    }
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
 8000e7e:	bf14      	ite	ne
 8000e80:	f44f 7000 	movne.w	r0, #512	; 0x200
 8000e84:	2000      	moveq	r0, #0
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8000e86:	4770      	bx	lr
 8000e88:	40007000 	.word	0x40007000

08000e8c <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8000e8c:	4b29      	ldr	r3, [pc, #164]	; (8000f34 <HAL_PWREx_ControlVoltageScaling+0xa8>)

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000e8e:	681a      	ldr	r2, [r3, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8000e90:	bb28      	cbnz	r0, 8000ede <HAL_PWREx_ControlVoltageScaling+0x52>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000e92:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8000e96:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8000e9a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8000e9e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000ea2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000ea6:	d119      	bne.n	8000edc <HAL_PWREx_ControlVoltageScaling+0x50>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000ea8:	681a      	ldr	r2, [r3, #0]
 8000eaa:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8000eae:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000eb2:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8000eb4:	4a20      	ldr	r2, [pc, #128]	; (8000f38 <HAL_PWREx_ControlVoltageScaling+0xac>)
 8000eb6:	6811      	ldr	r1, [r2, #0]
 8000eb8:	2232      	movs	r2, #50	; 0x32
 8000eba:	434a      	muls	r2, r1
 8000ebc:	491f      	ldr	r1, [pc, #124]	; (8000f3c <HAL_PWREx_ControlVoltageScaling+0xb0>)
 8000ebe:	fbb2 f2f1 	udiv	r2, r2, r1
 8000ec2:	4619      	mov	r1, r3
 8000ec4:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8000ec6:	6958      	ldr	r0, [r3, #20]
 8000ec8:	0540      	lsls	r0, r0, #21
 8000eca:	d500      	bpl.n	8000ece <HAL_PWREx_ControlVoltageScaling+0x42>
 8000ecc:	b922      	cbnz	r2, 8000ed8 <HAL_PWREx_ControlVoltageScaling+0x4c>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8000ece:	694b      	ldr	r3, [r1, #20]
 8000ed0:	055b      	lsls	r3, r3, #21
 8000ed2:	d52d      	bpl.n	8000f30 <HAL_PWREx_ControlVoltageScaling+0xa4>
      {
        return HAL_TIMEOUT;
 8000ed4:	2003      	movs	r0, #3
 8000ed6:	4770      	bx	lr
        wait_loop_index--;
 8000ed8:	3a01      	subs	r2, #1
 8000eda:	e7f4      	b.n	8000ec6 <HAL_PWREx_ControlVoltageScaling+0x3a>
 8000edc:	4770      	bx	lr
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000ede:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000ee2:	d120      	bne.n	8000f26 <HAL_PWREx_ControlVoltageScaling+0x9a>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000ee4:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8000ee8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8000eec:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8000ef0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000ef4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8000ef8:	d11a      	bne.n	8000f30 <HAL_PWREx_ControlVoltageScaling+0xa4>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000efa:	681a      	ldr	r2, [r3, #0]
 8000efc:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8000f00:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000f04:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8000f06:	4a0c      	ldr	r2, [pc, #48]	; (8000f38 <HAL_PWREx_ControlVoltageScaling+0xac>)
 8000f08:	6811      	ldr	r1, [r2, #0]
 8000f0a:	2232      	movs	r2, #50	; 0x32
 8000f0c:	434a      	muls	r2, r1
 8000f0e:	490b      	ldr	r1, [pc, #44]	; (8000f3c <HAL_PWREx_ControlVoltageScaling+0xb0>)
 8000f10:	fbb2 f2f1 	udiv	r2, r2, r1
 8000f14:	4619      	mov	r1, r3
 8000f16:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8000f18:	6958      	ldr	r0, [r3, #20]
 8000f1a:	0540      	lsls	r0, r0, #21
 8000f1c:	d5d7      	bpl.n	8000ece <HAL_PWREx_ControlVoltageScaling+0x42>
 8000f1e:	2a00      	cmp	r2, #0
 8000f20:	d0d5      	beq.n	8000ece <HAL_PWREx_ControlVoltageScaling+0x42>
      {
        wait_loop_index--;
 8000f22:	3a01      	subs	r2, #1
 8000f24:	e7f8      	b.n	8000f18 <HAL_PWREx_ControlVoltageScaling+0x8c>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8000f26:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8000f2a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000f2e:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 8000f30:	2000      	movs	r0, #0
}
 8000f32:	4770      	bx	lr
 8000f34:	40007000 	.word	0x40007000
 8000f38:	200000d8 	.word	0x200000d8
 8000f3c:	000f4240 	.word	0x000f4240

08000f40 <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8000f40:	4a02      	ldr	r2, [pc, #8]	; (8000f4c <HAL_PWREx_EnableVddUSB+0xc>)
 8000f42:	6853      	ldr	r3, [r2, #4]
 8000f44:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000f48:	6053      	str	r3, [r2, #4]
 8000f4a:	4770      	bx	lr
 8000f4c:	40007000 	.word	0x40007000

08000f50 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8000f50:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000f52:	4d1c      	ldr	r5, [pc, #112]	; (8000fc4 <RCC_SetFlashLatencyFromMSIRange+0x74>)
 8000f54:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8000f56:	00da      	lsls	r2, r3, #3
{
 8000f58:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000f5a:	d518      	bpl.n	8000f8e <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8000f5c:	f7ff ff84 	bl	8000e68 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000f60:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000f64:	d123      	bne.n	8000fae <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if(msirange > RCC_MSIRANGE_8)
 8000f66:	2c80      	cmp	r4, #128	; 0x80
 8000f68:	d928      	bls.n	8000fbc <RCC_SetFlashLatencyFromMSIRange+0x6c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8000f6a:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8000f6c:	bf8c      	ite	hi
 8000f6e:	2002      	movhi	r0, #2
 8000f70:	2001      	movls	r0, #1
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8000f72:	4a15      	ldr	r2, [pc, #84]	; (8000fc8 <RCC_SetFlashLatencyFromMSIRange+0x78>)
 8000f74:	6813      	ldr	r3, [r2, #0]
 8000f76:	f023 030f 	bic.w	r3, r3, #15
 8000f7a:	4303      	orrs	r3, r0
 8000f7c:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8000f7e:	6813      	ldr	r3, [r2, #0]
 8000f80:	f003 030f 	and.w	r3, r3, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8000f84:	1a18      	subs	r0, r3, r0
 8000f86:	bf18      	it	ne
 8000f88:	2001      	movne	r0, #1
 8000f8a:	b003      	add	sp, #12
 8000f8c:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8000f8e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8000f90:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000f94:	65ab      	str	r3, [r5, #88]	; 0x58
 8000f96:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8000f98:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000f9c:	9301      	str	r3, [sp, #4]
 8000f9e:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8000fa0:	f7ff ff62 	bl	8000e68 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8000fa4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8000fa6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000faa:	65ab      	str	r3, [r5, #88]	; 0x58
 8000fac:	e7d8      	b.n	8000f60 <RCC_SetFlashLatencyFromMSIRange+0x10>
    if(msirange >= RCC_MSIRANGE_8)
 8000fae:	2c7f      	cmp	r4, #127	; 0x7f
 8000fb0:	d806      	bhi.n	8000fc0 <RCC_SetFlashLatencyFromMSIRange+0x70>
      if(msirange == RCC_MSIRANGE_7)
 8000fb2:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
 8000fb6:	4258      	negs	r0, r3
 8000fb8:	4158      	adcs	r0, r3
 8000fba:	e7da      	b.n	8000f72 <RCC_SetFlashLatencyFromMSIRange+0x22>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8000fbc:	2000      	movs	r0, #0
 8000fbe:	e7d8      	b.n	8000f72 <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 8000fc0:	2002      	movs	r0, #2
 8000fc2:	e7d6      	b.n	8000f72 <RCC_SetFlashLatencyFromMSIRange+0x22>
 8000fc4:	40021000 	.word	0x40021000
 8000fc8:	40022000 	.word	0x40022000

08000fcc <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000fcc:	4b23      	ldr	r3, [pc, #140]	; (800105c <HAL_RCC_GetSysClockFreq+0x90>)
 8000fce:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000fd0:	68d9      	ldr	r1, [r3, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8000fd2:	f012 020c 	ands.w	r2, r2, #12
 8000fd6:	d005      	beq.n	8000fe4 <HAL_RCC_GetSysClockFreq+0x18>
 8000fd8:	2a0c      	cmp	r2, #12
 8000fda:	d115      	bne.n	8001008 <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000fdc:	f001 0103 	and.w	r1, r1, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8000fe0:	2901      	cmp	r1, #1
 8000fe2:	d118      	bne.n	8001016 <HAL_RCC_GetSysClockFreq+0x4a>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8000fe4:	6819      	ldr	r1, [r3, #0]
    msirange = MSIRangeTable[msirange];
 8000fe6:	481e      	ldr	r0, [pc, #120]	; (8001060 <HAL_RCC_GetSysClockFreq+0x94>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8000fe8:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000fea:	bf55      	itete	pl
 8000fec:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8000ff0:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000ff2:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8000ff6:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 8000ffa:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8000ffe:	b112      	cbz	r2, 8001006 <HAL_RCC_GetSysClockFreq+0x3a>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8001000:	2a0c      	cmp	r2, #12
 8001002:	d009      	beq.n	8001018 <HAL_RCC_GetSysClockFreq+0x4c>
 8001004:	2000      	movs	r0, #0
}
 8001006:	4770      	bx	lr
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8001008:	2a04      	cmp	r2, #4
 800100a:	d024      	beq.n	8001056 <HAL_RCC_GetSysClockFreq+0x8a>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 800100c:	2a08      	cmp	r2, #8
 800100e:	4815      	ldr	r0, [pc, #84]	; (8001064 <HAL_RCC_GetSysClockFreq+0x98>)
 8001010:	bf18      	it	ne
 8001012:	2000      	movne	r0, #0
 8001014:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8001016:	2000      	movs	r0, #0
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8001018:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800101a:	68da      	ldr	r2, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800101c:	f001 0103 	and.w	r1, r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001020:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
 8001024:	2902      	cmp	r1, #2
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001026:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 800102a:	d005      	beq.n	8001038 <HAL_RCC_GetSysClockFreq+0x6c>
 800102c:	2903      	cmp	r1, #3
 800102e:	d003      	beq.n	8001038 <HAL_RCC_GetSysClockFreq+0x6c>
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001030:	68d9      	ldr	r1, [r3, #12]
 8001032:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8001036:	e003      	b.n	8001040 <HAL_RCC_GetSysClockFreq+0x74>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001038:	68d9      	ldr	r1, [r3, #12]
 800103a:	480a      	ldr	r0, [pc, #40]	; (8001064 <HAL_RCC_GetSysClockFreq+0x98>)
 800103c:	f3c1 2106 	ubfx	r1, r1, #8, #7
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001040:	68db      	ldr	r3, [r3, #12]
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001042:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001046:	f3c3 6341 	ubfx	r3, r3, #25, #2
 800104a:	3301      	adds	r3, #1
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800104c:	4348      	muls	r0, r1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800104e:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8001050:	fbb0 f0f3 	udiv	r0, r0, r3
 8001054:	4770      	bx	lr
 8001056:	4803      	ldr	r0, [pc, #12]	; (8001064 <HAL_RCC_GetSysClockFreq+0x98>)
 8001058:	4770      	bx	lr
 800105a:	bf00      	nop
 800105c:	40021000 	.word	0x40021000
 8001060:	080035b8 	.word	0x080035b8
 8001064:	00f42400 	.word	0x00f42400

08001068 <HAL_RCC_OscConfig>:
{
 8001068:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(RCC_OscInitStruct == NULL)
 800106c:	4605      	mov	r5, r0
 800106e:	b908      	cbnz	r0, 8001074 <HAL_RCC_OscConfig+0xc>
      return HAL_ERROR;
 8001070:	2001      	movs	r0, #1
 8001072:	e046      	b.n	8001102 <HAL_RCC_OscConfig+0x9a>
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001074:	4ca8      	ldr	r4, [pc, #672]	; (8001318 <HAL_RCC_OscConfig+0x2b0>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001076:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001078:	68a6      	ldr	r6, [r4, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 800107a:	68e7      	ldr	r7, [r4, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800107c:	06d8      	lsls	r0, r3, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800107e:	f006 060c 	and.w	r6, r6, #12
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001082:	f007 0703 	and.w	r7, r7, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001086:	d572      	bpl.n	800116e <HAL_RCC_OscConfig+0x106>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8001088:	b11e      	cbz	r6, 8001092 <HAL_RCC_OscConfig+0x2a>
 800108a:	2e0c      	cmp	r6, #12
 800108c:	d151      	bne.n	8001132 <HAL_RCC_OscConfig+0xca>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 800108e:	2f01      	cmp	r7, #1
 8001090:	d14f      	bne.n	8001132 <HAL_RCC_OscConfig+0xca>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8001092:	6823      	ldr	r3, [r4, #0]
 8001094:	0799      	lsls	r1, r3, #30
 8001096:	d502      	bpl.n	800109e <HAL_RCC_OscConfig+0x36>
 8001098:	69ab      	ldr	r3, [r5, #24]
 800109a:	2b00      	cmp	r3, #0
 800109c:	d0e8      	beq.n	8001070 <HAL_RCC_OscConfig+0x8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800109e:	6823      	ldr	r3, [r4, #0]
 80010a0:	6a28      	ldr	r0, [r5, #32]
 80010a2:	071a      	lsls	r2, r3, #28
 80010a4:	bf56      	itet	pl
 80010a6:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
 80010aa:	6823      	ldrmi	r3, [r4, #0]
 80010ac:	091b      	lsrpl	r3, r3, #4
 80010ae:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80010b2:	4283      	cmp	r3, r0
 80010b4:	d228      	bcs.n	8001108 <HAL_RCC_OscConfig+0xa0>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80010b6:	f7ff ff4b 	bl	8000f50 <RCC_SetFlashLatencyFromMSIRange>
 80010ba:	2800      	cmp	r0, #0
 80010bc:	d1d8      	bne.n	8001070 <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80010be:	6823      	ldr	r3, [r4, #0]
 80010c0:	f043 0308 	orr.w	r3, r3, #8
 80010c4:	6023      	str	r3, [r4, #0]
 80010c6:	6823      	ldr	r3, [r4, #0]
 80010c8:	6a2a      	ldr	r2, [r5, #32]
 80010ca:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80010ce:	4313      	orrs	r3, r2
 80010d0:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80010d2:	6863      	ldr	r3, [r4, #4]
 80010d4:	69ea      	ldr	r2, [r5, #28]
 80010d6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80010da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80010de:	6063      	str	r3, [r4, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80010e0:	f7ff ff74 	bl	8000fcc <HAL_RCC_GetSysClockFreq>
 80010e4:	68a3      	ldr	r3, [r4, #8]
 80010e6:	4a8d      	ldr	r2, [pc, #564]	; (800131c <HAL_RCC_OscConfig+0x2b4>)
 80010e8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80010ec:	5cd3      	ldrb	r3, [r2, r3]
 80010ee:	f003 031f 	and.w	r3, r3, #31
 80010f2:	40d8      	lsrs	r0, r3
 80010f4:	4b8a      	ldr	r3, [pc, #552]	; (8001320 <HAL_RCC_OscConfig+0x2b8>)
 80010f6:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick (TICK_INT_PRIORITY);
 80010f8:	2000      	movs	r0, #0
 80010fa:	f7ff f87f 	bl	80001fc <HAL_InitTick>
        if(status != HAL_OK)
 80010fe:	2800      	cmp	r0, #0
 8001100:	d035      	beq.n	800116e <HAL_RCC_OscConfig+0x106>
}
 8001102:	b003      	add	sp, #12
 8001104:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001108:	6823      	ldr	r3, [r4, #0]
 800110a:	f043 0308 	orr.w	r3, r3, #8
 800110e:	6023      	str	r3, [r4, #0]
 8001110:	6823      	ldr	r3, [r4, #0]
 8001112:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001116:	4303      	orrs	r3, r0
 8001118:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800111a:	6863      	ldr	r3, [r4, #4]
 800111c:	69ea      	ldr	r2, [r5, #28]
 800111e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001122:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001126:	6063      	str	r3, [r4, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001128:	f7ff ff12 	bl	8000f50 <RCC_SetFlashLatencyFromMSIRange>
 800112c:	2800      	cmp	r0, #0
 800112e:	d0d7      	beq.n	80010e0 <HAL_RCC_OscConfig+0x78>
 8001130:	e79e      	b.n	8001070 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8001132:	69ab      	ldr	r3, [r5, #24]
 8001134:	2b00      	cmp	r3, #0
 8001136:	d03a      	beq.n	80011ae <HAL_RCC_OscConfig+0x146>
        __HAL_RCC_MSI_ENABLE();
 8001138:	6823      	ldr	r3, [r4, #0]
 800113a:	f043 0301 	orr.w	r3, r3, #1
 800113e:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8001140:	f7ff f88c 	bl	800025c <HAL_GetTick>
 8001144:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8001146:	6823      	ldr	r3, [r4, #0]
 8001148:	079b      	lsls	r3, r3, #30
 800114a:	d528      	bpl.n	800119e <HAL_RCC_OscConfig+0x136>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800114c:	6823      	ldr	r3, [r4, #0]
 800114e:	f043 0308 	orr.w	r3, r3, #8
 8001152:	6023      	str	r3, [r4, #0]
 8001154:	6823      	ldr	r3, [r4, #0]
 8001156:	6a2a      	ldr	r2, [r5, #32]
 8001158:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800115c:	4313      	orrs	r3, r2
 800115e:	6023      	str	r3, [r4, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001160:	6863      	ldr	r3, [r4, #4]
 8001162:	69ea      	ldr	r2, [r5, #28]
 8001164:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001168:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800116c:	6063      	str	r3, [r4, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800116e:	682b      	ldr	r3, [r5, #0]
 8001170:	07d9      	lsls	r1, r3, #31
 8001172:	d42d      	bmi.n	80011d0 <HAL_RCC_OscConfig+0x168>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001174:	682b      	ldr	r3, [r5, #0]
 8001176:	079a      	lsls	r2, r3, #30
 8001178:	d46b      	bmi.n	8001252 <HAL_RCC_OscConfig+0x1ea>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800117a:	682b      	ldr	r3, [r5, #0]
 800117c:	0719      	lsls	r1, r3, #28
 800117e:	f100 80a0 	bmi.w	80012c2 <HAL_RCC_OscConfig+0x25a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001182:	682b      	ldr	r3, [r5, #0]
 8001184:	075a      	lsls	r2, r3, #29
 8001186:	f100 80cd 	bmi.w	8001324 <HAL_RCC_OscConfig+0x2bc>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800118a:	682b      	ldr	r3, [r5, #0]
 800118c:	069a      	lsls	r2, r3, #26
 800118e:	f100 8136 	bmi.w	80013fe <HAL_RCC_OscConfig+0x396>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8001192:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001194:	2b00      	cmp	r3, #0
 8001196:	f040 815c 	bne.w	8001452 <HAL_RCC_OscConfig+0x3ea>
  return HAL_OK;
 800119a:	2000      	movs	r0, #0
 800119c:	e7b1      	b.n	8001102 <HAL_RCC_OscConfig+0x9a>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800119e:	f7ff f85d 	bl	800025c <HAL_GetTick>
 80011a2:	eba0 0008 	sub.w	r0, r0, r8
 80011a6:	2802      	cmp	r0, #2
 80011a8:	d9cd      	bls.n	8001146 <HAL_RCC_OscConfig+0xde>
            return HAL_TIMEOUT;
 80011aa:	2003      	movs	r0, #3
 80011ac:	e7a9      	b.n	8001102 <HAL_RCC_OscConfig+0x9a>
        __HAL_RCC_MSI_DISABLE();
 80011ae:	6823      	ldr	r3, [r4, #0]
 80011b0:	f023 0301 	bic.w	r3, r3, #1
 80011b4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80011b6:	f7ff f851 	bl	800025c <HAL_GetTick>
 80011ba:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80011bc:	6823      	ldr	r3, [r4, #0]
 80011be:	0798      	lsls	r0, r3, #30
 80011c0:	d5d5      	bpl.n	800116e <HAL_RCC_OscConfig+0x106>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80011c2:	f7ff f84b 	bl	800025c <HAL_GetTick>
 80011c6:	eba0 0008 	sub.w	r0, r0, r8
 80011ca:	2802      	cmp	r0, #2
 80011cc:	d9f6      	bls.n	80011bc <HAL_RCC_OscConfig+0x154>
 80011ce:	e7ec      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 80011d0:	2e08      	cmp	r6, #8
 80011d2:	d003      	beq.n	80011dc <HAL_RCC_OscConfig+0x174>
 80011d4:	2e0c      	cmp	r6, #12
 80011d6:	d108      	bne.n	80011ea <HAL_RCC_OscConfig+0x182>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSE)))
 80011d8:	2f03      	cmp	r7, #3
 80011da:	d106      	bne.n	80011ea <HAL_RCC_OscConfig+0x182>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80011dc:	6823      	ldr	r3, [r4, #0]
 80011de:	039b      	lsls	r3, r3, #14
 80011e0:	d5c8      	bpl.n	8001174 <HAL_RCC_OscConfig+0x10c>
 80011e2:	686b      	ldr	r3, [r5, #4]
 80011e4:	2b00      	cmp	r3, #0
 80011e6:	d1c5      	bne.n	8001174 <HAL_RCC_OscConfig+0x10c>
 80011e8:	e742      	b.n	8001070 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80011ea:	686b      	ldr	r3, [r5, #4]
 80011ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80011f0:	d110      	bne.n	8001214 <HAL_RCC_OscConfig+0x1ac>
 80011f2:	6823      	ldr	r3, [r4, #0]
 80011f4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80011f8:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80011fa:	f7ff f82f 	bl	800025c <HAL_GetTick>
 80011fe:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001200:	6823      	ldr	r3, [r4, #0]
 8001202:	0398      	lsls	r0, r3, #14
 8001204:	d4b6      	bmi.n	8001174 <HAL_RCC_OscConfig+0x10c>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001206:	f7ff f829 	bl	800025c <HAL_GetTick>
 800120a:	eba0 0008 	sub.w	r0, r0, r8
 800120e:	2864      	cmp	r0, #100	; 0x64
 8001210:	d9f6      	bls.n	8001200 <HAL_RCC_OscConfig+0x198>
 8001212:	e7ca      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001214:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001218:	d104      	bne.n	8001224 <HAL_RCC_OscConfig+0x1bc>
 800121a:	6823      	ldr	r3, [r4, #0]
 800121c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001220:	6023      	str	r3, [r4, #0]
 8001222:	e7e6      	b.n	80011f2 <HAL_RCC_OscConfig+0x18a>
 8001224:	6822      	ldr	r2, [r4, #0]
 8001226:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800122a:	6022      	str	r2, [r4, #0]
 800122c:	6822      	ldr	r2, [r4, #0]
 800122e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001232:	6022      	str	r2, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001234:	2b00      	cmp	r3, #0
 8001236:	d1e0      	bne.n	80011fa <HAL_RCC_OscConfig+0x192>
        tickstart = HAL_GetTick();
 8001238:	f7ff f810 	bl	800025c <HAL_GetTick>
 800123c:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800123e:	6823      	ldr	r3, [r4, #0]
 8001240:	0399      	lsls	r1, r3, #14
 8001242:	d597      	bpl.n	8001174 <HAL_RCC_OscConfig+0x10c>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001244:	f7ff f80a 	bl	800025c <HAL_GetTick>
 8001248:	eba0 0008 	sub.w	r0, r0, r8
 800124c:	2864      	cmp	r0, #100	; 0x64
 800124e:	d9f6      	bls.n	800123e <HAL_RCC_OscConfig+0x1d6>
 8001250:	e7ab      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 8001252:	2e04      	cmp	r6, #4
 8001254:	d003      	beq.n	800125e <HAL_RCC_OscConfig+0x1f6>
 8001256:	2e0c      	cmp	r6, #12
 8001258:	d110      	bne.n	800127c <HAL_RCC_OscConfig+0x214>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSI)))
 800125a:	2f02      	cmp	r7, #2
 800125c:	d10e      	bne.n	800127c <HAL_RCC_OscConfig+0x214>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800125e:	6823      	ldr	r3, [r4, #0]
 8001260:	055a      	lsls	r2, r3, #21
 8001262:	d503      	bpl.n	800126c <HAL_RCC_OscConfig+0x204>
 8001264:	68eb      	ldr	r3, [r5, #12]
 8001266:	2b00      	cmp	r3, #0
 8001268:	f43f af02 	beq.w	8001070 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800126c:	6863      	ldr	r3, [r4, #4]
 800126e:	692a      	ldr	r2, [r5, #16]
 8001270:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8001274:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001278:	6063      	str	r3, [r4, #4]
 800127a:	e77e      	b.n	800117a <HAL_RCC_OscConfig+0x112>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800127c:	68eb      	ldr	r3, [r5, #12]
 800127e:	b17b      	cbz	r3, 80012a0 <HAL_RCC_OscConfig+0x238>
        __HAL_RCC_HSI_ENABLE();
 8001280:	6823      	ldr	r3, [r4, #0]
 8001282:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001286:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8001288:	f7fe ffe8 	bl	800025c <HAL_GetTick>
 800128c:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800128e:	6823      	ldr	r3, [r4, #0]
 8001290:	055b      	lsls	r3, r3, #21
 8001292:	d4eb      	bmi.n	800126c <HAL_RCC_OscConfig+0x204>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001294:	f7fe ffe2 	bl	800025c <HAL_GetTick>
 8001298:	1bc0      	subs	r0, r0, r7
 800129a:	2802      	cmp	r0, #2
 800129c:	d9f7      	bls.n	800128e <HAL_RCC_OscConfig+0x226>
 800129e:	e784      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_DISABLE();
 80012a0:	6823      	ldr	r3, [r4, #0]
 80012a2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80012a6:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80012a8:	f7fe ffd8 	bl	800025c <HAL_GetTick>
 80012ac:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80012ae:	6823      	ldr	r3, [r4, #0]
 80012b0:	0558      	lsls	r0, r3, #21
 80012b2:	f57f af62 	bpl.w	800117a <HAL_RCC_OscConfig+0x112>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80012b6:	f7fe ffd1 	bl	800025c <HAL_GetTick>
 80012ba:	1bc0      	subs	r0, r0, r7
 80012bc:	2802      	cmp	r0, #2
 80012be:	d9f6      	bls.n	80012ae <HAL_RCC_OscConfig+0x246>
 80012c0:	e773      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80012c2:	696b      	ldr	r3, [r5, #20]
 80012c4:	b19b      	cbz	r3, 80012ee <HAL_RCC_OscConfig+0x286>
      __HAL_RCC_LSI_ENABLE();
 80012c6:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80012ca:	f043 0301 	orr.w	r3, r3, #1
 80012ce:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 80012d2:	f7fe ffc3 	bl	800025c <HAL_GetTick>
 80012d6:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80012d8:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80012dc:	079b      	lsls	r3, r3, #30
 80012de:	f53f af50 	bmi.w	8001182 <HAL_RCC_OscConfig+0x11a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80012e2:	f7fe ffbb 	bl	800025c <HAL_GetTick>
 80012e6:	1bc0      	subs	r0, r0, r7
 80012e8:	2802      	cmp	r0, #2
 80012ea:	d9f5      	bls.n	80012d8 <HAL_RCC_OscConfig+0x270>
 80012ec:	e75d      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_LSI_DISABLE();
 80012ee:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80012f2:	f023 0301 	bic.w	r3, r3, #1
 80012f6:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 80012fa:	f7fe ffaf 	bl	800025c <HAL_GetTick>
 80012fe:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8001300:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8001304:	0798      	lsls	r0, r3, #30
 8001306:	f57f af3c 	bpl.w	8001182 <HAL_RCC_OscConfig+0x11a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800130a:	f7fe ffa7 	bl	800025c <HAL_GetTick>
 800130e:	1bc0      	subs	r0, r0, r7
 8001310:	2802      	cmp	r0, #2
 8001312:	d9f5      	bls.n	8001300 <HAL_RCC_OscConfig+0x298>
 8001314:	e749      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
 8001316:	bf00      	nop
 8001318:	40021000 	.word	0x40021000
 800131c:	080035a8 	.word	0x080035a8
 8001320:	200000d8 	.word	0x200000d8
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8001324:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001326:	00d9      	lsls	r1, r3, #3
 8001328:	d429      	bmi.n	800137e <HAL_RCC_OscConfig+0x316>
      __HAL_RCC_PWR_CLK_ENABLE();
 800132a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800132c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001330:	65a3      	str	r3, [r4, #88]	; 0x58
 8001332:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001334:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001338:	9301      	str	r3, [sp, #4]
 800133a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800133c:	f04f 0801 	mov.w	r8, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001340:	4f71      	ldr	r7, [pc, #452]	; (8001508 <HAL_RCC_OscConfig+0x4a0>)
 8001342:	683b      	ldr	r3, [r7, #0]
 8001344:	05da      	lsls	r2, r3, #23
 8001346:	d51d      	bpl.n	8001384 <HAL_RCC_OscConfig+0x31c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001348:	68ab      	ldr	r3, [r5, #8]
 800134a:	2b01      	cmp	r3, #1
 800134c:	d12b      	bne.n	80013a6 <HAL_RCC_OscConfig+0x33e>
 800134e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001352:	f043 0301 	orr.w	r3, r3, #1
 8001356:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      tickstart = HAL_GetTick();
 800135a:	f7fe ff7f 	bl	800025c <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800135e:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8001362:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8001364:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001368:	0798      	lsls	r0, r3, #30
 800136a:	d542      	bpl.n	80013f2 <HAL_RCC_OscConfig+0x38a>
    if(pwrclkchanged == SET)
 800136c:	f1b8 0f00 	cmp.w	r8, #0
 8001370:	f43f af0b 	beq.w	800118a <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001374:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001376:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800137a:	65a3      	str	r3, [r4, #88]	; 0x58
 800137c:	e705      	b.n	800118a <HAL_RCC_OscConfig+0x122>
    FlagStatus       pwrclkchanged = RESET;
 800137e:	f04f 0800 	mov.w	r8, #0
 8001382:	e7dd      	b.n	8001340 <HAL_RCC_OscConfig+0x2d8>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001384:	683b      	ldr	r3, [r7, #0]
 8001386:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800138a:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 800138c:	f7fe ff66 	bl	800025c <HAL_GetTick>
 8001390:	4681      	mov	r9, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001392:	683b      	ldr	r3, [r7, #0]
 8001394:	05db      	lsls	r3, r3, #23
 8001396:	d4d7      	bmi.n	8001348 <HAL_RCC_OscConfig+0x2e0>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001398:	f7fe ff60 	bl	800025c <HAL_GetTick>
 800139c:	eba0 0009 	sub.w	r0, r0, r9
 80013a0:	2802      	cmp	r0, #2
 80013a2:	d9f6      	bls.n	8001392 <HAL_RCC_OscConfig+0x32a>
 80013a4:	e701      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80013a6:	2b05      	cmp	r3, #5
 80013a8:	d106      	bne.n	80013b8 <HAL_RCC_OscConfig+0x350>
 80013aa:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80013ae:	f043 0304 	orr.w	r3, r3, #4
 80013b2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 80013b6:	e7ca      	b.n	800134e <HAL_RCC_OscConfig+0x2e6>
 80013b8:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80013bc:	f022 0201 	bic.w	r2, r2, #1
 80013c0:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 80013c4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80013c8:	f022 0204 	bic.w	r2, r2, #4
 80013cc:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80013d0:	2b00      	cmp	r3, #0
 80013d2:	d1c2      	bne.n	800135a <HAL_RCC_OscConfig+0x2f2>
      tickstart = HAL_GetTick();
 80013d4:	f7fe ff42 	bl	800025c <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80013d8:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80013dc:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80013de:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80013e2:	0799      	lsls	r1, r3, #30
 80013e4:	d5c2      	bpl.n	800136c <HAL_RCC_OscConfig+0x304>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80013e6:	f7fe ff39 	bl	800025c <HAL_GetTick>
 80013ea:	1bc0      	subs	r0, r0, r7
 80013ec:	4548      	cmp	r0, r9
 80013ee:	d9f6      	bls.n	80013de <HAL_RCC_OscConfig+0x376>
 80013f0:	e6db      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80013f2:	f7fe ff33 	bl	800025c <HAL_GetTick>
 80013f6:	1bc0      	subs	r0, r0, r7
 80013f8:	4548      	cmp	r0, r9
 80013fa:	d9b3      	bls.n	8001364 <HAL_RCC_OscConfig+0x2fc>
 80013fc:	e6d5      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80013fe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8001400:	b19b      	cbz	r3, 800142a <HAL_RCC_OscConfig+0x3c2>
      __HAL_RCC_HSI48_ENABLE();
 8001402:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8001406:	f043 0301 	orr.w	r3, r3, #1
 800140a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 800140e:	f7fe ff25 	bl	800025c <HAL_GetTick>
 8001412:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8001414:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8001418:	079b      	lsls	r3, r3, #30
 800141a:	f53f aeba 	bmi.w	8001192 <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800141e:	f7fe ff1d 	bl	800025c <HAL_GetTick>
 8001422:	1bc0      	subs	r0, r0, r7
 8001424:	2802      	cmp	r0, #2
 8001426:	d9f5      	bls.n	8001414 <HAL_RCC_OscConfig+0x3ac>
 8001428:	e6bf      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_HSI48_DISABLE();
 800142a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800142e:	f023 0301 	bic.w	r3, r3, #1
 8001432:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 8001436:	f7fe ff11 	bl	800025c <HAL_GetTick>
 800143a:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800143c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8001440:	0798      	lsls	r0, r3, #30
 8001442:	f57f aea6 	bpl.w	8001192 <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8001446:	f7fe ff09 	bl	800025c <HAL_GetTick>
 800144a:	1bc0      	subs	r0, r0, r7
 800144c:	2802      	cmp	r0, #2
 800144e:	d9f5      	bls.n	800143c <HAL_RCC_OscConfig+0x3d4>
 8001450:	e6ab      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
    if(sysclk_source != RCC_CFGR_SWS_PLL)
 8001452:	2e0c      	cmp	r6, #12
 8001454:	f43f ae0c 	beq.w	8001070 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001458:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 800145a:	6823      	ldr	r3, [r4, #0]
 800145c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001460:	6023      	str	r3, [r4, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001462:	d136      	bne.n	80014d2 <HAL_RCC_OscConfig+0x46a>
        tickstart = HAL_GetTick();
 8001464:	f7fe fefa 	bl	800025c <HAL_GetTick>
 8001468:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800146a:	6823      	ldr	r3, [r4, #0]
 800146c:	0199      	lsls	r1, r3, #6
 800146e:	d42a      	bmi.n	80014c6 <HAL_RCC_OscConfig+0x45e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001470:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001472:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8001474:	06db      	lsls	r3, r3, #27
 8001476:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800147a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800147c:	4313      	orrs	r3, r2
 800147e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8001480:	3a01      	subs	r2, #1
 8001482:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8001486:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8001488:	0852      	lsrs	r2, r2, #1
 800148a:	3a01      	subs	r2, #1
 800148c:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8001490:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 8001492:	0852      	lsrs	r2, r2, #1
 8001494:	3a01      	subs	r2, #1
 8001496:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 800149a:	60e3      	str	r3, [r4, #12]
        __HAL_RCC_PLL_ENABLE();
 800149c:	6823      	ldr	r3, [r4, #0]
 800149e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80014a2:	6023      	str	r3, [r4, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80014a4:	68e3      	ldr	r3, [r4, #12]
 80014a6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80014aa:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80014ac:	f7fe fed6 	bl	800025c <HAL_GetTick>
 80014b0:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80014b2:	6823      	ldr	r3, [r4, #0]
 80014b4:	019a      	lsls	r2, r3, #6
 80014b6:	f53f ae70 	bmi.w	800119a <HAL_RCC_OscConfig+0x132>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80014ba:	f7fe fecf 	bl	800025c <HAL_GetTick>
 80014be:	1b40      	subs	r0, r0, r5
 80014c0:	2802      	cmp	r0, #2
 80014c2:	d9f6      	bls.n	80014b2 <HAL_RCC_OscConfig+0x44a>
 80014c4:	e671      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80014c6:	f7fe fec9 	bl	800025c <HAL_GetTick>
 80014ca:	1b80      	subs	r0, r0, r6
 80014cc:	2802      	cmp	r0, #2
 80014ce:	d9cc      	bls.n	800146a <HAL_RCC_OscConfig+0x402>
 80014d0:	e66b      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 80014d2:	6823      	ldr	r3, [r4, #0]
 80014d4:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80014d8:	bf02      	ittt	eq
 80014da:	68e3      	ldreq	r3, [r4, #12]
 80014dc:	f023 0303 	biceq.w	r3, r3, #3
 80014e0:	60e3      	streq	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 80014e2:	68e3      	ldr	r3, [r4, #12]
 80014e4:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80014e8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80014ec:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80014ee:	f7fe feb5 	bl	800025c <HAL_GetTick>
 80014f2:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80014f4:	6823      	ldr	r3, [r4, #0]
 80014f6:	019b      	lsls	r3, r3, #6
 80014f8:	f57f ae4f 	bpl.w	800119a <HAL_RCC_OscConfig+0x132>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80014fc:	f7fe feae 	bl	800025c <HAL_GetTick>
 8001500:	1b40      	subs	r0, r0, r5
 8001502:	2802      	cmp	r0, #2
 8001504:	d9f6      	bls.n	80014f4 <HAL_RCC_OscConfig+0x48c>
 8001506:	e650      	b.n	80011aa <HAL_RCC_OscConfig+0x142>
 8001508:	40007000 	.word	0x40007000

0800150c <HAL_RCC_ClockConfig>:
{
 800150c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001510:	460e      	mov	r6, r1
  if(RCC_ClkInitStruct == NULL)
 8001512:	4605      	mov	r5, r0
 8001514:	b910      	cbnz	r0, 800151c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8001516:	2001      	movs	r0, #1
 8001518:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800151c:	4a71      	ldr	r2, [pc, #452]	; (80016e4 <HAL_RCC_ClockConfig+0x1d8>)
 800151e:	6813      	ldr	r3, [r2, #0]
 8001520:	f003 030f 	and.w	r3, r3, #15
 8001524:	428b      	cmp	r3, r1
 8001526:	d334      	bcc.n	8001592 <HAL_RCC_ClockConfig+0x86>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001528:	6829      	ldr	r1, [r5, #0]
 800152a:	f011 0701 	ands.w	r7, r1, #1
 800152e:	d13b      	bne.n	80015a8 <HAL_RCC_ClockConfig+0x9c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001530:	682a      	ldr	r2, [r5, #0]
 8001532:	0791      	lsls	r1, r2, #30
 8001534:	f140 80bb 	bpl.w	80016ae <HAL_RCC_ClockConfig+0x1a2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001538:	496b      	ldr	r1, [pc, #428]	; (80016e8 <HAL_RCC_ClockConfig+0x1dc>)
 800153a:	68a8      	ldr	r0, [r5, #8]
 800153c:	688b      	ldr	r3, [r1, #8]
 800153e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001542:	4303      	orrs	r3, r0
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8001544:	608b      	str	r3, [r1, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8001546:	4967      	ldr	r1, [pc, #412]	; (80016e4 <HAL_RCC_ClockConfig+0x1d8>)
 8001548:	680b      	ldr	r3, [r1, #0]
 800154a:	f003 030f 	and.w	r3, r3, #15
 800154e:	429e      	cmp	r6, r3
 8001550:	f0c0 80b5 	bcc.w	80016be <HAL_RCC_ClockConfig+0x1b2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001554:	f012 0f04 	tst.w	r2, #4
 8001558:	4c63      	ldr	r4, [pc, #396]	; (80016e8 <HAL_RCC_ClockConfig+0x1dc>)
 800155a:	f040 80bc 	bne.w	80016d6 <HAL_RCC_ClockConfig+0x1ca>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800155e:	0713      	lsls	r3, r2, #28
 8001560:	d506      	bpl.n	8001570 <HAL_RCC_ClockConfig+0x64>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001562:	68a3      	ldr	r3, [r4, #8]
 8001564:	692a      	ldr	r2, [r5, #16]
 8001566:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 800156a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800156e:	60a3      	str	r3, [r4, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8001570:	f7ff fd2c 	bl	8000fcc <HAL_RCC_GetSysClockFreq>
 8001574:	68a3      	ldr	r3, [r4, #8]
 8001576:	4a5d      	ldr	r2, [pc, #372]	; (80016ec <HAL_RCC_ClockConfig+0x1e0>)
 8001578:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800157c:	5cd3      	ldrb	r3, [r2, r3]
 800157e:	f003 031f 	and.w	r3, r3, #31
 8001582:	40d8      	lsrs	r0, r3
 8001584:	4b5a      	ldr	r3, [pc, #360]	; (80016f0 <HAL_RCC_ClockConfig+0x1e4>)
 8001586:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick (TICK_INT_PRIORITY);
 8001588:	2000      	movs	r0, #0
}
 800158a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  status = HAL_InitTick (TICK_INT_PRIORITY);
 800158e:	f7fe be35 	b.w	80001fc <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001592:	6813      	ldr	r3, [r2, #0]
 8001594:	f023 030f 	bic.w	r3, r3, #15
 8001598:	430b      	orrs	r3, r1
 800159a:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800159c:	6813      	ldr	r3, [r2, #0]
 800159e:	f003 030f 	and.w	r3, r3, #15
 80015a2:	4299      	cmp	r1, r3
 80015a4:	d1b7      	bne.n	8001516 <HAL_RCC_ClockConfig+0xa>
 80015a6:	e7bf      	b.n	8001528 <HAL_RCC_ClockConfig+0x1c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80015a8:	686b      	ldr	r3, [r5, #4]
 80015aa:	4c4f      	ldr	r4, [pc, #316]	; (80016e8 <HAL_RCC_ClockConfig+0x1dc>)
 80015ac:	2b03      	cmp	r3, #3
 80015ae:	d168      	bne.n	8001682 <HAL_RCC_ClockConfig+0x176>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80015b0:	6823      	ldr	r3, [r4, #0]
 80015b2:	019b      	lsls	r3, r3, #6
 80015b4:	d5af      	bpl.n	8001516 <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 80015b6:	68e3      	ldr	r3, [r4, #12]
 80015b8:	f003 0303 	and.w	r3, r3, #3
 80015bc:	2b01      	cmp	r3, #1
 80015be:	d11e      	bne.n	80015fe <HAL_RCC_ClockConfig+0xf2>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80015c0:	6823      	ldr	r3, [r4, #0]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80015c2:	4a4c      	ldr	r2, [pc, #304]	; (80016f4 <HAL_RCC_ClockConfig+0x1e8>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80015c4:	071f      	lsls	r7, r3, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80015c6:	bf55      	itete	pl
 80015c8:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80015cc:	6823      	ldrmi	r3, [r4, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80015ce:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80015d2:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    msirange = MSIRangeTable[msirange];
 80015d6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80015da:	68e7      	ldr	r7, [r4, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80015dc:	68e3      	ldr	r3, [r4, #12]
 80015de:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80015e2:	1c58      	adds	r0, r3, #1
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80015e4:	f007 0303 	and.w	r3, r7, #3

  switch (pllsource)
 80015e8:	2b02      	cmp	r3, #2
 80015ea:	d00a      	beq.n	8001602 <HAL_RCC_ClockConfig+0xf6>
 80015ec:	2b03      	cmp	r3, #3
 80015ee:	d008      	beq.n	8001602 <HAL_RCC_ClockConfig+0xf6>
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80015f0:	fbb2 f3f0 	udiv	r3, r2, r0
 80015f4:	68e7      	ldr	r7, [r4, #12]
 80015f6:	f3c7 2706 	ubfx	r7, r7, #8, #7
 80015fa:	437b      	muls	r3, r7
 80015fc:	e008      	b.n	8001610 <HAL_RCC_ClockConfig+0x104>
  uint32_t msirange = 0U;
 80015fe:	2200      	movs	r2, #0
 8001600:	e7eb      	b.n	80015da <HAL_RCC_ClockConfig+0xce>
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001602:	68e2      	ldr	r2, [r4, #12]
 8001604:	4b3c      	ldr	r3, [pc, #240]	; (80016f8 <HAL_RCC_ClockConfig+0x1ec>)
 8001606:	fbb3 f3f0 	udiv	r3, r3, r0
 800160a:	f3c2 2206 	ubfx	r2, r2, #8, #7
 800160e:	4353      	muls	r3, r2
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001610:	68e2      	ldr	r2, [r4, #12]
 8001612:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8001616:	3201      	adds	r2, #1
 8001618:	0052      	lsls	r2, r2, #1
  sysclockfreq = pllvco/pllr;
 800161a:	fbb3 f3f2 	udiv	r3, r3, r2
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 800161e:	4a37      	ldr	r2, [pc, #220]	; (80016fc <HAL_RCC_ClockConfig+0x1f0>)
 8001620:	4293      	cmp	r3, r2
 8001622:	d81c      	bhi.n	800165e <HAL_RCC_ClockConfig+0x152>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8001624:	2700      	movs	r7, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001626:	68a3      	ldr	r3, [r4, #8]
 8001628:	686a      	ldr	r2, [r5, #4]
 800162a:	f023 0303 	bic.w	r3, r3, #3
 800162e:	4313      	orrs	r3, r2
 8001630:	60a3      	str	r3, [r4, #8]
    tickstart = HAL_GetTick();
 8001632:	f7fe fe13 	bl	800025c <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001636:	f241 3988 	movw	r9, #5000	; 0x1388
    tickstart = HAL_GetTick();
 800163a:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800163c:	68a3      	ldr	r3, [r4, #8]
 800163e:	686a      	ldr	r2, [r5, #4]
 8001640:	f003 030c 	and.w	r3, r3, #12
 8001644:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001648:	f43f af72 	beq.w	8001530 <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800164c:	f7fe fe06 	bl	800025c <HAL_GetTick>
 8001650:	eba0 0008 	sub.w	r0, r0, r8
 8001654:	4548      	cmp	r0, r9
 8001656:	d9f1      	bls.n	800163c <HAL_RCC_ClockConfig+0x130>
        return HAL_TIMEOUT;
 8001658:	2003      	movs	r0, #3
}
 800165a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 800165e:	68a3      	ldr	r3, [r4, #8]
 8001660:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8001664:	d107      	bne.n	8001676 <HAL_RCC_ClockConfig+0x16a>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8001666:	68a3      	ldr	r3, [r4, #8]
 8001668:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800166c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001670:	60a3      	str	r3, [r4, #8]
        hpre = RCC_SYSCLK_DIV2;
 8001672:	2780      	movs	r7, #128	; 0x80
 8001674:	e7d7      	b.n	8001626 <HAL_RCC_ClockConfig+0x11a>
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 8001676:	0788      	lsls	r0, r1, #30
 8001678:	d5d4      	bpl.n	8001624 <HAL_RCC_ClockConfig+0x118>
 800167a:	68ab      	ldr	r3, [r5, #8]
 800167c:	2b00      	cmp	r3, #0
 800167e:	d1d1      	bne.n	8001624 <HAL_RCC_ClockConfig+0x118>
 8001680:	e7f1      	b.n	8001666 <HAL_RCC_ClockConfig+0x15a>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001682:	2b02      	cmp	r3, #2
 8001684:	d10a      	bne.n	800169c <HAL_RCC_ClockConfig+0x190>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001686:	6823      	ldr	r3, [r4, #0]
 8001688:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800168c:	f43f af43 	beq.w	8001516 <HAL_RCC_ClockConfig+0xa>
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 8001690:	f7ff fc9c 	bl	8000fcc <HAL_RCC_GetSysClockFreq>
 8001694:	4b19      	ldr	r3, [pc, #100]	; (80016fc <HAL_RCC_ClockConfig+0x1f0>)
 8001696:	4298      	cmp	r0, r3
 8001698:	d9c4      	bls.n	8001624 <HAL_RCC_ClockConfig+0x118>
 800169a:	e7e4      	b.n	8001666 <HAL_RCC_ClockConfig+0x15a>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800169c:	b91b      	cbnz	r3, 80016a6 <HAL_RCC_ClockConfig+0x19a>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 800169e:	6823      	ldr	r3, [r4, #0]
 80016a0:	f013 0f02 	tst.w	r3, #2
 80016a4:	e7f2      	b.n	800168c <HAL_RCC_ClockConfig+0x180>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80016a6:	6823      	ldr	r3, [r4, #0]
 80016a8:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80016ac:	e7ee      	b.n	800168c <HAL_RCC_ClockConfig+0x180>
    if(hpre == RCC_SYSCLK_DIV2)
 80016ae:	2f80      	cmp	r7, #128	; 0x80
 80016b0:	f47f af49 	bne.w	8001546 <HAL_RCC_ClockConfig+0x3a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 80016b4:	490c      	ldr	r1, [pc, #48]	; (80016e8 <HAL_RCC_ClockConfig+0x1dc>)
 80016b6:	688b      	ldr	r3, [r1, #8]
 80016b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80016bc:	e742      	b.n	8001544 <HAL_RCC_ClockConfig+0x38>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80016be:	680b      	ldr	r3, [r1, #0]
 80016c0:	f023 030f 	bic.w	r3, r3, #15
 80016c4:	4333      	orrs	r3, r6
 80016c6:	600b      	str	r3, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80016c8:	680b      	ldr	r3, [r1, #0]
 80016ca:	f003 030f 	and.w	r3, r3, #15
 80016ce:	429e      	cmp	r6, r3
 80016d0:	f47f af21 	bne.w	8001516 <HAL_RCC_ClockConfig+0xa>
 80016d4:	e73e      	b.n	8001554 <HAL_RCC_ClockConfig+0x48>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80016d6:	68a3      	ldr	r3, [r4, #8]
 80016d8:	68e9      	ldr	r1, [r5, #12]
 80016da:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80016de:	430b      	orrs	r3, r1
 80016e0:	60a3      	str	r3, [r4, #8]
 80016e2:	e73c      	b.n	800155e <HAL_RCC_ClockConfig+0x52>
 80016e4:	40022000 	.word	0x40022000
 80016e8:	40021000 	.word	0x40021000
 80016ec:	080035a8 	.word	0x080035a8
 80016f0:	200000d8 	.word	0x200000d8
 80016f4:	080035b8 	.word	0x080035b8
 80016f8:	00f42400 	.word	0x00f42400
 80016fc:	04c4b400 	.word	0x04c4b400

08001700 <HAL_RCC_GetHCLKFreq>:
}
 8001700:	4b01      	ldr	r3, [pc, #4]	; (8001708 <HAL_RCC_GetHCLKFreq+0x8>)
 8001702:	6818      	ldr	r0, [r3, #0]
 8001704:	4770      	bx	lr
 8001706:	bf00      	nop
 8001708:	200000d8 	.word	0x200000d8

0800170c <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 800170c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800170e:	4b3f      	ldr	r3, [pc, #252]	; (800180c <RCCEx_PLLSAI1_Config+0x100>)
 8001710:	68da      	ldr	r2, [r3, #12]
 8001712:	f012 0f03 	tst.w	r2, #3
{
 8001716:	4605      	mov	r5, r0
 8001718:	460e      	mov	r6, r1
 800171a:	461c      	mov	r4, r3
 800171c:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800171e:	d022      	beq.n	8001766 <RCCEx_PLLSAI1_Config+0x5a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8001720:	68db      	ldr	r3, [r3, #12]
 8001722:	f003 0303 	and.w	r3, r3, #3
 8001726:	4283      	cmp	r3, r0
 8001728:	d130      	bne.n	800178c <RCCEx_PLLSAI1_Config+0x80>
       ||
 800172a:	b37b      	cbz	r3, 800178c <RCCEx_PLLSAI1_Config+0x80>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 800172c:	6823      	ldr	r3, [r4, #0]
 800172e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001732:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001734:	f7fe fd92 	bl	800025c <HAL_GetTick>
 8001738:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 800173a:	6823      	ldr	r3, [r4, #0]
 800173c:	011a      	lsls	r2, r3, #4
 800173e:	d42e      	bmi.n	800179e <RCCEx_PLLSAI1_Config+0x92>
 8001740:	68af      	ldr	r7, [r5, #8]
 8001742:	686b      	ldr	r3, [r5, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8001744:	b396      	cbz	r6, 80017ac <RCCEx_PLLSAI1_Config+0xa0>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8001746:	2e01      	cmp	r6, #1
 8001748:	d14c      	bne.n	80017e4 <RCCEx_PLLSAI1_Config+0xd8>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 800174a:	6922      	ldr	r2, [r4, #16]
 800174c:	4930      	ldr	r1, [pc, #192]	; (8001810 <RCCEx_PLLSAI1_Config+0x104>)
 800174e:	4011      	ands	r1, r2
 8001750:	692a      	ldr	r2, [r5, #16]
 8001752:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8001756:	3b01      	subs	r3, #1
 8001758:	0852      	lsrs	r2, r2, #1
 800175a:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 800175e:	3a01      	subs	r2, #1
 8001760:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8001764:	e02d      	b.n	80017c2 <RCCEx_PLLSAI1_Config+0xb6>
    switch(PllSai1->PLLSAI1Source)
 8001766:	2802      	cmp	r0, #2
 8001768:	d00c      	beq.n	8001784 <RCCEx_PLLSAI1_Config+0x78>
 800176a:	2803      	cmp	r0, #3
 800176c:	d010      	beq.n	8001790 <RCCEx_PLLSAI1_Config+0x84>
 800176e:	2801      	cmp	r0, #1
 8001770:	d10c      	bne.n	800178c <RCCEx_PLLSAI1_Config+0x80>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8001772:	681b      	ldr	r3, [r3, #0]
 8001774:	079f      	lsls	r7, r3, #30
 8001776:	d534      	bpl.n	80017e2 <RCCEx_PLLSAI1_Config+0xd6>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 8001778:	68e3      	ldr	r3, [r4, #12]
 800177a:	f023 0303 	bic.w	r3, r3, #3
 800177e:	4318      	orrs	r0, r3
 8001780:	60e0      	str	r0, [r4, #12]
 8001782:	e7d3      	b.n	800172c <RCCEx_PLLSAI1_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8001784:	681b      	ldr	r3, [r3, #0]
 8001786:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800178a:	d1f5      	bne.n	8001778 <RCCEx_PLLSAI1_Config+0x6c>
 800178c:	2001      	movs	r0, #1
 800178e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8001790:	681a      	ldr	r2, [r3, #0]
 8001792:	0391      	lsls	r1, r2, #14
 8001794:	d4f0      	bmi.n	8001778 <RCCEx_PLLSAI1_Config+0x6c>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8001796:	681b      	ldr	r3, [r3, #0]
 8001798:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 800179c:	e7f5      	b.n	800178a <RCCEx_PLLSAI1_Config+0x7e>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800179e:	f7fe fd5d 	bl	800025c <HAL_GetTick>
 80017a2:	1bc0      	subs	r0, r0, r7
 80017a4:	2802      	cmp	r0, #2
 80017a6:	d9c8      	bls.n	800173a <RCCEx_PLLSAI1_Config+0x2e>
        status = HAL_TIMEOUT;
 80017a8:	2003      	movs	r0, #3
 80017aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80017ac:	68e8      	ldr	r0, [r5, #12]
 80017ae:	6926      	ldr	r6, [r4, #16]
 80017b0:	4918      	ldr	r1, [pc, #96]	; (8001814 <RCCEx_PLLSAI1_Config+0x108>)
 80017b2:	06c2      	lsls	r2, r0, #27
 80017b4:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80017b8:	4031      	ands	r1, r6
 80017ba:	430a      	orrs	r2, r1
 80017bc:	3b01      	subs	r3, #1
 80017be:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80017c2:	6123      	str	r3, [r4, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 80017c4:	6823      	ldr	r3, [r4, #0]
 80017c6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80017ca:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80017cc:	f7fe fd46 	bl	800025c <HAL_GetTick>
 80017d0:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 80017d2:	6823      	ldr	r3, [r4, #0]
 80017d4:	011b      	lsls	r3, r3, #4
 80017d6:	d513      	bpl.n	8001800 <RCCEx_PLLSAI1_Config+0xf4>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 80017d8:	6923      	ldr	r3, [r4, #16]
 80017da:	69aa      	ldr	r2, [r5, #24]
 80017dc:	4313      	orrs	r3, r2
 80017de:	6123      	str	r3, [r4, #16]
 80017e0:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80017e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80017e4:	6921      	ldr	r1, [r4, #16]
 80017e6:	4a0c      	ldr	r2, [pc, #48]	; (8001818 <RCCEx_PLLSAI1_Config+0x10c>)
 80017e8:	400a      	ands	r2, r1
 80017ea:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80017ee:	3b01      	subs	r3, #1
 80017f0:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 80017f4:	696a      	ldr	r2, [r5, #20]
 80017f6:	0852      	lsrs	r2, r2, #1
 80017f8:	3a01      	subs	r2, #1
 80017fa:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 80017fe:	e7e0      	b.n	80017c2 <RCCEx_PLLSAI1_Config+0xb6>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8001800:	f7fe fd2c 	bl	800025c <HAL_GetTick>
 8001804:	1b80      	subs	r0, r0, r6
 8001806:	2802      	cmp	r0, #2
 8001808:	d9e3      	bls.n	80017d2 <RCCEx_PLLSAI1_Config+0xc6>
 800180a:	e7cd      	b.n	80017a8 <RCCEx_PLLSAI1_Config+0x9c>
 800180c:	40021000 	.word	0x40021000
 8001810:	ff9f800f 	.word	0xff9f800f
 8001814:	07ff800f 	.word	0x07ff800f
 8001818:	f9ff800f 	.word	0xf9ff800f

0800181c <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 800181c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800181e:	4b3f      	ldr	r3, [pc, #252]	; (800191c <RCCEx_PLLSAI2_Config+0x100>)
 8001820:	68da      	ldr	r2, [r3, #12]
 8001822:	f012 0f03 	tst.w	r2, #3
{
 8001826:	4605      	mov	r5, r0
 8001828:	460e      	mov	r6, r1
 800182a:	461c      	mov	r4, r3
 800182c:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800182e:	d022      	beq.n	8001876 <RCCEx_PLLSAI2_Config+0x5a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8001830:	68db      	ldr	r3, [r3, #12]
 8001832:	f003 0303 	and.w	r3, r3, #3
 8001836:	4283      	cmp	r3, r0
 8001838:	d130      	bne.n	800189c <RCCEx_PLLSAI2_Config+0x80>
       ||
 800183a:	b37b      	cbz	r3, 800189c <RCCEx_PLLSAI2_Config+0x80>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 800183c:	6823      	ldr	r3, [r4, #0]
 800183e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001842:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001844:	f7fe fd0a 	bl	800025c <HAL_GetTick>
 8001848:	4607      	mov	r7, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 800184a:	6823      	ldr	r3, [r4, #0]
 800184c:	009a      	lsls	r2, r3, #2
 800184e:	d42e      	bmi.n	80018ae <RCCEx_PLLSAI2_Config+0x92>
 8001850:	68af      	ldr	r7, [r5, #8]
 8001852:	686b      	ldr	r3, [r5, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8001854:	b396      	cbz	r6, 80018bc <RCCEx_PLLSAI2_Config+0xa0>
#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
      else if(Divider == DIVIDER_Q_UPDATE)
 8001856:	2e01      	cmp	r6, #1
 8001858:	d14c      	bne.n	80018f4 <RCCEx_PLLSAI2_Config+0xd8>
      {
        assert_param(IS_RCC_PLLSAI2Q_VALUE(PllSai2->PLLSAI2Q));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 800185a:	6962      	ldr	r2, [r4, #20]
 800185c:	4930      	ldr	r1, [pc, #192]	; (8001920 <RCCEx_PLLSAI2_Config+0x104>)
 800185e:	4011      	ands	r1, r2
 8001860:	692a      	ldr	r2, [r5, #16]
 8001862:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8001866:	3b01      	subs	r3, #1
 8001868:	0852      	lsrs	r2, r2, #1
 800186a:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 800186e:	3a01      	subs	r2, #1
 8001870:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8001874:	e02d      	b.n	80018d2 <RCCEx_PLLSAI2_Config+0xb6>
    switch(PllSai2->PLLSAI2Source)
 8001876:	2802      	cmp	r0, #2
 8001878:	d00c      	beq.n	8001894 <RCCEx_PLLSAI2_Config+0x78>
 800187a:	2803      	cmp	r0, #3
 800187c:	d010      	beq.n	80018a0 <RCCEx_PLLSAI2_Config+0x84>
 800187e:	2801      	cmp	r0, #1
 8001880:	d10c      	bne.n	800189c <RCCEx_PLLSAI2_Config+0x80>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8001882:	681b      	ldr	r3, [r3, #0]
 8001884:	079f      	lsls	r7, r3, #30
 8001886:	d534      	bpl.n	80018f2 <RCCEx_PLLSAI2_Config+0xd6>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 8001888:	68e3      	ldr	r3, [r4, #12]
 800188a:	f023 0303 	bic.w	r3, r3, #3
 800188e:	4318      	orrs	r0, r3
 8001890:	60e0      	str	r0, [r4, #12]
 8001892:	e7d3      	b.n	800183c <RCCEx_PLLSAI2_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8001894:	681b      	ldr	r3, [r3, #0]
 8001896:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800189a:	d1f5      	bne.n	8001888 <RCCEx_PLLSAI2_Config+0x6c>
 800189c:	2001      	movs	r0, #1
 800189e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80018a0:	681a      	ldr	r2, [r3, #0]
 80018a2:	0391      	lsls	r1, r2, #14
 80018a4:	d4f0      	bmi.n	8001888 <RCCEx_PLLSAI2_Config+0x6c>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80018a6:	681b      	ldr	r3, [r3, #0]
 80018a8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80018ac:	e7f5      	b.n	800189a <RCCEx_PLLSAI2_Config+0x7e>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80018ae:	f7fe fcd5 	bl	800025c <HAL_GetTick>
 80018b2:	1bc0      	subs	r0, r0, r7
 80018b4:	2802      	cmp	r0, #2
 80018b6:	d9c8      	bls.n	800184a <RCCEx_PLLSAI2_Config+0x2e>
        status = HAL_TIMEOUT;
 80018b8:	2003      	movs	r0, #3
 80018ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80018bc:	68e8      	ldr	r0, [r5, #12]
 80018be:	6966      	ldr	r6, [r4, #20]
 80018c0:	4918      	ldr	r1, [pc, #96]	; (8001924 <RCCEx_PLLSAI2_Config+0x108>)
 80018c2:	06c2      	lsls	r2, r0, #27
 80018c4:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80018c8:	4031      	ands	r1, r6
 80018ca:	430a      	orrs	r2, r1
 80018cc:	3b01      	subs	r3, #1
 80018ce:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
      else
      {
        assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80018d2:	6163      	str	r3, [r4, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 80018d4:	6823      	ldr	r3, [r4, #0]
 80018d6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80018da:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018dc:	f7fe fcbe 	bl	800025c <HAL_GetTick>
 80018e0:	4606      	mov	r6, r0

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 80018e2:	6823      	ldr	r3, [r4, #0]
 80018e4:	009b      	lsls	r3, r3, #2
 80018e6:	d513      	bpl.n	8001910 <RCCEx_PLLSAI2_Config+0xf4>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 80018e8:	6963      	ldr	r3, [r4, #20]
 80018ea:	69aa      	ldr	r2, [r5, #24]
 80018ec:	4313      	orrs	r3, r2
 80018ee:	6163      	str	r3, [r4, #20]
 80018f0:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80018f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80018f4:	6961      	ldr	r1, [r4, #20]
 80018f6:	4a0c      	ldr	r2, [pc, #48]	; (8001928 <RCCEx_PLLSAI2_Config+0x10c>)
 80018f8:	400a      	ands	r2, r1
 80018fa:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80018fe:	3b01      	subs	r3, #1
 8001900:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8001904:	696a      	ldr	r2, [r5, #20]
 8001906:	0852      	lsrs	r2, r2, #1
 8001908:	3a01      	subs	r2, #1
 800190a:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 800190e:	e7e0      	b.n	80018d2 <RCCEx_PLLSAI2_Config+0xb6>
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8001910:	f7fe fca4 	bl	800025c <HAL_GetTick>
 8001914:	1b80      	subs	r0, r0, r6
 8001916:	2802      	cmp	r0, #2
 8001918:	d9e3      	bls.n	80018e2 <RCCEx_PLLSAI2_Config+0xc6>
 800191a:	e7cd      	b.n	80018b8 <RCCEx_PLLSAI2_Config+0x9c>
 800191c:	40021000 	.word	0x40021000
 8001920:	ff9f800f 	.word	0xff9f800f
 8001924:	07ff800f 	.word	0x07ff800f
 8001928:	f9ff800f 	.word	0xf9ff800f

0800192c <HAL_RCCEx_PeriphCLKConfig>:
{
 800192c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001930:	6805      	ldr	r5, [r0, #0]
 8001932:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
{
 8001936:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001938:	d023      	beq.n	8001982 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 800193a:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 800193c:	2940      	cmp	r1, #64	; 0x40
 800193e:	d014      	beq.n	800196a <HAL_RCCEx_PeriphCLKConfig+0x3e>
 8001940:	d804      	bhi.n	800194c <HAL_RCCEx_PeriphCLKConfig+0x20>
 8001942:	b1c1      	cbz	r1, 8001976 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8001944:	2920      	cmp	r1, #32
 8001946:	d02b      	beq.n	80019a0 <HAL_RCCEx_PeriphCLKConfig+0x74>
      ret = HAL_ERROR;
 8001948:	2501      	movs	r5, #1
 800194a:	e01a      	b.n	8001982 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 800194c:	2960      	cmp	r1, #96	; 0x60
 800194e:	d001      	beq.n	8001954 <HAL_RCCEx_PeriphCLKConfig+0x28>
 8001950:	2980      	cmp	r1, #128	; 0x80
 8001952:	d1f9      	bne.n	8001948 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001954:	4a4e      	ldr	r2, [pc, #312]	; (8001a90 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001956:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8001958:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 800195c:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8001960:	430b      	orrs	r3, r1
 8001962:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8001966:	2500      	movs	r5, #0
 8001968:	e00b      	b.n	8001982 <HAL_RCCEx_PeriphCLKConfig+0x56>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 800196a:	4a49      	ldr	r2, [pc, #292]	; (8001a90 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800196c:	68d3      	ldr	r3, [r2, #12]
 800196e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001972:	60d3      	str	r3, [r2, #12]
      break;
 8001974:	e7ee      	b.n	8001954 <HAL_RCCEx_PeriphCLKConfig+0x28>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8001976:	3004      	adds	r0, #4
 8001978:	f7ff fec8 	bl	800170c <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 800197c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800197e:	2800      	cmp	r0, #0
 8001980:	d0e8      	beq.n	8001954 <HAL_RCCEx_PeriphCLKConfig+0x28>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8001982:	6823      	ldr	r3, [r4, #0]
 8001984:	04db      	lsls	r3, r3, #19
 8001986:	d509      	bpl.n	800199c <HAL_RCCEx_PeriphCLKConfig+0x70>
    switch(PeriphClkInit->Sai2ClockSelection)
 8001988:	6f21      	ldr	r1, [r4, #112]	; 0x70
 800198a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800198e:	d014      	beq.n	80019ba <HAL_RCCEx_PeriphCLKConfig+0x8e>
 8001990:	d80b      	bhi.n	80019aa <HAL_RCCEx_PeriphCLKConfig+0x7e>
 8001992:	b1c1      	cbz	r1, 80019c6 <HAL_RCCEx_PeriphCLKConfig+0x9a>
 8001994:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8001998:	d071      	beq.n	8001a7e <HAL_RCCEx_PeriphCLKConfig+0x152>
      ret = HAL_ERROR;
 800199a:	2501      	movs	r5, #1
 800199c:	462e      	mov	r6, r5
 800199e:	e021      	b.n	80019e4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80019a0:	2100      	movs	r1, #0
 80019a2:	3020      	adds	r0, #32
 80019a4:	f7ff ff3a 	bl	800181c <RCCEx_PLLSAI2_Config>
 80019a8:	e7e8      	b.n	800197c <HAL_RCCEx_PeriphCLKConfig+0x50>
    switch(PeriphClkInit->Sai2ClockSelection)
 80019aa:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 80019ae:	d002      	beq.n	80019b6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
 80019b0:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 80019b4:	d1f1      	bne.n	800199a <HAL_RCCEx_PeriphCLKConfig+0x6e>
 80019b6:	462e      	mov	r6, r5
 80019b8:	e009      	b.n	80019ce <HAL_RCCEx_PeriphCLKConfig+0xa2>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80019ba:	4a35      	ldr	r2, [pc, #212]	; (8001a90 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019bc:	68d3      	ldr	r3, [r2, #12]
 80019be:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80019c2:	60d3      	str	r3, [r2, #12]
 80019c4:	e7f7      	b.n	80019b6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 80019c6:	1d20      	adds	r0, r4, #4
 80019c8:	f7ff fea0 	bl	800170c <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80019cc:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 80019ce:	2e00      	cmp	r6, #0
 80019d0:	d15b      	bne.n	8001a8a <HAL_RCCEx_PeriphCLKConfig+0x15e>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 80019d2:	4a2f      	ldr	r2, [pc, #188]	; (8001a90 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019d4:	6f21      	ldr	r1, [r4, #112]	; 0x70
 80019d6:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 80019da:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80019de:	430b      	orrs	r3, r1
 80019e0:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80019e4:	6823      	ldr	r3, [r4, #0]
 80019e6:	039f      	lsls	r7, r3, #14
 80019e8:	d565      	bpl.n	8001ab6 <HAL_RCCEx_PeriphCLKConfig+0x18a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 80019ea:	4f29      	ldr	r7, [pc, #164]	; (8001a90 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80019ee:	00d8      	lsls	r0, r3, #3
 80019f0:	f140 81f3 	bpl.w	8001dda <HAL_RCCEx_PeriphCLKConfig+0x4ae>
    FlagStatus       pwrclkchanged = RESET;
 80019f4:	f04f 0800 	mov.w	r8, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80019f8:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8001a94 <HAL_RCCEx_PeriphCLKConfig+0x168>
 80019fc:	f8d9 3000 	ldr.w	r3, [r9]
 8001a00:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001a04:	f8c9 3000 	str.w	r3, [r9]
    tickstart = HAL_GetTick();
 8001a08:	f7fe fc28 	bl	800025c <HAL_GetTick>
 8001a0c:	4682      	mov	sl, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8001a0e:	f8d9 3000 	ldr.w	r3, [r9]
 8001a12:	05d9      	lsls	r1, r3, #23
 8001a14:	d540      	bpl.n	8001a98 <HAL_RCCEx_PeriphCLKConfig+0x16c>
    if(ret == HAL_OK)
 8001a16:	2e00      	cmp	r6, #0
 8001a18:	f040 8197 	bne.w	8001d4a <HAL_RCCEx_PeriphCLKConfig+0x41e>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8001a1c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8001a20:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001a24:	d015      	beq.n	8001a52 <HAL_RCCEx_PeriphCLKConfig+0x126>
 8001a26:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8001a2a:	4293      	cmp	r3, r2
 8001a2c:	d011      	beq.n	8001a52 <HAL_RCCEx_PeriphCLKConfig+0x126>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001a2e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 8001a32:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8001a36:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001a3a:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001a3e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001a42:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001a46:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001a4a:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8001a4e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8001a52:	07da      	lsls	r2, r3, #31
 8001a54:	d509      	bpl.n	8001a6a <HAL_RCCEx_PeriphCLKConfig+0x13e>
        tickstart = HAL_GetTick();
 8001a56:	f7fe fc01 	bl	800025c <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001a5a:	f241 3a88 	movw	sl, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8001a5e:	4681      	mov	r9, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8001a60:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8001a64:	079b      	lsls	r3, r3, #30
 8001a66:	f140 8168 	bpl.w	8001d3a <HAL_RCCEx_PeriphCLKConfig+0x40e>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001a6a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8001a6e:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8001a72:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a76:	4313      	orrs	r3, r2
 8001a78:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8001a7c:	e014      	b.n	8001aa8 <HAL_RCCEx_PeriphCLKConfig+0x17c>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8001a7e:	2100      	movs	r1, #0
 8001a80:	f104 0020 	add.w	r0, r4, #32
 8001a84:	f7ff feca 	bl	800181c <RCCEx_PLLSAI2_Config>
 8001a88:	e7a0      	b.n	80019cc <HAL_RCCEx_PeriphCLKConfig+0xa0>
 8001a8a:	4635      	mov	r5, r6
 8001a8c:	e7aa      	b.n	80019e4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
 8001a8e:	bf00      	nop
 8001a90:	40021000 	.word	0x40021000
 8001a94:	40007000 	.word	0x40007000
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001a98:	f7fe fbe0 	bl	800025c <HAL_GetTick>
 8001a9c:	eba0 000a 	sub.w	r0, r0, sl
 8001aa0:	2802      	cmp	r0, #2
 8001aa2:	d9b4      	bls.n	8001a0e <HAL_RCCEx_PeriphCLKConfig+0xe2>
        ret = HAL_TIMEOUT;
 8001aa4:	2503      	movs	r5, #3
 8001aa6:	462e      	mov	r6, r5
    if(pwrclkchanged == SET)
 8001aa8:	f1b8 0f00 	cmp.w	r8, #0
 8001aac:	d003      	beq.n	8001ab6 <HAL_RCCEx_PeriphCLKConfig+0x18a>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001aae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001ab0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001ab4:	65bb      	str	r3, [r7, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001ab6:	6823      	ldr	r3, [r4, #0]
 8001ab8:	07df      	lsls	r7, r3, #31
 8001aba:	d508      	bpl.n	8001ace <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001abc:	49c0      	ldr	r1, [pc, #768]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001abe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001ac0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001ac4:	f022 0203 	bic.w	r2, r2, #3
 8001ac8:	4302      	orrs	r2, r0
 8001aca:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001ace:	0798      	lsls	r0, r3, #30
 8001ad0:	d508      	bpl.n	8001ae4 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001ad2:	49bb      	ldr	r1, [pc, #748]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001ad4:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8001ad6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001ada:	f022 020c 	bic.w	r2, r2, #12
 8001ade:	4302      	orrs	r2, r0
 8001ae0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8001ae4:	0759      	lsls	r1, r3, #29
 8001ae6:	d508      	bpl.n	8001afa <HAL_RCCEx_PeriphCLKConfig+0x1ce>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8001ae8:	49b5      	ldr	r1, [pc, #724]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001aea:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8001aec:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001af0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8001af4:	4302      	orrs	r2, r0
 8001af6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8001afa:	071a      	lsls	r2, r3, #28
 8001afc:	d508      	bpl.n	8001b10 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8001afe:	49b0      	ldr	r1, [pc, #704]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b00:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8001b02:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b06:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8001b0a:	4302      	orrs	r2, r0
 8001b0c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8001b10:	06df      	lsls	r7, r3, #27
 8001b12:	d508      	bpl.n	8001b26 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8001b14:	49aa      	ldr	r1, [pc, #680]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b16:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8001b18:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b1c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001b20:	4302      	orrs	r2, r0
 8001b22:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8001b26:	0698      	lsls	r0, r3, #26
 8001b28:	d508      	bpl.n	8001b3c <HAL_RCCEx_PeriphCLKConfig+0x210>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8001b2a:	49a5      	ldr	r1, [pc, #660]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b2c:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8001b2e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b32:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8001b36:	4302      	orrs	r2, r0
 8001b38:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8001b3c:	0599      	lsls	r1, r3, #22
 8001b3e:	d508      	bpl.n	8001b52 <HAL_RCCEx_PeriphCLKConfig+0x226>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001b40:	499f      	ldr	r1, [pc, #636]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b42:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8001b44:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b48:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001b4c:	4302      	orrs	r2, r0
 8001b4e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8001b52:	055a      	lsls	r2, r3, #21
 8001b54:	d508      	bpl.n	8001b68 <HAL_RCCEx_PeriphCLKConfig+0x23c>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8001b56:	499a      	ldr	r1, [pc, #616]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b58:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8001b5a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b5e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001b62:	4302      	orrs	r2, r0
 8001b64:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001b68:	065f      	lsls	r7, r3, #25
 8001b6a:	d508      	bpl.n	8001b7e <HAL_RCCEx_PeriphCLKConfig+0x252>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001b6c:	4994      	ldr	r1, [pc, #592]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b6e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8001b70:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b74:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001b78:	4302      	orrs	r2, r0
 8001b7a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001b7e:	0618      	lsls	r0, r3, #24
 8001b80:	d508      	bpl.n	8001b94 <HAL_RCCEx_PeriphCLKConfig+0x268>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001b82:	498f      	ldr	r1, [pc, #572]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b84:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8001b86:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001b8a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8001b8e:	4302      	orrs	r2, r0
 8001b90:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001b94:	05d9      	lsls	r1, r3, #23
 8001b96:	d508      	bpl.n	8001baa <HAL_RCCEx_PeriphCLKConfig+0x27e>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001b98:	4989      	ldr	r1, [pc, #548]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001b9a:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8001b9c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001ba0:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8001ba4:	4302      	orrs	r2, r0
 8001ba6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8001baa:	02da      	lsls	r2, r3, #11
 8001bac:	d508      	bpl.n	8001bc0 <HAL_RCCEx_PeriphCLKConfig+0x294>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8001bae:	4984      	ldr	r1, [pc, #528]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001bb0:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8001bb2:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8001bb6:	f022 0203 	bic.w	r2, r2, #3
 8001bba:	4302      	orrs	r2, r0
 8001bbc:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8001bc0:	049f      	lsls	r7, r3, #18
 8001bc2:	d510      	bpl.n	8001be6 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001bc4:	4a7e      	ldr	r2, [pc, #504]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001bc6:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8001bc8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001bcc:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001bd0:	430b      	orrs	r3, r1
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001bd2:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001bd6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001bda:	f040 80b8 	bne.w	8001d4e <HAL_RCCEx_PeriphCLKConfig+0x422>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001bde:	68d3      	ldr	r3, [r2, #12]
 8001be0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001be4:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8001be6:	6823      	ldr	r3, [r4, #0]
 8001be8:	0318      	lsls	r0, r3, #12
 8001bea:	d50f      	bpl.n	8001c0c <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001bec:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8001bee:	4b74      	ldr	r3, [pc, #464]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001bf0:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8001bf4:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8001bf8:	f040 80b6 	bne.w	8001d68 <HAL_RCCEx_PeriphCLKConfig+0x43c>
 8001bfc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001c00:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8001c04:	68da      	ldr	r2, [r3, #12]
 8001c06:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001c0a:	60da      	str	r2, [r3, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8001c0c:	6823      	ldr	r3, [r4, #0]
 8001c0e:	0359      	lsls	r1, r3, #13
 8001c10:	d510      	bpl.n	8001c34 <HAL_RCCEx_PeriphCLKConfig+0x308>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001c12:	4a6b      	ldr	r2, [pc, #428]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001c14:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8001c16:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001c1a:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001c1e:	430b      	orrs	r3, r1
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001c20:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001c24:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001c28:	f040 80bd 	bne.w	8001da6 <HAL_RCCEx_PeriphCLKConfig+0x47a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001c2c:	68d3      	ldr	r3, [r2, #12]
 8001c2e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001c32:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8001c34:	6823      	ldr	r3, [r4, #0]
 8001c36:	045a      	lsls	r2, r3, #17
 8001c38:	d514      	bpl.n	8001c64 <HAL_RCCEx_PeriphCLKConfig+0x338>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001c3a:	4961      	ldr	r1, [pc, #388]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001c3c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8001c40:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001c44:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8001c48:	4313      	orrs	r3, r2
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001c4a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001c4e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001c52:	d107      	bne.n	8001c64 <HAL_RCCEx_PeriphCLKConfig+0x338>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8001c54:	2102      	movs	r1, #2
 8001c56:	1d20      	adds	r0, r4, #4
 8001c58:	f7ff fd58 	bl	800170c <RCCEx_PLLSAI1_Config>
 8001c5c:	4606      	mov	r6, r0
 8001c5e:	2800      	cmp	r0, #0
 8001c60:	bf18      	it	ne
 8001c62:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8001c64:	6822      	ldr	r2, [r4, #0]
 8001c66:	03d3      	lsls	r3, r2, #15
 8001c68:	d509      	bpl.n	8001c7e <HAL_RCCEx_PeriphCLKConfig+0x352>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8001c6a:	4955      	ldr	r1, [pc, #340]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001c6c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8001c70:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8001c74:	f023 0304 	bic.w	r3, r3, #4
 8001c78:	4303      	orrs	r3, r0
 8001c7a:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8001c7e:	0297      	lsls	r7, r2, #10
 8001c80:	d509      	bpl.n	8001c96 <HAL_RCCEx_PeriphCLKConfig+0x36a>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8001c82:	494f      	ldr	r1, [pc, #316]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001c84:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8001c88:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8001c8c:	f023 0318 	bic.w	r3, r3, #24
 8001c90:	4303      	orrs	r3, r0
 8001c92:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8001c96:	0250      	lsls	r0, r2, #9
 8001c98:	d51f      	bpl.n	8001cda <HAL_RCCEx_PeriphCLKConfig+0x3ae>
    __HAL_RCC_PLLSAI2_DISABLE();
 8001c9a:	4f49      	ldr	r7, [pc, #292]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001c9c:	683b      	ldr	r3, [r7, #0]
 8001c9e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001ca2:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8001ca4:	f7fe fada 	bl	800025c <HAL_GetTick>
 8001ca8:	4680      	mov	r8, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8001caa:	683b      	ldr	r3, [r7, #0]
 8001cac:	0099      	lsls	r1, r3, #2
 8001cae:	f100 8089 	bmi.w	8001dc4 <HAL_RCCEx_PeriphCLKConfig+0x498>
    if(ret == HAL_OK)
 8001cb2:	2e00      	cmp	r6, #0
 8001cb4:	f040 808f 	bne.w	8001dd6 <HAL_RCCEx_PeriphCLKConfig+0x4aa>
      __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
 8001cb8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8001cbc:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8001cc0:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001cc4:	4313      	orrs	r3, r2
 8001cc6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 8001cca:	2102      	movs	r1, #2
 8001ccc:	f104 0020 	add.w	r0, r4, #32
 8001cd0:	f7ff fda4 	bl	800181c <RCCEx_PLLSAI2_Config>
 8001cd4:	2800      	cmp	r0, #0
 8001cd6:	bf18      	it	ne
 8001cd8:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
 8001cda:	6823      	ldr	r3, [r4, #0]
 8001cdc:	021a      	lsls	r2, r3, #8
 8001cde:	d514      	bpl.n	8001d0a <HAL_RCCEx_PeriphCLKConfig+0x3de>
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8001ce0:	4937      	ldr	r1, [pc, #220]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001ce2:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8001ce6:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8001cea:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8001cee:	4313      	orrs	r3, r2
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 8001cf0:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8001cf4:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 8001cf8:	d107      	bne.n	8001d0a <HAL_RCCEx_PeriphCLKConfig+0x3de>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_Q_UPDATE);
 8001cfa:	2101      	movs	r1, #1
 8001cfc:	f104 0020 	add.w	r0, r4, #32
 8001d00:	f7ff fd8c 	bl	800181c <RCCEx_PLLSAI2_Config>
 8001d04:	2800      	cmp	r0, #0
 8001d06:	bf18      	it	ne
 8001d08:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8001d0a:	6823      	ldr	r3, [r4, #0]
 8001d0c:	01db      	lsls	r3, r3, #7
 8001d0e:	d510      	bpl.n	8001d32 <HAL_RCCEx_PeriphCLKConfig+0x406>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8001d10:	4a2b      	ldr	r2, [pc, #172]	; (8001dc0 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8001d12:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8001d16:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8001d1a:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001d1e:	430b      	orrs	r3, r1
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8001d20:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8001d24:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8001d28:	d103      	bne.n	8001d32 <HAL_RCCEx_PeriphCLKConfig+0x406>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001d2a:	68d3      	ldr	r3, [r2, #12]
 8001d2c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001d30:	60d3      	str	r3, [r2, #12]
}
 8001d32:	4628      	mov	r0, r5
 8001d34:	b002      	add	sp, #8
 8001d36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001d3a:	f7fe fa8f 	bl	800025c <HAL_GetTick>
 8001d3e:	eba0 0009 	sub.w	r0, r0, r9
 8001d42:	4550      	cmp	r0, sl
 8001d44:	f67f ae8c 	bls.w	8001a60 <HAL_RCCEx_PeriphCLKConfig+0x134>
 8001d48:	e6ac      	b.n	8001aa4 <HAL_RCCEx_PeriphCLKConfig+0x178>
 8001d4a:	4635      	mov	r5, r6
 8001d4c:	e6ac      	b.n	8001aa8 <HAL_RCCEx_PeriphCLKConfig+0x17c>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8001d4e:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001d52:	f47f af48 	bne.w	8001be6 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001d56:	2101      	movs	r1, #1
 8001d58:	1d20      	adds	r0, r4, #4
 8001d5a:	f7ff fcd7 	bl	800170c <RCCEx_PLLSAI1_Config>
 8001d5e:	4606      	mov	r6, r0
 8001d60:	2800      	cmp	r0, #0
 8001d62:	bf18      	it	ne
 8001d64:	4605      	movne	r5, r0
 8001d66:	e73e      	b.n	8001be6 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001d68:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001d6c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 8001d70:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8001d74:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8001d78:	430a      	orrs	r2, r1
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8001d7a:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001d7e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8001d82:	d103      	bne.n	8001d8c <HAL_RCCEx_PeriphCLKConfig+0x460>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001d84:	68da      	ldr	r2, [r3, #12]
 8001d86:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8001d8a:	e73e      	b.n	8001c0a <HAL_RCCEx_PeriphCLKConfig+0x2de>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8001d8c:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001d90:	f47f af3c 	bne.w	8001c0c <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001d94:	2101      	movs	r1, #1
 8001d96:	1d20      	adds	r0, r4, #4
 8001d98:	f7ff fcb8 	bl	800170c <RCCEx_PLLSAI1_Config>
 8001d9c:	4606      	mov	r6, r0
 8001d9e:	2800      	cmp	r0, #0
 8001da0:	bf18      	it	ne
 8001da2:	4605      	movne	r5, r0
 8001da4:	e732      	b.n	8001c0c <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8001da6:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001daa:	f47f af43 	bne.w	8001c34 <HAL_RCCEx_PeriphCLKConfig+0x308>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001dae:	2101      	movs	r1, #1
 8001db0:	1d20      	adds	r0, r4, #4
 8001db2:	f7ff fcab 	bl	800170c <RCCEx_PLLSAI1_Config>
 8001db6:	4606      	mov	r6, r0
 8001db8:	2800      	cmp	r0, #0
 8001dba:	bf18      	it	ne
 8001dbc:	4605      	movne	r5, r0
 8001dbe:	e739      	b.n	8001c34 <HAL_RCCEx_PeriphCLKConfig+0x308>
 8001dc0:	40021000 	.word	0x40021000
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8001dc4:	f7fe fa4a 	bl	800025c <HAL_GetTick>
 8001dc8:	eba0 0008 	sub.w	r0, r0, r8
 8001dcc:	2802      	cmp	r0, #2
 8001dce:	f67f af6c 	bls.w	8001caa <HAL_RCCEx_PeriphCLKConfig+0x37e>
        ret = HAL_TIMEOUT;
 8001dd2:	2503      	movs	r5, #3
 8001dd4:	e781      	b.n	8001cda <HAL_RCCEx_PeriphCLKConfig+0x3ae>
 8001dd6:	4635      	mov	r5, r6
 8001dd8:	e77f      	b.n	8001cda <HAL_RCCEx_PeriphCLKConfig+0x3ae>
      __HAL_RCC_PWR_CLK_ENABLE();
 8001dda:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001ddc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001de0:	65bb      	str	r3, [r7, #88]	; 0x58
 8001de2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001de4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001de8:	9301      	str	r3, [sp, #4]
 8001dea:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001dec:	f04f 0801 	mov.w	r8, #1
 8001df0:	e602      	b.n	80019f8 <HAL_RCCEx_PeriphCLKConfig+0xcc>
 8001df2:	bf00      	nop

08001df4 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8001df4:	4b0a      	ldr	r3, [pc, #40]	; (8001e20 <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8001df6:	3b01      	subs	r3, #1
 8001df8:	d101      	bne.n	8001dfe <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 8001dfa:	2003      	movs	r0, #3
 8001dfc:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8001dfe:	6902      	ldr	r2, [r0, #16]
 8001e00:	2a00      	cmp	r2, #0
 8001e02:	daf8      	bge.n	8001df6 <USB_CoreReset+0x2>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8001e04:	6903      	ldr	r3, [r0, #16]
 8001e06:	4a06      	ldr	r2, [pc, #24]	; (8001e20 <USB_CoreReset+0x2c>)
 8001e08:	f043 0301 	orr.w	r3, r3, #1
 8001e0c:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 8001e0e:	3a01      	subs	r2, #1
 8001e10:	d0f3      	beq.n	8001dfa <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8001e12:	6903      	ldr	r3, [r0, #16]
 8001e14:	f013 0301 	ands.w	r3, r3, #1
 8001e18:	d1f9      	bne.n	8001e0e <USB_CoreReset+0x1a>

  return HAL_OK;
 8001e1a:	4618      	mov	r0, r3
}
 8001e1c:	4770      	bx	lr
 8001e1e:	bf00      	nop
 8001e20:	00030d41 	.word	0x00030d41

08001e24 <USB_CoreInit>:
{
 8001e24:	b084      	sub	sp, #16
 8001e26:	b538      	push	{r3, r4, r5, lr}
 8001e28:	ad05      	add	r5, sp, #20
 8001e2a:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001e2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001e30:	2b01      	cmp	r3, #1
{
 8001e32:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001e34:	d11b      	bne.n	8001e6e <USB_CoreInit+0x4a>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8001e36:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001e38:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001e3c:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8001e3e:	68c3      	ldr	r3, [r0, #12]
 8001e40:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8001e44:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001e48:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8001e4a:	68c3      	ldr	r3, [r0, #12]
 8001e4c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001e50:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 8001e52:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001e54:	2b01      	cmp	r3, #1
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8001e56:	bf02      	ittt	eq
 8001e58:	68c3      	ldreq	r3, [r0, #12]
 8001e5a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8001e5e:	60c3      	streq	r3, [r0, #12]
    (void)USB_CoreReset(USBx);
 8001e60:	f7ff ffc8 	bl	8001df4 <USB_CoreReset>
}
 8001e64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001e68:	2000      	movs	r0, #0
 8001e6a:	b004      	add	sp, #16
 8001e6c:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8001e6e:	68c3      	ldr	r3, [r0, #12]
 8001e70:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001e74:	60c3      	str	r3, [r0, #12]
    (void)USB_CoreReset(USBx);
 8001e76:	f7ff ffbd 	bl	8001df4 <USB_CoreReset>
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001e7a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e7e:	63a3      	str	r3, [r4, #56]	; 0x38
 8001e80:	e7f0      	b.n	8001e64 <USB_CoreInit+0x40>

08001e82 <USB_EnableGlobalInt>:
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8001e82:	6883      	ldr	r3, [r0, #8]
 8001e84:	f043 0301 	orr.w	r3, r3, #1
 8001e88:	6083      	str	r3, [r0, #8]
}
 8001e8a:	2000      	movs	r0, #0
 8001e8c:	4770      	bx	lr

08001e8e <USB_DisableGlobalInt>:
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8001e8e:	6883      	ldr	r3, [r0, #8]
 8001e90:	f023 0301 	bic.w	r3, r3, #1
 8001e94:	6083      	str	r3, [r0, #8]
}
 8001e96:	2000      	movs	r0, #0
 8001e98:	4770      	bx	lr

08001e9a <USB_SetCurrentMode>:
{
 8001e9a:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8001e9c:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8001e9e:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8001ea0:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8001ea4:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8001ea6:	d108      	bne.n	8001eba <USB_SetCurrentMode+0x20>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8001ea8:	68c3      	ldr	r3, [r0, #12]
 8001eaa:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8001eae:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 8001eb0:	2032      	movs	r0, #50	; 0x32
 8001eb2:	f7fe f9d9 	bl	8000268 <HAL_Delay>
  return HAL_OK;
 8001eb6:	2000      	movs	r0, #0
 8001eb8:	bd08      	pop	{r3, pc}
  else if (mode == USB_DEVICE_MODE)
 8001eba:	b919      	cbnz	r1, 8001ec4 <USB_SetCurrentMode+0x2a>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8001ebc:	68c3      	ldr	r3, [r0, #12]
 8001ebe:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001ec2:	e7f4      	b.n	8001eae <USB_SetCurrentMode+0x14>
    return HAL_ERROR;
 8001ec4:	2001      	movs	r0, #1
}
 8001ec6:	bd08      	pop	{r3, pc}

08001ec8 <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8001ec8:	0189      	lsls	r1, r1, #6
 8001eca:	f041 0120 	orr.w	r1, r1, #32
 8001ece:	4a06      	ldr	r2, [pc, #24]	; (8001ee8 <USB_FlushTxFifo+0x20>)
 8001ed0:	6101      	str	r1, [r0, #16]
    if (++count > 200000U)
 8001ed2:	3a01      	subs	r2, #1
 8001ed4:	d005      	beq.n	8001ee2 <USB_FlushTxFifo+0x1a>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8001ed6:	6903      	ldr	r3, [r0, #16]
 8001ed8:	f013 0320 	ands.w	r3, r3, #32
 8001edc:	d1f9      	bne.n	8001ed2 <USB_FlushTxFifo+0xa>
  return HAL_OK;
 8001ede:	4618      	mov	r0, r3
 8001ee0:	4770      	bx	lr
      return HAL_TIMEOUT;
 8001ee2:	2003      	movs	r0, #3
}
 8001ee4:	4770      	bx	lr
 8001ee6:	bf00      	nop
 8001ee8:	00030d41 	.word	0x00030d41

08001eec <USB_FlushRxFifo>:
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8001eec:	2310      	movs	r3, #16
 8001eee:	4a06      	ldr	r2, [pc, #24]	; (8001f08 <USB_FlushRxFifo+0x1c>)
 8001ef0:	6103      	str	r3, [r0, #16]
    if (++count > 200000U)
 8001ef2:	3a01      	subs	r2, #1
 8001ef4:	d005      	beq.n	8001f02 <USB_FlushRxFifo+0x16>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8001ef6:	6903      	ldr	r3, [r0, #16]
 8001ef8:	f013 0310 	ands.w	r3, r3, #16
 8001efc:	d1f9      	bne.n	8001ef2 <USB_FlushRxFifo+0x6>
  return HAL_OK;
 8001efe:	4618      	mov	r0, r3
 8001f00:	4770      	bx	lr
      return HAL_TIMEOUT;
 8001f02:	2003      	movs	r0, #3
}
 8001f04:	4770      	bx	lr
 8001f06:	bf00      	nop
 8001f08:	00030d41 	.word	0x00030d41

08001f0c <USB_SetDevSpeed>:
  USBx_DEVICE->DCFG |= speed;
 8001f0c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001f10:	4319      	orrs	r1, r3
 8001f12:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 8001f16:	2000      	movs	r0, #0
 8001f18:	4770      	bx	lr
	...

08001f1c <USB_DevInit>:
{
 8001f1c:	b084      	sub	sp, #16
 8001f1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001f22:	4604      	mov	r4, r0
 8001f24:	a807      	add	r0, sp, #28
 8001f26:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  for (i = 0U; i < 15U; i++)
 8001f2a:	2300      	movs	r3, #0
 8001f2c:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8001f2e:	4688      	mov	r8, r1
    USBx->DIEPTXF[i] = 0U;
 8001f30:	4619      	mov	r1, r3
 8001f32:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8001f36:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  for (i = 0U; i < 15U; i++)
 8001f3a:	3301      	adds	r3, #1
 8001f3c:	2b0f      	cmp	r3, #15
    USBx->DIEPTXF[i] = 0U;
 8001f3e:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < 15U; i++)
 8001f40:	d1f7      	bne.n	8001f32 <USB_DevInit+0x16>
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8001f42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f44:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001f48:	63a3      	str	r3, [r4, #56]	; 0x38
  if (cfg.vbus_sensing_enable == 0U)
 8001f4a:	b95f      	cbnz	r7, 8001f64 <USB_DevInit+0x48>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 8001f4c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f4e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001f52:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 8001f54:	6823      	ldr	r3, [r4, #0]
 8001f56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001f5a:	6023      	str	r3, [r4, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 8001f5c:	6823      	ldr	r3, [r4, #0]
 8001f5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001f62:	6023      	str	r3, [r4, #0]
  USBx_PCGCCTL = 0U;
 8001f64:	2500      	movs	r5, #0
 8001f66:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001f6a:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001f6e:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8001f72:	2103      	movs	r1, #3
 8001f74:	4620      	mov	r0, r4
 8001f76:	f7ff ffc9 	bl	8001f0c <USB_SetDevSpeed>
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001f7a:	f504 6600 	add.w	r6, r4, #2048	; 0x800
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
 8001f7e:	2110      	movs	r1, #16
 8001f80:	4620      	mov	r0, r4
 8001f82:	f7ff ffa1 	bl	8001ec8 <USB_FlushTxFifo>
  (void)USB_FlushRxFifo(USBx);
 8001f86:	4620      	mov	r0, r4
 8001f88:	f7ff ffb0 	bl	8001eec <USB_FlushRxFifo>
  USBx_DEVICE->DIEPMSK = 0U;
 8001f8c:	6135      	str	r5, [r6, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001f8e:	462b      	mov	r3, r5
  USBx_DEVICE->DOEPMSK = 0U;
 8001f90:	6175      	str	r5, [r6, #20]
      USBx_INEP(i)->DIEPCTL = 0U;
 8001f92:	4629      	mov	r1, r5
  USBx_DEVICE->DAINTMSK = 0U;
 8001f94:	61f5      	str	r5, [r6, #28]
 8001f96:	f504 6210 	add.w	r2, r4, #2304	; 0x900
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8001f9a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8001f9e:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8001fa2:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001fa6:	4543      	cmp	r3, r8
 8001fa8:	d12f      	bne.n	800200a <USB_DevInit+0xee>
 8001faa:	2100      	movs	r1, #0
 8001fac:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001fb0:	4608      	mov	r0, r1
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8001fb2:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8001fb6:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8001fba:	f64f 3c7f 	movw	ip, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001fbe:	428b      	cmp	r3, r1
 8001fc0:	d134      	bne.n	800202c <USB_DevInit+0x110>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8001fc2:	6933      	ldr	r3, [r6, #16]
 8001fc4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001fc8:	6133      	str	r3, [r6, #16]
  USBx->GINTMSK = 0U;
 8001fca:	2300      	movs	r3, #0
 8001fcc:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001fce:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001fd2:	6163      	str	r3, [r4, #20]
  USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8001fd4:	69a3      	ldr	r3, [r4, #24]
 8001fd6:	f043 0310 	orr.w	r3, r3, #16
 8001fda:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8001fdc:	69a2      	ldr	r2, [r4, #24]
 8001fde:	4b1c      	ldr	r3, [pc, #112]	; (8002050 <USB_DevInit+0x134>)
 8001fe0:	4313      	orrs	r3, r2
 8001fe2:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 8001fe4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001fe6:	b11b      	cbz	r3, 8001ff0 <USB_DevInit+0xd4>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8001fe8:	69a3      	ldr	r3, [r4, #24]
 8001fea:	f043 0308 	orr.w	r3, r3, #8
 8001fee:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 8001ff0:	2f01      	cmp	r7, #1
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8001ff2:	bf01      	itttt	eq
 8001ff4:	69a3      	ldreq	r3, [r4, #24]
 8001ff6:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 8001ffa:	f043 0304 	orreq.w	r3, r3, #4
 8001ffe:	61a3      	streq	r3, [r4, #24]
}
 8002000:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8002004:	2000      	movs	r0, #0
 8002006:	b004      	add	sp, #16
 8002008:	4770      	bx	lr
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800200a:	f8d2 c000 	ldr.w	ip, [r2]
 800200e:	f1bc 0f00 	cmp.w	ip, #0
 8002012:	da09      	bge.n	8002028 <USB_DevInit+0x10c>
      if (i == 0U)
 8002014:	b933      	cbnz	r3, 8002024 <USB_DevInit+0x108>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8002016:	6015      	str	r5, [r2, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8002018:	6111      	str	r1, [r2, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800201a:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800201c:	f8c2 e008 	str.w	lr, [r2, #8]
 8002020:	3220      	adds	r2, #32
 8002022:	e7c0      	b.n	8001fa6 <USB_DevInit+0x8a>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8002024:	6010      	str	r0, [r2, #0]
 8002026:	e7f7      	b.n	8002018 <USB_DevInit+0xfc>
      USBx_INEP(i)->DIEPCTL = 0U;
 8002028:	6011      	str	r1, [r2, #0]
 800202a:	e7f5      	b.n	8002018 <USB_DevInit+0xfc>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800202c:	f8d2 8000 	ldr.w	r8, [r2]
 8002030:	f1b8 0f00 	cmp.w	r8, #0
 8002034:	da0a      	bge.n	800204c <USB_DevInit+0x130>
      if (i == 0U)
 8002036:	b939      	cbnz	r1, 8002048 <USB_DevInit+0x12c>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8002038:	f8c2 e000 	str.w	lr, [r2]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 800203c:	6110      	str	r0, [r2, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800203e:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8002040:	f8c2 c008 	str.w	ip, [r2, #8]
 8002044:	3220      	adds	r2, #32
 8002046:	e7ba      	b.n	8001fbe <USB_DevInit+0xa2>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8002048:	6015      	str	r5, [r2, #0]
 800204a:	e7f7      	b.n	800203c <USB_DevInit+0x120>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800204c:	6010      	str	r0, [r2, #0]
 800204e:	e7f5      	b.n	800203c <USB_DevInit+0x120>
 8002050:	803c3800 	.word	0x803c3800

08002054 <USB_ActivateEndpoint>:
{
 8002054:	b570      	push	{r4, r5, r6, lr}
  if (ep->is_in == 1U)
 8002056:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8002058:	780c      	ldrb	r4, [r1, #0]
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 800205a:	f8d0 681c 	ldr.w	r6, [r0, #2076]	; 0x81c
 800205e:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  if (ep->is_in == 1U)
 8002062:	2a01      	cmp	r2, #1
 8002064:	f004 050f 	and.w	r5, r4, #15
 8002068:	d11b      	bne.n	80020a2 <USB_ActivateEndpoint+0x4e>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 800206a:	40aa      	lsls	r2, r5
 800206c:	4332      	orrs	r2, r6
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800206e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 8002072:	61da      	str	r2, [r3, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8002074:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002078:	041a      	lsls	r2, r3, #16
 800207a:	d410      	bmi.n	800209e <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800207c:	688b      	ldr	r3, [r1, #8]
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800207e:	78c9      	ldrb	r1, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8002080:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8002084:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8002088:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800208c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002090:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8002094:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8002098:	4313      	orrs	r3, r2
 800209a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800209e:	2000      	movs	r0, #0
 80020a0:	bd70      	pop	{r4, r5, r6, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16);
 80020a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80020a6:	40aa      	lsls	r2, r5
 80020a8:	4332      	orrs	r2, r6
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80020aa:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16);
 80020ae:	61da      	str	r2, [r3, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80020b0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80020b4:	041b      	lsls	r3, r3, #16
 80020b6:	d4f2      	bmi.n	800209e <USB_ActivateEndpoint+0x4a>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80020b8:	688b      	ldr	r3, [r1, #8]
                                    ((uint32_t)ep->type << 18) |
 80020ba:	78c9      	ldrb	r1, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80020bc:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 80020c0:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80020c4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80020c8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80020cc:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 80020d0:	4313      	orrs	r3, r2
 80020d2:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80020d6:	e7e2      	b.n	800209e <USB_ActivateEndpoint+0x4a>

080020d8 <USB_DeactivateEndpoint>:
{
 80020d8:	b530      	push	{r4, r5, lr}
  if (ep->is_in == 1U)
 80020da:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80020dc:	780c      	ldrb	r4, [r1, #0]
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 80020de:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
 80020e2:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  if (ep->is_in == 1U)
 80020e6:	2b01      	cmp	r3, #1
 80020e8:	f004 050f 	and.w	r5, r4, #15
 80020ec:	d110      	bne.n	8002110 <USB_DeactivateEndpoint+0x38>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 80020ee:	40ab      	lsls	r3, r5
 80020f0:	43db      	mvns	r3, r3
 80020f2:	4019      	ands	r1, r3
 80020f4:	63d1      	str	r1, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 80020f6:	69d1      	ldr	r1, [r2, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 80020f8:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 80020fc:	400b      	ands	r3, r1
 80020fe:	61d3      	str	r3, [r2, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8002100:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8002104:	4b0b      	ldr	r3, [pc, #44]	; (8002134 <USB_DeactivateEndpoint+0x5c>)
 8002106:	4013      	ands	r3, r2
 8002108:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800210c:	2000      	movs	r0, #0
 800210e:	bd30      	pop	{r4, r5, pc}
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 8002110:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8002114:	40ab      	lsls	r3, r5
 8002116:	43db      	mvns	r3, r3
 8002118:	4019      	ands	r1, r3
 800211a:	63d1      	str	r1, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 800211c:	69d1      	ldr	r1, [r2, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 800211e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 8002122:	400b      	ands	r3, r1
 8002124:	61d3      	str	r3, [r2, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8002126:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 800212a:	4b03      	ldr	r3, [pc, #12]	; (8002138 <USB_DeactivateEndpoint+0x60>)
 800212c:	4013      	ands	r3, r2
 800212e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8002132:	e7eb      	b.n	800210c <USB_DeactivateEndpoint+0x34>
 8002134:	ec337800 	.word	0xec337800
 8002138:	eff37800 	.word	0xeff37800

0800213c <USB_EP0StartXfer>:
{
 800213c:	b570      	push	{r4, r5, r6, lr}
  if (ep->is_in == 1U)
 800213e:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8002140:	780a      	ldrb	r2, [r1, #0]
 8002142:	694d      	ldr	r5, [r1, #20]
 8002144:	4e35      	ldr	r6, [pc, #212]	; (800221c <USB_EP0StartXfer+0xe0>)
  if (ep->is_in == 1U)
 8002146:	2b01      	cmp	r3, #1
 8002148:	f04f 0320 	mov.w	r3, #32
 800214c:	d145      	bne.n	80021da <USB_EP0StartXfer+0x9e>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800214e:	fb13 0302 	smlabb	r3, r3, r2, r0
    if (ep->xfer_len == 0U)
 8002152:	bb45      	cbnz	r5, 80021a6 <USB_EP0StartXfer+0x6a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8002154:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 8002158:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800215c:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8002160:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8002164:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 8002168:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800216c:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002170:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 8002174:	4026      	ands	r6, r4
 8002176:	f8c3 6910 	str.w	r6, [r3, #2320]	; 0x910
    if (ep->xfer_len > 0U)
 800217a:	694b      	ldr	r3, [r1, #20]
 800217c:	b14b      	cbz	r3, 8002192 <USB_EP0StartXfer+0x56>
      USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & 0xFU);
 800217e:	780b      	ldrb	r3, [r1, #0]
 8002180:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8002184:	f003 010f 	and.w	r1, r3, #15
 8002188:	2301      	movs	r3, #1
 800218a:	408b      	lsls	r3, r1
 800218c:	432b      	orrs	r3, r5
 800218e:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8002192:	eb00 1042 	add.w	r0, r0, r2, lsl #5
 8002196:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 800219a:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 800219e:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
}
 80021a2:	2000      	movs	r0, #0
 80021a4:	bd70      	pop	{r4, r5, r6, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80021a6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80021aa:	691c      	ldr	r4, [r3, #16]
 80021ac:	4026      	ands	r6, r4
 80021ae:	611e      	str	r6, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80021b0:	691c      	ldr	r4, [r3, #16]
 80021b2:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80021b6:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80021ba:	611c      	str	r4, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 80021bc:	688c      	ldr	r4, [r1, #8]
 80021be:	42a5      	cmp	r5, r4
        ep->xfer_len = ep->maxpacket;
 80021c0:	bf88      	it	hi
 80021c2:	614c      	strhi	r4, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80021c4:	691c      	ldr	r4, [r3, #16]
 80021c6:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80021ca:	611c      	str	r4, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80021cc:	694c      	ldr	r4, [r1, #20]
 80021ce:	691d      	ldr	r5, [r3, #16]
 80021d0:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80021d4:	432c      	orrs	r4, r5
 80021d6:	611c      	str	r4, [r3, #16]
 80021d8:	e7cf      	b.n	800217a <USB_EP0StartXfer+0x3e>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80021da:	fb13 0002 	smlabb	r0, r3, r2, r0
 80021de:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 80021e2:	691a      	ldr	r2, [r3, #16]
 80021e4:	4032      	ands	r2, r6
 80021e6:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 80021e8:	691a      	ldr	r2, [r3, #16]
 80021ea:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 80021ee:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 80021f2:	611a      	str	r2, [r3, #16]
 80021f4:	688a      	ldr	r2, [r1, #8]
    if (ep->xfer_len > 0U)
 80021f6:	b105      	cbz	r5, 80021fa <USB_EP0StartXfer+0xbe>
      ep->xfer_len = ep->maxpacket;
 80021f8:	614a      	str	r2, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80021fa:	6919      	ldr	r1, [r3, #16]
 80021fc:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 8002200:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 8002202:	6919      	ldr	r1, [r3, #16]
 8002204:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8002208:	430a      	orrs	r2, r1
 800220a:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800220c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8002210:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8002214:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8002218:	e7c3      	b.n	80021a2 <USB_EP0StartXfer+0x66>
 800221a:	bf00      	nop
 800221c:	fff80000 	.word	0xfff80000

08002220 <USB_WritePacket>:
  count32b = ((uint32_t)len + 3U) / 4U;
 8002220:	3303      	adds	r3, #3
    USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 8002222:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 8002226:	f023 0303 	bic.w	r3, r3, #3
 800222a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800222e:	440b      	add	r3, r1
  for (i = 0U; i < count32b; i++)
 8002230:	4299      	cmp	r1, r3
 8002232:	d101      	bne.n	8002238 <USB_WritePacket+0x18>
}
 8002234:	2000      	movs	r0, #0
 8002236:	4770      	bx	lr
    USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 8002238:	f851 0b04 	ldr.w	r0, [r1], #4
 800223c:	6010      	str	r0, [r2, #0]
 800223e:	e7f7      	b.n	8002230 <USB_WritePacket+0x10>

08002240 <USB_EPStartXfer>:
{
 8002240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 8002242:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8002244:	780d      	ldrb	r5, [r1, #0]
 8002246:	4e5f      	ldr	r6, [pc, #380]	; (80023c4 <USB_EPStartXfer+0x184>)
  if (ep->is_in == 1U)
 8002248:	2b01      	cmp	r3, #1
 800224a:	f04f 0220 	mov.w	r2, #32
 800224e:	694b      	ldr	r3, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8002250:	fb12 0205 	smlabb	r2, r2, r5, r0
  if (ep->is_in == 1U)
 8002254:	d169      	bne.n	800232a <USB_EPStartXfer+0xea>
    if (ep->xfer_len == 0U)
 8002256:	bb83      	cbnz	r3, 80022ba <USB_EPStartXfer+0x7a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8002258:	f502 6410 	add.w	r4, r2, #2304	; 0x900
 800225c:	f8d2 2910 	ldr.w	r2, [r2, #2320]	; 0x910
 8002260:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 8002264:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 8002268:	6122      	str	r2, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800226a:	6922      	ldr	r2, [r4, #16]
 800226c:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8002270:	6122      	str	r2, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002272:	6922      	ldr	r2, [r4, #16]
 8002274:	4016      	ands	r6, r2
 8002276:	6126      	str	r6, [r4, #16]
    if (ep->type != EP_TYPE_ISOC)
 8002278:	78ce      	ldrb	r6, [r1, #3]
 800227a:	2e01      	cmp	r6, #1
 800227c:	f000 8094 	beq.w	80023a8 <USB_EPStartXfer+0x168>
      if (ep->xfer_len > 0U)
 8002280:	b153      	cbz	r3, 8002298 <USB_EPStartXfer+0x58>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & 0xFU);
 8002282:	780a      	ldrb	r2, [r1, #0]
 8002284:	f8d0 e834 	ldr.w	lr, [r0, #2100]	; 0x834
 8002288:	f002 040f 	and.w	r4, r2, #15
 800228c:	2201      	movs	r2, #1
 800228e:	40a2      	lsls	r2, r4
 8002290:	ea42 020e 	orr.w	r2, r2, lr
 8002294:	f8c0 2834 	str.w	r2, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8002298:	eb00 1245 	add.w	r2, r0, r5, lsl #5
    if (ep->type == EP_TYPE_ISOC)
 800229c:	2e01      	cmp	r6, #1
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800229e:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 80022a2:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80022a6:	f8c2 4900 	str.w	r4, [r2, #2304]	; 0x900
    if (ep->type == EP_TYPE_ISOC)
 80022aa:	d104      	bne.n	80022b6 <USB_EPStartXfer+0x76>
      (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len);
 80022ac:	780a      	ldrb	r2, [r1, #0]
 80022ae:	68c9      	ldr	r1, [r1, #12]
 80022b0:	b29b      	uxth	r3, r3
 80022b2:	f7ff ffb5 	bl	8002220 <USB_WritePacket>
}
 80022b6:	2000      	movs	r0, #0
 80022b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80022ba:	f8d2 4910 	ldr.w	r4, [r2, #2320]	; 0x910
 80022be:	4034      	ands	r4, r6
 80022c0:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80022c4:	f8d2 4910 	ldr.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80022c8:	688e      	ldr	r6, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80022ca:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80022ce:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80022d2:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80022d6:	199c      	adds	r4, r3, r6
 80022d8:	3c01      	subs	r4, #1
 80022da:	fbb4 f6f6 	udiv	r6, r4, r6
 80022de:	4c3a      	ldr	r4, [pc, #232]	; (80023c8 <USB_EPStartXfer+0x188>)
 80022e0:	f8d2 7910 	ldr.w	r7, [r2, #2320]	; 0x910
 80022e4:	ea04 44c6 	and.w	r4, r4, r6, lsl #19
 80022e8:	433c      	orrs	r4, r7
 80022ea:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80022ee:	f8d2 6910 	ldr.w	r6, [r2, #2320]	; 0x910
 80022f2:	f3c3 0412 	ubfx	r4, r3, #0, #19
 80022f6:	4334      	orrs	r4, r6
 80022f8:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 80022fc:	78cc      	ldrb	r4, [r1, #3]
 80022fe:	2c01      	cmp	r4, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002300:	f502 6210 	add.w	r2, r2, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 8002304:	d1b8      	bne.n	8002278 <USB_EPStartXfer+0x38>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8002306:	6914      	ldr	r4, [r2, #16]
 8002308:	f024 44c0 	bic.w	r4, r4, #1610612736	; 0x60000000
 800230c:	6114      	str	r4, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800230e:	6914      	ldr	r4, [r2, #16]
 8002310:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8002314:	6114      	str	r4, [r2, #16]
 8002316:	e7af      	b.n	8002278 <USB_EPStartXfer+0x38>
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8002318:	fb12 0205 	smlabb	r2, r2, r5, r0
 800231c:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 8002320:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8002324:	f8c2 4900 	str.w	r4, [r2, #2304]	; 0x900
 8002328:	e7b6      	b.n	8002298 <USB_EPStartXfer+0x58>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800232a:	f502 6530 	add.w	r5, r2, #2816	; 0xb00
 800232e:	692c      	ldr	r4, [r5, #16]
 8002330:	4034      	ands	r4, r6
 8002332:	612c      	str	r4, [r5, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8002334:	692c      	ldr	r4, [r5, #16]
 8002336:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800233a:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800233e:	612c      	str	r4, [r5, #16]
 8002340:	688c      	ldr	r4, [r1, #8]
    if (ep->xfer_len == 0U)
 8002342:	b9fb      	cbnz	r3, 8002384 <USB_EPStartXfer+0x144>
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8002344:	692b      	ldr	r3, [r5, #16]
 8002346:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800234a:	431c      	orrs	r4, r3
 800234c:	612c      	str	r4, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800234e:	692b      	ldr	r3, [r5, #16]
 8002350:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8002354:	612b      	str	r3, [r5, #16]
    if (ep->type == EP_TYPE_ISOC)
 8002356:	78cb      	ldrb	r3, [r1, #3]
 8002358:	2b01      	cmp	r3, #1
 800235a:	d10c      	bne.n	8002376 <USB_EPStartXfer+0x136>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800235c:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8002360:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8002364:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8002368:	bf0c      	ite	eq
 800236a:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800236e:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8002372:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8002376:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800237a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800237e:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  return HAL_OK;
 8002382:	e798      	b.n	80022b6 <USB_EPStartXfer+0x76>
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8002384:	4e10      	ldr	r6, [pc, #64]	; (80023c8 <USB_EPStartXfer+0x188>)
 8002386:	692f      	ldr	r7, [r5, #16]
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8002388:	4423      	add	r3, r4
 800238a:	3b01      	subs	r3, #1
 800238c:	fbb3 f3f4 	udiv	r3, r3, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8002390:	ea06 46c3 	and.w	r6, r6, r3, lsl #19
 8002394:	433e      	orrs	r6, r7
 8002396:	612e      	str	r6, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 8002398:	b29b      	uxth	r3, r3
 800239a:	692e      	ldr	r6, [r5, #16]
 800239c:	435c      	muls	r4, r3
 800239e:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80023a2:	4334      	orrs	r4, r6
 80023a4:	612c      	str	r4, [r5, #16]
 80023a6:	e7d6      	b.n	8002356 <USB_EPStartXfer+0x116>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80023a8:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 80023ac:	f412 7f80 	tst.w	r2, #256	; 0x100
 80023b0:	f04f 0220 	mov.w	r2, #32
 80023b4:	d0b0      	beq.n	8002318 <USB_EPStartXfer+0xd8>
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80023b6:	fb12 0205 	smlabb	r2, r2, r5, r0
 80023ba:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 80023be:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80023c2:	e7af      	b.n	8002324 <USB_EPStartXfer+0xe4>
 80023c4:	fff80000 	.word	0xfff80000
 80023c8:	1ff80000 	.word	0x1ff80000

080023cc <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 80023cc:	3203      	adds	r2, #3
 80023ce:	f022 0203 	bic.w	r2, r2, #3
 80023d2:	440a      	add	r2, r1
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 80023d4:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  for (i = 0U; i < count32b; i++)
 80023d8:	4291      	cmp	r1, r2
 80023da:	d101      	bne.n	80023e0 <USB_ReadPacket+0x14>
}
 80023dc:	4608      	mov	r0, r1
 80023de:	4770      	bx	lr
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 80023e0:	6803      	ldr	r3, [r0, #0]
 80023e2:	f841 3b04 	str.w	r3, [r1], #4
 80023e6:	e7f7      	b.n	80023d8 <USB_ReadPacket+0xc>

080023e8 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 80023e8:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80023ea:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 80023ec:	2b01      	cmp	r3, #1
 80023ee:	f04f 0320 	mov.w	r3, #32
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80023f2:	fb13 0002 	smlabb	r0, r3, r2, r0
  if (ep->is_in == 1U)
 80023f6:	d112      	bne.n	800241e <USB_EPSetStall+0x36>
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80023f8:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80023fc:	2b00      	cmp	r3, #0
 80023fe:	db06      	blt.n	800240e <USB_EPSetStall+0x26>
 8002400:	b12a      	cbz	r2, 800240e <USB_EPSetStall+0x26>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8002402:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002406:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800240a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800240e:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002412:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002416:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800241a:	2000      	movs	r0, #0
 800241c:	4770      	bx	lr
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800241e:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8002422:	2b00      	cmp	r3, #0
 8002424:	db06      	blt.n	8002434 <USB_EPSetStall+0x4c>
 8002426:	b12a      	cbz	r2, 8002434 <USB_EPSetStall+0x4c>
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8002428:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800242c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002430:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8002434:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8002438:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800243c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8002440:	e7eb      	b.n	800241a <USB_EPSetStall+0x32>

08002442 <USB_EPClearStall>:
  if (ep->is_in == 1U)
 8002442:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8002444:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 8002446:	2b01      	cmp	r3, #1
 8002448:	f04f 0320 	mov.w	r3, #32
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800244c:	fb13 0002 	smlabb	r0, r3, r2, r0
  if (ep->is_in == 1U)
 8002450:	d111      	bne.n	8002476 <USB_EPClearStall+0x34>
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8002452:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002456:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800245a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800245e:	78cb      	ldrb	r3, [r1, #3]
 8002460:	3b02      	subs	r3, #2
 8002462:	2b01      	cmp	r3, #1
 8002464:	d805      	bhi.n	8002472 <USB_EPClearStall+0x30>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8002466:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800246a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800246e:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8002472:	2000      	movs	r0, #0
 8002474:	4770      	bx	lr
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8002476:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800247a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800247e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8002482:	78cb      	ldrb	r3, [r1, #3]
 8002484:	3b02      	subs	r3, #2
 8002486:	2b01      	cmp	r3, #1
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8002488:	bf9e      	ittt	ls
 800248a:	f8d0 3b00 	ldrls.w	r3, [r0, #2816]	; 0xb00
 800248e:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
 8002492:	f8c0 3b00 	strls.w	r3, [r0, #2816]	; 0xb00
 8002496:	e7ec      	b.n	8002472 <USB_EPClearStall+0x30>

08002498 <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8002498:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800249c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80024a0:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 80024a4:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80024a8:	0109      	lsls	r1, r1, #4
 80024aa:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80024ae:	4319      	orrs	r1, r3
 80024b0:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 80024b4:	2000      	movs	r0, #0
 80024b6:	4770      	bx	lr

080024b8 <USB_DevConnect>:
{
 80024b8:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80024ba:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80024be:	f023 0302 	bic.w	r3, r3, #2
 80024c2:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80024c6:	2003      	movs	r0, #3
 80024c8:	f7fd fece 	bl	8000268 <HAL_Delay>
}
 80024cc:	2000      	movs	r0, #0
 80024ce:	bd08      	pop	{r3, pc}

080024d0 <USB_DevDisconnect>:
{
 80024d0:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80024d2:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80024d6:	f043 0302 	orr.w	r3, r3, #2
 80024da:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80024de:	2003      	movs	r0, #3
 80024e0:	f7fd fec2 	bl	8000268 <HAL_Delay>
}
 80024e4:	2000      	movs	r0, #0
 80024e6:	bd08      	pop	{r3, pc}

080024e8 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 80024e8:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 80024ea:	6980      	ldr	r0, [r0, #24]
}
 80024ec:	4010      	ands	r0, r2
 80024ee:	4770      	bx	lr

080024f0 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 80024f0:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80024f4:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80024f8:	69c0      	ldr	r0, [r0, #28]
 80024fa:	4018      	ands	r0, r3
}
 80024fc:	0c00      	lsrs	r0, r0, #16
 80024fe:	4770      	bx	lr

08002500 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8002500:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8002504:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8002508:	69c0      	ldr	r0, [r0, #28]
 800250a:	4018      	ands	r0, r3
}
 800250c:	b280      	uxth	r0, r0
 800250e:	4770      	bx	lr

08002510 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8002510:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8002514:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8002518:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 800251c:	6940      	ldr	r0, [r0, #20]
}
 800251e:	4010      	ands	r0, r2
 8002520:	4770      	bx	lr

08002522 <USB_ReadDevInEPInterrupt>:
{
 8002522:	b510      	push	{r4, lr}
  msk = USBx_DEVICE->DIEPMSK;
 8002524:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8002528:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800252c:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 8002530:	f001 010f 	and.w	r1, r1, #15
 8002534:	40cb      	lsrs	r3, r1
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8002536:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 800253a:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800253c:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 800253e:	b2db      	uxtb	r3, r3
 8002540:	4323      	orrs	r3, r4
}
 8002542:	4018      	ands	r0, r3
 8002544:	bd10      	pop	{r4, pc}

08002546 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8002546:	6940      	ldr	r0, [r0, #20]
}
 8002548:	f000 0001 	and.w	r0, r0, #1
 800254c:	4770      	bx	lr

0800254e <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800254e:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002552:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8002556:	f023 0307 	bic.w	r3, r3, #7
 800255a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800255e:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8002562:	689a      	ldr	r2, [r3, #8]
 8002564:	f002 0206 	and.w	r2, r2, #6
 8002568:	2a04      	cmp	r2, #4
    USBx_INEP(0U)->DIEPCTL |= 3U;
 800256a:	bf02      	ittt	eq
 800256c:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 8002570:	f042 0203 	orreq.w	r2, r2, #3
 8002574:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8002578:	685a      	ldr	r2, [r3, #4]
 800257a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800257e:	605a      	str	r2, [r3, #4]
}
 8002580:	2000      	movs	r0, #0
 8002582:	4770      	bx	lr

08002584 <USB_EP0_OutStart>:
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8002584:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8002588:	2000      	movs	r0, #0
 800258a:	6118      	str	r0, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800258c:	691a      	ldr	r2, [r3, #16]
 800258e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8002592:	611a      	str	r2, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8002594:	691a      	ldr	r2, [r3, #16]
 8002596:	f042 0218 	orr.w	r2, r2, #24
 800259a:	611a      	str	r2, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 800259c:	691a      	ldr	r2, [r3, #16]
 800259e:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 80025a2:	611a      	str	r2, [r3, #16]
}
 80025a4:	4770      	bx	lr
	...

080025a8 <USBD_CUSTOM_HID_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_CfgFSDesc);
 80025a8:	2329      	movs	r3, #41	; 0x29
 80025aa:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_CfgFSDesc;
}
 80025ac:	4800      	ldr	r0, [pc, #0]	; (80025b0 <USBD_CUSTOM_HID_GetFSCfgDesc+0x8>)
 80025ae:	4770      	bx	lr
 80025b0:	2000003c 	.word	0x2000003c

080025b4 <USBD_CUSTOM_HID_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_CfgHSDesc);
 80025b4:	2329      	movs	r3, #41	; 0x29
 80025b6:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_CfgHSDesc;
}
 80025b8:	4800      	ldr	r0, [pc, #0]	; (80025bc <USBD_CUSTOM_HID_GetHSCfgDesc+0x8>)
 80025ba:	4770      	bx	lr
 80025bc:	20000068 	.word	0x20000068

080025c0 <USBD_CUSTOM_HID_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_OtherSpeedCfgDesc);
 80025c0:	2329      	movs	r3, #41	; 0x29
 80025c2:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_OtherSpeedCfgDesc;
}
 80025c4:	4800      	ldr	r0, [pc, #0]	; (80025c8 <USBD_CUSTOM_HID_GetOtherSpeedCfgDesc+0x8>)
 80025c6:	4770      	bx	lr
 80025c8:	200000ac 	.word	0x200000ac

080025cc <USBD_CUSTOM_HID_DataIn>:
static uint8_t  USBD_CUSTOM_HID_DataIn (USBD_HandleTypeDef *pdev,
                                        uint8_t epnum)
{
  /* Ensure that the FIFO is empty before a new transfer, this condition could
  be caused by  a new transfer before the end of the previous transfer */
  ((USBD_CUSTOM_HID_HandleTypeDef *)pdev->pClassData)->state = CUSTOM_HID_IDLE;
 80025cc:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
 80025d0:	2000      	movs	r0, #0
 80025d2:	7718      	strb	r0, [r3, #28]

  return USBD_OK;
}
 80025d4:	4770      	bx	lr

080025d6 <USBD_CUSTOM_HID_EP0_RxReady>:
  *         Handles control request data.
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CUSTOM_HID_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 80025d6:	b510      	push	{r4, lr}
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 80025d8:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290

  if (hhid->IsReportAvailable == 1U)
 80025dc:	69a3      	ldr	r3, [r4, #24]
 80025de:	2b01      	cmp	r3, #1
 80025e0:	d107      	bne.n	80025f2 <USBD_CUSTOM_HID_EP0_RxReady+0x1c>
  {
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 80025e2:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 80025e6:	7861      	ldrb	r1, [r4, #1]
 80025e8:	68db      	ldr	r3, [r3, #12]
 80025ea:	7820      	ldrb	r0, [r4, #0]
 80025ec:	4798      	blx	r3
                                                              hhid->Report_buf[1]);
    hhid->IsReportAvailable = 0U;
 80025ee:	2300      	movs	r3, #0
 80025f0:	61a3      	str	r3, [r4, #24]
  }

  return USBD_OK;
}
 80025f2:	2000      	movs	r0, #0
 80025f4:	bd10      	pop	{r4, pc}
	...

080025f8 <USBD_CUSTOM_HID_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_CUSTOM_HID_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_DeviceQualifierDesc);
 80025f8:	230a      	movs	r3, #10
 80025fa:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_DeviceQualifierDesc;
}
 80025fc:	4800      	ldr	r0, [pc, #0]	; (8002600 <USBD_CUSTOM_HID_GetDeviceQualifierDesc+0x8>)
 80025fe:	4770      	bx	lr
 8002600:	200000a0 	.word	0x200000a0

08002604 <USBD_CUSTOM_HID_DataOut>:
{
 8002604:	b538      	push	{r3, r4, r5, lr}
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 8002606:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 800260a:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 800260e:	7869      	ldrb	r1, [r5, #1]
 8002610:	68db      	ldr	r3, [r3, #12]
{
 8002612:	4604      	mov	r4, r0
  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 8002614:	7828      	ldrb	r0, [r5, #0]
 8002616:	4798      	blx	r3
  USBD_LL_PrepareReceive(pdev, CUSTOM_HID_EPOUT_ADDR , hhid->Report_buf,
 8002618:	230c      	movs	r3, #12
 800261a:	462a      	mov	r2, r5
 800261c:	2101      	movs	r1, #1
 800261e:	4620      	mov	r0, r4
 8002620:	f000 fea6 	bl	8003370 <USBD_LL_PrepareReceive>
}
 8002624:	2000      	movs	r0, #0
 8002626:	bd38      	pop	{r3, r4, r5, pc}

08002628 <USBD_CUSTOM_HID_Setup>:
{
 8002628:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint16_t status_info = 0U;
 800262a:	2500      	movs	r5, #0
 800262c:	f8ad 5006 	strh.w	r5, [sp, #6]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002630:	780d      	ldrb	r5, [r1, #0]
  USBD_CUSTOM_HID_HandleTypeDef *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 8002632:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002636:	f015 0560 	ands.w	r5, r5, #96	; 0x60
{
 800263a:	4603      	mov	r3, r0
 800263c:	460a      	mov	r2, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800263e:	d028      	beq.n	8002692 <USBD_CUSTOM_HID_Setup+0x6a>
 8002640:	2d20      	cmp	r5, #32
 8002642:	d161      	bne.n	8002708 <USBD_CUSTOM_HID_Setup+0xe0>
    switch (req->bRequest)
 8002644:	7849      	ldrb	r1, [r1, #1]
 8002646:	3902      	subs	r1, #2
 8002648:	2909      	cmp	r1, #9
 800264a:	d85b      	bhi.n	8002704 <USBD_CUSTOM_HID_Setup+0xdc>
 800264c:	e8df f001 	tbb	[pc, r1]
 8002650:	5a5a0a15 	.word	0x5a5a0a15
 8002654:	195a5a5a 	.word	0x195a5a5a
 8002658:	0511      	.short	0x0511
      hhid->Protocol = (uint8_t)(req->wValue);
 800265a:	7893      	ldrb	r3, [r2, #2]
 800265c:	60e3      	str	r3, [r4, #12]
  uint8_t ret = USBD_OK;
 800265e:	2000      	movs	r0, #0
}
 8002660:	b003      	add	sp, #12
 8002662:	bd30      	pop	{r4, r5, pc}
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->Protocol, 1U);
 8002664:	2201      	movs	r2, #1
 8002666:	f104 010c 	add.w	r1, r4, #12
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->AltSetting, 1U);
 800266a:	4618      	mov	r0, r3
 800266c:	f000 fc04 	bl	8002e78 <USBD_CtlSendData>
 8002670:	e7f5      	b.n	800265e <USBD_CUSTOM_HID_Setup+0x36>
      hhid->IdleState = (uint8_t)(req->wValue >> 8);
 8002672:	8853      	ldrh	r3, [r2, #2]
 8002674:	0a1b      	lsrs	r3, r3, #8
 8002676:	6123      	str	r3, [r4, #16]
 8002678:	e7f1      	b.n	800265e <USBD_CUSTOM_HID_Setup+0x36>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->IdleState, 1U);
 800267a:	2201      	movs	r2, #1
 800267c:	f104 0110 	add.w	r1, r4, #16
 8002680:	e7f3      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
      hhid->IsReportAvailable = 1U;
 8002682:	2101      	movs	r1, #1
 8002684:	61a1      	str	r1, [r4, #24]
      USBD_CtlPrepareRx (pdev, hhid->Report_buf, req->wLength);
 8002686:	88d2      	ldrh	r2, [r2, #6]
 8002688:	4621      	mov	r1, r4
 800268a:	4618      	mov	r0, r3
 800268c:	f000 fc09 	bl	8002ea2 <USBD_CtlPrepareRx>
 8002690:	e7e5      	b.n	800265e <USBD_CUSTOM_HID_Setup+0x36>
    switch (req->bRequest)
 8002692:	7849      	ldrb	r1, [r1, #1]
 8002694:	290b      	cmp	r1, #11
 8002696:	d835      	bhi.n	8002704 <USBD_CUSTOM_HID_Setup+0xdc>
 8002698:	e8df f001 	tbb	[pc, r1]
 800269c:	34343406 	.word	0x34343406
 80026a0:	340e3434 	.word	0x340e3434
 80026a4:	2d253434 	.word	0x2d253434
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80026a8:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 80026ac:	2903      	cmp	r1, #3
 80026ae:	d129      	bne.n	8002704 <USBD_CUSTOM_HID_Setup+0xdc>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&status_info, 2U);
 80026b0:	2202      	movs	r2, #2
 80026b2:	f10d 0106 	add.w	r1, sp, #6
 80026b6:	e7d8      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
      if( req->wValue >> 8 == CUSTOM_HID_REPORT_DESC)
 80026b8:	8851      	ldrh	r1, [r2, #2]
 80026ba:	0a09      	lsrs	r1, r1, #8
 80026bc:	2922      	cmp	r1, #34	; 0x22
 80026be:	d107      	bne.n	80026d0 <USBD_CUSTOM_HID_Setup+0xa8>
        len = MIN(USBD_CUSTOM_HID_REPORT_DESC_SIZE , req->wLength);
 80026c0:	88d2      	ldrh	r2, [r2, #6]
        pbuf =  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->pReport;
 80026c2:	f8d3 1294 	ldr.w	r1, [r3, #660]	; 0x294
        len = MIN(USBD_CUSTOM_HID_REPORT_DESC_SIZE , req->wLength);
 80026c6:	2a21      	cmp	r2, #33	; 0x21
 80026c8:	bf28      	it	cs
 80026ca:	2221      	movcs	r2, #33	; 0x21
        pbuf =  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->pReport;
 80026cc:	6809      	ldr	r1, [r1, #0]
 80026ce:	e7cc      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
        if( req->wValue >> 8 == CUSTOM_HID_DESCRIPTOR_TYPE)
 80026d0:	2921      	cmp	r1, #33	; 0x21
 80026d2:	d105      	bne.n	80026e0 <USBD_CUSTOM_HID_Setup+0xb8>
          len = MIN(USB_CUSTOM_HID_DESC_SIZ , req->wLength);
 80026d4:	88d2      	ldrh	r2, [r2, #6]
          pbuf = USBD_CUSTOM_HID_Desc;
 80026d6:	490e      	ldr	r1, [pc, #56]	; (8002710 <USBD_CUSTOM_HID_Setup+0xe8>)
          len = MIN(USB_CUSTOM_HID_DESC_SIZ , req->wLength);
 80026d8:	2a09      	cmp	r2, #9
 80026da:	bf28      	it	cs
 80026dc:	2209      	movcs	r2, #9
 80026de:	e7c4      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
  uint8_t  *pbuf = NULL;
 80026e0:	2100      	movs	r1, #0
  uint16_t len = 0U;
 80026e2:	460a      	mov	r2, r1
 80026e4:	e7c1      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80026e6:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 80026ea:	2903      	cmp	r1, #3
 80026ec:	d10a      	bne.n	8002704 <USBD_CUSTOM_HID_Setup+0xdc>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->AltSetting, 1U);
 80026ee:	2201      	movs	r2, #1
 80026f0:	f104 0114 	add.w	r1, r4, #20
 80026f4:	e7b9      	b.n	800266a <USBD_CUSTOM_HID_Setup+0x42>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80026f6:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 80026fa:	2903      	cmp	r1, #3
 80026fc:	d102      	bne.n	8002704 <USBD_CUSTOM_HID_Setup+0xdc>
        hhid->AltSetting = (uint8_t)(req->wValue);
 80026fe:	7893      	ldrb	r3, [r2, #2]
 8002700:	6163      	str	r3, [r4, #20]
 8002702:	e7ac      	b.n	800265e <USBD_CUSTOM_HID_Setup+0x36>
      USBD_CtlError (pdev, req);
 8002704:	4611      	mov	r1, r2
 8002706:	4618      	mov	r0, r3
    USBD_CtlError (pdev, req);
 8002708:	f000 fb8f 	bl	8002e2a <USBD_CtlError>
    ret = USBD_FAIL;
 800270c:	2002      	movs	r0, #2
    break;
 800270e:	e7a7      	b.n	8002660 <USBD_CUSTOM_HID_Setup+0x38>
 8002710:	20000094 	.word	0x20000094

08002714 <USBD_CUSTOM_HID_DeInit>:
{
 8002714:	b538      	push	{r3, r4, r5, lr}
 8002716:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPIN_ADDR);
 8002718:	2181      	movs	r1, #129	; 0x81
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 0U;
 800271a:	2500      	movs	r5, #0
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPIN_ADDR);
 800271c:	f000 fdce 	bl	80032bc <USBD_LL_CloseEP>
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 0U;
 8002720:	62e5      	str	r5, [r4, #44]	; 0x2c
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPOUT_ADDR);
 8002722:	2101      	movs	r1, #1
 8002724:	4620      	mov	r0, r4
 8002726:	f000 fdc9 	bl	80032bc <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 800272a:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_out[CUSTOM_HID_EPOUT_ADDR & 0xFU].is_used = 0U;
 800272e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
  if(pdev->pClassData != NULL)
 8002732:	b14b      	cbz	r3, 8002748 <USBD_CUSTOM_HID_DeInit+0x34>
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->DeInit();
 8002734:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8002738:	689b      	ldr	r3, [r3, #8]
 800273a:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 800273c:	f8d4 0290 	ldr.w	r0, [r4, #656]	; 0x290
 8002740:	f000 fe5a 	bl	80033f8 <USBD_static_free>
    pdev->pClassData = NULL;
 8002744:	f8c4 5290 	str.w	r5, [r4, #656]	; 0x290
}
 8002748:	2000      	movs	r0, #0
 800274a:	bd38      	pop	{r3, r4, r5, pc}

0800274c <USBD_CUSTOM_HID_Init>:
{
 800274c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800274e:	4605      	mov	r5, r0
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 1U;
 8002750:	2401      	movs	r4, #1
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPIN_ADDR, USBD_EP_TYPE_INTR,
 8002752:	2302      	movs	r3, #2
 8002754:	2203      	movs	r2, #3
 8002756:	2181      	movs	r1, #129	; 0x81
 8002758:	f000 fda0 	bl	800329c <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPOUT_ADDR, USBD_EP_TYPE_INTR,
 800275c:	2302      	movs	r3, #2
 800275e:	2203      	movs	r2, #3
 8002760:	4621      	mov	r1, r4
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 1U;
 8002762:	62ec      	str	r4, [r5, #44]	; 0x2c
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPOUT_ADDR, USBD_EP_TYPE_INTR,
 8002764:	4628      	mov	r0, r5
 8002766:	f000 fd99 	bl	800329c <USBD_LL_OpenEP>
  pdev->ep_out[CUSTOM_HID_EPOUT_ADDR & 0xFU].is_used = 1U;
 800276a:	f8c5 4158 	str.w	r4, [r5, #344]	; 0x158
  pdev->pClassData = USBD_malloc(sizeof (USBD_CUSTOM_HID_HandleTypeDef));
 800276e:	2020      	movs	r0, #32
 8002770:	f000 fe3e 	bl	80033f0 <USBD_static_malloc>
 8002774:	4606      	mov	r6, r0
 8002776:	f8c5 0290 	str.w	r0, [r5, #656]	; 0x290
  if(pdev->pClassData == NULL)
 800277a:	b168      	cbz	r0, 8002798 <USBD_CUSTOM_HID_Init+0x4c>
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->Init();
 800277c:	f8d5 3294 	ldr.w	r3, [r5, #660]	; 0x294
    hhid->state = CUSTOM_HID_IDLE;
 8002780:	2700      	movs	r7, #0
 8002782:	7707      	strb	r7, [r0, #28]
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->Init();
 8002784:	685b      	ldr	r3, [r3, #4]
 8002786:	4798      	blx	r3
    USBD_LL_PrepareReceive(pdev, CUSTOM_HID_EPOUT_ADDR, hhid->Report_buf,
 8002788:	230c      	movs	r3, #12
 800278a:	4632      	mov	r2, r6
 800278c:	4621      	mov	r1, r4
 800278e:	4628      	mov	r0, r5
 8002790:	f000 fdee 	bl	8003370 <USBD_LL_PrepareReceive>
  uint8_t ret = 0U;
 8002794:	4638      	mov	r0, r7
 8002796:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1U;
 8002798:	4620      	mov	r0, r4
}
 800279a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800279c <USBD_CUSTOM_HID_RegisterInterface>:
uint8_t  USBD_CUSTOM_HID_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                             USBD_CUSTOM_HID_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;

  if(fops != NULL)
 800279c:	b119      	cbz	r1, 80027a6 <USBD_CUSTOM_HID_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 800279e:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
    ret = USBD_OK;
 80027a2:	2000      	movs	r0, #0
 80027a4:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 80027a6:	2002      	movs	r0, #2
  }

  return ret;
}
 80027a8:	4770      	bx	lr

080027aa <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 80027aa:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 80027ac:	b180      	cbz	r0, 80027d0 <USBD_Init+0x26>
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 80027ae:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80027b2:	b113      	cbz	r3, 80027ba <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 80027b4:	2300      	movs	r3, #0
 80027b6:	f8c0 328c 	str.w	r3, [r0, #652]	; 0x28c
  }

  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 80027ba:	b109      	cbz	r1, 80027c0 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 80027bc:	f8c0 1288 	str.w	r1, [r0, #648]	; 0x288
  }

  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 80027c0:	2301      	movs	r3, #1
 80027c2:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  pdev->id = id;
 80027c6:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 80027c8:	f000 fd2c 	bl	8003224 <USBD_LL_Init>

  return USBD_OK;
 80027cc:	2000      	movs	r0, #0
 80027ce:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 80027d0:	2002      	movs	r0, #2
}
 80027d2:	bd08      	pop	{r3, pc}

080027d4 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 80027d4:	b119      	cbz	r1, 80027de <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 80027d6:	f8c0 128c 	str.w	r1, [r0, #652]	; 0x28c
    status = USBD_OK;
 80027da:	2000      	movs	r0, #0
 80027dc:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 80027de:	2002      	movs	r0, #2
  }

  return status;
}
 80027e0:	4770      	bx	lr

080027e2 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 80027e2:	b508      	push	{r3, lr}

  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 80027e4:	f000 fd4c 	bl	8003280 <USBD_LL_Start>

  return USBD_OK;
}
 80027e8:	2000      	movs	r0, #0
 80027ea:	bd08      	pop	{r3, pc}

080027ec <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80027ec:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;

  if(pdev->pClass != NULL)
 80027ee:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80027f2:	b90b      	cbnz	r3, 80027f8 <USBD_SetClassConfig+0xc>
  USBD_StatusTypeDef   ret = USBD_FAIL;
 80027f4:	2002      	movs	r0, #2
 80027f6:	bd08      	pop	{r3, pc}
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0U)
 80027f8:	681b      	ldr	r3, [r3, #0]
 80027fa:	4798      	blx	r3
 80027fc:	2800      	cmp	r0, #0
 80027fe:	d1f9      	bne.n	80027f4 <USBD_SetClassConfig+0x8>
      ret = USBD_OK;
    }
  }

  return ret;
}
 8002800:	bd08      	pop	{r3, pc}

08002802 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002802:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 8002804:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002808:	685b      	ldr	r3, [r3, #4]
 800280a:	4798      	blx	r3
  return USBD_OK;
}
 800280c:	2000      	movs	r0, #0
 800280e:	bd08      	pop	{r3, pc}

08002810 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8002810:	b538      	push	{r3, r4, r5, lr}
 8002812:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 8002814:	f500 7520 	add.w	r5, r0, #640	; 0x280
 8002818:	4628      	mov	r0, r5
 800281a:	f000 faf2 	bl	8002e02 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 800281e:	2301      	movs	r3, #1

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 8002820:	f894 1280 	ldrb.w	r1, [r4, #640]	; 0x280
  pdev->ep0_state = USBD_EP0_SETUP;
 8002824:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
  pdev->ep0_data_len = pdev->request.wLength;
 8002828:	f8b4 3286 	ldrh.w	r3, [r4, #646]	; 0x286
 800282c:	f8c4 3270 	str.w	r3, [r4, #624]	; 0x270
  switch (pdev->request.bmRequest & 0x1FU)
 8002830:	f001 031f 	and.w	r3, r1, #31
 8002834:	2b01      	cmp	r3, #1
 8002836:	d00e      	beq.n	8002856 <USBD_LL_SetupStage+0x46>
 8002838:	d307      	bcc.n	800284a <USBD_LL_SetupStage+0x3a>
 800283a:	2b02      	cmp	r3, #2
 800283c:	d010      	beq.n	8002860 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:
    USBD_StdEPReq(pdev, &pdev->request);
    break;

  default:
    USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800283e:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8002842:	4620      	mov	r0, r4
 8002844:	f000 fd48 	bl	80032d8 <USBD_LL_StallEP>
    break;
 8002848:	e003      	b.n	8002852 <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 800284a:	4629      	mov	r1, r5
 800284c:	4620      	mov	r0, r4
 800284e:	f000 f901 	bl	8002a54 <USBD_StdDevReq>
  }

  return USBD_OK;
}
 8002852:	2000      	movs	r0, #0
 8002854:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8002856:	4629      	mov	r1, r5
 8002858:	4620      	mov	r0, r4
 800285a:	f000 fa25 	bl	8002ca8 <USBD_StdItfReq>
    break;
 800285e:	e7f8      	b.n	8002852 <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);
 8002860:	4629      	mov	r1, r5
 8002862:	4620      	mov	r0, r4
 8002864:	f000 fa45 	bl	8002cf2 <USBD_StdEPReq>
    break;
 8002868:	e7f3      	b.n	8002852 <USBD_LL_SetupStage+0x42>

0800286a <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800286a:	b570      	push	{r4, r5, r6, lr}
 800286c:	4605      	mov	r5, r0
 800286e:	4616      	mov	r6, r2
  USBD_EndpointTypeDef    *pep;

  if(epnum == 0U)
 8002870:	bb39      	cbnz	r1, 80028c2 <USBD_LL_DataOutStage+0x58>
  {
    pep = &pdev->ep_out[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8002872:	f8d0 326c 	ldr.w	r3, [r0, #620]	; 0x26c
 8002876:	2b03      	cmp	r3, #3
 8002878:	d11e      	bne.n	80028b8 <USBD_LL_DataOutStage+0x4e>
    {
      if(pep->rem_length > pep->maxpacket)
 800287a:	f8d0 314c 	ldr.w	r3, [r0, #332]	; 0x14c
 800287e:	f8d0 2150 	ldr.w	r2, [r0, #336]	; 0x150
 8002882:	4293      	cmp	r3, r2
 8002884:	d90b      	bls.n	800289e <USBD_LL_DataOutStage+0x34>
      {
        pep->rem_length -=  pep->maxpacket;
 8002886:	1a9b      	subs	r3, r3, r2

        USBD_CtlContinueRx (pdev,
 8002888:	429a      	cmp	r2, r3
        pep->rem_length -=  pep->maxpacket;
 800288a:	f8c0 314c 	str.w	r3, [r0, #332]	; 0x14c
        USBD_CtlContinueRx (pdev,
 800288e:	bf8c      	ite	hi
 8002890:	b29a      	uxthhi	r2, r3
 8002892:	b292      	uxthls	r2, r2
 8002894:	4631      	mov	r1, r6
 8002896:	f000 fb13 	bl	8002ec0 <USBD_CtlContinueRx>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 800289a:	2000      	movs	r0, #0
    pdev->pClass->DataOut(pdev, epnum);
 800289c:	bd70      	pop	{r4, r5, r6, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 800289e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80028a2:	691b      	ldr	r3, [r3, #16]
 80028a4:	b123      	cbz	r3, 80028b0 <USBD_LL_DataOutStage+0x46>
 80028a6:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 80028aa:	2a03      	cmp	r2, #3
 80028ac:	d100      	bne.n	80028b0 <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev);
 80028ae:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 80028b0:	4628      	mov	r0, r5
 80028b2:	f000 fb0d 	bl	8002ed0 <USBD_CtlSendStatus>
 80028b6:	e7f0      	b.n	800289a <USBD_LL_DataOutStage+0x30>
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 80028b8:	2b05      	cmp	r3, #5
 80028ba:	d1ee      	bne.n	800289a <USBD_LL_DataOutStage+0x30>
        USBD_LL_StallEP(pdev, 0U);
 80028bc:	f000 fd0c 	bl	80032d8 <USBD_LL_StallEP>
 80028c0:	e7eb      	b.n	800289a <USBD_LL_DataOutStage+0x30>
  else if((pdev->pClass->DataOut != NULL) &&
 80028c2:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80028c6:	699b      	ldr	r3, [r3, #24]
 80028c8:	b12b      	cbz	r3, 80028d6 <USBD_LL_DataOutStage+0x6c>
 80028ca:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 80028ce:	2a03      	cmp	r2, #3
 80028d0:	d101      	bne.n	80028d6 <USBD_LL_DataOutStage+0x6c>
    pdev->pClass->DataOut(pdev, epnum);
 80028d2:	4798      	blx	r3
 80028d4:	e7e1      	b.n	800289a <USBD_LL_DataOutStage+0x30>
    return USBD_FAIL;
 80028d6:	2002      	movs	r0, #2
}
 80028d8:	bd70      	pop	{r4, r5, r6, pc}

080028da <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev, uint8_t epnum,
                                       uint8_t *pdata)
{
 80028da:	b570      	push	{r4, r5, r6, lr}
 80028dc:	4613      	mov	r3, r2
 80028de:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if(epnum == 0U)
 80028e0:	460e      	mov	r6, r1
 80028e2:	2900      	cmp	r1, #0
 80028e4:	d148      	bne.n	8002978 <USBD_LL_DataInStage+0x9e>
  {
    pep = &pdev->ep_in[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 80028e6:	f8d0 226c 	ldr.w	r2, [r0, #620]	; 0x26c
 80028ea:	2a02      	cmp	r2, #2
 80028ec:	d13d      	bne.n	800296a <USBD_LL_DataInStage+0x90>
    {
      if(pep->rem_length > pep->maxpacket)
 80028ee:	6a05      	ldr	r5, [r0, #32]
 80028f0:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80028f2:	4295      	cmp	r5, r2
 80028f4:	d914      	bls.n	8002920 <USBD_LL_DataInStage+0x46>
      {
        pep->rem_length -= pep->maxpacket;
 80028f6:	1aaa      	subs	r2, r5, r2
 80028f8:	6202      	str	r2, [r0, #32]

        USBD_CtlContinueSendData (pdev, pdata, (uint16_t)pep->rem_length);
 80028fa:	4619      	mov	r1, r3
 80028fc:	b292      	uxth	r2, r2
 80028fe:	f000 fac8 	bl	8002e92 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8002902:	4633      	mov	r3, r6
        {
          USBD_CtlContinueSendData(pdev, NULL, 0U);
          pdev->ep0_data_len = 0U;

          /* Prepare endpoint for premature end of transfer */
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8002904:	461a      	mov	r2, r3
 8002906:	4619      	mov	r1, r3
 8002908:	4620      	mov	r0, r4
 800290a:	f000 fd31 	bl	8003370 <USBD_LL_PrepareReceive>
      {
        USBD_LL_StallEP(pdev, 0x80U);
      }
    }

    if (pdev->dev_test_mode == 1U)
 800290e:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
 8002912:	2b01      	cmp	r3, #1
 8002914:	f04f 0000 	mov.w	r0, #0
 8002918:	d13a      	bne.n	8002990 <USBD_LL_DataInStage+0xb6>
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 800291a:	f884 0278 	strb.w	r0, [r4, #632]	; 0x278
 800291e:	bd70      	pop	{r4, r5, r6, pc}
        if((pep->total_length % pep->maxpacket == 0U) &&
 8002920:	69c3      	ldr	r3, [r0, #28]
 8002922:	fbb3 f5f2 	udiv	r5, r3, r2
 8002926:	fb02 3515 	mls	r5, r2, r5, r3
 800292a:	b965      	cbnz	r5, 8002946 <USBD_LL_DataInStage+0x6c>
 800292c:	429a      	cmp	r2, r3
 800292e:	d80a      	bhi.n	8002946 <USBD_LL_DataInStage+0x6c>
           (pep->total_length >= pep->maxpacket) &&
 8002930:	f8d0 2270 	ldr.w	r2, [r0, #624]	; 0x270
 8002934:	4293      	cmp	r3, r2
 8002936:	d206      	bcs.n	8002946 <USBD_LL_DataInStage+0x6c>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 8002938:	462a      	mov	r2, r5
 800293a:	f000 faaa 	bl	8002e92 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800293e:	f8c4 5270 	str.w	r5, [r4, #624]	; 0x270
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8002942:	462b      	mov	r3, r5
 8002944:	e7de      	b.n	8002904 <USBD_LL_DataInStage+0x2a>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8002946:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 800294a:	68db      	ldr	r3, [r3, #12]
 800294c:	b12b      	cbz	r3, 800295a <USBD_LL_DataInStage+0x80>
 800294e:	f894 2274 	ldrb.w	r2, [r4, #628]	; 0x274
 8002952:	2a03      	cmp	r2, #3
 8002954:	d101      	bne.n	800295a <USBD_LL_DataInStage+0x80>
            pdev->pClass->EP0_TxSent(pdev);
 8002956:	4620      	mov	r0, r4
 8002958:	4798      	blx	r3
          USBD_LL_StallEP(pdev, 0x80U);
 800295a:	2180      	movs	r1, #128	; 0x80
 800295c:	4620      	mov	r0, r4
 800295e:	f000 fcbb 	bl	80032d8 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 8002962:	4620      	mov	r0, r4
 8002964:	f000 fabf 	bl	8002ee6 <USBD_CtlReceiveStatus>
 8002968:	e7d1      	b.n	800290e <USBD_LL_DataInStage+0x34>
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 800296a:	f032 0304 	bics.w	r3, r2, #4
 800296e:	d1ce      	bne.n	800290e <USBD_LL_DataInStage+0x34>
        USBD_LL_StallEP(pdev, 0x80U);
 8002970:	2180      	movs	r1, #128	; 0x80
 8002972:	f000 fcb1 	bl	80032d8 <USBD_LL_StallEP>
 8002976:	e7ca      	b.n	800290e <USBD_LL_DataInStage+0x34>
    }
  }
  else if((pdev->pClass->DataIn != NULL) &&
 8002978:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 800297c:	695b      	ldr	r3, [r3, #20]
 800297e:	b133      	cbz	r3, 800298e <USBD_LL_DataInStage+0xb4>
 8002980:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8002984:	2a03      	cmp	r2, #3
 8002986:	d102      	bne.n	800298e <USBD_LL_DataInStage+0xb4>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum);
 8002988:	4798      	blx	r3
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 800298a:	2000      	movs	r0, #0
    pdev->pClass->DataIn(pdev, epnum);
 800298c:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_FAIL;
 800298e:	2002      	movs	r0, #2
}
 8002990:	bd70      	pop	{r4, r5, r6, pc}

08002992 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8002992:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8002994:	2200      	movs	r2, #0
{
 8002996:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8002998:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800299a:	2501      	movs	r5, #1

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800299c:	2640      	movs	r6, #64	; 0x40
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800299e:	2340      	movs	r3, #64	; 0x40
 80029a0:	f000 fc7c 	bl	800329c <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80029a4:	4633      	mov	r3, r6
 80029a6:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80029a8:	f8c4 5144 	str.w	r5, [r4, #324]	; 0x144
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80029ac:	f8c4 6150 	str.w	r6, [r4, #336]	; 0x150
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80029b0:	2200      	movs	r2, #0
 80029b2:	4620      	mov	r0, r4
 80029b4:	f000 fc72 	bl	800329c <USBD_LL_OpenEP>
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
  pdev->dev_config= 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 80029b8:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80029bc:	61a5      	str	r5, [r4, #24]
  pdev->ep0_state = USBD_EP0_IDLE;
 80029be:	2100      	movs	r1, #0
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80029c0:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 80029c2:	f884 5274 	strb.w	r5, [r4, #628]	; 0x274
  pdev->ep0_state = USBD_EP0_IDLE;
 80029c6:	f8c4 126c 	str.w	r1, [r4, #620]	; 0x26c
  pdev->dev_config= 0U;
 80029ca:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 80029cc:	f8c4 127c 	str.w	r1, [r4, #636]	; 0x27c
  if (pdev->pClassData)
 80029d0:	b123      	cbz	r3, 80029dc <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 80029d2:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 80029d6:	4620      	mov	r0, r4
 80029d8:	685b      	ldr	r3, [r3, #4]
 80029da:	4798      	blx	r3
  }

  return USBD_OK;
}
 80029dc:	2000      	movs	r0, #0
 80029de:	bd70      	pop	{r4, r5, r6, pc}

080029e0 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 80029e0:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 80029e2:	2000      	movs	r0, #0
 80029e4:	4770      	bx	lr

080029e6 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 80029e6:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 80029ea:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 80029ee:	2304      	movs	r3, #4
 80029f0:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  return USBD_OK;
}
 80029f4:	2000      	movs	r0, #0
 80029f6:	4770      	bx	lr

080029f8 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;
 80029f8:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
 80029fc:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  return USBD_OK;
}
 8002a00:	2000      	movs	r0, #0
 8002a02:	4770      	bx	lr

08002a04 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8002a04:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002a06:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8002a0a:	2a03      	cmp	r2, #3
 8002a0c:	d104      	bne.n	8002a18 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8002a0e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002a12:	69db      	ldr	r3, [r3, #28]
 8002a14:	b103      	cbz	r3, 8002a18 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8002a16:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8002a18:	2000      	movs	r0, #0
 8002a1a:	bd08      	pop	{r3, pc}

08002a1c <USBD_LL_IsoINIncomplete>:
 8002a1c:	2000      	movs	r0, #0
 8002a1e:	4770      	bx	lr

08002a20 <USBD_LL_IsoOUTIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 8002a20:	2000      	movs	r0, #0
 8002a22:	4770      	bx	lr

08002a24 <USBD_LL_DevConnected>:
{
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
}
 8002a24:	2000      	movs	r0, #0
 8002a26:	4770      	bx	lr

08002a28 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8002a28:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002a2a:	2201      	movs	r2, #1
 8002a2c:	f880 2274 	strb.w	r2, [r0, #628]	; 0x274
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8002a30:	f8d0 228c 	ldr.w	r2, [r0, #652]	; 0x28c
 8002a34:	7901      	ldrb	r1, [r0, #4]
 8002a36:	6852      	ldr	r2, [r2, #4]
 8002a38:	4790      	blx	r2

  return USBD_OK;
}
 8002a3a:	2000      	movs	r0, #0
 8002a3c:	bd08      	pop	{r3, pc}

08002a3e <USBD_CtlError.constprop.1>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8002a3e:	b510      	push	{r4, lr}
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80U);
 8002a40:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8002a42:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80U);
 8002a44:	f000 fc48 	bl	80032d8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8002a48:	4620      	mov	r0, r4
 8002a4a:	2100      	movs	r1, #0
}
 8002a4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0U);
 8002a50:	f000 bc42 	b.w	80032d8 <USBD_LL_StallEP>

08002a54 <USBD_StdDevReq>:
{
 8002a54:	b537      	push	{r0, r1, r2, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002a56:	780b      	ldrb	r3, [r1, #0]
 8002a58:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8002a5c:	2b20      	cmp	r3, #32
{
 8002a5e:	4604      	mov	r4, r0
 8002a60:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002a62:	d014      	beq.n	8002a8e <USBD_StdDevReq+0x3a>
 8002a64:	2b40      	cmp	r3, #64	; 0x40
 8002a66:	d012      	beq.n	8002a8e <USBD_StdDevReq+0x3a>
 8002a68:	2b00      	cmp	r3, #0
 8002a6a:	f040 809c 	bne.w	8002ba6 <USBD_StdDevReq+0x152>
    switch (req->bRequest)
 8002a6e:	784b      	ldrb	r3, [r1, #1]
 8002a70:	2b09      	cmp	r3, #9
 8002a72:	f200 8097 	bhi.w	8002ba4 <USBD_StdDevReq+0x150>
 8002a76:	e8df f013 	tbh	[pc, r3, lsl #1]
 8002a7a:	00ef      	.short	0x00ef
 8002a7c:	00950109 	.word	0x00950109
 8002a80:	00950102 	.word	0x00950102
 8002a84:	00130089 	.word	0x00130089
 8002a88:	00da0095 	.word	0x00da0095
 8002a8c:	00a7      	.short	0x00a7
    pdev->pClass->Setup(pdev, req);
 8002a8e:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8002a92:	4629      	mov	r1, r5
 8002a94:	689b      	ldr	r3, [r3, #8]
 8002a96:	4620      	mov	r0, r4
 8002a98:	4798      	blx	r3
}
 8002a9a:	2000      	movs	r0, #0
 8002a9c:	b003      	add	sp, #12
 8002a9e:	bd30      	pop	{r4, r5, pc}
  switch (req->wValue >> 8)
 8002aa0:	8849      	ldrh	r1, [r1, #2]
 8002aa2:	0a0b      	lsrs	r3, r1, #8
 8002aa4:	3b01      	subs	r3, #1
 8002aa6:	2b0e      	cmp	r3, #14
 8002aa8:	d87c      	bhi.n	8002ba4 <USBD_StdDevReq+0x150>
 8002aaa:	e8df f003 	tbb	[pc, r3]
 8002aae:	2824      	.short	0x2824
 8002ab0:	5c7b7b35 	.word	0x5c7b7b35
 8002ab4:	7b7b7b65 	.word	0x7b7b7b65
 8002ab8:	7b7b7b7b 	.word	0x7b7b7b7b
 8002abc:	08          	.byte	0x08
 8002abd:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 8002abe:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002ac2:	69db      	ldr	r3, [r3, #28]
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8002ac4:	7c20      	ldrb	r0, [r4, #16]
 8002ac6:	f10d 0106 	add.w	r1, sp, #6
 8002aca:	4798      	blx	r3
  if((len != 0U) && (req->wLength != 0U))
 8002acc:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8002ad0:	b152      	cbz	r2, 8002ae8 <USBD_StdDevReq+0x94>
 8002ad2:	88eb      	ldrh	r3, [r5, #6]
 8002ad4:	b143      	cbz	r3, 8002ae8 <USBD_StdDevReq+0x94>
    len = MIN(len, req->wLength);
 8002ad6:	429a      	cmp	r2, r3
 8002ad8:	bf28      	it	cs
 8002ada:	461a      	movcs	r2, r3
    USBD_CtlSendData (pdev, pbuf, len);
 8002adc:	4601      	mov	r1, r0
 8002ade:	4620      	mov	r0, r4
    len = MIN(len, req->wLength);
 8002ae0:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, pbuf, len);
 8002ae4:	f000 f9c8 	bl	8002e78 <USBD_CtlSendData>
  if(req->wLength == 0U)
 8002ae8:	88eb      	ldrh	r3, [r5, #6]
 8002aea:	2b00      	cmp	r3, #0
 8002aec:	d1d5      	bne.n	8002a9a <USBD_StdDevReq+0x46>
    USBD_CtlSendStatus(pdev);
 8002aee:	4620      	mov	r0, r4
 8002af0:	f000 f9ee 	bl	8002ed0 <USBD_CtlSendStatus>
 8002af4:	e7d1      	b.n	8002a9a <USBD_StdDevReq+0x46>
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8002af6:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002afa:	681b      	ldr	r3, [r3, #0]
 8002afc:	e7e2      	b.n	8002ac4 <USBD_StdDevReq+0x70>
    if(pdev->dev_speed == USBD_SPEED_HIGH )
 8002afe:	7c02      	ldrb	r2, [r0, #16]
 8002b00:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002b04:	b932      	cbnz	r2, 8002b14 <USBD_StdDevReq+0xc0>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8002b06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8002b08:	f10d 0006 	add.w	r0, sp, #6
 8002b0c:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8002b0e:	2302      	movs	r3, #2
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8002b10:	7043      	strb	r3, [r0, #1]
 8002b12:	e7db      	b.n	8002acc <USBD_StdDevReq+0x78>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8002b14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002b16:	e7f7      	b.n	8002b08 <USBD_StdDevReq+0xb4>
    switch ((uint8_t)(req->wValue))
 8002b18:	b2c9      	uxtb	r1, r1
 8002b1a:	2905      	cmp	r1, #5
 8002b1c:	d81c      	bhi.n	8002b58 <USBD_StdDevReq+0x104>
 8002b1e:	e8df f001 	tbb	[pc, r1]
 8002b22:	0703      	.short	0x0703
 8002b24:	17130f0b 	.word	0x17130f0b
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8002b28:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b2c:	685b      	ldr	r3, [r3, #4]
 8002b2e:	e7c9      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8002b30:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b34:	689b      	ldr	r3, [r3, #8]
 8002b36:	e7c5      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8002b38:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b3c:	68db      	ldr	r3, [r3, #12]
 8002b3e:	e7c1      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8002b40:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b44:	691b      	ldr	r3, [r3, #16]
 8002b46:	e7bd      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8002b48:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b4c:	695b      	ldr	r3, [r3, #20]
 8002b4e:	e7b9      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8002b50:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8002b54:	699b      	ldr	r3, [r3, #24]
 8002b56:	e7b5      	b.n	8002ac4 <USBD_StdDevReq+0x70>
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
 8002b58:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002b5c:	f10d 0206 	add.w	r2, sp, #6
 8002b60:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002b62:	4798      	blx	r3
 8002b64:	e7b2      	b.n	8002acc <USBD_StdDevReq+0x78>
    if(pdev->dev_speed == USBD_SPEED_HIGH)
 8002b66:	7c03      	ldrb	r3, [r0, #16]
 8002b68:	b9e3      	cbnz	r3, 8002ba4 <USBD_StdDevReq+0x150>
      pbuf = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8002b6a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002b6e:	f10d 0006 	add.w	r0, sp, #6
 8002b72:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002b74:	4798      	blx	r3
 8002b76:	e7a9      	b.n	8002acc <USBD_StdDevReq+0x78>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )
 8002b78:	7c03      	ldrb	r3, [r0, #16]
 8002b7a:	b99b      	cbnz	r3, 8002ba4 <USBD_StdDevReq+0x150>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8002b7c:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8002b80:	f10d 0006 	add.w	r0, sp, #6
 8002b84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002b86:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8002b88:	2307      	movs	r3, #7
 8002b8a:	e7c1      	b.n	8002b10 <USBD_StdDevReq+0xbc>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8002b8c:	888b      	ldrh	r3, [r1, #4]
 8002b8e:	b94b      	cbnz	r3, 8002ba4 <USBD_StdDevReq+0x150>
 8002b90:	88cb      	ldrh	r3, [r1, #6]
 8002b92:	b93b      	cbnz	r3, 8002ba4 <USBD_StdDevReq+0x150>
 8002b94:	884d      	ldrh	r5, [r1, #2]
 8002b96:	2d7f      	cmp	r5, #127	; 0x7f
 8002b98:	d804      	bhi.n	8002ba4 <USBD_StdDevReq+0x150>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8002b9a:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002b9e:	2b03      	cmp	r3, #3
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8002ba0:	b2e9      	uxtb	r1, r5
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8002ba2:	d103      	bne.n	8002bac <USBD_StdDevReq+0x158>
      USBD_CtlError(pdev, req);
 8002ba4:	4620      	mov	r0, r4
    USBD_CtlError(pdev, req);
 8002ba6:	f7ff ff4a 	bl	8002a3e <USBD_CtlError.constprop.1>
    break;
 8002baa:	e776      	b.n	8002a9a <USBD_StdDevReq+0x46>
      pdev->dev_address = dev_addr;
 8002bac:	f880 1276 	strb.w	r1, [r0, #630]	; 0x276
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8002bb0:	f000 fbc2 	bl	8003338 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8002bb4:	4620      	mov	r0, r4
 8002bb6:	f000 f98b 	bl	8002ed0 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8002bba:	b11d      	cbz	r5, 8002bc4 <USBD_StdDevReq+0x170>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8002bbc:	2302      	movs	r3, #2
        pdev->dev_state = USBD_STATE_DEFAULT;
 8002bbe:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 8002bc2:	e76a      	b.n	8002a9a <USBD_StdDevReq+0x46>
 8002bc4:	2301      	movs	r3, #1
 8002bc6:	e7fa      	b.n	8002bbe <USBD_StdDevReq+0x16a>
  cfgidx = (uint8_t)(req->wValue);
 8002bc8:	7889      	ldrb	r1, [r1, #2]
 8002bca:	4d36      	ldr	r5, [pc, #216]	; (8002ca4 <USBD_StdDevReq+0x250>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8002bcc:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 8002bce:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8002bd0:	d8e8      	bhi.n	8002ba4 <USBD_StdDevReq+0x150>
    switch (pdev->dev_state)
 8002bd2:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002bd6:	2b02      	cmp	r3, #2
 8002bd8:	d008      	beq.n	8002bec <USBD_StdDevReq+0x198>
 8002bda:	2b03      	cmp	r3, #3
 8002bdc:	d015      	beq.n	8002c0a <USBD_StdDevReq+0x1b6>
      USBD_CtlError(pdev, req);
 8002bde:	f7ff ff2e 	bl	8002a3e <USBD_CtlError.constprop.1>
      USBD_ClrClassConfig(pdev, cfgidx);
 8002be2:	7829      	ldrb	r1, [r5, #0]
 8002be4:	4620      	mov	r0, r4
 8002be6:	f7ff fe0c 	bl	8002802 <USBD_ClrClassConfig>
 8002bea:	e756      	b.n	8002a9a <USBD_StdDevReq+0x46>
      if (cfgidx)
 8002bec:	2900      	cmp	r1, #0
 8002bee:	f43f af7e 	beq.w	8002aee <USBD_StdDevReq+0x9a>
        pdev->dev_config = cfgidx;
 8002bf2:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8002bf4:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 8002bf6:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8002bf8:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8002bfc:	4620      	mov	r0, r4
 8002bfe:	f7ff fdf5 	bl	80027ec <USBD_SetClassConfig>
 8002c02:	2802      	cmp	r0, #2
 8002c04:	f47f af73 	bne.w	8002aee <USBD_StdDevReq+0x9a>
 8002c08:	e7cc      	b.n	8002ba4 <USBD_StdDevReq+0x150>
      if (cfgidx == 0U)
 8002c0a:	b931      	cbnz	r1, 8002c1a <USBD_StdDevReq+0x1c6>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8002c0c:	2302      	movs	r3, #2
 8002c0e:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        pdev->dev_config = cfgidx;
 8002c12:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev, cfgidx);
 8002c14:	f7ff fdf5 	bl	8002802 <USBD_ClrClassConfig>
 8002c18:	e769      	b.n	8002aee <USBD_StdDevReq+0x9a>
      else if (cfgidx != pdev->dev_config)
 8002c1a:	6841      	ldr	r1, [r0, #4]
 8002c1c:	2901      	cmp	r1, #1
 8002c1e:	f43f af66 	beq.w	8002aee <USBD_StdDevReq+0x9a>
        USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8002c22:	b2c9      	uxtb	r1, r1
 8002c24:	f7ff fded 	bl	8002802 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8002c28:	7829      	ldrb	r1, [r5, #0]
 8002c2a:	6061      	str	r1, [r4, #4]
 8002c2c:	e7e6      	b.n	8002bfc <USBD_StdDevReq+0x1a8>
  if (req->wLength != 1U)
 8002c2e:	88ca      	ldrh	r2, [r1, #6]
 8002c30:	2a01      	cmp	r2, #1
 8002c32:	d1b7      	bne.n	8002ba4 <USBD_StdDevReq+0x150>
    switch (pdev->dev_state)
 8002c34:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d0b3      	beq.n	8002ba4 <USBD_StdDevReq+0x150>
 8002c3c:	2b02      	cmp	r3, #2
 8002c3e:	d903      	bls.n	8002c48 <USBD_StdDevReq+0x1f4>
 8002c40:	2b03      	cmp	r3, #3
 8002c42:	d1af      	bne.n	8002ba4 <USBD_StdDevReq+0x150>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8002c44:	1d01      	adds	r1, r0, #4
 8002c46:	e003      	b.n	8002c50 <USBD_StdDevReq+0x1fc>
      pdev->dev_default_config = 0U;
 8002c48:	4601      	mov	r1, r0
 8002c4a:	2300      	movs	r3, #0
 8002c4c:	f841 3f08 	str.w	r3, [r1, #8]!
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8002c50:	4620      	mov	r0, r4
 8002c52:	f000 f911 	bl	8002e78 <USBD_CtlSendData>
 8002c56:	e720      	b.n	8002a9a <USBD_StdDevReq+0x46>
  switch (pdev->dev_state)
 8002c58:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002c5c:	3b01      	subs	r3, #1
 8002c5e:	2b02      	cmp	r3, #2
 8002c60:	d8a0      	bhi.n	8002ba4 <USBD_StdDevReq+0x150>
    if(req->wLength != 0x2U)
 8002c62:	88cb      	ldrh	r3, [r1, #6]
 8002c64:	2b02      	cmp	r3, #2
 8002c66:	d19d      	bne.n	8002ba4 <USBD_StdDevReq+0x150>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 8002c68:	2301      	movs	r3, #1
 8002c6a:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup)
 8002c6c:	f8d0 327c 	ldr.w	r3, [r0, #636]	; 0x27c
 8002c70:	b10b      	cbz	r3, 8002c76 <USBD_StdDevReq+0x222>
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 8002c72:	2303      	movs	r3, #3
 8002c74:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8002c76:	2202      	movs	r2, #2
 8002c78:	f104 010c 	add.w	r1, r4, #12
 8002c7c:	e7e8      	b.n	8002c50 <USBD_StdDevReq+0x1fc>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8002c7e:	884b      	ldrh	r3, [r1, #2]
 8002c80:	2b01      	cmp	r3, #1
 8002c82:	f47f af0a 	bne.w	8002a9a <USBD_StdDevReq+0x46>
    pdev->dev_remote_wakeup = 1U;
 8002c86:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
 8002c8a:	e730      	b.n	8002aee <USBD_StdDevReq+0x9a>
  switch (pdev->dev_state)
 8002c8c:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002c90:	3b01      	subs	r3, #1
 8002c92:	2b02      	cmp	r3, #2
 8002c94:	d886      	bhi.n	8002ba4 <USBD_StdDevReq+0x150>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8002c96:	884b      	ldrh	r3, [r1, #2]
 8002c98:	2b01      	cmp	r3, #1
 8002c9a:	f47f aefe 	bne.w	8002a9a <USBD_StdDevReq+0x46>
      pdev->dev_remote_wakeup = 0U;
 8002c9e:	2300      	movs	r3, #0
 8002ca0:	e7f1      	b.n	8002c86 <USBD_StdDevReq+0x232>
 8002ca2:	bf00      	nop
 8002ca4:	20000170 	.word	0x20000170

08002ca8 <USBD_StdItfReq>:
{
 8002ca8:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002caa:	780b      	ldrb	r3, [r1, #0]
 8002cac:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8002cb0:	2b20      	cmp	r3, #32
{
 8002cb2:	4604      	mov	r4, r0
 8002cb4:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002cb6:	d002      	beq.n	8002cbe <USBD_StdItfReq+0x16>
 8002cb8:	2b40      	cmp	r3, #64	; 0x40
 8002cba:	d000      	beq.n	8002cbe <USBD_StdItfReq+0x16>
 8002cbc:	b9b3      	cbnz	r3, 8002cec <USBD_StdItfReq+0x44>
    switch (pdev->dev_state)
 8002cbe:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 8002cc2:	3b01      	subs	r3, #1
 8002cc4:	2b02      	cmp	r3, #2
 8002cc6:	d810      	bhi.n	8002cea <USBD_StdItfReq+0x42>
      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8002cc8:	792b      	ldrb	r3, [r5, #4]
 8002cca:	2b01      	cmp	r3, #1
 8002ccc:	d80d      	bhi.n	8002cea <USBD_StdItfReq+0x42>
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup (pdev, req);
 8002cce:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8002cd2:	4629      	mov	r1, r5
 8002cd4:	689b      	ldr	r3, [r3, #8]
 8002cd6:	4620      	mov	r0, r4
 8002cd8:	4798      	blx	r3
        if ((req->wLength == 0U) && (ret == USBD_OK))
 8002cda:	88eb      	ldrh	r3, [r5, #6]
 8002cdc:	b91b      	cbnz	r3, 8002ce6 <USBD_StdItfReq+0x3e>
 8002cde:	b910      	cbnz	r0, 8002ce6 <USBD_StdItfReq+0x3e>
          USBD_CtlSendStatus(pdev);
 8002ce0:	4620      	mov	r0, r4
 8002ce2:	f000 f8f5 	bl	8002ed0 <USBD_CtlSendStatus>
}
 8002ce6:	2000      	movs	r0, #0
 8002ce8:	bd38      	pop	{r3, r4, r5, pc}
      USBD_CtlError(pdev, req);
 8002cea:	4620      	mov	r0, r4
    USBD_CtlError(pdev, req);
 8002cec:	f7ff fea7 	bl	8002a3e <USBD_CtlError.constprop.1>
    break;
 8002cf0:	e7f9      	b.n	8002ce6 <USBD_StdItfReq+0x3e>

08002cf2 <USBD_StdEPReq>:
{
 8002cf2:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002cf4:	780a      	ldrb	r2, [r1, #0]
 8002cf6:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8002cfa:	2a20      	cmp	r2, #32
{
 8002cfc:	4604      	mov	r4, r0
 8002cfe:	460b      	mov	r3, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002d00:	d013      	beq.n	8002d2a <USBD_StdEPReq+0x38>
 8002d02:	2a40      	cmp	r2, #64	; 0x40
 8002d04:	d011      	beq.n	8002d2a <USBD_StdEPReq+0x38>
 8002d06:	b96a      	cbnz	r2, 8002d24 <USBD_StdEPReq+0x32>
    switch (req->bRequest)
 8002d08:	785d      	ldrb	r5, [r3, #1]
  ep_addr  = LOBYTE(req->wIndex);
 8002d0a:	888a      	ldrh	r2, [r1, #4]
    switch (req->bRequest)
 8002d0c:	2d01      	cmp	r5, #1
  ep_addr  = LOBYTE(req->wIndex);
 8002d0e:	b2d1      	uxtb	r1, r2
    switch (req->bRequest)
 8002d10:	d01f      	beq.n	8002d52 <USBD_StdEPReq+0x60>
 8002d12:	d335      	bcc.n	8002d80 <USBD_StdEPReq+0x8e>
 8002d14:	2d03      	cmp	r5, #3
 8002d16:	d105      	bne.n	8002d24 <USBD_StdEPReq+0x32>
      switch (pdev->dev_state)
 8002d18:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8002d1c:	2a02      	cmp	r2, #2
 8002d1e:	d026      	beq.n	8002d6e <USBD_StdEPReq+0x7c>
 8002d20:	2a03      	cmp	r2, #3
 8002d22:	d00a      	beq.n	8002d3a <USBD_StdEPReq+0x48>
    USBD_CtlError(pdev, req);
 8002d24:	f7ff fe8b 	bl	8002a3e <USBD_CtlError.constprop.1>
    break;
 8002d28:	e005      	b.n	8002d36 <USBD_StdEPReq+0x44>
    pdev->pClass->Setup (pdev, req);
 8002d2a:	f8d4 228c 	ldr.w	r2, [r4, #652]	; 0x28c
 8002d2e:	4619      	mov	r1, r3
 8002d30:	6892      	ldr	r2, [r2, #8]
 8002d32:	4620      	mov	r0, r4
 8002d34:	4790      	blx	r2
}
 8002d36:	2000      	movs	r0, #0
 8002d38:	bd38      	pop	{r3, r4, r5, pc}
        if (req->wValue == USB_FEATURE_EP_HALT)
 8002d3a:	885a      	ldrh	r2, [r3, #2]
 8002d3c:	b92a      	cbnz	r2, 8002d4a <USBD_StdEPReq+0x58>
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8002d3e:	064a      	lsls	r2, r1, #25
 8002d40:	d003      	beq.n	8002d4a <USBD_StdEPReq+0x58>
 8002d42:	88db      	ldrh	r3, [r3, #6]
 8002d44:	b90b      	cbnz	r3, 8002d4a <USBD_StdEPReq+0x58>
            USBD_LL_StallEP(pdev, ep_addr);
 8002d46:	f000 fac7 	bl	80032d8 <USBD_LL_StallEP>
        USBD_CtlSendStatus(pdev);
 8002d4a:	4620      	mov	r0, r4
 8002d4c:	f000 f8c0 	bl	8002ed0 <USBD_CtlSendStatus>
        break;
 8002d50:	e7f1      	b.n	8002d36 <USBD_StdEPReq+0x44>
      switch (pdev->dev_state)
 8002d52:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8002d56:	2a02      	cmp	r2, #2
 8002d58:	d009      	beq.n	8002d6e <USBD_StdEPReq+0x7c>
 8002d5a:	2a03      	cmp	r2, #3
 8002d5c:	d1e2      	bne.n	8002d24 <USBD_StdEPReq+0x32>
        if (req->wValue == USB_FEATURE_EP_HALT)
 8002d5e:	885b      	ldrh	r3, [r3, #2]
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d1e8      	bne.n	8002d36 <USBD_StdEPReq+0x44>
          if ((ep_addr & 0x7FU) != 0x00U)
 8002d64:	064d      	lsls	r5, r1, #25
 8002d66:	d0f0      	beq.n	8002d4a <USBD_StdEPReq+0x58>
            USBD_LL_ClearStallEP(pdev, ep_addr);
 8002d68:	f000 fac4 	bl	80032f4 <USBD_LL_ClearStallEP>
 8002d6c:	e7ed      	b.n	8002d4a <USBD_StdEPReq+0x58>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8002d6e:	064b      	lsls	r3, r1, #25
 8002d70:	d017      	beq.n	8002da2 <USBD_StdEPReq+0xb0>
          USBD_LL_StallEP(pdev, ep_addr);
 8002d72:	f000 fab1 	bl	80032d8 <USBD_LL_StallEP>
          USBD_LL_StallEP(pdev, 0x80U);
 8002d76:	2180      	movs	r1, #128	; 0x80
 8002d78:	4620      	mov	r0, r4
 8002d7a:	f000 faad 	bl	80032d8 <USBD_LL_StallEP>
 8002d7e:	e7da      	b.n	8002d36 <USBD_StdEPReq+0x44>
      switch (pdev->dev_state)
 8002d80:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8002d84:	2b02      	cmp	r3, #2
 8002d86:	d00e      	beq.n	8002da6 <USBD_StdEPReq+0xb4>
 8002d88:	2b03      	cmp	r3, #3
 8002d8a:	d1cb      	bne.n	8002d24 <USBD_StdEPReq+0x32>
        if((ep_addr & 0x80U) == 0x80U)
 8002d8c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8002d90:	f04f 0314 	mov.w	r3, #20
 8002d94:	f001 020f 	and.w	r2, r1, #15
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8002d98:	fb03 0202 	mla	r2, r3, r2, r0
        if((ep_addr & 0x80U) == 0x80U)
 8002d9c:	d012      	beq.n	8002dc4 <USBD_StdEPReq+0xd2>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8002d9e:	6992      	ldr	r2, [r2, #24]
 8002da0:	b9da      	cbnz	r2, 8002dda <USBD_StdEPReq+0xe8>
          USBD_CtlError(pdev, req);
 8002da2:	4620      	mov	r0, r4
 8002da4:	e7be      	b.n	8002d24 <USBD_StdEPReq+0x32>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8002da6:	0649      	lsls	r1, r1, #25
 8002da8:	d1fb      	bne.n	8002da2 <USBD_StdEPReq+0xb0>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8002daa:	0613      	lsls	r3, r2, #24
 8002dac:	bf4c      	ite	mi
 8002dae:	f100 0114 	addmi.w	r1, r0, #20
 8002db2:	f500 71a0 	addpl.w	r1, r0, #320	; 0x140
          pep->status = 0x0000U;
 8002db6:	2300      	movs	r3, #0
 8002db8:	600b      	str	r3, [r1, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8002dba:	2202      	movs	r2, #2
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8002dbc:	4620      	mov	r0, r4
 8002dbe:	f000 f85b 	bl	8002e78 <USBD_CtlSendData>
          break;
 8002dc2:	e7b8      	b.n	8002d36 <USBD_StdEPReq+0x44>
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8002dc4:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
 8002dc8:	2a00      	cmp	r2, #0
 8002dca:	d0ea      	beq.n	8002da2 <USBD_StdEPReq+0xb0>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8002dcc:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8002dd0:	fb03 0505 	mla	r5, r3, r5, r0
 8002dd4:	f505 75a0 	add.w	r5, r5, #320	; 0x140
 8002dd8:	e004      	b.n	8002de4 <USBD_StdEPReq+0xf2>
 8002dda:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8002dde:	fb05 3503 	mla	r5, r5, r3, r3
 8002de2:	4405      	add	r5, r0
          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8002de4:	f011 037f 	ands.w	r3, r1, #127	; 0x7f
 8002de8:	d103      	bne.n	8002df2 <USBD_StdEPReq+0x100>
            pep->status = 0x0001U;
 8002dea:	602b      	str	r3, [r5, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8002dec:	2202      	movs	r2, #2
 8002dee:	4629      	mov	r1, r5
 8002df0:	e7e4      	b.n	8002dbc <USBD_StdEPReq+0xca>
          else if(USBD_LL_IsStallEP(pdev, ep_addr))
 8002df2:	4620      	mov	r0, r4
 8002df4:	f000 fa8c 	bl	8003310 <USBD_LL_IsStallEP>
 8002df8:	b108      	cbz	r0, 8002dfe <USBD_StdEPReq+0x10c>
            pep->status = 0x0001U;
 8002dfa:	2301      	movs	r3, #1
 8002dfc:	e7f5      	b.n	8002dea <USBD_StdEPReq+0xf8>
            pep->status = 0x0000U;
 8002dfe:	6028      	str	r0, [r5, #0]
 8002e00:	e7f4      	b.n	8002dec <USBD_StdEPReq+0xfa>

08002e02 <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 8002e02:	780b      	ldrb	r3, [r1, #0]
 8002e04:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8002e06:	784b      	ldrb	r3, [r1, #1]
 8002e08:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8002e0a:	78ca      	ldrb	r2, [r1, #3]
 8002e0c:	788b      	ldrb	r3, [r1, #2]
 8002e0e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e12:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8002e14:	794a      	ldrb	r2, [r1, #5]
 8002e16:	790b      	ldrb	r3, [r1, #4]
 8002e18:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e1c:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8002e1e:	79ca      	ldrb	r2, [r1, #7]
 8002e20:	798b      	ldrb	r3, [r1, #6]
 8002e22:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e26:	80c3      	strh	r3, [r0, #6]
 8002e28:	4770      	bx	lr

08002e2a <USBD_CtlError>:
{
 8002e2a:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80U);
 8002e2c:	2180      	movs	r1, #128	; 0x80
{
 8002e2e:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80U);
 8002e30:	f000 fa52 	bl	80032d8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8002e34:	4620      	mov	r0, r4
 8002e36:	2100      	movs	r1, #0
}
 8002e38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0U);
 8002e3c:	f000 ba4c 	b.w	80032d8 <USBD_LL_StallEP>

08002e40 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8002e40:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0U;

  if (desc != NULL)
 8002e42:	b188      	cbz	r0, 8002e68 <USBD_GetString+0x28>
 8002e44:	4605      	mov	r5, r0
 8002e46:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0U;

    while (*buf != '\0')
 8002e48:	f815 4b01 	ldrb.w	r4, [r5], #1
 8002e4c:	b2db      	uxtb	r3, r3
 8002e4e:	2c00      	cmp	r4, #0
 8002e50:	d1f9      	bne.n	8002e46 <USBD_GetString+0x6>
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 8002e52:	3301      	adds	r3, #1
 8002e54:	005b      	lsls	r3, r3, #1
 8002e56:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 8002e58:	700b      	strb	r3, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8002e5a:	2303      	movs	r3, #3
 8002e5c:	704b      	strb	r3, [r1, #1]
 8002e5e:	3801      	subs	r0, #1
 8002e60:	2302      	movs	r3, #2
    while (*desc != '\0')
 8002e62:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8002e66:	b905      	cbnz	r5, 8002e6a <USBD_GetString+0x2a>
 8002e68:	bd30      	pop	{r4, r5, pc}
      unicode[idx++] = *desc++;
 8002e6a:	1c5a      	adds	r2, r3, #1
 8002e6c:	b2d2      	uxtb	r2, r2
 8002e6e:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0U;
 8002e70:	3302      	adds	r3, #2
 8002e72:	b2db      	uxtb	r3, r3
 8002e74:	548c      	strb	r4, [r1, r2]
 8002e76:	e7f4      	b.n	8002e62 <USBD_GetString+0x22>

08002e78 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                     uint16_t len)
{
 8002e78:	b510      	push	{r4, lr}
 8002e7a:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8002e7c:	2202      	movs	r2, #2
 8002e7e:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  pdev->ep_in[0].total_length = len;
 8002e82:	61c3      	str	r3, [r0, #28]
  pdev->ep_in[0].rem_length   = len;

 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8002e84:	460a      	mov	r2, r1
  pdev->ep_in[0].rem_length   = len;
 8002e86:	6203      	str	r3, [r0, #32]
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8002e88:	2100      	movs	r1, #0
 8002e8a:	f000 fa63 	bl	8003354 <USBD_LL_Transmit>

  return USBD_OK;
}
 8002e8e:	2000      	movs	r0, #0
 8002e90:	bd10      	pop	{r4, pc}

08002e92 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData (USBD_HandleTypeDef *pdev,
                                             uint8_t *pbuf, uint16_t len)
{
 8002e92:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8002e94:	4613      	mov	r3, r2
 8002e96:	460a      	mov	r2, r1
 8002e98:	2100      	movs	r1, #0
 8002e9a:	f000 fa5b 	bl	8003354 <USBD_LL_Transmit>

  return USBD_OK;
}
 8002e9e:	2000      	movs	r0, #0
 8002ea0:	bd08      	pop	{r3, pc}

08002ea2 <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                      uint16_t len)
{
 8002ea2:	b510      	push	{r4, lr}
 8002ea4:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8002ea6:	2203      	movs	r2, #3
 8002ea8:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  pdev->ep_out[0].total_length = len;
 8002eac:	f8c0 3148 	str.w	r3, [r0, #328]	; 0x148
  pdev->ep_out[0].rem_length   = len;

  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8002eb0:	460a      	mov	r2, r1
  pdev->ep_out[0].rem_length   = len;
 8002eb2:	f8c0 314c 	str.w	r3, [r0, #332]	; 0x14c
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8002eb6:	2100      	movs	r1, #0
 8002eb8:	f000 fa5a 	bl	8003370 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8002ebc:	2000      	movs	r0, #0
 8002ebe:	bd10      	pop	{r4, pc}

08002ec0 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                       uint16_t len)
{
 8002ec0:	b508      	push	{r3, lr}
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8002ec2:	4613      	mov	r3, r2
 8002ec4:	460a      	mov	r2, r1
 8002ec6:	2100      	movs	r1, #0
 8002ec8:	f000 fa52 	bl	8003370 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8002ecc:	2000      	movs	r0, #0
 8002ece:	bd08      	pop	{r3, pc}

08002ed0 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus (USBD_HandleTypeDef *pdev)
{
 8002ed0:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8002ed2:	2304      	movs	r3, #4
 8002ed4:	f8c0 326c 	str.w	r3, [r0, #620]	; 0x26c

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8002ed8:	2300      	movs	r3, #0
 8002eda:	461a      	mov	r2, r3
 8002edc:	4619      	mov	r1, r3
 8002ede:	f000 fa39 	bl	8003354 <USBD_LL_Transmit>

  return USBD_OK;
}
 8002ee2:	2000      	movs	r0, #0
 8002ee4:	bd08      	pop	{r3, pc}

08002ee6 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus (USBD_HandleTypeDef *pdev)
{
 8002ee6:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8002ee8:	2305      	movs	r3, #5
 8002eea:	f8c0 326c 	str.w	r3, [r0, #620]	; 0x26c

 /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8002eee:	2300      	movs	r3, #0
 8002ef0:	461a      	mov	r2, r3
 8002ef2:	4619      	mov	r1, r3
 8002ef4:	f000 fa3c 	bl	8003370 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8002ef8:	2000      	movs	r0, #0
 8002efa:	bd08      	pop	{r3, pc}

08002efc <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8002efc:	b570      	push	{r4, r5, r6, lr}
 8002efe:	b0be      	sub	sp, #248	; 0xf8
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8002f00:	2244      	movs	r2, #68	; 0x44
 8002f02:	2100      	movs	r1, #0
 8002f04:	a806      	add	r0, sp, #24
 8002f06:	f000 fb3b 	bl	8003580 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002f0a:	2214      	movs	r2, #20
 8002f0c:	2100      	movs	r1, #0
 8002f0e:	a801      	add	r0, sp, #4
 8002f10:	f000 fb36 	bl	8003580 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8002f14:	229c      	movs	r2, #156	; 0x9c
 8002f16:	2100      	movs	r1, #0
 8002f18:	a817      	add	r0, sp, #92	; 0x5c
 8002f1a:	f000 fb31 	bl	8003580 <memset>

  /** Configure the main internal regulator output voltage 
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8002f1e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8002f22:	f7fd ffb3 	bl	8000e8c <HAL_PWREx_ControlVoltageScaling>
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8002f26:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002f2a:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002f2c:	2503      	movs	r5, #3
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8002f2e:	2601      	movs	r6, #1
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8002f30:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 8;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002f32:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLN = 8;
 8002f34:	2308      	movs	r3, #8
 8002f36:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8002f38:	9606      	str	r6, [sp, #24]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002f3a:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002f3c:	9511      	str	r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 2;
 8002f3e:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8002f40:	9414      	str	r4, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8002f42:	9415      	str	r4, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8002f44:	9416      	str	r4, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002f46:	f7fe f88f 	bl	8001068 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002f4a:	230f      	movs	r3, #15
 8002f4c:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8002f4e:	4631      	mov	r1, r6
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002f50:	2300      	movs	r3, #0
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8002f52:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002f54:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8002f56:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8002f58:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002f5a:	9502      	str	r5, [sp, #8]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8002f5c:	f7fe fad6 	bl	800150c <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8002f60:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002f64:	9317      	str	r3, [sp, #92]	; 0x5c
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 8002f66:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8002f6a:	9334      	str	r3, [sp, #208]	; 0xd0
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 2;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
 8002f6c:	230c      	movs	r3, #12
 8002f6e:	931a      	str	r3, [sp, #104]	; 0x68
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002f70:	a817      	add	r0, sp, #92	; 0x5c
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8002f72:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
 8002f76:	9518      	str	r5, [sp, #96]	; 0x60
  PeriphClkInit.PLLSAI1.PLLSAI1M = 2;
 8002f78:	9419      	str	r4, [sp, #100]	; 0x64
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV2;
 8002f7a:	941b      	str	r4, [sp, #108]	; 0x6c
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8002f7c:	941c      	str	r4, [sp, #112]	; 0x70
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8002f7e:	941d      	str	r4, [sp, #116]	; 0x74
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8002f80:	931e      	str	r3, [sp, #120]	; 0x78
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002f82:	f7fe fcd3 	bl	800192c <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
}
 8002f86:	b03e      	add	sp, #248	; 0xf8
 8002f88:	bd70      	pop	{r4, r5, r6, pc}
	...

08002f8c <main>:
{
 8002f8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_Init();
 8002f8e:	f7fd f94d 	bl	800022c <HAL_Init>
  SystemClock_Config();
 8002f92:	f7ff ffb3 	bl	8002efc <SystemClock_Config>
  */
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8002f96:	4b13      	ldr	r3, [pc, #76]	; (8002fe4 <main+0x58>)
 8002f98:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002f9a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002f9e:	64da      	str	r2, [r3, #76]	; 0x4c
 8002fa0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002fa2:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8002fa6:	9201      	str	r2, [sp, #4]
 8002fa8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8002faa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002fac:	f042 0201 	orr.w	r2, r2, #1
 8002fb0:	64da      	str	r2, [r3, #76]	; 0x4c
 8002fb2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002fb4:	f002 0201 	and.w	r2, r2, #1
 8002fb8:	9202      	str	r2, [sp, #8]
 8002fba:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8002fbc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002fbe:	f042 0202 	orr.w	r2, r2, #2
 8002fc2:	64da      	str	r2, [r3, #76]	; 0x4c
 8002fc4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002fc6:	f003 0302 	and.w	r3, r3, #2
 8002fca:	9303      	str	r3, [sp, #12]
 8002fcc:	9b03      	ldr	r3, [sp, #12]
  MX_USB_DEVICE_Init();
 8002fce:	f000 f85d 	bl	800308c <MX_USB_DEVICE_Init>
  usbStatus = hUsbDeviceFS.dev_state;
 8002fd2:	4b05      	ldr	r3, [pc, #20]	; (8002fe8 <main+0x5c>)
 8002fd4:	f893 2274 	ldrb.w	r2, [r3, #628]	; 0x274
 8002fd8:	4b04      	ldr	r3, [pc, #16]	; (8002fec <main+0x60>)
 8002fda:	701a      	strb	r2, [r3, #0]
	  HAL_Delay(1);
 8002fdc:	2001      	movs	r0, #1
 8002fde:	f7fd f943 	bl	8000268 <HAL_Delay>
 8002fe2:	e7fb      	b.n	8002fdc <main+0x50>
 8002fe4:	40021000 	.word	0x40021000
 8002fe8:	200001a8 	.word	0x200001a8
 8002fec:	2000017d 	.word	0x2000017d

08002ff0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8002ff0:	4770      	bx	lr
	...

08002ff4 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002ff4:	4b0a      	ldr	r3, [pc, #40]	; (8003020 <HAL_MspInit+0x2c>)
 8002ff6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8002ff8:	f042 0201 	orr.w	r2, r2, #1
 8002ffc:	661a      	str	r2, [r3, #96]	; 0x60
 8002ffe:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 8003000:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003002:	f002 0201 	and.w	r2, r2, #1
 8003006:	9200      	str	r2, [sp, #0]
 8003008:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800300a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800300c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003010:	659a      	str	r2, [r3, #88]	; 0x58
 8003012:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003014:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003018:	9301      	str	r3, [sp, #4]
 800301a:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800301c:	b002      	add	sp, #8
 800301e:	4770      	bx	lr
 8003020:	40021000 	.word	0x40021000

08003024 <NMI_Handler>:
 8003024:	4770      	bx	lr

08003026 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8003026:	e7fe      	b.n	8003026 <HardFault_Handler>

08003028 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8003028:	e7fe      	b.n	8003028 <MemManage_Handler>

0800302a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800302a:	e7fe      	b.n	800302a <BusFault_Handler>

0800302c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800302c:	e7fe      	b.n	800302c <UsageFault_Handler>

0800302e <SVC_Handler>:
 800302e:	4770      	bx	lr

08003030 <DebugMon_Handler>:
 8003030:	4770      	bx	lr

08003032 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8003032:	4770      	bx	lr

08003034 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8003034:	f7fd b90a 	b.w	800024c <HAL_IncTick>

08003038 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8003038:	4801      	ldr	r0, [pc, #4]	; (8003040 <OTG_FS_IRQHandler+0x8>)
 800303a:	f7fd baf5 	b.w	8000628 <HAL_PCD_IRQHandler>
 800303e:	bf00      	nop
 8003040:	20000444 	.word	0x20000444

08003044 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003044:	490f      	ldr	r1, [pc, #60]	; (8003084 <SystemInit+0x40>)
 8003046:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800304a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800304e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8003052:	4b0d      	ldr	r3, [pc, #52]	; (8003088 <SystemInit+0x44>)
 8003054:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8003056:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 8003058:	f042 0201 	orr.w	r2, r2, #1
 800305c:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 800305e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8003060:	681a      	ldr	r2, [r3, #0]
 8003062:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8003066:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 800306a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 800306c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003070:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8003072:	681a      	ldr	r2, [r3, #0]
 8003074:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003078:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 800307a:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800307c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003080:	608b      	str	r3, [r1, #8]
 8003082:	4770      	bx	lr
 8003084:	e000ed00 	.word	0xe000ed00
 8003088:	40021000 	.word	0x40021000

0800308c <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 800308c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 800308e:	2200      	movs	r2, #0
 8003090:	490a      	ldr	r1, [pc, #40]	; (80030bc <MX_USB_DEVICE_Init+0x30>)
 8003092:	480b      	ldr	r0, [pc, #44]	; (80030c0 <MX_USB_DEVICE_Init+0x34>)
 8003094:	f7ff fb89 	bl	80027aa <USBD_Init>
  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CUSTOM_HID);
 8003098:	490a      	ldr	r1, [pc, #40]	; (80030c4 <MX_USB_DEVICE_Init+0x38>)
 800309a:	4809      	ldr	r0, [pc, #36]	; (80030c0 <MX_USB_DEVICE_Init+0x34>)
 800309c:	f7ff fb9a 	bl	80027d4 <USBD_RegisterClass>
  USBD_CUSTOM_HID_RegisterInterface(&hUsbDeviceFS, &USBD_CustomHID_fops_FS);
 80030a0:	4909      	ldr	r1, [pc, #36]	; (80030c8 <MX_USB_DEVICE_Init+0x3c>)
 80030a2:	4807      	ldr	r0, [pc, #28]	; (80030c0 <MX_USB_DEVICE_Init+0x34>)
 80030a4:	f7ff fb7a 	bl	800279c <USBD_CUSTOM_HID_RegisterInterface>
  /* Verify if the Battery Charging Detection mode (BCD) is used : */
  /* If yes, the USB device is started in the HAL_PCDEx_BCD_Callback */
  /* upon reception of PCD_BCD_DISCOVERY_COMPLETED message. */
  /* If no, the USB device is started now. */
  if (USBD_LL_BatteryCharging(&hUsbDeviceFS) != USBD_OK) {
 80030a8:	4805      	ldr	r0, [pc, #20]	; (80030c0 <MX_USB_DEVICE_Init+0x34>)
 80030aa:	f000 f9a6 	bl	80033fa <USBD_LL_BatteryCharging>
 80030ae:	b120      	cbz	r0, 80030ba <MX_USB_DEVICE_Init+0x2e>
  USBD_Start(&hUsbDeviceFS);
 80030b0:	4803      	ldr	r0, [pc, #12]	; (80030c0 <MX_USB_DEVICE_Init+0x34>)
  }
  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 80030b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  USBD_Start(&hUsbDeviceFS);
 80030b6:	f7ff bb94 	b.w	80027e2 <USBD_Start>
 80030ba:	bd08      	pop	{r3, pc}
 80030bc:	20000110 	.word	0x20000110
 80030c0:	200001a8 	.word	0x200001a8
 80030c4:	20000000 	.word	0x20000000
 80030c8:	20000100 	.word	0x20000100

080030cc <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80030cc:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80030ce:	6803      	ldr	r3, [r0, #0]
 80030d0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
{
 80030d4:	b088      	sub	sp, #32
  if(pcdHandle->Instance==USB_OTG_FS)
 80030d6:	d133      	bne.n	8003140 <HAL_PCD_MspInit+0x74>
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80030d8:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80030dc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80030de:	2302      	movs	r3, #2
 80030e0:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80030e2:	2300      	movs	r3, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80030e4:	4c19      	ldr	r4, [pc, #100]	; (800314c <HAL_PCD_MspInit+0x80>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80030e6:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80030e8:	2303      	movs	r3, #3
 80030ea:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030ec:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80030ee:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030f0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80030f4:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030f6:	f7fd f92d 	bl	8000354 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80030fa:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80030fc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003100:	64e3      	str	r3, [r4, #76]	; 0x4c
 8003102:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003104:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003108:	9301      	str	r3, [sp, #4]
 800310a:	9b01      	ldr	r3, [sp, #4]

    /* Enable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800310c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800310e:	00db      	lsls	r3, r3, #3
 8003110:	d418      	bmi.n	8003144 <HAL_PCD_MspInit+0x78>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003112:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003114:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003118:	65a3      	str	r3, [r4, #88]	; 0x58
 800311a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800311c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003120:	9302      	str	r3, [sp, #8]
 8003122:	9b02      	ldr	r3, [sp, #8]
      HAL_PWREx_EnableVddUSB();
 8003124:	f7fd ff0c 	bl	8000f40 <HAL_PWREx_EnableVddUSB>
      __HAL_RCC_PWR_CLK_DISABLE();
 8003128:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800312a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800312e:	65a3      	str	r3, [r4, #88]	; 0x58
    {
      HAL_PWREx_EnableVddUSB();
    }

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8003130:	2200      	movs	r2, #0
 8003132:	2043      	movs	r0, #67	; 0x43
 8003134:	4611      	mov	r1, r2
 8003136:	f7fd f8b7 	bl	80002a8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800313a:	2043      	movs	r0, #67	; 0x43
 800313c:	f7fd f8e8 	bl	8000310 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8003140:	b008      	add	sp, #32
 8003142:	bd10      	pop	{r4, pc}
      HAL_PWREx_EnableVddUSB();
 8003144:	f7fd fefc 	bl	8000f40 <HAL_PWREx_EnableVddUSB>
 8003148:	e7f2      	b.n	8003130 <HAL_PCD_MspInit+0x64>
 800314a:	bf00      	nop
 800314c:	40021000 	.word	0x40021000

08003150 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8003150:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 8003154:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003158:	f7ff bb5a 	b.w	8002810 <USBD_LL_SetupStage>

0800315c <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800315c:	231c      	movs	r3, #28
 800315e:	fb03 0301 	mla	r3, r3, r1, r0
 8003162:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003166:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 800316a:	f7ff bb7e 	b.w	800286a <USBD_LL_DataOutStage>

0800316e <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 800316e:	231c      	movs	r3, #28
 8003170:	fb03 0301 	mla	r3, r3, r1, r0
 8003174:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003178:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800317a:	f7ff bbae 	b.w	80028da <USBD_LL_DataInStage>

0800317e <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 800317e:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003182:	f7ff bc3f 	b.w	8002a04 <USBD_LL_SOF>

08003186 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8003186:	b510      	push	{r4, lr}
 8003188:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 800318a:	2101      	movs	r1, #1
 800318c:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003190:	f7ff fc26 	bl	80029e0 <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8003194:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
}
 8003198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 800319c:	f7ff bbf9 	b.w	8002992 <USBD_LL_Reset>

080031a0 <HAL_PCD_SuspendCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80031a0:	6802      	ldr	r2, [r0, #0]
 80031a2:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
{
 80031a6:	b510      	push	{r4, lr}
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80031a8:	f043 0301 	orr.w	r3, r3, #1
{
 80031ac:	4604      	mov	r4, r0
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80031ae:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 80031b2:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 80031b6:	f7ff fc16 	bl	80029e6 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 80031ba:	6a23      	ldr	r3, [r4, #32]
 80031bc:	b123      	cbz	r3, 80031c8 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80031be:	4a03      	ldr	r2, [pc, #12]	; (80031cc <HAL_PCD_SuspendCallback+0x2c>)
 80031c0:	6913      	ldr	r3, [r2, #16]
 80031c2:	f043 0306 	orr.w	r3, r3, #6
 80031c6:	6113      	str	r3, [r2, #16]
 80031c8:	bd10      	pop	{r4, pc}
 80031ca:	bf00      	nop
 80031cc:	e000ed00 	.word	0xe000ed00

080031d0 <HAL_PCD_ResumeCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 80031d0:	6802      	ldr	r2, [r0, #0]
 80031d2:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80031d6:	f023 0301 	bic.w	r3, r3, #1
{
 80031da:	b510      	push	{r4, lr}
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 80031dc:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00

  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
 80031e0:	6a03      	ldr	r3, [r0, #32]
{
 80031e2:	4604      	mov	r4, r0
  if (hpcd->Init.low_power_enable)
 80031e4:	b133      	cbz	r3, 80031f4 <HAL_PCD_ResumeCallback+0x24>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80031e6:	4a06      	ldr	r2, [pc, #24]	; (8003200 <HAL_PCD_ResumeCallback+0x30>)
 80031e8:	6913      	ldr	r3, [r2, #16]
 80031ea:	f023 0306 	bic.w	r3, r3, #6
 80031ee:	6113      	str	r3, [r2, #16]
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
  SystemClock_Config();
 80031f0:	f7ff fe84 	bl	8002efc <SystemClock_Config>
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 80031f4:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
}
 80031f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 80031fc:	f7ff bbfc 	b.w	80029f8 <USBD_LL_Resume>
 8003200:	e000ed00 	.word	0xe000ed00

08003204 <HAL_PCD_ISOOUTIncompleteCallback>:
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8003204:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003208:	f7ff bc0a 	b.w	8002a20 <USBD_LL_IsoOUTIncomplete>

0800320c <HAL_PCD_ISOINIncompleteCallback>:
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 800320c:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003210:	f7ff bc04 	b.w	8002a1c <USBD_LL_IsoINIncomplete>

08003214 <HAL_PCD_ConnectCallback>:
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8003214:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003218:	f7ff bc04 	b.w	8002a24 <USBD_LL_DevConnected>

0800321c <HAL_PCD_DisconnectCallback>:
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 800321c:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003220:	f7ff bc02 	b.w	8002a28 <USBD_LL_DevDisconnected>

08003224 <USBD_LL_Init>:
{
 8003224:	b508      	push	{r3, lr}
  if (pdev->id == DEVICE_FS) {
 8003226:	7802      	ldrb	r2, [r0, #0]
 8003228:	bb32      	cbnz	r2, 8003278 <USBD_LL_Init+0x54>
  hpcd_USB_OTG_FS.pData = pdev;
 800322a:	4b14      	ldr	r3, [pc, #80]	; (800327c <USBD_LL_Init+0x58>)
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 800322c:	2106      	movs	r1, #6
  hpcd_USB_OTG_FS.pData = pdev;
 800322e:	f8c3 0404 	str.w	r0, [r3, #1028]	; 0x404
  pdev->pData = &hpcd_USB_OTG_FS;
 8003232:	f8c0 3298 	str.w	r3, [r0, #664]	; 0x298
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8003236:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 800323a:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800323e:	2102      	movs	r1, #2
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8003240:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003242:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8003244:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8003246:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8003248:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 800324a:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
 800324c:	629a      	str	r2, [r3, #40]	; 0x28
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 800324e:	631a      	str	r2, [r3, #48]	; 0x30
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 8003250:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8003252:	f7fd f957 	bl	8000504 <HAL_PCD_Init>
 8003256:	b108      	cbz	r0, 800325c <USBD_LL_Init+0x38>
    Error_Handler();
 8003258:	f7ff feca 	bl	8002ff0 <Error_Handler>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 800325c:	2180      	movs	r1, #128	; 0x80
 800325e:	4807      	ldr	r0, [pc, #28]	; (800327c <USBD_LL_Init+0x58>)
 8003260:	f7fd fde0 	bl	8000e24 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8003264:	2240      	movs	r2, #64	; 0x40
 8003266:	2100      	movs	r1, #0
 8003268:	4804      	ldr	r0, [pc, #16]	; (800327c <USBD_LL_Init+0x58>)
 800326a:	f7fd fdba 	bl	8000de2 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 800326e:	2280      	movs	r2, #128	; 0x80
 8003270:	2101      	movs	r1, #1
 8003272:	4802      	ldr	r0, [pc, #8]	; (800327c <USBD_LL_Init+0x58>)
 8003274:	f7fd fdb5 	bl	8000de2 <HAL_PCDEx_SetTxFiFo>
}
 8003278:	2000      	movs	r0, #0
 800327a:	bd08      	pop	{r3, pc}
 800327c:	20000444 	.word	0x20000444

08003280 <USBD_LL_Start>:
{
 8003280:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 8003282:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8003286:	f7fd f9ba 	bl	80005fe <HAL_PCD_Start>
 800328a:	2803      	cmp	r0, #3
 800328c:	bf9a      	itte	ls
 800328e:	4b02      	ldrls	r3, [pc, #8]	; (8003298 <USBD_LL_Start+0x18>)
 8003290:	5c18      	ldrbls	r0, [r3, r0]
 8003292:	2002      	movhi	r0, #2
}
 8003294:	bd08      	pop	{r3, pc}
 8003296:	bf00      	nop
 8003298:	080035e8 	.word	0x080035e8

0800329c <USBD_LL_OpenEP>:
{
 800329c:	b510      	push	{r4, lr}
 800329e:	461c      	mov	r4, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 80032a0:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80032a4:	4613      	mov	r3, r2
 80032a6:	4622      	mov	r2, r4
 80032a8:	f7fd fc98 	bl	8000bdc <HAL_PCD_EP_Open>
 80032ac:	2803      	cmp	r0, #3
 80032ae:	bf9a      	itte	ls
 80032b0:	4b01      	ldrls	r3, [pc, #4]	; (80032b8 <USBD_LL_OpenEP+0x1c>)
 80032b2:	5c18      	ldrbls	r0, [r3, r0]
 80032b4:	2002      	movhi	r0, #2
}
 80032b6:	bd10      	pop	{r4, pc}
 80032b8:	080035e8 	.word	0x080035e8

080032bc <USBD_LL_CloseEP>:
{
 80032bc:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 80032be:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80032c2:	f7fd fcc0 	bl	8000c46 <HAL_PCD_EP_Close>
 80032c6:	2803      	cmp	r0, #3
 80032c8:	bf9a      	itte	ls
 80032ca:	4b02      	ldrls	r3, [pc, #8]	; (80032d4 <USBD_LL_CloseEP+0x18>)
 80032cc:	5c18      	ldrbls	r0, [r3, r0]
 80032ce:	2002      	movhi	r0, #2
}
 80032d0:	bd08      	pop	{r3, pc}
 80032d2:	bf00      	nop
 80032d4:	080035e8 	.word	0x080035e8

080032d8 <USBD_LL_StallEP>:
{
 80032d8:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80032da:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80032de:	f7fd fd15 	bl	8000d0c <HAL_PCD_EP_SetStall>
 80032e2:	2803      	cmp	r0, #3
 80032e4:	bf9a      	itte	ls
 80032e6:	4b02      	ldrls	r3, [pc, #8]	; (80032f0 <USBD_LL_StallEP+0x18>)
 80032e8:	5c18      	ldrbls	r0, [r3, r0]
 80032ea:	2002      	movhi	r0, #2
}
 80032ec:	bd08      	pop	{r3, pc}
 80032ee:	bf00      	nop
 80032f0:	080035e8 	.word	0x080035e8

080032f4 <USBD_LL_ClearStallEP>:
{
 80032f4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 80032f6:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80032fa:	f7fd fd40 	bl	8000d7e <HAL_PCD_EP_ClrStall>
 80032fe:	2803      	cmp	r0, #3
 8003300:	bf9a      	itte	ls
 8003302:	4b02      	ldrls	r3, [pc, #8]	; (800330c <USBD_LL_ClearStallEP+0x18>)
 8003304:	5c18      	ldrbls	r0, [r3, r0]
 8003306:	2002      	movhi	r0, #2
}
 8003308:	bd08      	pop	{r3, pc}
 800330a:	bf00      	nop
 800330c:	080035e8 	.word	0x080035e8

08003310 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 8003310:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8003314:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 8003318:	f04f 021c 	mov.w	r2, #28
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800331c:	bf1b      	ittet	ne
 800331e:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 8003322:	fb02 3101 	mlane	r1, r2, r1, r3
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003326:	fb02 3101 	mlaeq	r1, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800332a:	f891 003e 	ldrbne.w	r0, [r1, #62]	; 0x3e
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 800332e:	bf08      	it	eq
 8003330:	f891 01fe 	ldrbeq.w	r0, [r1, #510]	; 0x1fe
}
 8003334:	4770      	bx	lr
	...

08003338 <USBD_LL_SetUSBAddress>:
{
 8003338:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800333a:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 800333e:	f7fd fc39 	bl	8000bb4 <HAL_PCD_SetAddress>
 8003342:	2803      	cmp	r0, #3
 8003344:	bf9a      	itte	ls
 8003346:	4b02      	ldrls	r3, [pc, #8]	; (8003350 <USBD_LL_SetUSBAddress+0x18>)
 8003348:	5c18      	ldrbls	r0, [r3, r0]
 800334a:	2002      	movhi	r0, #2
}
 800334c:	bd08      	pop	{r3, pc}
 800334e:	bf00      	nop
 8003350:	080035e8 	.word	0x080035e8

08003354 <USBD_LL_Transmit>:
{
 8003354:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003356:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 800335a:	f7fd fcbc 	bl	8000cd6 <HAL_PCD_EP_Transmit>
 800335e:	2803      	cmp	r0, #3
 8003360:	bf9a      	itte	ls
 8003362:	4b02      	ldrls	r3, [pc, #8]	; (800336c <USBD_LL_Transmit+0x18>)
 8003364:	5c18      	ldrbls	r0, [r3, r0]
 8003366:	2002      	movhi	r0, #2
}
 8003368:	bd08      	pop	{r3, pc}
 800336a:	bf00      	nop
 800336c:	080035e8 	.word	0x080035e8

08003370 <USBD_LL_PrepareReceive>:
{
 8003370:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003372:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8003376:	f7fd fc90 	bl	8000c9a <HAL_PCD_EP_Receive>
 800337a:	2803      	cmp	r0, #3
 800337c:	bf9a      	itte	ls
 800337e:	4b02      	ldrls	r3, [pc, #8]	; (8003388 <USBD_LL_PrepareReceive+0x18>)
 8003380:	5c18      	ldrbls	r0, [r3, r0]
 8003382:	2002      	movhi	r0, #2
}
 8003384:	bd08      	pop	{r3, pc}
 8003386:	bf00      	nop
 8003388:	080035e8 	.word	0x080035e8

0800338c <HAL_PCDEx_LPM_Callback>:
{
 800338c:	b510      	push	{r4, lr}
 800338e:	4604      	mov	r4, r0
  switch (msg)
 8003390:	b111      	cbz	r1, 8003398 <HAL_PCDEx_LPM_Callback+0xc>
 8003392:	2901      	cmp	r1, #1
 8003394:	d016      	beq.n	80033c4 <HAL_PCDEx_LPM_Callback+0x38>
 8003396:	bd10      	pop	{r4, pc}
    if (hpcd->Init.low_power_enable)
 8003398:	6a03      	ldr	r3, [r0, #32]
 800339a:	b133      	cbz	r3, 80033aa <HAL_PCDEx_LPM_Callback+0x1e>
      SystemClock_Config();
 800339c:	f7ff fdae 	bl	8002efc <SystemClock_Config>
      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80033a0:	4a12      	ldr	r2, [pc, #72]	; (80033ec <HAL_PCDEx_LPM_Callback+0x60>)
 80033a2:	6913      	ldr	r3, [r2, #16]
 80033a4:	f023 0306 	bic.w	r3, r3, #6
 80033a8:	6113      	str	r3, [r2, #16]
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 80033aa:	6822      	ldr	r2, [r4, #0]
    USBD_LL_Resume(hpcd->pData);
 80033ac:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 80033b0:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80033b4:	f023 0301 	bic.w	r3, r3, #1
 80033b8:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
}
 80033bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBD_LL_Resume(hpcd->pData);
 80033c0:	f7ff bb1a 	b.w	80029f8 <USBD_LL_Resume>
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80033c4:	6802      	ldr	r2, [r0, #0]
    USBD_LL_Suspend(hpcd->pData);
 80033c6:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80033ca:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80033ce:	f043 0301 	orr.w	r3, r3, #1
 80033d2:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    USBD_LL_Suspend(hpcd->pData);
 80033d6:	f7ff fb06 	bl	80029e6 <USBD_LL_Suspend>
    if (hpcd->Init.low_power_enable)
 80033da:	6a23      	ldr	r3, [r4, #32]
 80033dc:	b123      	cbz	r3, 80033e8 <HAL_PCDEx_LPM_Callback+0x5c>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80033de:	4a03      	ldr	r2, [pc, #12]	; (80033ec <HAL_PCDEx_LPM_Callback+0x60>)
 80033e0:	6913      	ldr	r3, [r2, #16]
 80033e2:	f043 0306 	orr.w	r3, r3, #6
 80033e6:	6113      	str	r3, [r2, #16]
 80033e8:	bd10      	pop	{r4, pc}
 80033ea:	bf00      	nop
 80033ec:	e000ed00 	.word	0xe000ed00

080033f0 <USBD_static_malloc>:
}
 80033f0:	4800      	ldr	r0, [pc, #0]	; (80033f4 <USBD_static_malloc+0x4>)
 80033f2:	4770      	bx	lr
 80033f4:	20000180 	.word	0x20000180

080033f8 <USBD_static_free>:
{
 80033f8:	4770      	bx	lr

080033fa <USBD_LL_BatteryCharging>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_BatteryCharging(USBD_HandleTypeDef *pdev)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*)pdev->pData;
  if (hpcd->Init.battery_charging_enable == ENABLE)
 80033fa:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 80033fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003400:	2b01      	cmp	r3, #1
  }
  else
  {
    return USBD_FAIL;
  }
}
 8003402:	bf14      	ite	ne
 8003404:	2002      	movne	r0, #2
 8003406:	2000      	moveq	r0, #0
 8003408:	4770      	bx	lr

0800340a <CUSTOM_HID_DeInit_FS>:
static int8_t CUSTOM_HID_DeInit_FS(void)
{
  /* USER CODE BEGIN 5 */
  return (USBD_OK);
  /* USER CODE END 5 */
}
 800340a:	2000      	movs	r0, #0
 800340c:	4770      	bx	lr
	...

08003410 <CUSTOM_HID_OutEvent_FS>:
  * @param  state: Event state
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)
{
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)hUsbDeviceFS.pClassData;;  
 8003410:	4b05      	ldr	r3, [pc, #20]	; (8003428 <CUSTOM_HID_OutEvent_FS+0x18>)
 
  for (uint8_t i = 0; i < 12; i++)
  {
    dataToReceive[i] = hhid->Report_buf[i];
 8003412:	4a06      	ldr	r2, [pc, #24]	; (800342c <CUSTOM_HID_OutEvent_FS+0x1c>)
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)hUsbDeviceFS.pClassData;;  
 8003414:	f8d3 0290 	ldr.w	r0, [r3, #656]	; 0x290
 8003418:	2300      	movs	r3, #0
    dataToReceive[i] = hhid->Report_buf[i];
 800341a:	5cc1      	ldrb	r1, [r0, r3]
 800341c:	5499      	strb	r1, [r3, r2]
 800341e:	3301      	adds	r3, #1
  for (uint8_t i = 0; i < 12; i++)
 8003420:	2b0c      	cmp	r3, #12
 8003422:	d1fa      	bne.n	800341a <CUSTOM_HID_OutEvent_FS+0xa>
  }
 
 
  return (USBD_OK);
}
 8003424:	2000      	movs	r0, #0
 8003426:	4770      	bx	lr
 8003428:	200001a8 	.word	0x200001a8
 800342c:	20000171 	.word	0x20000171

08003430 <CUSTOM_HID_Init_FS>:
 8003430:	2000      	movs	r0, #0
 8003432:	4770      	bx	lr

08003434 <USBD_FS_DeviceDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8003434:	2312      	movs	r3, #18
 8003436:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8003438:	4800      	ldr	r0, [pc, #0]	; (800343c <USBD_FS_DeviceDescriptor+0x8>)
 800343a:	4770      	bx	lr
 800343c:	2000013c 	.word	0x2000013c

08003440 <USBD_FS_LangIDStrDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 8003440:	2304      	movs	r3, #4
 8003442:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8003444:	4800      	ldr	r0, [pc, #0]	; (8003448 <USBD_FS_LangIDStrDescriptor+0x8>)
 8003446:	4770      	bx	lr
 8003448:	20000150 	.word	0x20000150

0800344c <USBD_FS_USR_BOSDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_USR_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_BOSDesc);
 800344c:	230c      	movs	r3, #12
 800344e:	800b      	strh	r3, [r1, #0]
  return (uint8_t*)USBD_FS_BOSDesc;
}
 8003450:	4800      	ldr	r0, [pc, #0]	; (8003454 <USBD_FS_USR_BOSDescriptor+0x8>)
 8003452:	4770      	bx	lr
 8003454:	20000130 	.word	0x20000130

08003458 <USBD_FS_ManufacturerStrDescriptor>:
{
 8003458:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800345a:	4c04      	ldr	r4, [pc, #16]	; (800346c <USBD_FS_ManufacturerStrDescriptor+0x14>)
 800345c:	4804      	ldr	r0, [pc, #16]	; (8003470 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800345e:	460a      	mov	r2, r1
 8003460:	4621      	mov	r1, r4
 8003462:	f7ff fced 	bl	8002e40 <USBD_GetString>
}
 8003466:	4620      	mov	r0, r4
 8003468:	bd10      	pop	{r4, pc}
 800346a:	bf00      	nop
 800346c:	2000084c 	.word	0x2000084c
 8003470:	08003613 	.word	0x08003613

08003474 <USBD_FS_ProductStrDescriptor>:
{
 8003474:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8003476:	4c04      	ldr	r4, [pc, #16]	; (8003488 <USBD_FS_ProductStrDescriptor+0x14>)
 8003478:	4804      	ldr	r0, [pc, #16]	; (800348c <USBD_FS_ProductStrDescriptor+0x18>)
 800347a:	460a      	mov	r2, r1
 800347c:	4621      	mov	r1, r4
 800347e:	f7ff fcdf 	bl	8002e40 <USBD_GetString>
}
 8003482:	4620      	mov	r0, r4
 8003484:	bd10      	pop	{r4, pc}
 8003486:	bf00      	nop
 8003488:	2000084c 	.word	0x2000084c
 800348c:	0800361a 	.word	0x0800361a

08003490 <USBD_FS_SerialStrDescriptor>:
{
 8003490:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 8003492:	4c04      	ldr	r4, [pc, #16]	; (80034a4 <USBD_FS_SerialStrDescriptor+0x14>)
 8003494:	4804      	ldr	r0, [pc, #16]	; (80034a8 <USBD_FS_SerialStrDescriptor+0x18>)
 8003496:	460a      	mov	r2, r1
 8003498:	4621      	mov	r1, r4
 800349a:	f7ff fcd1 	bl	8002e40 <USBD_GetString>
}
 800349e:	4620      	mov	r0, r4
 80034a0:	bd10      	pop	{r4, pc}
 80034a2:	bf00      	nop
 80034a4:	2000084c 	.word	0x2000084c
 80034a8:	08003638 	.word	0x08003638

080034ac <USBD_FS_ConfigStrDescriptor>:
{
 80034ac:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 80034ae:	4c04      	ldr	r4, [pc, #16]	; (80034c0 <USBD_FS_ConfigStrDescriptor+0x14>)
 80034b0:	4804      	ldr	r0, [pc, #16]	; (80034c4 <USBD_FS_ConfigStrDescriptor+0x18>)
 80034b2:	460a      	mov	r2, r1
 80034b4:	4621      	mov	r1, r4
 80034b6:	f7ff fcc3 	bl	8002e40 <USBD_GetString>
}
 80034ba:	4620      	mov	r0, r4
 80034bc:	bd10      	pop	{r4, pc}
 80034be:	bf00      	nop
 80034c0:	2000084c 	.word	0x2000084c
 80034c4:	080035ec 	.word	0x080035ec

080034c8 <USBD_FS_InterfaceStrDescriptor>:
{
 80034c8:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80034ca:	4c04      	ldr	r4, [pc, #16]	; (80034dc <USBD_FS_InterfaceStrDescriptor+0x14>)
 80034cc:	4804      	ldr	r0, [pc, #16]	; (80034e0 <USBD_FS_InterfaceStrDescriptor+0x18>)
 80034ce:	460a      	mov	r2, r1
 80034d0:	4621      	mov	r1, r4
 80034d2:	f7ff fcb5 	bl	8002e40 <USBD_GetString>
}
 80034d6:	4620      	mov	r0, r4
 80034d8:	bd10      	pop	{r4, pc}
 80034da:	bf00      	nop
 80034dc:	2000084c 	.word	0x2000084c
 80034e0:	080035fe 	.word	0x080035fe

080034e4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80034e4:	f8df d034 	ldr.w	sp, [pc, #52]	; 800351c <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80034e8:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80034ea:	e003      	b.n	80034f4 <LoopCopyDataInit>

080034ec <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80034ec:	4b0c      	ldr	r3, [pc, #48]	; (8003520 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80034ee:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80034f0:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80034f2:	3104      	adds	r1, #4

080034f4 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80034f4:	480b      	ldr	r0, [pc, #44]	; (8003524 <LoopForever+0xa>)
	ldr	r3, =_edata
 80034f6:	4b0c      	ldr	r3, [pc, #48]	; (8003528 <LoopForever+0xe>)
	adds	r2, r0, r1
 80034f8:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80034fa:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80034fc:	d3f6      	bcc.n	80034ec <CopyDataInit>
	ldr	r2, =_sbss
 80034fe:	4a0b      	ldr	r2, [pc, #44]	; (800352c <LoopForever+0x12>)
	b	LoopFillZerobss
 8003500:	e002      	b.n	8003508 <LoopFillZerobss>

08003502 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8003502:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8003504:	f842 3b04 	str.w	r3, [r2], #4

08003508 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8003508:	4b09      	ldr	r3, [pc, #36]	; (8003530 <LoopForever+0x16>)
	cmp	r2, r3
 800350a:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800350c:	d3f9      	bcc.n	8003502 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800350e:	f7ff fd99 	bl	8003044 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8003512:	f000 f811 	bl	8003538 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8003516:	f7ff fd39 	bl	8002f8c <main>

0800351a <LoopForever>:

LoopForever:
    b LoopForever
 800351a:	e7fe      	b.n	800351a <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800351c:	200a0000 	.word	0x200a0000
	ldr	r3, =_sidata
 8003520:	08003650 	.word	0x08003650
	ldr	r0, =_sdata
 8003524:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8003528:	20000154 	.word	0x20000154
	ldr	r2, =_sbss
 800352c:	20000154 	.word	0x20000154
	ldr	r3, = _ebss
 8003530:	20000a4c 	.word	0x20000a4c

08003534 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8003534:	e7fe      	b.n	8003534 <ADC1_IRQHandler>
	...

08003538 <__libc_init_array>:
 8003538:	b570      	push	{r4, r5, r6, lr}
 800353a:	4e0d      	ldr	r6, [pc, #52]	; (8003570 <__libc_init_array+0x38>)
 800353c:	4c0d      	ldr	r4, [pc, #52]	; (8003574 <__libc_init_array+0x3c>)
 800353e:	1ba4      	subs	r4, r4, r6
 8003540:	10a4      	asrs	r4, r4, #2
 8003542:	2500      	movs	r5, #0
 8003544:	42a5      	cmp	r5, r4
 8003546:	d109      	bne.n	800355c <__libc_init_array+0x24>
 8003548:	4e0b      	ldr	r6, [pc, #44]	; (8003578 <__libc_init_array+0x40>)
 800354a:	4c0c      	ldr	r4, [pc, #48]	; (800357c <__libc_init_array+0x44>)
 800354c:	f000 f820 	bl	8003590 <_init>
 8003550:	1ba4      	subs	r4, r4, r6
 8003552:	10a4      	asrs	r4, r4, #2
 8003554:	2500      	movs	r5, #0
 8003556:	42a5      	cmp	r5, r4
 8003558:	d105      	bne.n	8003566 <__libc_init_array+0x2e>
 800355a:	bd70      	pop	{r4, r5, r6, pc}
 800355c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003560:	4798      	blx	r3
 8003562:	3501      	adds	r5, #1
 8003564:	e7ee      	b.n	8003544 <__libc_init_array+0xc>
 8003566:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800356a:	4798      	blx	r3
 800356c:	3501      	adds	r5, #1
 800356e:	e7f2      	b.n	8003556 <__libc_init_array+0x1e>
 8003570:	08003648 	.word	0x08003648
 8003574:	08003648 	.word	0x08003648
 8003578:	08003648 	.word	0x08003648
 800357c:	0800364c 	.word	0x0800364c

08003580 <memset>:
 8003580:	4402      	add	r2, r0
 8003582:	4603      	mov	r3, r0
 8003584:	4293      	cmp	r3, r2
 8003586:	d100      	bne.n	800358a <memset+0xa>
 8003588:	4770      	bx	lr
 800358a:	f803 1b01 	strb.w	r1, [r3], #1
 800358e:	e7f9      	b.n	8003584 <memset+0x4>

08003590 <_init>:
 8003590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003592:	bf00      	nop
 8003594:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003596:	bc08      	pop	{r3}
 8003598:	469e      	mov	lr, r3
 800359a:	4770      	bx	lr

0800359c <_fini>:
 800359c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800359e:	bf00      	nop
 80035a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80035a2:	bc08      	pop	{r3}
 80035a4:	469e      	mov	lr, r3
 80035a6:	4770      	bx	lr
