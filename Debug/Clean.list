
Clean.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001bc  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00012a08  080001c0  080001c0  000101c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000cab0  08012bc8  08012bc8  00022bc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0801f678  0801f678  0002f678  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0801f680  0801f680  0002f680  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0801f684  0801f684  0002f684  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000280  20000000  0801f688  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0008642c  20000280  0801f908  00030280  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  200866ac  0801f908  000366ac  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00030280  2**0
                  CONTENTS, READONLY
 10 .debug_info   0004bca2  00000000  00000000  000302b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000080b4  00000000  00000000  0007bf52  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001c31a  00000000  00000000  00084006  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000022d0  00000000  00000000  000a0320  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002a20  00000000  00000000  000a25f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00014855  00000000  00000000  000a5010  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000b9dc  00000000  00000000  000b9865  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  000c5241  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00006f8c  00000000  00000000  000c52c0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c0 <__do_global_dtors_aux>:
 80001c0:	b510      	push	{r4, lr}
 80001c2:	4c05      	ldr	r4, [pc, #20]	; (80001d8 <__do_global_dtors_aux+0x18>)
 80001c4:	7823      	ldrb	r3, [r4, #0]
 80001c6:	b933      	cbnz	r3, 80001d6 <__do_global_dtors_aux+0x16>
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x1c>)
 80001ca:	b113      	cbz	r3, 80001d2 <__do_global_dtors_aux+0x12>
 80001cc:	4804      	ldr	r0, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x20>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	2301      	movs	r3, #1
 80001d4:	7023      	strb	r3, [r4, #0]
 80001d6:	bd10      	pop	{r4, pc}
 80001d8:	20000280 	.word	0x20000280
 80001dc:	00000000 	.word	0x00000000
 80001e0:	08012bb0 	.word	0x08012bb0

080001e4 <frame_dummy>:
 80001e4:	b508      	push	{r3, lr}
 80001e6:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <frame_dummy+0x10>)
 80001e8:	b11b      	cbz	r3, 80001f2 <frame_dummy+0xe>
 80001ea:	4903      	ldr	r1, [pc, #12]	; (80001f8 <frame_dummy+0x14>)
 80001ec:	4803      	ldr	r0, [pc, #12]	; (80001fc <frame_dummy+0x18>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	bd08      	pop	{r3, pc}
 80001f4:	00000000 	.word	0x00000000
 80001f8:	20000284 	.word	0x20000284
 80001fc:	08012bb0 	.word	0x08012bb0

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_drsub>:
 80002a0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002a4:	e002      	b.n	80002ac <__adddf3>
 80002a6:	bf00      	nop

080002a8 <__aeabi_dsub>:
 80002a8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002ac <__adddf3>:
 80002ac:	b530      	push	{r4, r5, lr}
 80002ae:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002b2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002b6:	ea94 0f05 	teq	r4, r5
 80002ba:	bf08      	it	eq
 80002bc:	ea90 0f02 	teqeq	r0, r2
 80002c0:	bf1f      	itttt	ne
 80002c2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002c6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ca:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ce:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002d2:	f000 80e2 	beq.w	800049a <__adddf3+0x1ee>
 80002d6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002da:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002de:	bfb8      	it	lt
 80002e0:	426d      	neglt	r5, r5
 80002e2:	dd0c      	ble.n	80002fe <__adddf3+0x52>
 80002e4:	442c      	add	r4, r5
 80002e6:	ea80 0202 	eor.w	r2, r0, r2
 80002ea:	ea81 0303 	eor.w	r3, r1, r3
 80002ee:	ea82 0000 	eor.w	r0, r2, r0
 80002f2:	ea83 0101 	eor.w	r1, r3, r1
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	2d36      	cmp	r5, #54	; 0x36
 8000300:	bf88      	it	hi
 8000302:	bd30      	pophi	{r4, r5, pc}
 8000304:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000308:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800030c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000310:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000314:	d002      	beq.n	800031c <__adddf3+0x70>
 8000316:	4240      	negs	r0, r0
 8000318:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800031c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000320:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000324:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000328:	d002      	beq.n	8000330 <__adddf3+0x84>
 800032a:	4252      	negs	r2, r2
 800032c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000330:	ea94 0f05 	teq	r4, r5
 8000334:	f000 80a7 	beq.w	8000486 <__adddf3+0x1da>
 8000338:	f1a4 0401 	sub.w	r4, r4, #1
 800033c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000340:	db0d      	blt.n	800035e <__adddf3+0xb2>
 8000342:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000346:	fa22 f205 	lsr.w	r2, r2, r5
 800034a:	1880      	adds	r0, r0, r2
 800034c:	f141 0100 	adc.w	r1, r1, #0
 8000350:	fa03 f20e 	lsl.w	r2, r3, lr
 8000354:	1880      	adds	r0, r0, r2
 8000356:	fa43 f305 	asr.w	r3, r3, r5
 800035a:	4159      	adcs	r1, r3
 800035c:	e00e      	b.n	800037c <__adddf3+0xd0>
 800035e:	f1a5 0520 	sub.w	r5, r5, #32
 8000362:	f10e 0e20 	add.w	lr, lr, #32
 8000366:	2a01      	cmp	r2, #1
 8000368:	fa03 fc0e 	lsl.w	ip, r3, lr
 800036c:	bf28      	it	cs
 800036e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000372:	fa43 f305 	asr.w	r3, r3, r5
 8000376:	18c0      	adds	r0, r0, r3
 8000378:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800037c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000380:	d507      	bpl.n	8000392 <__adddf3+0xe6>
 8000382:	f04f 0e00 	mov.w	lr, #0
 8000386:	f1dc 0c00 	rsbs	ip, ip, #0
 800038a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800038e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000392:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000396:	d31b      	bcc.n	80003d0 <__adddf3+0x124>
 8000398:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800039c:	d30c      	bcc.n	80003b8 <__adddf3+0x10c>
 800039e:	0849      	lsrs	r1, r1, #1
 80003a0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003a4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003a8:	f104 0401 	add.w	r4, r4, #1
 80003ac:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003b0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003b4:	f080 809a 	bcs.w	80004ec <__adddf3+0x240>
 80003b8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003bc:	bf08      	it	eq
 80003be:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003c2:	f150 0000 	adcs.w	r0, r0, #0
 80003c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ca:	ea41 0105 	orr.w	r1, r1, r5
 80003ce:	bd30      	pop	{r4, r5, pc}
 80003d0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003d4:	4140      	adcs	r0, r0
 80003d6:	eb41 0101 	adc.w	r1, r1, r1
 80003da:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003de:	f1a4 0401 	sub.w	r4, r4, #1
 80003e2:	d1e9      	bne.n	80003b8 <__adddf3+0x10c>
 80003e4:	f091 0f00 	teq	r1, #0
 80003e8:	bf04      	itt	eq
 80003ea:	4601      	moveq	r1, r0
 80003ec:	2000      	moveq	r0, #0
 80003ee:	fab1 f381 	clz	r3, r1
 80003f2:	bf08      	it	eq
 80003f4:	3320      	addeq	r3, #32
 80003f6:	f1a3 030b 	sub.w	r3, r3, #11
 80003fa:	f1b3 0220 	subs.w	r2, r3, #32
 80003fe:	da0c      	bge.n	800041a <__adddf3+0x16e>
 8000400:	320c      	adds	r2, #12
 8000402:	dd08      	ble.n	8000416 <__adddf3+0x16a>
 8000404:	f102 0c14 	add.w	ip, r2, #20
 8000408:	f1c2 020c 	rsb	r2, r2, #12
 800040c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000410:	fa21 f102 	lsr.w	r1, r1, r2
 8000414:	e00c      	b.n	8000430 <__adddf3+0x184>
 8000416:	f102 0214 	add.w	r2, r2, #20
 800041a:	bfd8      	it	le
 800041c:	f1c2 0c20 	rsble	ip, r2, #32
 8000420:	fa01 f102 	lsl.w	r1, r1, r2
 8000424:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000428:	bfdc      	itt	le
 800042a:	ea41 010c 	orrle.w	r1, r1, ip
 800042e:	4090      	lslle	r0, r2
 8000430:	1ae4      	subs	r4, r4, r3
 8000432:	bfa2      	ittt	ge
 8000434:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000438:	4329      	orrge	r1, r5
 800043a:	bd30      	popge	{r4, r5, pc}
 800043c:	ea6f 0404 	mvn.w	r4, r4
 8000440:	3c1f      	subs	r4, #31
 8000442:	da1c      	bge.n	800047e <__adddf3+0x1d2>
 8000444:	340c      	adds	r4, #12
 8000446:	dc0e      	bgt.n	8000466 <__adddf3+0x1ba>
 8000448:	f104 0414 	add.w	r4, r4, #20
 800044c:	f1c4 0220 	rsb	r2, r4, #32
 8000450:	fa20 f004 	lsr.w	r0, r0, r4
 8000454:	fa01 f302 	lsl.w	r3, r1, r2
 8000458:	ea40 0003 	orr.w	r0, r0, r3
 800045c:	fa21 f304 	lsr.w	r3, r1, r4
 8000460:	ea45 0103 	orr.w	r1, r5, r3
 8000464:	bd30      	pop	{r4, r5, pc}
 8000466:	f1c4 040c 	rsb	r4, r4, #12
 800046a:	f1c4 0220 	rsb	r2, r4, #32
 800046e:	fa20 f002 	lsr.w	r0, r0, r2
 8000472:	fa01 f304 	lsl.w	r3, r1, r4
 8000476:	ea40 0003 	orr.w	r0, r0, r3
 800047a:	4629      	mov	r1, r5
 800047c:	bd30      	pop	{r4, r5, pc}
 800047e:	fa21 f004 	lsr.w	r0, r1, r4
 8000482:	4629      	mov	r1, r5
 8000484:	bd30      	pop	{r4, r5, pc}
 8000486:	f094 0f00 	teq	r4, #0
 800048a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800048e:	bf06      	itte	eq
 8000490:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000494:	3401      	addeq	r4, #1
 8000496:	3d01      	subne	r5, #1
 8000498:	e74e      	b.n	8000338 <__adddf3+0x8c>
 800049a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800049e:	bf18      	it	ne
 80004a0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004a4:	d029      	beq.n	80004fa <__adddf3+0x24e>
 80004a6:	ea94 0f05 	teq	r4, r5
 80004aa:	bf08      	it	eq
 80004ac:	ea90 0f02 	teqeq	r0, r2
 80004b0:	d005      	beq.n	80004be <__adddf3+0x212>
 80004b2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004b6:	bf04      	itt	eq
 80004b8:	4619      	moveq	r1, r3
 80004ba:	4610      	moveq	r0, r2
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	ea91 0f03 	teq	r1, r3
 80004c2:	bf1e      	ittt	ne
 80004c4:	2100      	movne	r1, #0
 80004c6:	2000      	movne	r0, #0
 80004c8:	bd30      	popne	{r4, r5, pc}
 80004ca:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ce:	d105      	bne.n	80004dc <__adddf3+0x230>
 80004d0:	0040      	lsls	r0, r0, #1
 80004d2:	4149      	adcs	r1, r1
 80004d4:	bf28      	it	cs
 80004d6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004da:	bd30      	pop	{r4, r5, pc}
 80004dc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004e0:	bf3c      	itt	cc
 80004e2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004e6:	bd30      	popcc	{r4, r5, pc}
 80004e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004ec:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004f0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004f4:	f04f 0000 	mov.w	r0, #0
 80004f8:	bd30      	pop	{r4, r5, pc}
 80004fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004fe:	bf1a      	itte	ne
 8000500:	4619      	movne	r1, r3
 8000502:	4610      	movne	r0, r2
 8000504:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000508:	bf1c      	itt	ne
 800050a:	460b      	movne	r3, r1
 800050c:	4602      	movne	r2, r0
 800050e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000512:	bf06      	itte	eq
 8000514:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000518:	ea91 0f03 	teqeq	r1, r3
 800051c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000520:	bd30      	pop	{r4, r5, pc}
 8000522:	bf00      	nop

08000524 <__aeabi_ui2d>:
 8000524:	f090 0f00 	teq	r0, #0
 8000528:	bf04      	itt	eq
 800052a:	2100      	moveq	r1, #0
 800052c:	4770      	bxeq	lr
 800052e:	b530      	push	{r4, r5, lr}
 8000530:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000534:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000538:	f04f 0500 	mov.w	r5, #0
 800053c:	f04f 0100 	mov.w	r1, #0
 8000540:	e750      	b.n	80003e4 <__adddf3+0x138>
 8000542:	bf00      	nop

08000544 <__aeabi_i2d>:
 8000544:	f090 0f00 	teq	r0, #0
 8000548:	bf04      	itt	eq
 800054a:	2100      	moveq	r1, #0
 800054c:	4770      	bxeq	lr
 800054e:	b530      	push	{r4, r5, lr}
 8000550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000558:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800055c:	bf48      	it	mi
 800055e:	4240      	negmi	r0, r0
 8000560:	f04f 0100 	mov.w	r1, #0
 8000564:	e73e      	b.n	80003e4 <__adddf3+0x138>
 8000566:	bf00      	nop

08000568 <__aeabi_f2d>:
 8000568:	0042      	lsls	r2, r0, #1
 800056a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800056e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000572:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000576:	bf1f      	itttt	ne
 8000578:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800057c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000580:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000584:	4770      	bxne	lr
 8000586:	f092 0f00 	teq	r2, #0
 800058a:	bf14      	ite	ne
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	4770      	bxeq	lr
 8000592:	b530      	push	{r4, r5, lr}
 8000594:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000598:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800059c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005a0:	e720      	b.n	80003e4 <__adddf3+0x138>
 80005a2:	bf00      	nop

080005a4 <__aeabi_ul2d>:
 80005a4:	ea50 0201 	orrs.w	r2, r0, r1
 80005a8:	bf08      	it	eq
 80005aa:	4770      	bxeq	lr
 80005ac:	b530      	push	{r4, r5, lr}
 80005ae:	f04f 0500 	mov.w	r5, #0
 80005b2:	e00a      	b.n	80005ca <__aeabi_l2d+0x16>

080005b4 <__aeabi_l2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005c2:	d502      	bpl.n	80005ca <__aeabi_l2d+0x16>
 80005c4:	4240      	negs	r0, r0
 80005c6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005ca:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005ce:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005d2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005d6:	f43f aedc 	beq.w	8000392 <__adddf3+0xe6>
 80005da:	f04f 0203 	mov.w	r2, #3
 80005de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005e2:	bf18      	it	ne
 80005e4:	3203      	addne	r2, #3
 80005e6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ea:	bf18      	it	ne
 80005ec:	3203      	addne	r2, #3
 80005ee:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005f2:	f1c2 0320 	rsb	r3, r2, #32
 80005f6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005fa:	fa20 f002 	lsr.w	r0, r0, r2
 80005fe:	fa01 fe03 	lsl.w	lr, r1, r3
 8000602:	ea40 000e 	orr.w	r0, r0, lr
 8000606:	fa21 f102 	lsr.w	r1, r1, r2
 800060a:	4414      	add	r4, r2
 800060c:	e6c1      	b.n	8000392 <__adddf3+0xe6>
 800060e:	bf00      	nop

08000610 <__aeabi_dmul>:
 8000610:	b570      	push	{r4, r5, r6, lr}
 8000612:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000616:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800061a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800061e:	bf1d      	ittte	ne
 8000620:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000624:	ea94 0f0c 	teqne	r4, ip
 8000628:	ea95 0f0c 	teqne	r5, ip
 800062c:	f000 f8de 	bleq	80007ec <__aeabi_dmul+0x1dc>
 8000630:	442c      	add	r4, r5
 8000632:	ea81 0603 	eor.w	r6, r1, r3
 8000636:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800063a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800063e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000642:	bf18      	it	ne
 8000644:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000648:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800064c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000650:	d038      	beq.n	80006c4 <__aeabi_dmul+0xb4>
 8000652:	fba0 ce02 	umull	ip, lr, r0, r2
 8000656:	f04f 0500 	mov.w	r5, #0
 800065a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800065e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000662:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000666:	f04f 0600 	mov.w	r6, #0
 800066a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800066e:	f09c 0f00 	teq	ip, #0
 8000672:	bf18      	it	ne
 8000674:	f04e 0e01 	orrne.w	lr, lr, #1
 8000678:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800067c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000680:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000684:	d204      	bcs.n	8000690 <__aeabi_dmul+0x80>
 8000686:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800068a:	416d      	adcs	r5, r5
 800068c:	eb46 0606 	adc.w	r6, r6, r6
 8000690:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000694:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000698:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800069c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006a0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006a4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006a8:	bf88      	it	hi
 80006aa:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006ae:	d81e      	bhi.n	80006ee <__aeabi_dmul+0xde>
 80006b0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006b4:	bf08      	it	eq
 80006b6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ba:	f150 0000 	adcs.w	r0, r0, #0
 80006be:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006c2:	bd70      	pop	{r4, r5, r6, pc}
 80006c4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006c8:	ea46 0101 	orr.w	r1, r6, r1
 80006cc:	ea40 0002 	orr.w	r0, r0, r2
 80006d0:	ea81 0103 	eor.w	r1, r1, r3
 80006d4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006d8:	bfc2      	ittt	gt
 80006da:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006de:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006e2:	bd70      	popgt	{r4, r5, r6, pc}
 80006e4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006e8:	f04f 0e00 	mov.w	lr, #0
 80006ec:	3c01      	subs	r4, #1
 80006ee:	f300 80ab 	bgt.w	8000848 <__aeabi_dmul+0x238>
 80006f2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006f6:	bfde      	ittt	le
 80006f8:	2000      	movle	r0, #0
 80006fa:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006fe:	bd70      	pople	{r4, r5, r6, pc}
 8000700:	f1c4 0400 	rsb	r4, r4, #0
 8000704:	3c20      	subs	r4, #32
 8000706:	da35      	bge.n	8000774 <__aeabi_dmul+0x164>
 8000708:	340c      	adds	r4, #12
 800070a:	dc1b      	bgt.n	8000744 <__aeabi_dmul+0x134>
 800070c:	f104 0414 	add.w	r4, r4, #20
 8000710:	f1c4 0520 	rsb	r5, r4, #32
 8000714:	fa00 f305 	lsl.w	r3, r0, r5
 8000718:	fa20 f004 	lsr.w	r0, r0, r4
 800071c:	fa01 f205 	lsl.w	r2, r1, r5
 8000720:	ea40 0002 	orr.w	r0, r0, r2
 8000724:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000728:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800072c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000730:	fa21 f604 	lsr.w	r6, r1, r4
 8000734:	eb42 0106 	adc.w	r1, r2, r6
 8000738:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800073c:	bf08      	it	eq
 800073e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000742:	bd70      	pop	{r4, r5, r6, pc}
 8000744:	f1c4 040c 	rsb	r4, r4, #12
 8000748:	f1c4 0520 	rsb	r5, r4, #32
 800074c:	fa00 f304 	lsl.w	r3, r0, r4
 8000750:	fa20 f005 	lsr.w	r0, r0, r5
 8000754:	fa01 f204 	lsl.w	r2, r1, r4
 8000758:	ea40 0002 	orr.w	r0, r0, r2
 800075c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000760:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000764:	f141 0100 	adc.w	r1, r1, #0
 8000768:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800076c:	bf08      	it	eq
 800076e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000772:	bd70      	pop	{r4, r5, r6, pc}
 8000774:	f1c4 0520 	rsb	r5, r4, #32
 8000778:	fa00 f205 	lsl.w	r2, r0, r5
 800077c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000780:	fa20 f304 	lsr.w	r3, r0, r4
 8000784:	fa01 f205 	lsl.w	r2, r1, r5
 8000788:	ea43 0302 	orr.w	r3, r3, r2
 800078c:	fa21 f004 	lsr.w	r0, r1, r4
 8000790:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000794:	fa21 f204 	lsr.w	r2, r1, r4
 8000798:	ea20 0002 	bic.w	r0, r0, r2
 800079c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a4:	bf08      	it	eq
 80007a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007aa:	bd70      	pop	{r4, r5, r6, pc}
 80007ac:	f094 0f00 	teq	r4, #0
 80007b0:	d10f      	bne.n	80007d2 <__aeabi_dmul+0x1c2>
 80007b2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007b6:	0040      	lsls	r0, r0, #1
 80007b8:	eb41 0101 	adc.w	r1, r1, r1
 80007bc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007c0:	bf08      	it	eq
 80007c2:	3c01      	subeq	r4, #1
 80007c4:	d0f7      	beq.n	80007b6 <__aeabi_dmul+0x1a6>
 80007c6:	ea41 0106 	orr.w	r1, r1, r6
 80007ca:	f095 0f00 	teq	r5, #0
 80007ce:	bf18      	it	ne
 80007d0:	4770      	bxne	lr
 80007d2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007d6:	0052      	lsls	r2, r2, #1
 80007d8:	eb43 0303 	adc.w	r3, r3, r3
 80007dc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007e0:	bf08      	it	eq
 80007e2:	3d01      	subeq	r5, #1
 80007e4:	d0f7      	beq.n	80007d6 <__aeabi_dmul+0x1c6>
 80007e6:	ea43 0306 	orr.w	r3, r3, r6
 80007ea:	4770      	bx	lr
 80007ec:	ea94 0f0c 	teq	r4, ip
 80007f0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007f4:	bf18      	it	ne
 80007f6:	ea95 0f0c 	teqne	r5, ip
 80007fa:	d00c      	beq.n	8000816 <__aeabi_dmul+0x206>
 80007fc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000800:	bf18      	it	ne
 8000802:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000806:	d1d1      	bne.n	80007ac <__aeabi_dmul+0x19c>
 8000808:	ea81 0103 	eor.w	r1, r1, r3
 800080c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000810:	f04f 0000 	mov.w	r0, #0
 8000814:	bd70      	pop	{r4, r5, r6, pc}
 8000816:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800081a:	bf06      	itte	eq
 800081c:	4610      	moveq	r0, r2
 800081e:	4619      	moveq	r1, r3
 8000820:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000824:	d019      	beq.n	800085a <__aeabi_dmul+0x24a>
 8000826:	ea94 0f0c 	teq	r4, ip
 800082a:	d102      	bne.n	8000832 <__aeabi_dmul+0x222>
 800082c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000830:	d113      	bne.n	800085a <__aeabi_dmul+0x24a>
 8000832:	ea95 0f0c 	teq	r5, ip
 8000836:	d105      	bne.n	8000844 <__aeabi_dmul+0x234>
 8000838:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800083c:	bf1c      	itt	ne
 800083e:	4610      	movne	r0, r2
 8000840:	4619      	movne	r1, r3
 8000842:	d10a      	bne.n	800085a <__aeabi_dmul+0x24a>
 8000844:	ea81 0103 	eor.w	r1, r1, r3
 8000848:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800084c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000850:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000854:	f04f 0000 	mov.w	r0, #0
 8000858:	bd70      	pop	{r4, r5, r6, pc}
 800085a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800085e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000862:	bd70      	pop	{r4, r5, r6, pc}

08000864 <__aeabi_ddiv>:
 8000864:	b570      	push	{r4, r5, r6, lr}
 8000866:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800086a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800086e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000872:	bf1d      	ittte	ne
 8000874:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000878:	ea94 0f0c 	teqne	r4, ip
 800087c:	ea95 0f0c 	teqne	r5, ip
 8000880:	f000 f8a7 	bleq	80009d2 <__aeabi_ddiv+0x16e>
 8000884:	eba4 0405 	sub.w	r4, r4, r5
 8000888:	ea81 0e03 	eor.w	lr, r1, r3
 800088c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000890:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000894:	f000 8088 	beq.w	80009a8 <__aeabi_ddiv+0x144>
 8000898:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800089c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008a0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008a4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008a8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008ac:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008b0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008b4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008b8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008bc:	429d      	cmp	r5, r3
 80008be:	bf08      	it	eq
 80008c0:	4296      	cmpeq	r6, r2
 80008c2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008c6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008ca:	d202      	bcs.n	80008d2 <__aeabi_ddiv+0x6e>
 80008cc:	085b      	lsrs	r3, r3, #1
 80008ce:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d2:	1ab6      	subs	r6, r6, r2
 80008d4:	eb65 0503 	sbc.w	r5, r5, r3
 80008d8:	085b      	lsrs	r3, r3, #1
 80008da:	ea4f 0232 	mov.w	r2, r2, rrx
 80008de:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008e2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008e6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ea:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ee:	bf22      	ittt	cs
 80008f0:	1ab6      	subcs	r6, r6, r2
 80008f2:	4675      	movcs	r5, lr
 80008f4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008f8:	085b      	lsrs	r3, r3, #1
 80008fa:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fe:	ebb6 0e02 	subs.w	lr, r6, r2
 8000902:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000906:	bf22      	ittt	cs
 8000908:	1ab6      	subcs	r6, r6, r2
 800090a:	4675      	movcs	r5, lr
 800090c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	ebb6 0e02 	subs.w	lr, r6, r2
 800091a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800091e:	bf22      	ittt	cs
 8000920:	1ab6      	subcs	r6, r6, r2
 8000922:	4675      	movcs	r5, lr
 8000924:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000928:	085b      	lsrs	r3, r3, #1
 800092a:	ea4f 0232 	mov.w	r2, r2, rrx
 800092e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000932:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000936:	bf22      	ittt	cs
 8000938:	1ab6      	subcs	r6, r6, r2
 800093a:	4675      	movcs	r5, lr
 800093c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000940:	ea55 0e06 	orrs.w	lr, r5, r6
 8000944:	d018      	beq.n	8000978 <__aeabi_ddiv+0x114>
 8000946:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800094a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800094e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000952:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000956:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800095a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800095e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000962:	d1c0      	bne.n	80008e6 <__aeabi_ddiv+0x82>
 8000964:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000968:	d10b      	bne.n	8000982 <__aeabi_ddiv+0x11e>
 800096a:	ea41 0100 	orr.w	r1, r1, r0
 800096e:	f04f 0000 	mov.w	r0, #0
 8000972:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000976:	e7b6      	b.n	80008e6 <__aeabi_ddiv+0x82>
 8000978:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800097c:	bf04      	itt	eq
 800097e:	4301      	orreq	r1, r0
 8000980:	2000      	moveq	r0, #0
 8000982:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000986:	bf88      	it	hi
 8000988:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800098c:	f63f aeaf 	bhi.w	80006ee <__aeabi_dmul+0xde>
 8000990:	ebb5 0c03 	subs.w	ip, r5, r3
 8000994:	bf04      	itt	eq
 8000996:	ebb6 0c02 	subseq.w	ip, r6, r2
 800099a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800099e:	f150 0000 	adcs.w	r0, r0, #0
 80009a2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009a6:	bd70      	pop	{r4, r5, r6, pc}
 80009a8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009ac:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009b0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009b4:	bfc2      	ittt	gt
 80009b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009be:	bd70      	popgt	{r4, r5, r6, pc}
 80009c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009c4:	f04f 0e00 	mov.w	lr, #0
 80009c8:	3c01      	subs	r4, #1
 80009ca:	e690      	b.n	80006ee <__aeabi_dmul+0xde>
 80009cc:	ea45 0e06 	orr.w	lr, r5, r6
 80009d0:	e68d      	b.n	80006ee <__aeabi_dmul+0xde>
 80009d2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009d6:	ea94 0f0c 	teq	r4, ip
 80009da:	bf08      	it	eq
 80009dc:	ea95 0f0c 	teqeq	r5, ip
 80009e0:	f43f af3b 	beq.w	800085a <__aeabi_dmul+0x24a>
 80009e4:	ea94 0f0c 	teq	r4, ip
 80009e8:	d10a      	bne.n	8000a00 <__aeabi_ddiv+0x19c>
 80009ea:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ee:	f47f af34 	bne.w	800085a <__aeabi_dmul+0x24a>
 80009f2:	ea95 0f0c 	teq	r5, ip
 80009f6:	f47f af25 	bne.w	8000844 <__aeabi_dmul+0x234>
 80009fa:	4610      	mov	r0, r2
 80009fc:	4619      	mov	r1, r3
 80009fe:	e72c      	b.n	800085a <__aeabi_dmul+0x24a>
 8000a00:	ea95 0f0c 	teq	r5, ip
 8000a04:	d106      	bne.n	8000a14 <__aeabi_ddiv+0x1b0>
 8000a06:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a0a:	f43f aefd 	beq.w	8000808 <__aeabi_dmul+0x1f8>
 8000a0e:	4610      	mov	r0, r2
 8000a10:	4619      	mov	r1, r3
 8000a12:	e722      	b.n	800085a <__aeabi_dmul+0x24a>
 8000a14:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a18:	bf18      	it	ne
 8000a1a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a1e:	f47f aec5 	bne.w	80007ac <__aeabi_dmul+0x19c>
 8000a22:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a26:	f47f af0d 	bne.w	8000844 <__aeabi_dmul+0x234>
 8000a2a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a2e:	f47f aeeb 	bne.w	8000808 <__aeabi_dmul+0x1f8>
 8000a32:	e712      	b.n	800085a <__aeabi_dmul+0x24a>

08000a34 <__gedf2>:
 8000a34:	f04f 3cff 	mov.w	ip, #4294967295
 8000a38:	e006      	b.n	8000a48 <__cmpdf2+0x4>
 8000a3a:	bf00      	nop

08000a3c <__ledf2>:
 8000a3c:	f04f 0c01 	mov.w	ip, #1
 8000a40:	e002      	b.n	8000a48 <__cmpdf2+0x4>
 8000a42:	bf00      	nop

08000a44 <__cmpdf2>:
 8000a44:	f04f 0c01 	mov.w	ip, #1
 8000a48:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a4c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a54:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a58:	bf18      	it	ne
 8000a5a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a5e:	d01b      	beq.n	8000a98 <__cmpdf2+0x54>
 8000a60:	b001      	add	sp, #4
 8000a62:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a66:	bf0c      	ite	eq
 8000a68:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a6c:	ea91 0f03 	teqne	r1, r3
 8000a70:	bf02      	ittt	eq
 8000a72:	ea90 0f02 	teqeq	r0, r2
 8000a76:	2000      	moveq	r0, #0
 8000a78:	4770      	bxeq	lr
 8000a7a:	f110 0f00 	cmn.w	r0, #0
 8000a7e:	ea91 0f03 	teq	r1, r3
 8000a82:	bf58      	it	pl
 8000a84:	4299      	cmppl	r1, r3
 8000a86:	bf08      	it	eq
 8000a88:	4290      	cmpeq	r0, r2
 8000a8a:	bf2c      	ite	cs
 8000a8c:	17d8      	asrcs	r0, r3, #31
 8000a8e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a92:	f040 0001 	orr.w	r0, r0, #1
 8000a96:	4770      	bx	lr
 8000a98:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a9c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aa0:	d102      	bne.n	8000aa8 <__cmpdf2+0x64>
 8000aa2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000aa6:	d107      	bne.n	8000ab8 <__cmpdf2+0x74>
 8000aa8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000aac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ab0:	d1d6      	bne.n	8000a60 <__cmpdf2+0x1c>
 8000ab2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000ab6:	d0d3      	beq.n	8000a60 <__cmpdf2+0x1c>
 8000ab8:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop

08000ac0 <__aeabi_cdrcmple>:
 8000ac0:	4684      	mov	ip, r0
 8000ac2:	4610      	mov	r0, r2
 8000ac4:	4662      	mov	r2, ip
 8000ac6:	468c      	mov	ip, r1
 8000ac8:	4619      	mov	r1, r3
 8000aca:	4663      	mov	r3, ip
 8000acc:	e000      	b.n	8000ad0 <__aeabi_cdcmpeq>
 8000ace:	bf00      	nop

08000ad0 <__aeabi_cdcmpeq>:
 8000ad0:	b501      	push	{r0, lr}
 8000ad2:	f7ff ffb7 	bl	8000a44 <__cmpdf2>
 8000ad6:	2800      	cmp	r0, #0
 8000ad8:	bf48      	it	mi
 8000ada:	f110 0f00 	cmnmi.w	r0, #0
 8000ade:	bd01      	pop	{r0, pc}

08000ae0 <__aeabi_dcmpeq>:
 8000ae0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ae4:	f7ff fff4 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000ae8:	bf0c      	ite	eq
 8000aea:	2001      	moveq	r0, #1
 8000aec:	2000      	movne	r0, #0
 8000aee:	f85d fb08 	ldr.w	pc, [sp], #8
 8000af2:	bf00      	nop

08000af4 <__aeabi_dcmplt>:
 8000af4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000af8:	f7ff ffea 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000afc:	bf34      	ite	cc
 8000afe:	2001      	movcc	r0, #1
 8000b00:	2000      	movcs	r0, #0
 8000b02:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b06:	bf00      	nop

08000b08 <__aeabi_dcmple>:
 8000b08:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b0c:	f7ff ffe0 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000b10:	bf94      	ite	ls
 8000b12:	2001      	movls	r0, #1
 8000b14:	2000      	movhi	r0, #0
 8000b16:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1a:	bf00      	nop

08000b1c <__aeabi_dcmpge>:
 8000b1c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b20:	f7ff ffce 	bl	8000ac0 <__aeabi_cdrcmple>
 8000b24:	bf94      	ite	ls
 8000b26:	2001      	movls	r0, #1
 8000b28:	2000      	movhi	r0, #0
 8000b2a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b2e:	bf00      	nop

08000b30 <__aeabi_dcmpgt>:
 8000b30:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b34:	f7ff ffc4 	bl	8000ac0 <__aeabi_cdrcmple>
 8000b38:	bf34      	ite	cc
 8000b3a:	2001      	movcc	r0, #1
 8000b3c:	2000      	movcs	r0, #0
 8000b3e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b42:	bf00      	nop

08000b44 <__aeabi_d2iz>:
 8000b44:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b48:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b4c:	d215      	bcs.n	8000b7a <__aeabi_d2iz+0x36>
 8000b4e:	d511      	bpl.n	8000b74 <__aeabi_d2iz+0x30>
 8000b50:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b54:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b58:	d912      	bls.n	8000b80 <__aeabi_d2iz+0x3c>
 8000b5a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b5e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000b62:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b66:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b6a:	fa23 f002 	lsr.w	r0, r3, r2
 8000b6e:	bf18      	it	ne
 8000b70:	4240      	negne	r0, r0
 8000b72:	4770      	bx	lr
 8000b74:	f04f 0000 	mov.w	r0, #0
 8000b78:	4770      	bx	lr
 8000b7a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000b7e:	d105      	bne.n	8000b8c <__aeabi_d2iz+0x48>
 8000b80:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000b84:	bf08      	it	eq
 8000b86:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000b8a:	4770      	bx	lr
 8000b8c:	f04f 0000 	mov.w	r0, #0
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop

08000b94 <__aeabi_d2f>:
 8000b94:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b98:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000b9c:	bf24      	itt	cs
 8000b9e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000ba2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000ba6:	d90d      	bls.n	8000bc4 <__aeabi_d2f+0x30>
 8000ba8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000bac:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000bb0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000bb4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000bb8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000bbc:	bf08      	it	eq
 8000bbe:	f020 0001 	biceq.w	r0, r0, #1
 8000bc2:	4770      	bx	lr
 8000bc4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000bc8:	d121      	bne.n	8000c0e <__aeabi_d2f+0x7a>
 8000bca:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000bce:	bfbc      	itt	lt
 8000bd0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000bd4:	4770      	bxlt	lr
 8000bd6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000bda:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000bde:	f1c2 0218 	rsb	r2, r2, #24
 8000be2:	f1c2 0c20 	rsb	ip, r2, #32
 8000be6:	fa10 f30c 	lsls.w	r3, r0, ip
 8000bea:	fa20 f002 	lsr.w	r0, r0, r2
 8000bee:	bf18      	it	ne
 8000bf0:	f040 0001 	orrne.w	r0, r0, #1
 8000bf4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bf8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000bfc:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c00:	ea40 000c 	orr.w	r0, r0, ip
 8000c04:	fa23 f302 	lsr.w	r3, r3, r2
 8000c08:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c0c:	e7cc      	b.n	8000ba8 <__aeabi_d2f+0x14>
 8000c0e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000c12:	d107      	bne.n	8000c24 <__aeabi_d2f+0x90>
 8000c14:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000c18:	bf1e      	ittt	ne
 8000c1a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000c1e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000c22:	4770      	bxne	lr
 8000c24:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000c28:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000c2c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c30:	4770      	bx	lr
 8000c32:	bf00      	nop

08000c34 <__aeabi_uldivmod>:
 8000c34:	b953      	cbnz	r3, 8000c4c <__aeabi_uldivmod+0x18>
 8000c36:	b94a      	cbnz	r2, 8000c4c <__aeabi_uldivmod+0x18>
 8000c38:	2900      	cmp	r1, #0
 8000c3a:	bf08      	it	eq
 8000c3c:	2800      	cmpeq	r0, #0
 8000c3e:	bf1c      	itt	ne
 8000c40:	f04f 31ff 	movne.w	r1, #4294967295
 8000c44:	f04f 30ff 	movne.w	r0, #4294967295
 8000c48:	f000 b97a 	b.w	8000f40 <__aeabi_idiv0>
 8000c4c:	f1ad 0c08 	sub.w	ip, sp, #8
 8000c50:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000c54:	f000 f806 	bl	8000c64 <__udivmoddi4>
 8000c58:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000c5c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000c60:	b004      	add	sp, #16
 8000c62:	4770      	bx	lr

08000c64 <__udivmoddi4>:
 8000c64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000c68:	468c      	mov	ip, r1
 8000c6a:	460d      	mov	r5, r1
 8000c6c:	4604      	mov	r4, r0
 8000c6e:	9e08      	ldr	r6, [sp, #32]
 8000c70:	2b00      	cmp	r3, #0
 8000c72:	d151      	bne.n	8000d18 <__udivmoddi4+0xb4>
 8000c74:	428a      	cmp	r2, r1
 8000c76:	4617      	mov	r7, r2
 8000c78:	d96d      	bls.n	8000d56 <__udivmoddi4+0xf2>
 8000c7a:	fab2 fe82 	clz	lr, r2
 8000c7e:	f1be 0f00 	cmp.w	lr, #0
 8000c82:	d00b      	beq.n	8000c9c <__udivmoddi4+0x38>
 8000c84:	f1ce 0c20 	rsb	ip, lr, #32
 8000c88:	fa01 f50e 	lsl.w	r5, r1, lr
 8000c8c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000c90:	fa02 f70e 	lsl.w	r7, r2, lr
 8000c94:	ea4c 0c05 	orr.w	ip, ip, r5
 8000c98:	fa00 f40e 	lsl.w	r4, r0, lr
 8000c9c:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000ca0:	0c25      	lsrs	r5, r4, #16
 8000ca2:	fbbc f8fa 	udiv	r8, ip, sl
 8000ca6:	fa1f f987 	uxth.w	r9, r7
 8000caa:	fb0a cc18 	mls	ip, sl, r8, ip
 8000cae:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000cb2:	fb08 f309 	mul.w	r3, r8, r9
 8000cb6:	42ab      	cmp	r3, r5
 8000cb8:	d90a      	bls.n	8000cd0 <__udivmoddi4+0x6c>
 8000cba:	19ed      	adds	r5, r5, r7
 8000cbc:	f108 32ff 	add.w	r2, r8, #4294967295
 8000cc0:	f080 8123 	bcs.w	8000f0a <__udivmoddi4+0x2a6>
 8000cc4:	42ab      	cmp	r3, r5
 8000cc6:	f240 8120 	bls.w	8000f0a <__udivmoddi4+0x2a6>
 8000cca:	f1a8 0802 	sub.w	r8, r8, #2
 8000cce:	443d      	add	r5, r7
 8000cd0:	1aed      	subs	r5, r5, r3
 8000cd2:	b2a4      	uxth	r4, r4
 8000cd4:	fbb5 f0fa 	udiv	r0, r5, sl
 8000cd8:	fb0a 5510 	mls	r5, sl, r0, r5
 8000cdc:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000ce0:	fb00 f909 	mul.w	r9, r0, r9
 8000ce4:	45a1      	cmp	r9, r4
 8000ce6:	d909      	bls.n	8000cfc <__udivmoddi4+0x98>
 8000ce8:	19e4      	adds	r4, r4, r7
 8000cea:	f100 33ff 	add.w	r3, r0, #4294967295
 8000cee:	f080 810a 	bcs.w	8000f06 <__udivmoddi4+0x2a2>
 8000cf2:	45a1      	cmp	r9, r4
 8000cf4:	f240 8107 	bls.w	8000f06 <__udivmoddi4+0x2a2>
 8000cf8:	3802      	subs	r0, #2
 8000cfa:	443c      	add	r4, r7
 8000cfc:	eba4 0409 	sub.w	r4, r4, r9
 8000d00:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000d04:	2100      	movs	r1, #0
 8000d06:	2e00      	cmp	r6, #0
 8000d08:	d061      	beq.n	8000dce <__udivmoddi4+0x16a>
 8000d0a:	fa24 f40e 	lsr.w	r4, r4, lr
 8000d0e:	2300      	movs	r3, #0
 8000d10:	6034      	str	r4, [r6, #0]
 8000d12:	6073      	str	r3, [r6, #4]
 8000d14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d18:	428b      	cmp	r3, r1
 8000d1a:	d907      	bls.n	8000d2c <__udivmoddi4+0xc8>
 8000d1c:	2e00      	cmp	r6, #0
 8000d1e:	d054      	beq.n	8000dca <__udivmoddi4+0x166>
 8000d20:	2100      	movs	r1, #0
 8000d22:	e886 0021 	stmia.w	r6, {r0, r5}
 8000d26:	4608      	mov	r0, r1
 8000d28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d2c:	fab3 f183 	clz	r1, r3
 8000d30:	2900      	cmp	r1, #0
 8000d32:	f040 808e 	bne.w	8000e52 <__udivmoddi4+0x1ee>
 8000d36:	42ab      	cmp	r3, r5
 8000d38:	d302      	bcc.n	8000d40 <__udivmoddi4+0xdc>
 8000d3a:	4282      	cmp	r2, r0
 8000d3c:	f200 80fa 	bhi.w	8000f34 <__udivmoddi4+0x2d0>
 8000d40:	1a84      	subs	r4, r0, r2
 8000d42:	eb65 0503 	sbc.w	r5, r5, r3
 8000d46:	2001      	movs	r0, #1
 8000d48:	46ac      	mov	ip, r5
 8000d4a:	2e00      	cmp	r6, #0
 8000d4c:	d03f      	beq.n	8000dce <__udivmoddi4+0x16a>
 8000d4e:	e886 1010 	stmia.w	r6, {r4, ip}
 8000d52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d56:	b912      	cbnz	r2, 8000d5e <__udivmoddi4+0xfa>
 8000d58:	2701      	movs	r7, #1
 8000d5a:	fbb7 f7f2 	udiv	r7, r7, r2
 8000d5e:	fab7 fe87 	clz	lr, r7
 8000d62:	f1be 0f00 	cmp.w	lr, #0
 8000d66:	d134      	bne.n	8000dd2 <__udivmoddi4+0x16e>
 8000d68:	1beb      	subs	r3, r5, r7
 8000d6a:	0c3a      	lsrs	r2, r7, #16
 8000d6c:	fa1f fc87 	uxth.w	ip, r7
 8000d70:	2101      	movs	r1, #1
 8000d72:	fbb3 f8f2 	udiv	r8, r3, r2
 8000d76:	0c25      	lsrs	r5, r4, #16
 8000d78:	fb02 3318 	mls	r3, r2, r8, r3
 8000d7c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000d80:	fb0c f308 	mul.w	r3, ip, r8
 8000d84:	42ab      	cmp	r3, r5
 8000d86:	d907      	bls.n	8000d98 <__udivmoddi4+0x134>
 8000d88:	19ed      	adds	r5, r5, r7
 8000d8a:	f108 30ff 	add.w	r0, r8, #4294967295
 8000d8e:	d202      	bcs.n	8000d96 <__udivmoddi4+0x132>
 8000d90:	42ab      	cmp	r3, r5
 8000d92:	f200 80d1 	bhi.w	8000f38 <__udivmoddi4+0x2d4>
 8000d96:	4680      	mov	r8, r0
 8000d98:	1aed      	subs	r5, r5, r3
 8000d9a:	b2a3      	uxth	r3, r4
 8000d9c:	fbb5 f0f2 	udiv	r0, r5, r2
 8000da0:	fb02 5510 	mls	r5, r2, r0, r5
 8000da4:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000da8:	fb0c fc00 	mul.w	ip, ip, r0
 8000dac:	45a4      	cmp	ip, r4
 8000dae:	d907      	bls.n	8000dc0 <__udivmoddi4+0x15c>
 8000db0:	19e4      	adds	r4, r4, r7
 8000db2:	f100 33ff 	add.w	r3, r0, #4294967295
 8000db6:	d202      	bcs.n	8000dbe <__udivmoddi4+0x15a>
 8000db8:	45a4      	cmp	ip, r4
 8000dba:	f200 80b8 	bhi.w	8000f2e <__udivmoddi4+0x2ca>
 8000dbe:	4618      	mov	r0, r3
 8000dc0:	eba4 040c 	sub.w	r4, r4, ip
 8000dc4:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000dc8:	e79d      	b.n	8000d06 <__udivmoddi4+0xa2>
 8000dca:	4631      	mov	r1, r6
 8000dcc:	4630      	mov	r0, r6
 8000dce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000dd2:	f1ce 0420 	rsb	r4, lr, #32
 8000dd6:	fa05 f30e 	lsl.w	r3, r5, lr
 8000dda:	fa07 f70e 	lsl.w	r7, r7, lr
 8000dde:	fa20 f804 	lsr.w	r8, r0, r4
 8000de2:	0c3a      	lsrs	r2, r7, #16
 8000de4:	fa25 f404 	lsr.w	r4, r5, r4
 8000de8:	ea48 0803 	orr.w	r8, r8, r3
 8000dec:	fbb4 f1f2 	udiv	r1, r4, r2
 8000df0:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000df4:	fb02 4411 	mls	r4, r2, r1, r4
 8000df8:	fa1f fc87 	uxth.w	ip, r7
 8000dfc:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000e00:	fb01 f30c 	mul.w	r3, r1, ip
 8000e04:	42ab      	cmp	r3, r5
 8000e06:	fa00 f40e 	lsl.w	r4, r0, lr
 8000e0a:	d909      	bls.n	8000e20 <__udivmoddi4+0x1bc>
 8000e0c:	19ed      	adds	r5, r5, r7
 8000e0e:	f101 30ff 	add.w	r0, r1, #4294967295
 8000e12:	f080 808a 	bcs.w	8000f2a <__udivmoddi4+0x2c6>
 8000e16:	42ab      	cmp	r3, r5
 8000e18:	f240 8087 	bls.w	8000f2a <__udivmoddi4+0x2c6>
 8000e1c:	3902      	subs	r1, #2
 8000e1e:	443d      	add	r5, r7
 8000e20:	1aeb      	subs	r3, r5, r3
 8000e22:	fa1f f588 	uxth.w	r5, r8
 8000e26:	fbb3 f0f2 	udiv	r0, r3, r2
 8000e2a:	fb02 3310 	mls	r3, r2, r0, r3
 8000e2e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000e32:	fb00 f30c 	mul.w	r3, r0, ip
 8000e36:	42ab      	cmp	r3, r5
 8000e38:	d907      	bls.n	8000e4a <__udivmoddi4+0x1e6>
 8000e3a:	19ed      	adds	r5, r5, r7
 8000e3c:	f100 38ff 	add.w	r8, r0, #4294967295
 8000e40:	d26f      	bcs.n	8000f22 <__udivmoddi4+0x2be>
 8000e42:	42ab      	cmp	r3, r5
 8000e44:	d96d      	bls.n	8000f22 <__udivmoddi4+0x2be>
 8000e46:	3802      	subs	r0, #2
 8000e48:	443d      	add	r5, r7
 8000e4a:	1aeb      	subs	r3, r5, r3
 8000e4c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000e50:	e78f      	b.n	8000d72 <__udivmoddi4+0x10e>
 8000e52:	f1c1 0720 	rsb	r7, r1, #32
 8000e56:	fa22 f807 	lsr.w	r8, r2, r7
 8000e5a:	408b      	lsls	r3, r1
 8000e5c:	fa05 f401 	lsl.w	r4, r5, r1
 8000e60:	ea48 0303 	orr.w	r3, r8, r3
 8000e64:	fa20 fe07 	lsr.w	lr, r0, r7
 8000e68:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000e6c:	40fd      	lsrs	r5, r7
 8000e6e:	ea4e 0e04 	orr.w	lr, lr, r4
 8000e72:	fbb5 f9fc 	udiv	r9, r5, ip
 8000e76:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000e7a:	fb0c 5519 	mls	r5, ip, r9, r5
 8000e7e:	fa1f f883 	uxth.w	r8, r3
 8000e82:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000e86:	fb09 f408 	mul.w	r4, r9, r8
 8000e8a:	42ac      	cmp	r4, r5
 8000e8c:	fa02 f201 	lsl.w	r2, r2, r1
 8000e90:	fa00 fa01 	lsl.w	sl, r0, r1
 8000e94:	d908      	bls.n	8000ea8 <__udivmoddi4+0x244>
 8000e96:	18ed      	adds	r5, r5, r3
 8000e98:	f109 30ff 	add.w	r0, r9, #4294967295
 8000e9c:	d243      	bcs.n	8000f26 <__udivmoddi4+0x2c2>
 8000e9e:	42ac      	cmp	r4, r5
 8000ea0:	d941      	bls.n	8000f26 <__udivmoddi4+0x2c2>
 8000ea2:	f1a9 0902 	sub.w	r9, r9, #2
 8000ea6:	441d      	add	r5, r3
 8000ea8:	1b2d      	subs	r5, r5, r4
 8000eaa:	fa1f fe8e 	uxth.w	lr, lr
 8000eae:	fbb5 f0fc 	udiv	r0, r5, ip
 8000eb2:	fb0c 5510 	mls	r5, ip, r0, r5
 8000eb6:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000eba:	fb00 f808 	mul.w	r8, r0, r8
 8000ebe:	45a0      	cmp	r8, r4
 8000ec0:	d907      	bls.n	8000ed2 <__udivmoddi4+0x26e>
 8000ec2:	18e4      	adds	r4, r4, r3
 8000ec4:	f100 35ff 	add.w	r5, r0, #4294967295
 8000ec8:	d229      	bcs.n	8000f1e <__udivmoddi4+0x2ba>
 8000eca:	45a0      	cmp	r8, r4
 8000ecc:	d927      	bls.n	8000f1e <__udivmoddi4+0x2ba>
 8000ece:	3802      	subs	r0, #2
 8000ed0:	441c      	add	r4, r3
 8000ed2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000ed6:	eba4 0408 	sub.w	r4, r4, r8
 8000eda:	fba0 8902 	umull	r8, r9, r0, r2
 8000ede:	454c      	cmp	r4, r9
 8000ee0:	46c6      	mov	lr, r8
 8000ee2:	464d      	mov	r5, r9
 8000ee4:	d315      	bcc.n	8000f12 <__udivmoddi4+0x2ae>
 8000ee6:	d012      	beq.n	8000f0e <__udivmoddi4+0x2aa>
 8000ee8:	b156      	cbz	r6, 8000f00 <__udivmoddi4+0x29c>
 8000eea:	ebba 030e 	subs.w	r3, sl, lr
 8000eee:	eb64 0405 	sbc.w	r4, r4, r5
 8000ef2:	fa04 f707 	lsl.w	r7, r4, r7
 8000ef6:	40cb      	lsrs	r3, r1
 8000ef8:	431f      	orrs	r7, r3
 8000efa:	40cc      	lsrs	r4, r1
 8000efc:	6037      	str	r7, [r6, #0]
 8000efe:	6074      	str	r4, [r6, #4]
 8000f00:	2100      	movs	r1, #0
 8000f02:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000f06:	4618      	mov	r0, r3
 8000f08:	e6f8      	b.n	8000cfc <__udivmoddi4+0x98>
 8000f0a:	4690      	mov	r8, r2
 8000f0c:	e6e0      	b.n	8000cd0 <__udivmoddi4+0x6c>
 8000f0e:	45c2      	cmp	sl, r8
 8000f10:	d2ea      	bcs.n	8000ee8 <__udivmoddi4+0x284>
 8000f12:	ebb8 0e02 	subs.w	lr, r8, r2
 8000f16:	eb69 0503 	sbc.w	r5, r9, r3
 8000f1a:	3801      	subs	r0, #1
 8000f1c:	e7e4      	b.n	8000ee8 <__udivmoddi4+0x284>
 8000f1e:	4628      	mov	r0, r5
 8000f20:	e7d7      	b.n	8000ed2 <__udivmoddi4+0x26e>
 8000f22:	4640      	mov	r0, r8
 8000f24:	e791      	b.n	8000e4a <__udivmoddi4+0x1e6>
 8000f26:	4681      	mov	r9, r0
 8000f28:	e7be      	b.n	8000ea8 <__udivmoddi4+0x244>
 8000f2a:	4601      	mov	r1, r0
 8000f2c:	e778      	b.n	8000e20 <__udivmoddi4+0x1bc>
 8000f2e:	3802      	subs	r0, #2
 8000f30:	443c      	add	r4, r7
 8000f32:	e745      	b.n	8000dc0 <__udivmoddi4+0x15c>
 8000f34:	4608      	mov	r0, r1
 8000f36:	e708      	b.n	8000d4a <__udivmoddi4+0xe6>
 8000f38:	f1a8 0802 	sub.w	r8, r8, #2
 8000f3c:	443d      	add	r5, r7
 8000f3e:	e72b      	b.n	8000d98 <__udivmoddi4+0x134>

08000f40 <__aeabi_idiv0>:
 8000f40:	4770      	bx	lr
 8000f42:	bf00      	nop

08000f44 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000f44:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 8000f46:	4b0a      	ldr	r3, [pc, #40]	; (8000f70 <HAL_InitTick+0x2c>)
{
 8000f48:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 8000f4a:	6818      	ldr	r0, [r3, #0]
 8000f4c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000f50:	fbb0 f0f3 	udiv	r0, r0, r3
 8000f54:	f000 fd34 	bl	80019c0 <HAL_SYSTICK_Config>
 8000f58:	4604      	mov	r4, r0
 8000f5a:	b938      	cbnz	r0, 8000f6c <HAL_InitTick+0x28>
    status = HAL_ERROR;
  }
  else
  {
    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
 8000f5c:	4602      	mov	r2, r0
 8000f5e:	4629      	mov	r1, r5
 8000f60:	f04f 30ff 	mov.w	r0, #4294967295
 8000f64:	f000 fcde 	bl	8001924 <HAL_NVIC_SetPriority>
 8000f68:	4620      	mov	r0, r4
 8000f6a:	bd38      	pop	{r3, r4, r5, pc}
    status = HAL_ERROR;
 8000f6c:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8000f6e:	bd38      	pop	{r3, r4, r5, pc}
 8000f70:	200001a0 	.word	0x200001a0

08000f74 <HAL_Init>:
{
 8000f74:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000f76:	2003      	movs	r0, #3
 8000f78:	f000 fcc2 	bl	8001900 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000f7c:	2000      	movs	r0, #0
 8000f7e:	f7ff ffe1 	bl	8000f44 <HAL_InitTick>
 8000f82:	4604      	mov	r4, r0
 8000f84:	b918      	cbnz	r0, 8000f8e <HAL_Init+0x1a>
    HAL_MspInit();
 8000f86:	f010 fce7 	bl	8011958 <HAL_MspInit>
}
 8000f8a:	4620      	mov	r0, r4
 8000f8c:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8000f8e:	2401      	movs	r4, #1
 8000f90:	e7fb      	b.n	8000f8a <HAL_Init+0x16>
	...

08000f94 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000f94:	4a02      	ldr	r2, [pc, #8]	; (8000fa0 <HAL_IncTick+0xc>)
 8000f96:	6813      	ldr	r3, [r2, #0]
 8000f98:	3301      	adds	r3, #1
 8000f9a:	6013      	str	r3, [r2, #0]
 8000f9c:	4770      	bx	lr
 8000f9e:	bf00      	nop
 8000fa0:	20084b84 	.word	0x20084b84

08000fa4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000fa4:	4b01      	ldr	r3, [pc, #4]	; (8000fac <HAL_GetTick+0x8>)
 8000fa6:	6818      	ldr	r0, [r3, #0]
}
 8000fa8:	4770      	bx	lr
 8000faa:	bf00      	nop
 8000fac:	20084b84 	.word	0x20084b84

08000fb0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000fb0:	b538      	push	{r3, r4, r5, lr}
 8000fb2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000fb4:	f7ff fff6 	bl	8000fa4 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000fb8:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000fba:	4605      	mov	r5, r0
  {
    wait++;
 8000fbc:	bf18      	it	ne
 8000fbe:	3401      	addne	r4, #1
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000fc0:	f7ff fff0 	bl	8000fa4 <HAL_GetTick>
 8000fc4:	1b40      	subs	r0, r0, r5
 8000fc6:	4284      	cmp	r4, r0
 8000fc8:	d8fa      	bhi.n	8000fc0 <HAL_Delay+0x10>
  {
  }
}
 8000fca:	bd38      	pop	{r3, r4, r5, pc}

08000fcc <LL_ADC_SetChannelSamplingTime>:
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8000fcc:	b570      	push	{r4, r5, r6, lr}
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000fce:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
 8000fd2:	fa96 f6a6 	rbit	r6, r6
  
  MODIFY_REG(*preg,
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
#else
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPRX_REGOFFSET_MASK));
 8000fd6:	fab6 f386 	clz	r3, r6
 8000fda:	f001 7600 	and.w	r6, r1, #33554432	; 0x2000000
 8000fde:	40de      	lsrs	r6, r3
 8000fe0:	3014      	adds	r0, #20
  
  MODIFY_REG(*preg,
 8000fe2:	f001 71f8 	and.w	r1, r1, #32505856	; 0x1f00000
 8000fe6:	f04f 73f8 	mov.w	r3, #32505856	; 0x1f00000
 8000fea:	fa93 f5a3 	rbit	r5, r3
 8000fee:	fab5 f585 	clz	r5, r5
 8000ff2:	fa93 f3a3 	rbit	r3, r3
 8000ff6:	2407      	movs	r4, #7
 8000ff8:	fa21 f505 	lsr.w	r5, r1, r5
 8000ffc:	fa04 f505 	lsl.w	r5, r4, r5
 8001000:	fab3 f383 	clz	r3, r3
 8001004:	f850 4026 	ldr.w	r4, [r0, r6, lsl #2]
 8001008:	40d9      	lsrs	r1, r3
 800100a:	ea24 0405 	bic.w	r4, r4, r5
 800100e:	fa02 f101 	lsl.w	r1, r2, r1
 8001012:	4321      	orrs	r1, r4
 8001014:	f840 1026 	str.w	r1, [r0, r6, lsl #2]
 8001018:	bd70      	pop	{r4, r5, r6, pc}
	...

0800101c <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 800101c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR = 0U;
  __IO uint32_t wait_loop_index = 0;
 800101e:	2300      	movs	r3, #0
 8001020:	9301      	str	r3, [sp, #4]
  
  /* Check ADC handle */
  if(hadc == NULL)
 8001022:	4604      	mov	r4, r0
 8001024:	2800      	cmp	r0, #0
 8001026:	f000 80b4 	beq.w	8001192 <HAL_ADC_Init+0x176>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if(hadc->State == HAL_ADC_STATE_RESET)
 800102a:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 800102c:	b925      	cbnz	r5, 8001038 <HAL_ADC_Init+0x1c>
  {
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 800102e:	f010 fdbb 	bl	8011ba8 <HAL_ADC_MspInit>
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8001032:	6625      	str	r5, [r4, #96]	; 0x60
    
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8001034:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
  }
  
  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if(LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0U)
 8001038:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
  return (READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD));
 800103a:	689a      	ldr	r2, [r3, #8]
 800103c:	0090      	lsls	r0, r2, #2
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 800103e:	bf41      	itttt	mi
 8001040:	689a      	ldrmi	r2, [r3, #8]
 8001042:	f022 4220 	bicmi.w	r2, r2, #2684354560	; 0xa0000000
 8001046:	f022 023f 	bicmi.w	r2, r2, #63	; 0x3f
 800104a:	609a      	strmi	r2, [r3, #8]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return (READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN));
 800104c:	689a      	ldr	r2, [r3, #8]
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor 
     re-applied once the ADC voltage regulator is enabled */    
  }
  
  if(LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0U)
 800104e:	00d1      	lsls	r1, r2, #3
 8001050:	d576      	bpl.n	8001140 <HAL_ADC_Init+0x124>
 8001052:	689a      	ldr	r2, [r3, #8]
  }
  
  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if(LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0U)
 8001054:	00d2      	lsls	r2, r2, #3
 8001056:	f140 808a 	bpl.w	800116e <HAL_ADC_Init+0x152>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800105a:	2000      	movs	r0, #0
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  if(   (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 800105c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800105e:	06d5      	lsls	r5, r2, #27
 8001060:	f100 8093 	bmi.w	800118a <HAL_ADC_Init+0x16e>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return (READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 8001064:	689a      	ldr	r2, [r3, #8]
     && (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001066:	0751      	lsls	r1, r2, #29
 8001068:	f100 808f 	bmi.w	800118a <HAL_ADC_Init+0x16e>
    )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800106c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800106e:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8001072:	f042 0202 	orr.w	r2, r2, #2
 8001076:	65e2      	str	r2, [r4, #92]	; 0x5c
    /* Configuration of common ADC parameters                                 */
    
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if ((ADC_IS_ENABLE(hadc) == RESET)   &&
 8001078:	689a      	ldr	r2, [r3, #8]
 800107a:	f002 0203 	and.w	r2, r2, #3
 800107e:	2a01      	cmp	r2, #1
 8001080:	f040 8089 	bne.w	8001196 <HAL_ADC_Init+0x17a>
 8001084:	681a      	ldr	r2, [r3, #0]
 8001086:	07d2      	lsls	r2, r2, #31
 8001088:	f140 8085 	bpl.w	8001196 <HAL_ADC_Init+0x17a>
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                           |
                hadc->Init.DataAlign                                         |
 800108c:	68e5      	ldr	r5, [r4, #12]
 800108e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
                hadc->Init.Resolution                                        |
                ADC_CFGR_REG_DISCONTINUOUS(hadc->Init.DiscontinuousConvMode)  );
 8001090:	6a61      	ldr	r1, [r4, #36]	; 0x24
                hadc->Init.DataAlign                                         |
 8001092:	432a      	orrs	r2, r5
 8001094:	68a5      	ldr	r5, [r4, #8]
 8001096:	432a      	orrs	r2, r5
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
 8001098:	69e5      	ldr	r5, [r4, #28]
    
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800109a:	2901      	cmp	r1, #1
                hadc->Init.DataAlign                                         |
 800109c:	ea42 3245 	orr.w	r2, r2, r5, lsl #13
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
 80010a0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 80010a4:	bf02      	ittt	eq
 80010a6:	6aa1      	ldreq	r1, [r4, #40]	; 0x28
 80010a8:	f101 31ff 	addeq.w	r1, r1, #4294967295
 80010ac:	ea42 4241 	orreq.w	r2, r2, r1, lsl #17
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80010b0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80010b2:	b121      	cbz	r1, 80010be <HAL_ADC_Init+0xa2>
    {
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 80010b4:	6b25      	ldr	r5, [r4, #48]	; 0x30
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80010b6:	f401 7170 	and.w	r1, r1, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 80010ba:	4329      	orrs	r1, r5
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80010bc:	430a      	orrs	r2, r1
                 );
    }
    
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR); 
 80010be:	68dd      	ldr	r5, [r3, #12]
 80010c0:	4939      	ldr	r1, [pc, #228]	; (80011a8 <HAL_ADC_Init+0x18c>)
 80010c2:	4029      	ands	r1, r5
 80010c4:	430a      	orrs	r2, r1
 80010c6:	60da      	str	r2, [r3, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 80010c8:	689a      	ldr	r2, [r3, #8]
 80010ca:	f012 0f0c 	tst.w	r2, #12
 80010ce:	d120      	bne.n	8001112 <HAL_ADC_Init+0xf6>
    {
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
                  ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
                  ADC_CFGR_DMACONTREQ(hadc->Init.DMAContinuousRequests) );
 80010d0:	6b62      	ldr	r2, [r4, #52]	; 0x34
                  ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
 80010d2:	69a5      	ldr	r5, [r4, #24]
      
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 80010d4:	68d9      	ldr	r1, [r3, #12]
                  ADC_CFGR_DMACONTREQ(hadc->Init.DMAContinuousRequests) );
 80010d6:	0052      	lsls	r2, r2, #1
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
 80010d8:	ea42 3285 	orr.w	r2, r2, r5, lsl #14
 80010dc:	6d25      	ldr	r5, [r4, #80]	; 0x50
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 80010de:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
 80010e2:	432a      	orrs	r2, r5
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 80010e4:	f021 0106 	bic.w	r1, r1, #6
 80010e8:	430a      	orrs	r2, r1
 80010ea:	60da      	str	r2, [r3, #12]
      
      if (hadc->Init.OversamplingMode == ENABLE)
 80010ec:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80010ee:	2a01      	cmp	r2, #1
 80010f0:	d147      	bne.n	8001182 <HAL_ADC_Init+0x166>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 80010f2:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80010f4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80010f6:	6919      	ldr	r1, [r3, #16]
 80010f8:	432a      	orrs	r2, r5
 80010fa:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 80010fc:	f042 0201 	orr.w	r2, r2, #1
 8001100:	432a      	orrs	r2, r5
 8001102:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 8001104:	f421 61ff 	bic.w	r1, r1, #2040	; 0x7f8
 8001108:	432a      	orrs	r2, r5
 800110a:	f021 0104 	bic.w	r1, r1, #4
 800110e:	430a      	orrs	r2, r1
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8001110:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8001112:	6922      	ldr	r2, [r4, #16]
 8001114:	2a01      	cmp	r2, #1
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001116:	bf05      	ittet	eq
 8001118:	6b19      	ldreq	r1, [r3, #48]	; 0x30
 800111a:	6a22      	ldreq	r2, [r4, #32]
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800111c:	6b1a      	ldrne	r2, [r3, #48]	; 0x30
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800111e:	f102 32ff 	addeq.w	r2, r2, #4294967295
 8001122:	bf06      	itte	eq
 8001124:	f021 010f 	biceq.w	r1, r1, #15
 8001128:	430a      	orreq	r2, r1
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800112a:	f022 020f 	bicne.w	r2, r2, #15
 800112e:	631a      	str	r2, [r3, #48]	; 0x30
    }
    
    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8001130:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001132:	f023 0303 	bic.w	r3, r3, #3
 8001136:	f043 0301 	orr.w	r3, r3, #1
 800113a:	65e3      	str	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 800113c:	b003      	add	sp, #12
 800113e:	bd30      	pop	{r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 8001140:	689a      	ldr	r2, [r3, #8]
    wait_loop_index = (LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (1000000 * 2)));
 8001142:	491a      	ldr	r1, [pc, #104]	; (80011ac <HAL_ADC_Init+0x190>)
 8001144:	f022 4210 	bic.w	r2, r2, #2415919104	; 0x90000000
 8001148:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 800114c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001150:	609a      	str	r2, [r3, #8]
 8001152:	4a17      	ldr	r2, [pc, #92]	; (80011b0 <HAL_ADC_Init+0x194>)
 8001154:	6812      	ldr	r2, [r2, #0]
 8001156:	fbb2 f1f1 	udiv	r1, r2, r1
 800115a:	220a      	movs	r2, #10
 800115c:	434a      	muls	r2, r1
      wait_loop_index--;
 800115e:	9201      	str	r2, [sp, #4]
    while(wait_loop_index != 0)
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	2a00      	cmp	r2, #0
 8001164:	f43f af75 	beq.w	8001052 <HAL_ADC_Init+0x36>
      wait_loop_index--;
 8001168:	9a01      	ldr	r2, [sp, #4]
 800116a:	3a01      	subs	r2, #1
 800116c:	e7f7      	b.n	800115e <HAL_ADC_Init+0x142>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800116e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001170:	f042 0210 	orr.w	r2, r2, #16
 8001174:	65e2      	str	r2, [r4, #92]	; 0x5c
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001176:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8001178:	f042 0201 	orr.w	r2, r2, #1
 800117c:	6622      	str	r2, [r4, #96]	; 0x60
    tmp_hal_status = HAL_ERROR;
 800117e:	2001      	movs	r0, #1
 8001180:	e76c      	b.n	800105c <HAL_ADC_Init+0x40>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8001182:	691a      	ldr	r2, [r3, #16]
 8001184:	f022 0201 	bic.w	r2, r2, #1
 8001188:	e7c2      	b.n	8001110 <HAL_ADC_Init+0xf4>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800118a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800118c:	f043 0310 	orr.w	r3, r3, #16
 8001190:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 8001192:	2001      	movs	r0, #1
 8001194:	e7d2      	b.n	800113c <HAL_ADC_Init+0x120>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001196:	4907      	ldr	r1, [pc, #28]	; (80011b4 <HAL_ADC_Init+0x198>)
 8001198:	6865      	ldr	r5, [r4, #4]
 800119a:	688a      	ldr	r2, [r1, #8]
 800119c:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 80011a0:	432a      	orrs	r2, r5
 80011a2:	608a      	str	r2, [r1, #8]
 80011a4:	e772      	b.n	800108c <HAL_ADC_Init+0x70>
 80011a6:	bf00      	nop
 80011a8:	fff0c007 	.word	0xfff0c007
 80011ac:	001e8480 	.word	0x001e8480
 80011b0:	200001a0 	.word	0x200001a0
 80011b4:	50040300 	.word	0x50040300

080011b8 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 80011b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80011ba:	6945      	ldr	r5, [r0, #20]
 80011bc:	2d08      	cmp	r5, #8
{
 80011be:	4604      	mov	r4, r0
 80011c0:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80011c2:	d00a      	beq.n	80011da <HAL_ADC_PollForConversion+0x22>
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if(ADC_IS_DUAL_REGULAR_CONVERSION_ENABLE(hadc) == RESET)
    {
      /* Check ADC DMA mode in independant mode */
      if(READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN) != RESET)
 80011c4:	6803      	ldr	r3, [r0, #0]
 80011c6:	68db      	ldr	r3, [r3, #12]
 80011c8:	07dd      	lsls	r5, r3, #31
 80011ca:	d505      	bpl.n	80011d8 <HAL_ADC_PollForConversion+0x20>
      {
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80011cc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80011ce:	f043 0320 	orr.w	r3, r3, #32
 80011d2:	65c3      	str	r3, [r0, #92]	; 0x5c
        return HAL_ERROR;
 80011d4:	2001      	movs	r0, #1
 80011d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
      else
      {
        tmp_Flag_End = (ADC_FLAG_EOC);
 80011d8:	2504      	movs	r5, #4
      }
    }
  }
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 80011da:	f7ff fee3 	bl	8000fa4 <HAL_GetTick>
 80011de:	4607      	mov	r7, r0
  
  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_End))
 80011e0:	6823      	ldr	r3, [r4, #0]
 80011e2:	681a      	ldr	r2, [r3, #0]
 80011e4:	4215      	tst	r5, r2
 80011e6:	d01d      	beq.n	8001224 <HAL_ADC_PollForConversion+0x6c>
      }
    }
  }
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80011e8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80011ea:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80011ee:	65e2      	str	r2, [r4, #92]	; 0x5c
  
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80011f0:	68da      	ldr	r2, [r3, #12]
 80011f2:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 80011f6:	d10f      	bne.n	8001218 <HAL_ADC_PollForConversion+0x60>
 80011f8:	69e2      	ldr	r2, [r4, #28]
 80011fa:	b96a      	cbnz	r2, 8001218 <HAL_ADC_PollForConversion+0x60>
     (hadc->Init.ContinuousConvMode == DISABLE)   )
  {
    /* Check whether end of sequence is reached */
    if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 80011fc:	681a      	ldr	r2, [r3, #0]
 80011fe:	0711      	lsls	r1, r2, #28
 8001200:	d50a      	bpl.n	8001218 <HAL_ADC_PollForConversion+0x60>
    {
      /* Set ADC state */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8001202:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001204:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001208:	65e2      	str	r2, [r4, #92]	; 0x5c
      
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800120a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800120c:	04d2      	lsls	r2, r2, #19
      { 
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 800120e:	bf5e      	ittt	pl
 8001210:	6de2      	ldrpl	r2, [r4, #92]	; 0x5c
 8001212:	f042 0201 	orrpl.w	r2, r2, #1
 8001216:	65e2      	strpl	r2, [r4, #92]	; 0x5c
    tmpADC_Master = ADC_MASTER_REGISTER(hadc);
    tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
  }
  
  /* Clear polled flag */
  if (tmp_Flag_End == ADC_FLAG_EOS)
 8001218:	2d08      	cmp	r5, #8
    tmp_cfgr = READ_REG(hadc->Instance->CFGR);  
 800121a:	68d8      	ldr	r0, [r3, #12]
  if (tmp_Flag_End == ADC_FLAG_EOS)
 800121c:	d114      	bne.n	8001248 <HAL_ADC_PollForConversion+0x90>
  {
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOS);  
 800121e:	601d      	str	r5, [r3, #0]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
    }
  }
  
  /* Return function status */
  return HAL_OK;
 8001220:	2000      	movs	r0, #0
}
 8001222:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(Timeout != HAL_MAX_DELAY)
 8001224:	1c70      	adds	r0, r6, #1
 8001226:	d0dc      	beq.n	80011e2 <HAL_ADC_PollForConversion+0x2a>
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8001228:	b946      	cbnz	r6, 800123c <HAL_ADC_PollForConversion+0x84>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 800122a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800122c:	f043 0304 	orr.w	r3, r3, #4
 8001230:	65e3      	str	r3, [r4, #92]	; 0x5c
        __HAL_UNLOCK(hadc);
 8001232:	2300      	movs	r3, #0
 8001234:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        return HAL_TIMEOUT;
 8001238:	2003      	movs	r0, #3
 800123a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 800123c:	f7ff feb2 	bl	8000fa4 <HAL_GetTick>
 8001240:	1bc0      	subs	r0, r0, r7
 8001242:	4286      	cmp	r6, r0
 8001244:	d2cc      	bcs.n	80011e0 <HAL_ADC_PollForConversion+0x28>
 8001246:	e7f0      	b.n	800122a <HAL_ADC_PollForConversion+0x72>
    if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == RESET)
 8001248:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
 800124c:	d1e8      	bne.n	8001220 <HAL_ADC_PollForConversion+0x68>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 800124e:	220c      	movs	r2, #12
 8001250:	601a      	str	r2, [r3, #0]
 8001252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001254 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8001254:	6803      	ldr	r3, [r0, #0]
 8001256:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 8001258:	4770      	bx	lr
	...

0800125c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 800125c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpOffsetShifted;
  __IO uint32_t wait_loop_index = 0;
 800125e:	2300      	movs	r3, #0
 8001260:	9301      	str	r3, [sp, #4]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001262:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 8001266:	2b01      	cmp	r3, #1
{
 8001268:	4605      	mov	r5, r0
 800126a:	460c      	mov	r4, r1
  __HAL_LOCK(hadc);
 800126c:	f000 8168 	beq.w	8001540 <HAL_ADC_ConfigChannel+0x2e4>
 8001270:	2301      	movs	r3, #1
 8001272:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001276:	6800      	ldr	r0, [r0, #0]
  return (READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 8001278:	6882      	ldr	r2, [r0, #8]
 800127a:	0757      	lsls	r7, r2, #29
 800127c:	f100 815a 	bmi.w	8001534 <HAL_ADC_ConfigChannel+0x2d8>
    /* Correspondance for compatibility with legacy definition of             */
    /* sequencer ranks in direct number format. This correspondance can       */
    /* be done only on ranks 1 to 5 due to literal values.                    */
    /* Note: Sequencer ranks in direct number format are no more used         */
    /*       and are detected by activating USE_FULL_ASSERT feature.          */
    if (sConfig->Rank <= 5U)
 8001280:	684b      	ldr	r3, [r1, #4]
 8001282:	2b05      	cmp	r3, #5
 8001284:	d808      	bhi.n	8001298 <HAL_ADC_ConfigChannel+0x3c>
    {
      switch (sConfig->Rank)
 8001286:	3b02      	subs	r3, #2
 8001288:	2b03      	cmp	r3, #3
 800128a:	d864      	bhi.n	8001356 <HAL_ADC_ConfigChannel+0xfa>
 800128c:	e8df f003 	tbb	[pc, r3]
 8001290:	605e5c02 	.word	0x605e5c02
      {
        case 2U: sConfig->Rank = ADC_REGULAR_RANK_2; break;
 8001294:	230c      	movs	r3, #12
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
        /* case 1U */
        default: sConfig->Rank = ADC_REGULAR_RANK_1;
 8001296:	6063      	str	r3, [r4, #4]
      }
    }
    #endif
    
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8001298:	6861      	ldr	r1, [r4, #4]
 800129a:	f44f 7340 	mov.w	r3, #768	; 0x300
 800129e:	fa93 f3a3 	rbit	r3, r3
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
 80012a2:	fab3 f383 	clz	r3, r3
 80012a6:	f401 7640 	and.w	r6, r1, #768	; 0x300
 80012aa:	40de      	lsrs	r6, r3
 80012ac:	f100 0730 	add.w	r7, r0, #48	; 0x30
  MODIFY_REG(*preg,
 80012b0:	f001 011f 	and.w	r1, r1, #31
 80012b4:	231f      	movs	r3, #31
 80012b6:	fa03 f201 	lsl.w	r2, r3, r1
 80012ba:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 80012be:	ea23 0302 	bic.w	r3, r3, r2
 80012c2:	6822      	ldr	r2, [r4, #0]
 80012c4:	f3c2 6284 	ubfx	r2, r2, #26, #5
 80012c8:	408a      	lsls	r2, r1
 80012ca:	4313      	orrs	r3, r2
 80012cc:	f847 3026 	str.w	r3, [r7, r6, lsl #2]
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 80012d0:	6882      	ldr	r2, [r0, #8]
 80012d2:	f012 020c 	ands.w	r2, r2, #12
 80012d6:	d126      	bne.n	8001326 <HAL_ADC_ConfigChannel+0xca>
    {
#if defined(ADC_SMPR1_SMPPLUS)
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if(sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80012d8:	68a3      	ldr	r3, [r4, #8]
 80012da:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80012de:	d13c      	bne.n	800135a <HAL_ADC_ConfigChannel+0xfe>
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80012e0:	6821      	ldr	r1, [r4, #0]
 80012e2:	f7ff fe73 	bl	8000fcc <LL_ADC_SetChannelSamplingTime>
        
        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 80012e6:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80012e8:	6953      	ldr	r3, [r2, #20]
 80012ea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80012ee:	6153      	str	r3, [r2, #20]

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
     
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80012f0:	6926      	ldr	r6, [r4, #16]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 80012f2:	f8d5 e000 	ldr.w	lr, [r5]
 80012f6:	6823      	ldr	r3, [r4, #0]
 80012f8:	f8de 100c 	ldr.w	r1, [lr, #12]
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80012fc:	2e04      	cmp	r6, #4
 80012fe:	f10e 0260 	add.w	r2, lr, #96	; 0x60
 8001302:	d033      	beq.n	800136c <HAL_ADC_ConfigChannel+0x110>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 8001304:	f3c1 01c1 	ubfx	r1, r1, #3, #2
 8001308:	0048      	lsls	r0, r1, #1
 800130a:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(*preg,
 800130c:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 8001310:	4081      	lsls	r1, r0
 8001312:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001316:	4319      	orrs	r1, r3
 8001318:	f852 0026 	ldr.w	r0, [r2, r6, lsl #2]
 800131c:	4bc5      	ldr	r3, [pc, #788]	; (8001634 <HAL_ADC_ConfigChannel+0x3d8>)
 800131e:	4003      	ands	r3, r0
 8001320:	4319      	orrs	r1, r3
 8001322:	f842 1026 	str.w	r1, [r2, r6, lsl #2]
    
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (ADC_IS_ENABLE(hadc) == RESET)
 8001326:	6828      	ldr	r0, [r5, #0]
 8001328:	6883      	ldr	r3, [r0, #8]
 800132a:	f003 0303 	and.w	r3, r3, #3
 800132e:	2b01      	cmp	r3, #1
 8001330:	f040 8108 	bne.w	8001544 <HAL_ADC_ConfigChannel+0x2e8>
 8001334:	6803      	ldr	r3, [r0, #0]
 8001336:	07de      	lsls	r6, r3, #31
 8001338:	f140 8104 	bpl.w	8001544 <HAL_ADC_ConfigChannel+0x2e8>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800133c:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800133e:	2300      	movs	r3, #0
 8001340:	f885 3058 	strb.w	r3, [r5, #88]	; 0x58
  
  /* Return function status */
  return tmp_hal_status;
}
 8001344:	b003      	add	sp, #12
 8001346:	bdf0      	pop	{r4, r5, r6, r7, pc}
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
 8001348:	2312      	movs	r3, #18
 800134a:	e7a4      	b.n	8001296 <HAL_ADC_ConfigChannel+0x3a>
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
 800134c:	2318      	movs	r3, #24
 800134e:	e7a2      	b.n	8001296 <HAL_ADC_ConfigChannel+0x3a>
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
 8001350:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001354:	e79f      	b.n	8001296 <HAL_ADC_ConfigChannel+0x3a>
        default: sConfig->Rank = ADC_REGULAR_RANK_1;
 8001356:	2306      	movs	r3, #6
 8001358:	e79d      	b.n	8001296 <HAL_ADC_ConfigChannel+0x3a>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800135a:	461a      	mov	r2, r3
 800135c:	6821      	ldr	r1, [r4, #0]
 800135e:	f7ff fe35 	bl	8000fcc <LL_ADC_SetChannelSamplingTime>
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 8001362:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8001364:	6953      	ldr	r3, [r2, #20]
 8001366:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800136a:	e7c0      	b.n	80012ee <HAL_ADC_ConfigChannel+0x92>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800136c:	f8de 1060 	ldr.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001370:	f3c3 0012 	ubfx	r0, r3, #0, #19
 8001374:	f3c1 6784 	ubfx	r7, r1, #26, #5
 8001378:	f10e 0664 	add.w	r6, lr, #100	; 0x64
 800137c:	2800      	cmp	r0, #0
 800137e:	d13a      	bne.n	80013f6 <HAL_ADC_ConfigChannel+0x19a>
 8001380:	f3c3 6084 	ubfx	r0, r3, #26, #5
 8001384:	4287      	cmp	r7, r0
 8001386:	f040 8149 	bne.w	800161c <HAL_ADC_ConfigChannel+0x3c0>
  MODIFY_REG(*preg,
 800138a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800138e:	f8ce 1060 	str.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001392:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001394:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
 8001398:	f3c3 0712 	ubfx	r7, r3, #0, #19
 800139c:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80013a0:	bb9f      	cbnz	r7, 800140a <HAL_ADC_ConfigChannel+0x1ae>
 80013a2:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80013a6:	4283      	cmp	r3, r0
 80013a8:	f040 813d 	bne.w	8001626 <HAL_ADC_ConfigChannel+0x3ca>
  MODIFY_REG(*preg,
 80013ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80013b0:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80013b2:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80013b4:	6891      	ldr	r1, [r2, #8]
 80013b6:	f3c3 0712 	ubfx	r7, r3, #0, #19
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80013ba:	f102 0608 	add.w	r6, r2, #8
 80013be:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80013c2:	bb77      	cbnz	r7, 8001422 <HAL_ADC_ConfigChannel+0x1c6>
 80013c4:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80013c8:	4283      	cmp	r3, r0
 80013ca:	f040 8147 	bne.w	800165c <HAL_ADC_ConfigChannel+0x400>
  MODIFY_REG(*preg,
 80013ce:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80013d2:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80013d4:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80013d6:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80013da:	68d2      	ldr	r2, [r2, #12]
 80013dc:	f3c3 0612 	ubfx	r6, r3, #0, #19
 80013e0:	f3c2 6184 	ubfx	r1, r2, #26, #5
 80013e4:	bb4e      	cbnz	r6, 800143a <HAL_ADC_ConfigChannel+0x1de>
 80013e6:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80013ea:	428b      	cmp	r3, r1
  MODIFY_REG(*preg,
 80013ec:	bf04      	itt	eq
 80013ee:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 80013f2:	6002      	streq	r2, [r0, #0]
 80013f4:	e797      	b.n	8001326 <HAL_ADC_ConfigChannel+0xca>
 80013f6:	fa93 f0a3 	rbit	r0, r3
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80013fa:	fab0 f080 	clz	r0, r0
 80013fe:	4287      	cmp	r7, r0
 8001400:	d0c3      	beq.n	800138a <HAL_ADC_ConfigChannel+0x12e>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001402:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001406:	f3c1 6084 	ubfx	r0, r1, #26, #5
 800140a:	fa93 f3a3 	rbit	r3, r3
 800140e:	fab3 f383 	clz	r3, r3
 8001412:	4283      	cmp	r3, r0
 8001414:	d0ca      	beq.n	80013ac <HAL_ADC_ConfigChannel+0x150>
 8001416:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001418:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800141a:	f102 0608 	add.w	r6, r2, #8
 800141e:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001422:	fa93 f3a3 	rbit	r3, r3
 8001426:	fab3 f383 	clz	r3, r3
 800142a:	4283      	cmp	r3, r0
 800142c:	d0cf      	beq.n	80013ce <HAL_ADC_ConfigChannel+0x172>
 800142e:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001432:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001434:	6823      	ldr	r3, [r4, #0]
 8001436:	f3c2 6184 	ubfx	r1, r2, #26, #5
 800143a:	fa93 f3a3 	rbit	r3, r3
 800143e:	fab3 f383 	clz	r3, r3
 8001442:	e7d2      	b.n	80013ea <HAL_ADC_ConfigChannel+0x18e>
 8001444:	fa93 f2a3 	rbit	r2, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL(__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1), sConfig->SamplingTime);
 8001448:	fab2 f282 	clz	r2, r2
 800144c:	3201      	adds	r2, #1
 800144e:	2a09      	cmp	r2, #9
 8001450:	d90d      	bls.n	800146e <HAL_ADC_ConfigChannel+0x212>
 8001452:	fa93 f2a3 	rbit	r2, r3
 8001456:	fab2 f282 	clz	r2, r2
 800145a:	3201      	adds	r2, #1
 800145c:	0696      	lsls	r6, r2, #26
 800145e:	fa93 f1a3 	rbit	r1, r3
 8001462:	fab1 f181 	clz	r1, r1
 8001466:	1c4a      	adds	r2, r1, #1
 8001468:	2101      	movs	r1, #1
 800146a:	4091      	lsls	r1, r2
 800146c:	e016      	b.n	800149c <HAL_ADC_ConfigChannel+0x240>
 800146e:	fa93 f2a3 	rbit	r2, r3
 8001472:	fab2 f282 	clz	r2, r2
 8001476:	3201      	adds	r2, #1
 8001478:	0692      	lsls	r2, r2, #26
 800147a:	fa93 f1a3 	rbit	r1, r3
 800147e:	fab1 f181 	clz	r1, r1
 8001482:	1c4e      	adds	r6, r1, #1
 8001484:	2101      	movs	r1, #1
 8001486:	40b1      	lsls	r1, r6
 8001488:	e07f      	b.n	800158a <HAL_ADC_ConfigChannel+0x32e>
 800148a:	fa93 f1a3 	rbit	r1, r3
 800148e:	fab1 f181 	clz	r1, r1
 8001492:	3101      	adds	r1, #1
 8001494:	e080      	b.n	8001598 <HAL_ADC_ConfigChannel+0x33c>
 8001496:	4616      	mov	r6, r2
 8001498:	fa01 f10e 	lsl.w	r1, r1, lr
 800149c:	ea41 0206 	orr.w	r2, r1, r6
 80014a0:	b94f      	cbnz	r7, 80014b6 <HAL_ADC_ConfigChannel+0x25a>
 80014a2:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80014a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80014aa:	f1a3 011b 	sub.w	r1, r3, #27
 80014ae:	0509      	lsls	r1, r1, #20
 80014b0:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80014b4:	e073      	b.n	800159e <HAL_ADC_ConfigChannel+0x342>
 80014b6:	fa93 f3a3 	rbit	r3, r3
 80014ba:	fab3 f383 	clz	r3, r3
 80014be:	e7f2      	b.n	80014a6 <HAL_ADC_ConfigChannel+0x24a>
            ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0U)) ||
 80014c0:	4b5d      	ldr	r3, [pc, #372]	; (8001638 <HAL_ADC_ConfigChannel+0x3dc>)
 80014c2:	429a      	cmp	r2, r3
 80014c4:	d104      	bne.n	80014d0 <HAL_ADC_ConfigChannel+0x274>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80014c6:	4b5d      	ldr	r3, [pc, #372]	; (800163c <HAL_ADC_ConfigChannel+0x3e0>)
 80014c8:	689b      	ldr	r3, [r3, #8]
          ( (sConfig->Channel == ADC_CHANNEL_VBAT)       &&
 80014ca:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 80014ce:	e072      	b.n	80015b6 <HAL_ADC_ConfigChannel+0x35a>
            ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_VBAT) == 0U))       ||
 80014d0:	4b5b      	ldr	r3, [pc, #364]	; (8001640 <HAL_ADC_ConfigChannel+0x3e4>)
 80014d2:	429a      	cmp	r2, r3
 80014d4:	f47f af32 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
 80014d8:	4b58      	ldr	r3, [pc, #352]	; (800163c <HAL_ADC_ConfigChannel+0x3e0>)
 80014da:	689b      	ldr	r3, [r3, #8]
          ( (sConfig->Channel == ADC_CHANNEL_VREFINT)    &&
 80014dc:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80014e0:	e069      	b.n	80015b6 <HAL_ADC_ConfigChannel+0x35a>
          else if (sConfig->Channel == ADC_CHANNEL_VBAT)
 80014e2:	4955      	ldr	r1, [pc, #340]	; (8001638 <HAL_ADC_ConfigChannel+0x3dc>)
 80014e4:	428a      	cmp	r2, r1
 80014e6:	d111      	bne.n	800150c <HAL_ADC_ConfigChannel+0x2b0>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80014e8:	4a56      	ldr	r2, [pc, #344]	; (8001644 <HAL_ADC_ConfigChannel+0x3e8>)
 80014ea:	4293      	cmp	r3, r2
 80014ec:	f47f af26 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
 80014f0:	f8d2 1308 	ldr.w	r1, [r2, #776]	; 0x308
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80014f4:	f8d2 3308 	ldr.w	r3, [r2, #776]	; 0x308
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80014f8:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80014fc:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8001500:	430b      	orrs	r3, r1
 8001502:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001506:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
 800150a:	e717      	b.n	800133c <HAL_ADC_ConfigChannel+0xe0>
          else if (sConfig->Channel == ADC_CHANNEL_VREFINT)
 800150c:	494c      	ldr	r1, [pc, #304]	; (8001640 <HAL_ADC_ConfigChannel+0x3e4>)
 800150e:	428a      	cmp	r2, r1
 8001510:	f47f af14 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
            if (ADC_VREFINT_INSTANCE(hadc))
 8001514:	4a4b      	ldr	r2, [pc, #300]	; (8001644 <HAL_ADC_ConfigChannel+0x3e8>)
 8001516:	4293      	cmp	r3, r2
 8001518:	f47f af10 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800151c:	f8d2 1308 	ldr.w	r1, [r2, #776]	; 0x308
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001520:	f8d2 3308 	ldr.w	r3, [r2, #776]	; 0x308
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001524:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001528:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 800152c:	430b      	orrs	r3, r1
 800152e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001532:	e7e8      	b.n	8001506 <HAL_ADC_ConfigChannel+0x2aa>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001534:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8001536:	f042 0220 	orr.w	r2, r2, #32
 800153a:	65ea      	str	r2, [r5, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
 800153c:	4618      	mov	r0, r3
 800153e:	e6fe      	b.n	800133e <HAL_ADC_ConfigChannel+0xe2>
  __HAL_LOCK(hadc);
 8001540:	2002      	movs	r0, #2
 8001542:	e6ff      	b.n	8001344 <HAL_ADC_ConfigChannel+0xe8>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8001544:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(ADCx->DIFSEL,
 8001546:	4a40      	ldr	r2, [pc, #256]	; (8001648 <HAL_ADC_ConfigChannel+0x3ec>)
 8001548:	f8d0 60b0 	ldr.w	r6, [r0, #176]	; 0xb0
 800154c:	6823      	ldr	r3, [r4, #0]
 800154e:	f001 0e20 	and.w	lr, r1, #32
 8001552:	fa02 f20e 	lsl.w	r2, r2, lr
 8001556:	f3c3 0712 	ubfx	r7, r3, #0, #19
 800155a:	4072      	eors	r2, r6
 800155c:	403a      	ands	r2, r7
 800155e:	4072      	eors	r2, r6
 8001560:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8001564:	4a39      	ldr	r2, [pc, #228]	; (800164c <HAL_ADC_ConfigChannel+0x3f0>)
 8001566:	4291      	cmp	r1, r2
 8001568:	d11d      	bne.n	80015a6 <HAL_ADC_ConfigChannel+0x34a>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL(__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1), sConfig->SamplingTime);
 800156a:	2f00      	cmp	r7, #0
 800156c:	f47f af6a 	bne.w	8001444 <HAL_ADC_ConfigChannel+0x1e8>
 8001570:	f3c3 6184 	ubfx	r1, r3, #26, #5
 8001574:	f101 0e01 	add.w	lr, r1, #1
 8001578:	f1be 0f09 	cmp.w	lr, #9
 800157c:	f04f 0101 	mov.w	r1, #1
 8001580:	ea4f 628e 	mov.w	r2, lr, lsl #26
 8001584:	d887      	bhi.n	8001496 <HAL_ADC_ConfigChannel+0x23a>
 8001586:	fa01 f10e 	lsl.w	r1, r1, lr
 800158a:	430a      	orrs	r2, r1
 800158c:	2f00      	cmp	r7, #0
 800158e:	f47f af7c 	bne.w	800148a <HAL_ADC_ConfigChannel+0x22e>
 8001592:	f3c3 6384 	ubfx	r3, r3, #26, #5
 8001596:	1c59      	adds	r1, r3, #1
 8001598:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800159c:	0509      	lsls	r1, r1, #20
 800159e:	4311      	orrs	r1, r2
 80015a0:	68a2      	ldr	r2, [r4, #8]
 80015a2:	f7ff fd13 	bl	8000fcc <LL_ADC_SetChannelSamplingTime>
      if (( (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 80015a6:	6822      	ldr	r2, [r4, #0]
 80015a8:	4b29      	ldr	r3, [pc, #164]	; (8001650 <HAL_ADC_ConfigChannel+0x3f4>)
 80015aa:	429a      	cmp	r2, r3
 80015ac:	d188      	bne.n	80014c0 <HAL_ADC_ConfigChannel+0x264>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80015ae:	4b23      	ldr	r3, [pc, #140]	; (800163c <HAL_ADC_ConfigChannel+0x3e0>)
 80015b0:	689b      	ldr	r3, [r3, #8]
 80015b2:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
          ( (sConfig->Channel == ADC_CHANNEL_VREFINT)    &&
 80015b6:	f47f aec1 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
        if ((ADC_IS_ENABLE(hadc) == RESET)   &&
 80015ba:	682b      	ldr	r3, [r5, #0]
 80015bc:	6898      	ldr	r0, [r3, #8]
 80015be:	f000 0003 	and.w	r0, r0, #3
 80015c2:	2801      	cmp	r0, #1
 80015c4:	d102      	bne.n	80015cc <HAL_ADC_ConfigChannel+0x370>
 80015c6:	6819      	ldr	r1, [r3, #0]
 80015c8:	07c9      	lsls	r1, r1, #31
 80015ca:	d422      	bmi.n	8001612 <HAL_ADC_ConfigChannel+0x3b6>
          if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80015cc:	4920      	ldr	r1, [pc, #128]	; (8001650 <HAL_ADC_ConfigChannel+0x3f4>)
 80015ce:	428a      	cmp	r2, r1
 80015d0:	d187      	bne.n	80014e2 <HAL_ADC_ConfigChannel+0x286>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc)) 
 80015d2:	4a1c      	ldr	r2, [pc, #112]	; (8001644 <HAL_ADC_ConfigChannel+0x3e8>)
 80015d4:	4293      	cmp	r3, r2
 80015d6:	f47f aeb1 	bne.w	800133c <HAL_ADC_ConfigChannel+0xe0>
 80015da:	f8d2 1308 	ldr.w	r1, [r2, #776]	; 0x308
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80015de:	f8d2 3308 	ldr.w	r3, [r2, #776]	; 0x308
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80015e2:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80015e6:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 80015ea:	430b      	orrs	r3, r1
 80015ec:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80015f0:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
              wait_loop_index = (LL_ADC_DELAY_TEMPSENSOR_STAB_US * (SystemCoreClock / (1000000 * 2)));
 80015f4:	4b17      	ldr	r3, [pc, #92]	; (8001654 <HAL_ADC_ConfigChannel+0x3f8>)
 80015f6:	4a18      	ldr	r2, [pc, #96]	; (8001658 <HAL_ADC_ConfigChannel+0x3fc>)
 80015f8:	681b      	ldr	r3, [r3, #0]
 80015fa:	fbb3 f2f2 	udiv	r2, r3, r2
 80015fe:	2378      	movs	r3, #120	; 0x78
 8001600:	4353      	muls	r3, r2
                wait_loop_index--;
 8001602:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0)
 8001604:	9b01      	ldr	r3, [sp, #4]
 8001606:	2b00      	cmp	r3, #0
 8001608:	f43f ae98 	beq.w	800133c <HAL_ADC_ConfigChannel+0xe0>
                wait_loop_index--;
 800160c:	9b01      	ldr	r3, [sp, #4]
 800160e:	3b01      	subs	r3, #1
 8001610:	e7f7      	b.n	8001602 <HAL_ADC_ConfigChannel+0x3a6>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001612:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 8001614:	f043 0320 	orr.w	r3, r3, #32
 8001618:	65eb      	str	r3, [r5, #92]	; 0x5c
 800161a:	e690      	b.n	800133e <HAL_ADC_ConfigChannel+0xe2>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800161c:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001620:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001624:	e6bd      	b.n	80013a2 <HAL_ADC_ConfigChannel+0x146>
 8001626:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001628:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800162a:	f102 0608 	add.w	r6, r2, #8
 800162e:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001632:	e6c7      	b.n	80013c4 <HAL_ADC_ConfigChannel+0x168>
 8001634:	03fff000 	.word	0x03fff000
 8001638:	cb840000 	.word	0xcb840000
 800163c:	50040300 	.word	0x50040300
 8001640:	80000001 	.word	0x80000001
 8001644:	50040000 	.word	0x50040000
 8001648:	0007ffff 	.word	0x0007ffff
 800164c:	407f0000 	.word	0x407f0000
 8001650:	c7520000 	.word	0xc7520000
 8001654:	200001a0 	.word	0x200001a0
 8001658:	001e8480 	.word	0x001e8480
 800165c:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001660:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001662:	6823      	ldr	r3, [r4, #0]
 8001664:	f3c2 6184 	ubfx	r1, r2, #26, #5
 8001668:	e6bd      	b.n	80013e6 <HAL_ADC_ConfigChannel+0x18a>
 800166a:	bf00      	nop

0800166c <ADC_ConversionStop>:
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));
    
  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc))
 800166c:	6803      	ldr	r3, [r0, #0]
 800166e:	689a      	ldr	r2, [r3, #8]
 8001670:	f012 0f0c 	tst.w	r2, #12
{
 8001674:	b570      	push	{r4, r5, r6, lr}
 8001676:	4604      	mov	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc))
 8001678:	d101      	bne.n	800167e <ADC_ConversionStop+0x12>
    }
    
  }
  
  /* Return HAL status */
  return HAL_OK;
 800167a:	2000      	movs	r0, #0
 800167c:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_IS_BIT_SET(hadc->Instance->CFGR, ADC_CFGR_JAUTO)) 
 800167e:	68da      	ldr	r2, [r3, #12]
 8001680:	0190      	lsls	r0, r2, #6
 8001682:	d52a      	bpl.n	80016da <ADC_ConversionStop+0x6e>
         && (hadc->Init.ContinuousConvMode==ENABLE) 
 8001684:	69e2      	ldr	r2, [r4, #28]
 8001686:	2a01      	cmp	r2, #1
 8001688:	d127      	bne.n	80016da <ADC_ConversionStop+0x6e>
         && (hadc->Init.LowPowerAutoWait==ENABLE))
 800168a:	69a2      	ldr	r2, [r4, #24]
 800168c:	2a01      	cmp	r2, #1
 800168e:	d124      	bne.n	80016da <ADC_ConversionStop+0x6e>
 8001690:	4a22      	ldr	r2, [pc, #136]	; (800171c <ADC_ConversionStop+0xb0>)
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == RESET)
 8001692:	6819      	ldr	r1, [r3, #0]
 8001694:	0649      	lsls	r1, r1, #25
 8001696:	d514      	bpl.n	80016c2 <ADC_ConversionStop+0x56>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
 8001698:	2240      	movs	r2, #64	; 0x40
 800169a:	601a      	str	r2, [r3, #0]
      ConversionGroup = ADC_REGULAR_GROUP;
 800169c:	2101      	movs	r1, #1
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADSTART) && 
 800169e:	689a      	ldr	r2, [r3, #8]
 80016a0:	0756      	lsls	r6, r2, #29
 80016a2:	d50a      	bpl.n	80016ba <ADC_ConversionStop+0x4e>
          HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADDIS)     )
 80016a4:	689a      	ldr	r2, [r3, #8]
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADSTART) && 
 80016a6:	0795      	lsls	r5, r2, #30
 80016a8:	d407      	bmi.n	80016ba <ADC_ConversionStop+0x4e>
  MODIFY_REG(ADCx->CR,
 80016aa:	689a      	ldr	r2, [r3, #8]
 80016ac:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80016b0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80016b4:	f042 0210 	orr.w	r2, r2, #16
 80016b8:	609a      	str	r2, [r3, #8]
    if (ConversionGroup != ADC_REGULAR_GROUP)
 80016ba:	2901      	cmp	r1, #1
 80016bc:	d10f      	bne.n	80016de <ADC_ConversionStop+0x72>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
 80016be:	2504      	movs	r5, #4
        break;
 80016c0:	e01e      	b.n	8001700 <ADC_ConversionStop+0x94>
        if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES *4))
 80016c2:	3a01      	subs	r2, #1
 80016c4:	d1e5      	bne.n	8001692 <ADC_ConversionStop+0x26>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80016c6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80016c8:	f043 0310 	orr.w	r3, r3, #16
 80016cc:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80016ce:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80016d0:	f043 0301 	orr.w	r3, r3, #1
 80016d4:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 80016d6:	2001      	movs	r0, #1
 80016d8:	bd70      	pop	{r4, r5, r6, pc}
    if (ConversionGroup != ADC_INJECTED_GROUP)
 80016da:	2902      	cmp	r1, #2
 80016dc:	d1df      	bne.n	800169e <ADC_ConversionStop+0x32>
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_JADSTART) && 
 80016de:	689a      	ldr	r2, [r3, #8]
 80016e0:	0710      	lsls	r0, r2, #28
 80016e2:	d506      	bpl.n	80016f2 <ADC_ConversionStop+0x86>
          HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADDIS)      )
 80016e4:	689a      	ldr	r2, [r3, #8]
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_JADSTART) && 
 80016e6:	0792      	lsls	r2, r2, #30
        SET_BIT(hadc->Instance->CR, ADC_CR_JADSTP);
 80016e8:	bf5e      	ittt	pl
 80016ea:	689a      	ldrpl	r2, [r3, #8]
 80016ec:	f042 0220 	orrpl.w	r2, r2, #32
 80016f0:	609a      	strpl	r2, [r3, #8]
    switch(ConversionGroup)
 80016f2:	2902      	cmp	r1, #2
 80016f4:	d003      	beq.n	80016fe <ADC_ConversionStop+0x92>
 80016f6:	2903      	cmp	r1, #3
 80016f8:	d1e1      	bne.n	80016be <ADC_ConversionStop+0x52>
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
 80016fa:	250c      	movs	r5, #12
 80016fc:	e000      	b.n	8001700 <ADC_ConversionStop+0x94>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
 80016fe:	2508      	movs	r5, #8
    tickstart = HAL_GetTick();
 8001700:	f7ff fc50 	bl	8000fa4 <HAL_GetTick>
 8001704:	4606      	mov	r6, r0
    while((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != RESET)
 8001706:	6823      	ldr	r3, [r4, #0]
 8001708:	689b      	ldr	r3, [r3, #8]
 800170a:	421d      	tst	r5, r3
 800170c:	d0b5      	beq.n	800167a <ADC_ConversionStop+0xe>
      if((HAL_GetTick()-tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 800170e:	f7ff fc49 	bl	8000fa4 <HAL_GetTick>
 8001712:	1b80      	subs	r0, r0, r6
 8001714:	2805      	cmp	r0, #5
 8001716:	d9f6      	bls.n	8001706 <ADC_ConversionStop+0x9a>
 8001718:	e7d5      	b.n	80016c6 <ADC_ConversionStop+0x5a>
 800171a:	bf00      	nop
 800171c:	0a340001 	.word	0x0a340001

08001720 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
 8001720:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0;
  __IO uint32_t wait_loop_index = 0;
 8001722:	2300      	movs	r3, #0
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8001724:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0;
 8001726:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8001728:	6893      	ldr	r3, [r2, #8]
 800172a:	f003 0303 	and.w	r3, r3, #3
 800172e:	2b01      	cmp	r3, #1
{
 8001730:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 8001732:	d108      	bne.n	8001746 <ADC_Enable+0x26>
 8001734:	6813      	ldr	r3, [r2, #0]
 8001736:	07d8      	lsls	r0, r3, #31
 8001738:	d505      	bpl.n	8001746 <ADC_Enable+0x26>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 800173a:	2000      	movs	r0, #0
}
 800173c:	b002      	add	sp, #8
 800173e:	bd70      	pop	{r4, r5, r6, pc}
      wait_loop_index--;
 8001740:	9b01      	ldr	r3, [sp, #4]
 8001742:	3b01      	subs	r3, #1
 8001744:	e012      	b.n	800176c <ADC_Enable+0x4c>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8001746:	6891      	ldr	r1, [r2, #8]
 8001748:	4b1a      	ldr	r3, [pc, #104]	; (80017b4 <ADC_Enable+0x94>)
 800174a:	4219      	tst	r1, r3
 800174c:	d127      	bne.n	800179e <ADC_Enable+0x7e>
  MODIFY_REG(ADCx->CR,
 800174e:	6893      	ldr	r3, [r2, #8]
 8001750:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001754:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001758:	f043 0301 	orr.w	r3, r3, #1
 800175c:	6093      	str	r3, [r2, #8]
    wait_loop_index = (LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (1000000 * 2)));
 800175e:	4b16      	ldr	r3, [pc, #88]	; (80017b8 <ADC_Enable+0x98>)
 8001760:	4a16      	ldr	r2, [pc, #88]	; (80017bc <ADC_Enable+0x9c>)
 8001762:	681b      	ldr	r3, [r3, #0]
 8001764:	fbb3 f2f2 	udiv	r2, r3, r2
 8001768:	230a      	movs	r3, #10
 800176a:	4353      	muls	r3, r2
      wait_loop_index--;
 800176c:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0)
 800176e:	9b01      	ldr	r3, [sp, #4]
 8001770:	2b00      	cmp	r3, #0
 8001772:	d1e5      	bne.n	8001740 <ADC_Enable+0x20>
    tickstart = HAL_GetTick();
 8001774:	f7ff fc16 	bl	8000fa4 <HAL_GetTick>
 8001778:	4e11      	ldr	r6, [pc, #68]	; (80017c0 <ADC_Enable+0xa0>)
 800177a:	4605      	mov	r5, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 800177c:	6822      	ldr	r2, [r4, #0]
 800177e:	6813      	ldr	r3, [r2, #0]
 8001780:	07db      	lsls	r3, r3, #31
 8001782:	d4da      	bmi.n	800173a <ADC_Enable+0x1a>
  return (READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN));
 8001784:	6893      	ldr	r3, [r2, #8]
      if(LL_ADC_IsEnabled(hadc->Instance) == 0)
 8001786:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 8001788:	bf5f      	itttt	pl
 800178a:	6893      	ldrpl	r3, [r2, #8]
 800178c:	4033      	andpl	r3, r6
 800178e:	f043 0301 	orrpl.w	r3, r3, #1
 8001792:	6093      	strpl	r3, [r2, #8]
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8001794:	f7ff fc06 	bl	8000fa4 <HAL_GetTick>
 8001798:	1b40      	subs	r0, r0, r5
 800179a:	2802      	cmp	r0, #2
 800179c:	d9ee      	bls.n	800177c <ADC_Enable+0x5c>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800179e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80017a0:	f043 0310 	orr.w	r3, r3, #16
 80017a4:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80017a6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017a8:	f043 0301 	orr.w	r3, r3, #1
 80017ac:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 80017ae:	2001      	movs	r0, #1
 80017b0:	e7c4      	b.n	800173c <ADC_Enable+0x1c>
 80017b2:	bf00      	nop
 80017b4:	8000003f 	.word	0x8000003f
 80017b8:	200001a0 	.word	0x200001a0
 80017bc:	001e8480 	.word	0x001e8480
 80017c0:	7fffffc0 	.word	0x7fffffc0

080017c4 <HAL_ADC_Start>:
{
 80017c4:	b538      	push	{r3, r4, r5, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80017c6:	6803      	ldr	r3, [r0, #0]
  return (READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 80017c8:	689d      	ldr	r5, [r3, #8]
 80017ca:	f015 0504 	ands.w	r5, r5, #4
{
 80017ce:	4604      	mov	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80017d0:	d13a      	bne.n	8001848 <HAL_ADC_Start+0x84>
    __HAL_LOCK(hadc);
 80017d2:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 80017d6:	2b01      	cmp	r3, #1
 80017d8:	d036      	beq.n	8001848 <HAL_ADC_Start+0x84>
 80017da:	2301      	movs	r3, #1
 80017dc:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    tmp_hal_status = ADC_Enable(hadc);
 80017e0:	f7ff ff9e 	bl	8001720 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80017e4:	2800      	cmp	r0, #0
 80017e6:	d12c      	bne.n	8001842 <HAL_ADC_Start+0x7e>
      ADC_STATE_CLR_SET(hadc->State,
 80017e8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80017ea:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80017ee:	f023 0301 	bic.w	r3, r3, #1
 80017f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80017f6:	65e3      	str	r3, [r4, #92]	; 0x5c
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80017f8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80017fa:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80017fe:	65e3      	str	r3, [r4, #92]	; 0x5c
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8001800:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001802:	04da      	lsls	r2, r3, #19
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8001804:	bf48      	it	mi
 8001806:	6e23      	ldrmi	r3, [r4, #96]	; 0x60
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8001808:	6822      	ldr	r2, [r4, #0]
        ADC_CLEAR_ERRORCODE(hadc); 
 800180a:	bf52      	itee	pl
 800180c:	6620      	strpl	r0, [r4, #96]	; 0x60
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 800180e:	f023 0306 	bicmi.w	r3, r3, #6
 8001812:	6623      	strmi	r3, [r4, #96]	; 0x60
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8001814:	231c      	movs	r3, #28
 8001816:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 8001818:	2300      	movs	r3, #0
 800181a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != RESET)
 800181e:	68d3      	ldr	r3, [r2, #12]
 8001820:	019b      	lsls	r3, r3, #6
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8001822:	bf41      	itttt	mi
 8001824:	6de3      	ldrmi	r3, [r4, #92]	; 0x5c
 8001826:	f423 5340 	bicmi.w	r3, r3, #12288	; 0x3000
 800182a:	f443 5380 	orrmi.w	r3, r3, #4096	; 0x1000
 800182e:	65e3      	strmi	r3, [r4, #92]	; 0x5c
  MODIFY_REG(ADCx->CR,
 8001830:	6893      	ldr	r3, [r2, #8]
 8001832:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001836:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800183a:	f043 0304 	orr.w	r3, r3, #4
 800183e:	6093      	str	r3, [r2, #8]
 8001840:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 8001842:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 8001846:	bd38      	pop	{r3, r4, r5, pc}
    tmp_hal_status = HAL_BUSY;
 8001848:	2002      	movs	r0, #2
}
 800184a:	bd38      	pop	{r3, r4, r5, pc}

0800184c <ADC_Disable>:
  uint32_t tickstart = 0;
  
  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if (ADC_IS_ENABLE(hadc) != RESET)
 800184c:	6802      	ldr	r2, [r0, #0]
{
 800184e:	b538      	push	{r3, r4, r5, lr}
 8001850:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) != RESET)
 8001852:	6890      	ldr	r0, [r2, #8]
 8001854:	f000 0003 	and.w	r0, r0, #3
 8001858:	2801      	cmp	r0, #1
 800185a:	d001      	beq.n	8001860 <ADC_Disable+0x14>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 800185c:	2000      	movs	r0, #0
 800185e:	bd38      	pop	{r3, r4, r5, pc}
  if (ADC_IS_ENABLE(hadc) != RESET)
 8001860:	6813      	ldr	r3, [r2, #0]
 8001862:	07d9      	lsls	r1, r3, #31
 8001864:	d5fa      	bpl.n	800185c <ADC_Disable+0x10>
    if (ADC_DISABLING_CONDITIONS(hadc) != RESET)
 8001866:	6893      	ldr	r3, [r2, #8]
 8001868:	f003 030d 	and.w	r3, r3, #13
 800186c:	2b01      	cmp	r3, #1
 800186e:	d11f      	bne.n	80018b0 <ADC_Disable+0x64>
  MODIFY_REG(ADCx->CR,
 8001870:	6893      	ldr	r3, [r2, #8]
 8001872:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001876:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800187a:	f043 0302 	orr.w	r3, r3, #2
 800187e:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8001880:	2303      	movs	r3, #3
 8001882:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8001884:	f7ff fb8e 	bl	8000fa4 <HAL_GetTick>
 8001888:	4605      	mov	r5, r0
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADEN))
 800188a:	6823      	ldr	r3, [r4, #0]
 800188c:	689b      	ldr	r3, [r3, #8]
 800188e:	07db      	lsls	r3, r3, #31
 8001890:	d5e4      	bpl.n	800185c <ADC_Disable+0x10>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8001892:	f7ff fb87 	bl	8000fa4 <HAL_GetTick>
 8001896:	1b40      	subs	r0, r0, r5
 8001898:	2802      	cmp	r0, #2
 800189a:	d9f6      	bls.n	800188a <ADC_Disable+0x3e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800189c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800189e:	f043 0310 	orr.w	r3, r3, #16
 80018a2:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80018a4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80018a6:	f043 0301 	orr.w	r3, r3, #1
 80018aa:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 80018ac:	2001      	movs	r0, #1
 80018ae:	bd38      	pop	{r3, r4, r5, pc}
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80018b0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80018b2:	f043 0310 	orr.w	r3, r3, #16
 80018b6:	65e3      	str	r3, [r4, #92]	; 0x5c
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80018b8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80018ba:	f043 0301 	orr.w	r3, r3, #1
 80018be:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_ERROR;
 80018c0:	bd38      	pop	{r3, r4, r5, pc}

080018c2 <HAL_ADC_Stop>:
  __HAL_LOCK(hadc);
 80018c2:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 80018c6:	2b01      	cmp	r3, #1
{
 80018c8:	b510      	push	{r4, lr}
 80018ca:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 80018cc:	d016      	beq.n	80018fc <HAL_ADC_Stop+0x3a>
 80018ce:	2301      	movs	r3, #1
 80018d0:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 80018d4:	2103      	movs	r1, #3
 80018d6:	f7ff fec9 	bl	800166c <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 80018da:	b958      	cbnz	r0, 80018f4 <HAL_ADC_Stop+0x32>
    tmp_hal_status = ADC_Disable(hadc);
 80018dc:	4620      	mov	r0, r4
 80018de:	f7ff ffb5 	bl	800184c <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 80018e2:	b938      	cbnz	r0, 80018f4 <HAL_ADC_Stop+0x32>
      ADC_STATE_CLR_SET(hadc->State,
 80018e4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80018e6:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80018ea:	f023 0301 	bic.w	r3, r3, #1
 80018ee:	f043 0301 	orr.w	r3, r3, #1
 80018f2:	65e3      	str	r3, [r4, #92]	; 0x5c
  __HAL_UNLOCK(hadc);
 80018f4:	2300      	movs	r3, #0
 80018f6:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
  return tmp_hal_status;
 80018fa:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 80018fc:	2002      	movs	r0, #2
}
 80018fe:	bd10      	pop	{r4, pc}

08001900 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001900:	4a07      	ldr	r2, [pc, #28]	; (8001920 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001902:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001904:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001908:	041b      	lsls	r3, r3, #16
 800190a:	0c1b      	lsrs	r3, r3, #16
 800190c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8001910:	0200      	lsls	r0, r0, #8
 8001912:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001916:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 800191a:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 800191c:	60d3      	str	r3, [r2, #12]
 800191e:	4770      	bx	lr
 8001920:	e000ed00 	.word	0xe000ed00

08001924 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001924:	4b17      	ldr	r3, [pc, #92]	; (8001984 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001926:	b530      	push	{r4, r5, lr}
 8001928:	68dc      	ldr	r4, [r3, #12]
 800192a:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800192e:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001932:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001934:	2b04      	cmp	r3, #4
 8001936:	bf28      	it	cs
 8001938:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800193a:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800193c:	f04f 0501 	mov.w	r5, #1
 8001940:	fa05 f303 	lsl.w	r3, r5, r3
 8001944:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001948:	bf8c      	ite	hi
 800194a:	3c03      	subhi	r4, #3
 800194c:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800194e:	4019      	ands	r1, r3
 8001950:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001952:	fa05 f404 	lsl.w	r4, r5, r4
 8001956:	3c01      	subs	r4, #1
 8001958:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 800195a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800195c:	ea42 0201 	orr.w	r2, r2, r1
 8001960:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001964:	bfaf      	iteee	ge
 8001966:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800196a:	f000 000f 	andlt.w	r0, r0, #15
 800196e:	4b06      	ldrlt	r3, [pc, #24]	; (8001988 <HAL_NVIC_SetPriority+0x64>)
 8001970:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001972:	bfa5      	ittet	ge
 8001974:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8001978:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800197a:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800197c:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8001980:	bd30      	pop	{r4, r5, pc}
 8001982:	bf00      	nop
 8001984:	e000ed00 	.word	0xe000ed00
 8001988:	e000ed14 	.word	0xe000ed14

0800198c <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800198c:	0942      	lsrs	r2, r0, #5
 800198e:	2301      	movs	r3, #1
 8001990:	f000 001f 	and.w	r0, r0, #31
 8001994:	fa03 f000 	lsl.w	r0, r3, r0
 8001998:	4b01      	ldr	r3, [pc, #4]	; (80019a0 <HAL_NVIC_EnableIRQ+0x14>)
 800199a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800199e:	4770      	bx	lr
 80019a0:	e000e100 	.word	0xe000e100

080019a4 <HAL_NVIC_DisableIRQ>:
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80019a4:	0943      	lsrs	r3, r0, #5
 80019a6:	2201      	movs	r2, #1
 80019a8:	f000 001f 	and.w	r0, r0, #31
 80019ac:	fa02 f000 	lsl.w	r0, r2, r0
 80019b0:	3320      	adds	r3, #32
 80019b2:	4a02      	ldr	r2, [pc, #8]	; (80019bc <HAL_NVIC_DisableIRQ+0x18>)
 80019b4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80019b8:	4770      	bx	lr
 80019ba:	bf00      	nop
 80019bc:	e000e100 	.word	0xe000e100

080019c0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80019c0:	3801      	subs	r0, #1
 80019c2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80019c6:	d20a      	bcs.n	80019de <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80019c8:	4b06      	ldr	r3, [pc, #24]	; (80019e4 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019ca:	4a07      	ldr	r2, [pc, #28]	; (80019e8 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80019cc:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019ce:	21f0      	movs	r1, #240	; 0xf0
 80019d0:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80019d4:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80019d6:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80019d8:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80019da:	601a      	str	r2, [r3, #0]
 80019dc:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80019de:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80019e0:	4770      	bx	lr
 80019e2:	bf00      	nop
 80019e4:	e000e010 	.word	0xe000e010
 80019e8:	e000ed00 	.word	0xe000ed00

080019ec <HAL_NVIC_ClearPendingIRQ>:
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80019ec:	0943      	lsrs	r3, r0, #5
 80019ee:	2201      	movs	r2, #1
 80019f0:	f000 001f 	and.w	r0, r0, #31
 80019f4:	fa02 f000 	lsl.w	r0, r2, r0
 80019f8:	3360      	adds	r3, #96	; 0x60
 80019fa:	4a02      	ldr	r2, [pc, #8]	; (8001a04 <HAL_NVIC_ClearPendingIRQ+0x18>)
 80019fc:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8001a00:	4770      	bx	lr
 8001a02:	bf00      	nop
 8001a04:	e000e100 	.word	0xe000e100

08001a08 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8001a08:	4b04      	ldr	r3, [pc, #16]	; (8001a1c <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001a0a:	681a      	ldr	r2, [r3, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8001a0c:	2804      	cmp	r0, #4
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001a0e:	bf0c      	ite	eq
 8001a10:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8001a14:	f022 0204 	bicne.w	r2, r2, #4
 8001a18:	601a      	str	r2, [r3, #0]
 8001a1a:	4770      	bx	lr
 8001a1c:	e000e010 	.word	0xe000e010

08001a20 <DMA2D_SetConfig>:
  * @param  Width:      The width of data to be transferred from source to destination.
  * @param  Height:     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
{  
 8001a20:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp2 = 0;
  uint32_t tmp3 = 0;
  uint32_t tmp4 = 0;
    
  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_POSITION_NLR_PL))); 
 8001a22:	6805      	ldr	r5, [r0, #0]
 8001a24:	4e0a      	ldr	r6, [pc, #40]	; (8001a50 <DMA2D_SetConfig+0x30>)
 8001a26:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 8001a28:	fa96 f6a6 	rbit	r6, r6
 8001a2c:	9f05      	ldr	r7, [sp, #20]
 8001a2e:	fab6 f686 	clz	r6, r6
 8001a32:	f004 4440 	and.w	r4, r4, #3221225472	; 0xc0000000
 8001a36:	433c      	orrs	r4, r7
 8001a38:	40b3      	lsls	r3, r6
 8001a3a:	4323      	orrs	r3, r4
 8001a3c:	646b      	str	r3, [r5, #68]	; 0x44
  
  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 
  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001a3e:	6843      	ldr	r3, [r0, #4]
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 8001a40:	63ea      	str	r2, [r5, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001a42:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
      tmp3 = (tmp3 >> 12);
      tmp4 = (tmp4 >> 4 );
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
    }    
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, pdata);    
 8001a46:	bf0c      	ite	eq
 8001a48:	63a9      	streq	r1, [r5, #56]	; 0x38
  } 
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
  WRITE_REG(hdma2d->Instance->FGMAR, pdata);
 8001a4a:	60e9      	strne	r1, [r5, #12]
 8001a4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a4e:	bf00      	nop
 8001a50:	3fff0000 	.word	0x3fff0000

08001a54 <HAL_DMA2D_Init>:
{ 
 8001a54:	b538      	push	{r3, r4, r5, lr}
  if(hdma2d == NULL)
 8001a56:	4604      	mov	r4, r0
 8001a58:	2800      	cmp	r0, #0
 8001a5a:	d043      	beq.n	8001ae4 <HAL_DMA2D_Init+0x90>
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8001a5c:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
 8001a60:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001a64:	b91b      	cbnz	r3, 8001a6e <HAL_DMA2D_Init+0x1a>
    hdma2d->Lock = HAL_UNLOCKED;
 8001a66:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
    HAL_DMA2D_MspInit(hdma2d);
 8001a6a:	f010 f959 	bl	8011d20 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8001a6e:	2302      	movs	r3, #2
 8001a70:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
 8001a74:	6823      	ldr	r3, [r4, #0]
 8001a76:	69e0      	ldr	r0, [r4, #28]
 8001a78:	6819      	ldr	r1, [r3, #0]
 8001a7a:	6862      	ldr	r2, [r4, #4]
 8001a7c:	f421 21e0 	bic.w	r1, r1, #458752	; 0x70000
 8001a80:	4302      	orrs	r2, r0
 8001a82:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8001a86:	430a      	orrs	r2, r1
 8001a88:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB, hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);
 8001a8a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001a8c:	68a2      	ldr	r2, [r4, #8]
 8001a8e:	69a0      	ldr	r0, [r4, #24]
 8001a90:	f421 7183 	bic.w	r1, r1, #262	; 0x106
 8001a94:	4302      	orrs	r2, r0
 8001a96:	f021 0101 	bic.w	r1, r1, #1
 8001a9a:	430a      	orrs	r2, r1
 8001a9c:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  
 8001a9e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001aa0:	68e1      	ldr	r1, [r4, #12]
 8001aa2:	0c12      	lsrs	r2, r2, #16
 8001aa4:	0412      	lsls	r2, r2, #16
 8001aa6:	430a      	orrs	r2, r1
 8001aa8:	641a      	str	r2, [r3, #64]	; 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI|DMA2D_OPFCCR_RBS), \
 8001aaa:	6b5d      	ldr	r5, [r3, #52]	; 0x34
 8001aac:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8001ab0:	fa92 f2a2 	rbit	r2, r2
 8001ab4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001ab8:	fab2 f082 	clz	r0, r2
 8001abc:	fa91 f1a1 	rbit	r1, r1
 8001ac0:	6922      	ldr	r2, [r4, #16]
 8001ac2:	4082      	lsls	r2, r0
 8001ac4:	6960      	ldr	r0, [r4, #20]
 8001ac6:	fab1 f181 	clz	r1, r1
 8001aca:	fa00 f101 	lsl.w	r1, r0, r1
 8001ace:	430a      	orrs	r2, r1
 8001ad0:	f425 1140 	bic.w	r1, r5, #3145728	; 0x300000
 8001ad4:	430a      	orrs	r2, r1
 8001ad6:	635a      	str	r2, [r3, #52]	; 0x34
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001ad8:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001ada:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001adc:	65e0      	str	r0, [r4, #92]	; 0x5c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001ade:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
  return HAL_OK;
 8001ae2:	bd38      	pop	{r3, r4, r5, pc}
     return HAL_ERROR;
 8001ae4:	2001      	movs	r0, #1
}
 8001ae6:	bd38      	pop	{r3, r4, r5, pc}

08001ae8 <HAL_DMA2D_Start>:
{
 8001ae8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hdma2d);
 8001aea:	f890 4058 	ldrb.w	r4, [r0, #88]	; 0x58
 8001aee:	2c01      	cmp	r4, #1
 8001af0:	f04f 0402 	mov.w	r4, #2
 8001af4:	d00f      	beq.n	8001b16 <HAL_DMA2D_Start+0x2e>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001af6:	f880 4059 	strb.w	r4, [r0, #89]	; 0x59
  __HAL_LOCK(hdma2d);
 8001afa:	2601      	movs	r6, #1
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8001afc:	9c06      	ldr	r4, [sp, #24]
  __HAL_LOCK(hdma2d);
 8001afe:	f880 6058 	strb.w	r6, [r0, #88]	; 0x58
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8001b02:	9400      	str	r4, [sp, #0]
 8001b04:	f7ff ff8c 	bl	8001a20 <DMA2D_SetConfig>
  __HAL_DMA2D_ENABLE(hdma2d);
 8001b08:	6802      	ldr	r2, [r0, #0]
 8001b0a:	6813      	ldr	r3, [r2, #0]
 8001b0c:	4333      	orrs	r3, r6
 8001b0e:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8001b10:	2000      	movs	r0, #0
}
 8001b12:	b002      	add	sp, #8
 8001b14:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdma2d);
 8001b16:	4620      	mov	r0, r4
 8001b18:	e7fb      	b.n	8001b12 <HAL_DMA2D_Start+0x2a>

08001b1a <HAL_DMA2D_PollForTransfer>:
{
 8001b1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0;  
 8001b1c:	2300      	movs	r3, #0
 8001b1e:	9301      	str	r3, [sp, #4]
  if((hdma2d->Instance->CR & DMA2D_CR_START) != RESET)
 8001b20:	6803      	ldr	r3, [r0, #0]
 8001b22:	681b      	ldr	r3, [r3, #0]
 8001b24:	07db      	lsls	r3, r3, #31
{
 8001b26:	4604      	mov	r4, r0
 8001b28:	460d      	mov	r5, r1
  if((hdma2d->Instance->CR & DMA2D_CR_START) != RESET)
 8001b2a:	d427      	bmi.n	8001b7c <HAL_DMA2D_PollForTransfer+0x62>
  if (((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != RESET)  || 
 8001b2c:	6823      	ldr	r3, [r4, #0]
 8001b2e:	69da      	ldr	r2, [r3, #28]
 8001b30:	0696      	lsls	r6, r2, #26
 8001b32:	d55c      	bpl.n	8001bee <HAL_DMA2D_PollForTransfer+0xd4>
    tickstart = HAL_GetTick();
 8001b34:	f7ff fa36 	bl	8000fa4 <HAL_GetTick>
 8001b38:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
 8001b3a:	6823      	ldr	r3, [r4, #0]
 8001b3c:	685a      	ldr	r2, [r3, #4]
 8001b3e:	06d2      	lsls	r2, r2, #27
 8001b40:	d458      	bmi.n	8001bf4 <HAL_DMA2D_PollForTransfer+0xda>
      isrflags = READ_REG(hdma2d->Instance->ISR);   
 8001b42:	685a      	ldr	r2, [r3, #4]
 8001b44:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != RESET)        
 8001b46:	9a01      	ldr	r2, [sp, #4]
 8001b48:	f012 0f29 	tst.w	r2, #41	; 0x29
 8001b4c:	d05d      	beq.n	8001c0a <HAL_DMA2D_PollForTransfer+0xf0>
        if ((isrflags & DMA2D_FLAG_CAE) != RESET)
 8001b4e:	9a01      	ldr	r2, [sp, #4]
 8001b50:	0716      	lsls	r6, r2, #28
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;        
 8001b52:	bf42      	ittt	mi
 8001b54:	6de2      	ldrmi	r2, [r4, #92]	; 0x5c
 8001b56:	f042 0204 	orrmi.w	r2, r2, #4
 8001b5a:	65e2      	strmi	r2, [r4, #92]	; 0x5c
        if ((isrflags & DMA2D_FLAG_CE) != RESET)             
 8001b5c:	9a01      	ldr	r2, [sp, #4]
 8001b5e:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;        
 8001b60:	bf42      	ittt	mi
 8001b62:	6de2      	ldrmi	r2, [r4, #92]	; 0x5c
 8001b64:	f042 0202 	orrmi.w	r2, r2, #2
 8001b68:	65e2      	strmi	r2, [r4, #92]	; 0x5c
        if ((isrflags & DMA2D_FLAG_TE) != RESET)        
 8001b6a:	9a01      	ldr	r2, [sp, #4]
 8001b6c:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;        
 8001b6e:	bf42      	ittt	mi
 8001b70:	6de2      	ldrmi	r2, [r4, #92]	; 0x5c
 8001b72:	f042 0201 	orrmi.w	r2, r2, #1
 8001b76:	65e2      	strmi	r2, [r4, #92]	; 0x5c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001b78:	2229      	movs	r2, #41	; 0x29
 8001b7a:	e01b      	b.n	8001bb4 <HAL_DMA2D_PollForTransfer+0x9a>
   tickstart = HAL_GetTick();
 8001b7c:	f7ff fa12 	bl	8000fa4 <HAL_GetTick>
 8001b80:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
 8001b82:	6823      	ldr	r3, [r4, #0]
 8001b84:	685a      	ldr	r2, [r3, #4]
 8001b86:	0792      	lsls	r2, r2, #30
 8001b88:	d4d0      	bmi.n	8001b2c <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR); 
 8001b8a:	685a      	ldr	r2, [r3, #4]
 8001b8c:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != RESET)
 8001b8e:	9a01      	ldr	r2, [sp, #4]
 8001b90:	f012 0f21 	tst.w	r2, #33	; 0x21
 8001b94:	d017      	beq.n	8001bc6 <HAL_DMA2D_PollForTransfer+0xac>
        if ((isrflags & DMA2D_FLAG_CE) != RESET)
 8001b96:	9a01      	ldr	r2, [sp, #4]
 8001b98:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;        
 8001b9a:	bf42      	ittt	mi
 8001b9c:	6de2      	ldrmi	r2, [r4, #92]	; 0x5c
 8001b9e:	f042 0202 	orrmi.w	r2, r2, #2
 8001ba2:	65e2      	strmi	r2, [r4, #92]	; 0x5c
        if ((isrflags & DMA2D_FLAG_TE) != RESET)        
 8001ba4:	9a01      	ldr	r2, [sp, #4]
 8001ba6:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;        
 8001ba8:	bf42      	ittt	mi
 8001baa:	6de2      	ldrmi	r2, [r4, #92]	; 0x5c
 8001bac:	f042 0201 	orrmi.w	r2, r2, #1
 8001bb0:	65e2      	strmi	r2, [r4, #92]	; 0x5c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001bb2:	2221      	movs	r2, #33	; 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001bb4:	609a      	str	r2, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8001bb6:	2304      	movs	r3, #4
 8001bb8:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
        __HAL_UNLOCK(hdma2d);
 8001bbc:	2300      	movs	r3, #0
 8001bbe:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        return HAL_ERROR;      
 8001bc2:	2001      	movs	r0, #1
 8001bc4:	e01f      	b.n	8001c06 <HAL_DMA2D_PollForTransfer+0xec>
      if(Timeout != HAL_MAX_DELAY)
 8001bc6:	1c69      	adds	r1, r5, #1
 8001bc8:	d0dc      	beq.n	8001b84 <HAL_DMA2D_PollForTransfer+0x6a>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001bca:	b955      	cbnz	r5, 8001be2 <HAL_DMA2D_PollForTransfer+0xc8>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8001bcc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001bce:	f043 0320 	orr.w	r3, r3, #32
 8001bd2:	65e3      	str	r3, [r4, #92]	; 0x5c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8001bd4:	2003      	movs	r0, #3
          __HAL_UNLOCK(hdma2d);
 8001bd6:	2300      	movs	r3, #0
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8001bd8:	f884 0059 	strb.w	r0, [r4, #89]	; 0x59
          __HAL_UNLOCK(hdma2d);
 8001bdc:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 8001be0:	e011      	b.n	8001c06 <HAL_DMA2D_PollForTransfer+0xec>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001be2:	f7ff f9df 	bl	8000fa4 <HAL_GetTick>
 8001be6:	1b80      	subs	r0, r0, r6
 8001be8:	4285      	cmp	r5, r0
 8001bea:	d2ca      	bcs.n	8001b82 <HAL_DMA2D_PollForTransfer+0x68>
 8001bec:	e7ee      	b.n	8001bcc <HAL_DMA2D_PollForTransfer+0xb2>
      ((hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START) != RESET))
 8001bee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  if (((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != RESET)  || 
 8001bf0:	069b      	lsls	r3, r3, #26
 8001bf2:	d49f      	bmi.n	8001b34 <HAL_DMA2D_PollForTransfer+0x1a>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8001bf4:	6823      	ldr	r3, [r4, #0]
 8001bf6:	2212      	movs	r2, #18
 8001bf8:	609a      	str	r2, [r3, #8]
  __HAL_UNLOCK(hdma2d);
 8001bfa:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001bfc:	2301      	movs	r3, #1
 8001bfe:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
  __HAL_UNLOCK(hdma2d);
 8001c02:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
}
 8001c06:	b002      	add	sp, #8
 8001c08:	bd70      	pop	{r4, r5, r6, pc}
      if(Timeout != HAL_MAX_DELAY)
 8001c0a:	1c69      	adds	r1, r5, #1
 8001c0c:	d096      	beq.n	8001b3c <HAL_DMA2D_PollForTransfer+0x22>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001c0e:	2d00      	cmp	r5, #0
 8001c10:	d0dc      	beq.n	8001bcc <HAL_DMA2D_PollForTransfer+0xb2>
 8001c12:	f7ff f9c7 	bl	8000fa4 <HAL_GetTick>
 8001c16:	1b80      	subs	r0, r0, r6
 8001c18:	4285      	cmp	r5, r0
 8001c1a:	d28e      	bcs.n	8001b3a <HAL_DMA2D_PollForTransfer+0x20>
 8001c1c:	e7d6      	b.n	8001bcc <HAL_DMA2D_PollForTransfer+0xb2>
	...

08001c20 <HAL_DMA2D_ConfigLayer>:
  __HAL_LOCK(hdma2d);
 8001c20:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 8001c24:	2b01      	cmp	r3, #1
{   
 8001c26:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c28:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(hdma2d);
 8001c2c:	d041      	beq.n	8001cb2 <HAL_DMA2D_ConfigLayer+0x92>
 8001c2e:	2201      	movs	r2, #1
 8001c30:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
  hdma2d->State = HAL_DMA2D_STATE_BUSY;   
 8001c34:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
 8001c38:	6802      	ldr	r2, [r0, #0]
  if(LayerIdx == 0)
 8001c3a:	2900      	cmp	r1, #0
 8001c3c:	d14d      	bne.n	8001cda <HAL_DMA2D_ConfigLayer+0xba>
    if ((LayerCfg->InputColorMode == DMA2D_INPUT_A4) || (LayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001c3e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 8001c40:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8001c42:	6b07      	ldr	r7, [r0, #48]	; 0x30
 8001c44:	f1a6 0509 	sub.w	r5, r6, #9
 8001c48:	2d01      	cmp	r5, #1
 8001c4a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001c4e:	d832      	bhi.n	8001cb6 <HAL_DMA2D_ConfigLayer+0x96>
 8001c50:	fa93 f3a3 	rbit	r3, r3
      tmp = (LayerCfg->InputColorMode | (LayerCfg->AlphaMode << DMA2D_POSITION_BGPFCCR_AM) | (LayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA));
 8001c54:	fab3 f383 	clz	r3, r3
 8001c58:	f004 417f 	and.w	r1, r4, #4278190080	; 0xff000000
 8001c5c:	4331      	orrs	r1, r6
 8001c5e:	fa07 f303 	lsl.w	r3, r7, r3
 8001c62:	4319      	orrs	r1, r3
    MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS), \
 8001c64:	f8d2 e024 	ldr.w	lr, [r2, #36]	; 0x24
 8001c68:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001c6c:	fa93 f3a3 	rbit	r3, r3
 8001c70:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 8001c74:	fab3 f783 	clz	r7, r3
 8001c78:	fa96 f6a6 	rbit	r6, r6
 8001c7c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001c7e:	40bb      	lsls	r3, r7
 8001c80:	4f3c      	ldr	r7, [pc, #240]	; (8001d74 <HAL_DMA2D_ConfigLayer+0x154>)
 8001c82:	ea0e 0707 	and.w	r7, lr, r7
 8001c86:	4339      	orrs	r1, r7
 8001c88:	430b      	orrs	r3, r1
 8001c8a:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8001c8c:	fab6 f686 	clz	r6, r6
 8001c90:	fa01 f606 	lsl.w	r6, r1, r6
 8001c94:	4333      	orrs	r3, r6
 8001c96:	6253      	str	r3, [r2, #36]	; 0x24
    if ((LayerCfg->InputColorMode == DMA2D_INPUT_A4) || (LayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001c98:	2d01      	cmp	r5, #1
    WRITE_REG(hdma2d->Instance->BGOR, LayerCfg->InputOffset);
 8001c9a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001c9c:	6193      	str	r3, [r2, #24]
    if ((LayerCfg->InputColorMode == DMA2D_INPUT_A4) || (LayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001c9e:	d802      	bhi.n	8001ca6 <HAL_DMA2D_ConfigLayer+0x86>
      WRITE_REG(hdma2d->Instance->BGCOLR, LayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8001ca0:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8001ca4:	6294      	str	r4, [r2, #40]	; 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001ca6:	2301      	movs	r3, #1
 8001ca8:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
  __HAL_UNLOCK(hdma2d);  
 8001cac:	2300      	movs	r3, #0
 8001cae:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
  __HAL_LOCK(hdma2d);
 8001cb2:	4618      	mov	r0, r3
}
 8001cb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001cb6:	fa93 f3a3 	rbit	r3, r3
 8001cba:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
      tmp = (LayerCfg->InputColorMode | (LayerCfg->AlphaMode << DMA2D_POSITION_BGPFCCR_AM) | (LayerCfg->InputAlpha << DMA2D_POSITION_BGPFCCR_ALPHA));
 8001cbe:	fab3 f383 	clz	r3, r3
 8001cc2:	fa91 f1a1 	rbit	r1, r1
 8001cc6:	fab1 f181 	clz	r1, r1
 8001cca:	fa04 f101 	lsl.w	r1, r4, r1
 8001cce:	fa07 f303 	lsl.w	r3, r7, r3
 8001cd2:	430b      	orrs	r3, r1
 8001cd4:	ea43 0106 	orr.w	r1, r3, r6
 8001cd8:	e7c4      	b.n	8001c64 <HAL_DMA2D_ConfigLayer+0x44>
    if ((LayerCfg->InputColorMode == DMA2D_INPUT_A4) || (LayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001cda:	2418      	movs	r4, #24
 8001cdc:	fb04 0401 	mla	r4, r4, r1, r0
 8001ce0:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001ce4:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8001ce6:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8001ce8:	6b24      	ldr	r4, [r4, #48]	; 0x30
 8001cea:	f1a7 0509 	sub.w	r5, r7, #9
 8001cee:	2d01      	cmp	r5, #1
 8001cf0:	d82f      	bhi.n	8001d52 <HAL_DMA2D_ConfigLayer+0x132>
 8001cf2:	fa93 f3a3 	rbit	r3, r3
      tmp = (LayerCfg->InputColorMode | (LayerCfg->AlphaMode << DMA2D_POSITION_FGPFCCR_AM) | (LayerCfg->InputAlpha & DMA2D_FGPFCCR_ALPHA));
 8001cf6:	fab3 f383 	clz	r3, r3
 8001cfa:	f006 467f 	and.w	r6, r6, #4278190080	; 0xff000000
 8001cfe:	4337      	orrs	r7, r6
 8001d00:	fa04 f303 	lsl.w	r3, r4, r3
      tmp = (LayerCfg->InputColorMode | (LayerCfg->AlphaMode << DMA2D_POSITION_FGPFCCR_AM) | (LayerCfg->InputAlpha << DMA2D_POSITION_FGPFCCR_ALPHA));
 8001d04:	433b      	orrs	r3, r7
    MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA | DMA2D_FGPFCCR_AI | DMA2D_FGPFCCR_RBS), \
 8001d06:	f8d2 e01c 	ldr.w	lr, [r2, #28]
 8001d0a:	f44f 1480 	mov.w	r4, #1048576	; 0x100000
 8001d0e:	fa94 f4a4 	rbit	r4, r4
 8001d12:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 8001d16:	fab4 f784 	clz	r7, r4
 8001d1a:	fa96 f6a6 	rbit	r6, r6
 8001d1e:	2418      	movs	r4, #24
 8001d20:	fb04 0101 	mla	r1, r4, r1, r0
 8001d24:	fab6 f686 	clz	r6, r6
 8001d28:	6b8c      	ldr	r4, [r1, #56]	; 0x38
 8001d2a:	40bc      	lsls	r4, r7
 8001d2c:	4f11      	ldr	r7, [pc, #68]	; (8001d74 <HAL_DMA2D_ConfigLayer+0x154>)
 8001d2e:	ea0e 0707 	and.w	r7, lr, r7
 8001d32:	433b      	orrs	r3, r7
 8001d34:	4323      	orrs	r3, r4
 8001d36:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
 8001d38:	fa04 f606 	lsl.w	r6, r4, r6
 8001d3c:	4333      	orrs	r3, r6
 8001d3e:	61d3      	str	r3, [r2, #28]
    if ((LayerCfg->InputColorMode == DMA2D_INPUT_A4) || (LayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001d40:	2d01      	cmp	r5, #1
    WRITE_REG(hdma2d->Instance->FGOR, LayerCfg->InputOffset);      
 8001d42:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8001d44:	6113      	str	r3, [r2, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, LayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));      
 8001d46:	bf9e      	ittt	ls
 8001d48:	6b4b      	ldrls	r3, [r1, #52]	; 0x34
 8001d4a:	f023 437f 	bicls.w	r3, r3, #4278190080	; 0xff000000
 8001d4e:	6213      	strls	r3, [r2, #32]
 8001d50:	e7a9      	b.n	8001ca6 <HAL_DMA2D_ConfigLayer+0x86>
 8001d52:	fa93 f3a3 	rbit	r3, r3
 8001d56:	f04f 4e7f 	mov.w	lr, #4278190080	; 0xff000000
      tmp = (LayerCfg->InputColorMode | (LayerCfg->AlphaMode << DMA2D_POSITION_FGPFCCR_AM) | (LayerCfg->InputAlpha << DMA2D_POSITION_FGPFCCR_ALPHA));
 8001d5a:	fab3 f383 	clz	r3, r3
 8001d5e:	fa9e feae 	rbit	lr, lr
 8001d62:	fabe fe8e 	clz	lr, lr
 8001d66:	fa04 f303 	lsl.w	r3, r4, r3
 8001d6a:	fa06 f60e 	lsl.w	r6, r6, lr
 8001d6e:	4333      	orrs	r3, r6
 8001d70:	e7c8      	b.n	8001d04 <HAL_DMA2D_ConfigLayer+0xe4>
 8001d72:	bf00      	nop
 8001d74:	00ccfff0 	.word	0x00ccfff0

08001d78 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001d78:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001d7c:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001d80:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8001f24 <HAL_GPIO_Init+0x1ac>
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001d84:	4a65      	ldr	r2, [pc, #404]	; (8001f1c <HAL_GPIO_Init+0x1a4>)
  uint32_t position = 0x00u;
 8001d86:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001d88:	fa38 f403 	lsrs.w	r4, r8, r3
 8001d8c:	d102      	bne.n	8001d94 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 8001d8e:	b003      	add	sp, #12
 8001d90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8001d94:	f04f 0e01 	mov.w	lr, #1
 8001d98:	fa0e fe03 	lsl.w	lr, lr, r3
    if (iocurrent != 0x00u)
 8001d9c:	ea18 060e 	ands.w	r6, r8, lr
 8001da0:	f000 80ab 	beq.w	8001efa <HAL_GPIO_Init+0x182>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001da4:	684c      	ldr	r4, [r1, #4]
 8001da6:	f024 0710 	bic.w	r7, r4, #16
 8001daa:	2f02      	cmp	r7, #2
 8001dac:	d116      	bne.n	8001ddc <HAL_GPIO_Init+0x64>
        temp = GPIOx->AFR[position >> 3u];
 8001dae:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001db2:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001db6:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3u];
 8001dba:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001dbe:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001dc2:	f04f 0c0f 	mov.w	ip, #15
 8001dc6:	fa0c fc0b 	lsl.w	ip, ip, fp
 8001dca:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8001dce:	690d      	ldr	r5, [r1, #16]
 8001dd0:	fa05 f50b 	lsl.w	r5, r5, fp
 8001dd4:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3u] = temp;
 8001dd8:	f8ca 5020 	str.w	r5, [sl, #32]
 8001ddc:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001de0:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8001de2:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001de6:	fa05 f50a 	lsl.w	r5, r5, sl
 8001dea:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001dec:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001df0:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001df4:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001df8:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001dfa:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001dfe:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8001e00:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001e04:	d811      	bhi.n	8001e2a <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
 8001e06:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8001e08:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2u));
 8001e0c:	68cf      	ldr	r7, [r1, #12]
 8001e0e:	fa07 fc0a 	lsl.w	ip, r7, sl
 8001e12:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8001e16:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8001e18:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001e1a:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8001e1e:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8001e22:	409f      	lsls	r7, r3
 8001e24:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8001e28:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8001e2a:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8001e2c:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8001e2e:	688f      	ldr	r7, [r1, #8]
 8001e30:	fa07 f70a 	lsl.w	r7, r7, sl
 8001e34:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8001e36:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001e38:	00e5      	lsls	r5, r4, #3
 8001e3a:	d55e      	bpl.n	8001efa <HAL_GPIO_Init+0x182>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001e3c:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 8001e40:	f045 0501 	orr.w	r5, r5, #1
 8001e44:	f8c9 5060 	str.w	r5, [r9, #96]	; 0x60
 8001e48:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 8001e4c:	f023 0703 	bic.w	r7, r3, #3
 8001e50:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8001e54:	f005 0501 	and.w	r5, r5, #1
 8001e58:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 8001e5c:	9501      	str	r5, [sp, #4]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001e5e:	f003 0e03 	and.w	lr, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001e62:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 8001e64:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001e68:	f04f 0c0f 	mov.w	ip, #15
 8001e6c:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8001e70:	fa0c f50e 	lsl.w	r5, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001e74:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001e78:	ea2a 0c05 	bic.w	ip, sl, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001e7c:	d03f      	beq.n	8001efe <HAL_GPIO_Init+0x186>
 8001e7e:	4d28      	ldr	r5, [pc, #160]	; (8001f20 <HAL_GPIO_Init+0x1a8>)
 8001e80:	42a8      	cmp	r0, r5
 8001e82:	d03e      	beq.n	8001f02 <HAL_GPIO_Init+0x18a>
 8001e84:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001e88:	42a8      	cmp	r0, r5
 8001e8a:	d03c      	beq.n	8001f06 <HAL_GPIO_Init+0x18e>
 8001e8c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001e90:	42a8      	cmp	r0, r5
 8001e92:	d03a      	beq.n	8001f0a <HAL_GPIO_Init+0x192>
 8001e94:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001e98:	42a8      	cmp	r0, r5
 8001e9a:	d038      	beq.n	8001f0e <HAL_GPIO_Init+0x196>
 8001e9c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001ea0:	42a8      	cmp	r0, r5
 8001ea2:	d036      	beq.n	8001f12 <HAL_GPIO_Init+0x19a>
 8001ea4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001ea8:	42a8      	cmp	r0, r5
 8001eaa:	d034      	beq.n	8001f16 <HAL_GPIO_Init+0x19e>
 8001eac:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001eb0:	42a8      	cmp	r0, r5
 8001eb2:	bf14      	ite	ne
 8001eb4:	2508      	movne	r5, #8
 8001eb6:	2507      	moveq	r5, #7
 8001eb8:	fa05 f50e 	lsl.w	r5, r5, lr
 8001ebc:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2u] = temp;
 8001ec0:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 8001ec2:	6815      	ldr	r5, [r2, #0]
        temp &= ~(iocurrent);
 8001ec4:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001ec6:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 8001eca:	bf0c      	ite	eq
 8001ecc:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8001ece:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 8001ed0:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR1;
 8001ed2:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001ed4:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 8001ed8:	bf0c      	ite	eq
 8001eda:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8001edc:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 8001ede:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR1;
 8001ee0:	6895      	ldr	r5, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001ee2:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 8001ee6:	bf0c      	ite	eq
 8001ee8:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8001eea:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 8001eec:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR1;
 8001eee:	68d5      	ldr	r5, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001ef0:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 8001ef2:	bf54      	ite	pl
 8001ef4:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001ef6:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 8001ef8:	60d5      	str	r5, [r2, #12]
    position++;
 8001efa:	3301      	adds	r3, #1
 8001efc:	e744      	b.n	8001d88 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001efe:	2500      	movs	r5, #0
 8001f00:	e7da      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f02:	2501      	movs	r5, #1
 8001f04:	e7d8      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f06:	2502      	movs	r5, #2
 8001f08:	e7d6      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f0a:	2503      	movs	r5, #3
 8001f0c:	e7d4      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f0e:	2504      	movs	r5, #4
 8001f10:	e7d2      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f12:	2505      	movs	r5, #5
 8001f14:	e7d0      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f16:	2506      	movs	r5, #6
 8001f18:	e7ce      	b.n	8001eb8 <HAL_GPIO_Init+0x140>
 8001f1a:	bf00      	nop
 8001f1c:	40010400 	.word	0x40010400
 8001f20:	48000400 	.word	0x48000400
 8001f24:	40021000 	.word	0x40021000

08001f28 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8001f28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = 0x0FuL << (4u * (position & 0x03u));
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
 8001f2c:	4d46      	ldr	r5, [pc, #280]	; (8002048 <HAL_GPIO_DeInit+0x120>)
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8001f2e:	f8df a120 	ldr.w	sl, [pc, #288]	; 8002050 <HAL_GPIO_DeInit+0x128>
 8001f32:	f8df b120 	ldr.w	fp, [pc, #288]	; 8002054 <HAL_GPIO_DeInit+0x12c>
  uint32_t position = 0x00u;
 8001f36:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 8001f38:	f04f 0901 	mov.w	r9, #1
  while ((GPIO_Pin >> position) != 0x00u)
 8001f3c:	fa31 f302 	lsrs.w	r3, r1, r2
 8001f40:	d101      	bne.n	8001f46 <HAL_GPIO_DeInit+0x1e>
      }
    }

    position++;
  }
}
 8001f42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 8001f46:	fa09 f802 	lsl.w	r8, r9, r2
    if (iocurrent != 0x00u)
 8001f4a:	ea11 0608 	ands.w	r6, r1, r8
 8001f4e:	d06b      	beq.n	8002028 <HAL_GPIO_DeInit+0x100>
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 8001f50:	6807      	ldr	r7, [r0, #0]
 8001f52:	2303      	movs	r3, #3
 8001f54:	0054      	lsls	r4, r2, #1
 8001f56:	fa03 f404 	lsl.w	r4, r3, r4
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 8001f5a:	fa22 fc03 	lsr.w	ip, r2, r3
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 8001f5e:	4327      	orrs	r7, r4
 8001f60:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8001f64:	6007      	str	r7, [r0, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 8001f66:	f8dc 7020 	ldr.w	r7, [ip, #32]
 8001f6a:	f002 0e07 	and.w	lr, r2, #7
 8001f6e:	463b      	mov	r3, r7
 8001f70:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8001f74:	270f      	movs	r7, #15
 8001f76:	fa07 fe0e 	lsl.w	lr, r7, lr
 8001f7a:	ea23 0e0e 	bic.w	lr, r3, lr
 8001f7e:	f8cc e020 	str.w	lr, [ip, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8001f82:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8001f86:	43e4      	mvns	r4, r4
 8001f88:	ea0e 0e04 	and.w	lr, lr, r4
 8001f8c:	f8c0 e008 	str.w	lr, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8001f90:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8001f94:	ea2e 0808 	bic.w	r8, lr, r8
 8001f98:	f8c0 8004 	str.w	r8, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8001f9c:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 8001fa0:	ea04 040e 	and.w	r4, r4, lr
 8001fa4:	60c4      	str	r4, [r0, #12]
 8001fa6:	f022 0403 	bic.w	r4, r2, #3
 8001faa:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8001fae:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8001fb2:	f002 0e03 	and.w	lr, r2, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 8001fb6:	f8d4 c008 	ldr.w	ip, [r4, #8]
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8001fba:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8001fbe:	fa07 f70e 	lsl.w	r7, r7, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8001fc2:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8001fc6:	ea0c 0c07 	and.w	ip, ip, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8001fca:	d02f      	beq.n	800202c <HAL_GPIO_DeInit+0x104>
 8001fcc:	4b1f      	ldr	r3, [pc, #124]	; (800204c <HAL_GPIO_DeInit+0x124>)
 8001fce:	4298      	cmp	r0, r3
 8001fd0:	d02e      	beq.n	8002030 <HAL_GPIO_DeInit+0x108>
 8001fd2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001fd6:	4298      	cmp	r0, r3
 8001fd8:	d02c      	beq.n	8002034 <HAL_GPIO_DeInit+0x10c>
 8001fda:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001fde:	4298      	cmp	r0, r3
 8001fe0:	d02a      	beq.n	8002038 <HAL_GPIO_DeInit+0x110>
 8001fe2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001fe6:	4298      	cmp	r0, r3
 8001fe8:	d028      	beq.n	800203c <HAL_GPIO_DeInit+0x114>
 8001fea:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001fee:	4298      	cmp	r0, r3
 8001ff0:	d026      	beq.n	8002040 <HAL_GPIO_DeInit+0x118>
 8001ff2:	4550      	cmp	r0, sl
 8001ff4:	d026      	beq.n	8002044 <HAL_GPIO_DeInit+0x11c>
 8001ff6:	4558      	cmp	r0, fp
 8001ff8:	bf0c      	ite	eq
 8001ffa:	2307      	moveq	r3, #7
 8001ffc:	2308      	movne	r3, #8
 8001ffe:	fa03 f30e 	lsl.w	r3, r3, lr
 8002002:	459c      	cmp	ip, r3
 8002004:	d110      	bne.n	8002028 <HAL_GPIO_DeInit+0x100>
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8002006:	68a3      	ldr	r3, [r4, #8]
 8002008:	ea23 0707 	bic.w	r7, r3, r7
 800200c:	60a7      	str	r7, [r4, #8]
        EXTI->IMR1 &= ~(iocurrent);
 800200e:	682b      	ldr	r3, [r5, #0]
 8002010:	43f6      	mvns	r6, r6
 8002012:	4033      	ands	r3, r6
 8002014:	602b      	str	r3, [r5, #0]
        EXTI->EMR1 &= ~(iocurrent);
 8002016:	686b      	ldr	r3, [r5, #4]
 8002018:	4033      	ands	r3, r6
 800201a:	606b      	str	r3, [r5, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 800201c:	68ab      	ldr	r3, [r5, #8]
 800201e:	4033      	ands	r3, r6
 8002020:	60ab      	str	r3, [r5, #8]
        EXTI->FTSR1 &= ~(iocurrent);
 8002022:	68eb      	ldr	r3, [r5, #12]
 8002024:	401e      	ands	r6, r3
 8002026:	60ee      	str	r6, [r5, #12]
    position++;
 8002028:	3201      	adds	r2, #1
 800202a:	e787      	b.n	8001f3c <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 800202c:	2300      	movs	r3, #0
 800202e:	e7e6      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002030:	2301      	movs	r3, #1
 8002032:	e7e4      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002034:	2302      	movs	r3, #2
 8002036:	e7e2      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002038:	2303      	movs	r3, #3
 800203a:	e7e0      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 800203c:	2304      	movs	r3, #4
 800203e:	e7de      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002040:	2305      	movs	r3, #5
 8002042:	e7dc      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002044:	2306      	movs	r3, #6
 8002046:	e7da      	b.n	8001ffe <HAL_GPIO_DeInit+0xd6>
 8002048:	40010400 	.word	0x40010400
 800204c:	48000400 	.word	0x48000400
 8002050:	48001800 	.word	0x48001800
 8002054:	48001c00 	.word	0x48001c00

08002058 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002058:	b10a      	cbz	r2, 800205e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800205a:	6181      	str	r1, [r0, #24]
 800205c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800205e:	6281      	str	r1, [r0, #40]	; 0x28
 8002060:	4770      	bx	lr

08002062 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8002062:	6943      	ldr	r3, [r0, #20]
 8002064:	4059      	eors	r1, r3
 8002066:	6141      	str	r1, [r0, #20]
 8002068:	4770      	bx	lr

0800206a <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 800206a:	4770      	bx	lr

0800206c <HAL_GPIO_EXTI_IRQHandler>:
{
 800206c:	b508      	push	{r3, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800206e:	4b04      	ldr	r3, [pc, #16]	; (8002080 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8002070:	6959      	ldr	r1, [r3, #20]
 8002072:	4201      	tst	r1, r0
 8002074:	d002      	beq.n	800207c <HAL_GPIO_EXTI_IRQHandler+0x10>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8002076:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8002078:	f7ff fff7 	bl	800206a <HAL_GPIO_EXTI_Callback>
 800207c:	bd08      	pop	{r3, pc}
 800207e:	bf00      	nop
 8002080:	40010400 	.word	0x40010400

08002084 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8002084:	6803      	ldr	r3, [r0, #0]
 8002086:	699a      	ldr	r2, [r3, #24]
 8002088:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 800208a:	bf44      	itt	mi
 800208c:	2200      	movmi	r2, #0
 800208e:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8002090:	699a      	ldr	r2, [r3, #24]
 8002092:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8002094:	bf5e      	ittt	pl
 8002096:	699a      	ldrpl	r2, [r3, #24]
 8002098:	f042 0201 	orrpl.w	r2, r2, #1
 800209c:	619a      	strpl	r2, [r3, #24]
 800209e:	4770      	bx	lr

080020a0 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
 80020a0:	b530      	push	{r4, r5, lr}
 80020a2:	9c03      	ldr	r4, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80020a4:	6805      	ldr	r5, [r0, #0]
 80020a6:	4323      	orrs	r3, r4
 80020a8:	0d64      	lsrs	r4, r4, #21
 80020aa:	f404 6480 	and.w	r4, r4, #1024	; 0x400
 80020ae:	f044 747f 	orr.w	r4, r4, #66846720	; 0x3fc0000
 80020b2:	f444 3458 	orr.w	r4, r4, #221184	; 0x36000
 80020b6:	6868      	ldr	r0, [r5, #4]
 80020b8:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80020bc:	f444 747f 	orr.w	r4, r4, #1020	; 0x3fc
 80020c0:	4319      	orrs	r1, r3
 80020c2:	f044 0403 	orr.w	r4, r4, #3
 80020c6:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 80020ca:	ea20 0404 	bic.w	r4, r0, r4
 80020ce:	4321      	orrs	r1, r4
 80020d0:	6069      	str	r1, [r5, #4]
 80020d2:	bd30      	pop	{r4, r5, pc}

080020d4 <I2C_WaitOnFlagUntilTimeout>:
{
 80020d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80020d8:	9f06      	ldr	r7, [sp, #24]
 80020da:	4604      	mov	r4, r0
 80020dc:	4688      	mov	r8, r1
 80020de:	4616      	mov	r6, r2
 80020e0:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80020e2:	6822      	ldr	r2, [r4, #0]
 80020e4:	6993      	ldr	r3, [r2, #24]
 80020e6:	ea38 0303 	bics.w	r3, r8, r3
 80020ea:	bf0c      	ite	eq
 80020ec:	2301      	moveq	r3, #1
 80020ee:	2300      	movne	r3, #0
 80020f0:	42b3      	cmp	r3, r6
 80020f2:	d002      	beq.n	80020fa <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 80020f4:	2000      	movs	r0, #0
}
 80020f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (Timeout != HAL_MAX_DELAY)
 80020fa:	1c6b      	adds	r3, r5, #1
 80020fc:	d0f2      	beq.n	80020e4 <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80020fe:	f7fe ff51 	bl	8000fa4 <HAL_GetTick>
 8002102:	1bc0      	subs	r0, r0, r7
 8002104:	4285      	cmp	r5, r0
 8002106:	d301      	bcc.n	800210c <I2C_WaitOnFlagUntilTimeout+0x38>
 8002108:	2d00      	cmp	r5, #0
 800210a:	d1ea      	bne.n	80020e2 <I2C_WaitOnFlagUntilTimeout+0xe>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800210c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800210e:	f043 0320 	orr.w	r3, r3, #32
 8002112:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8002114:	2320      	movs	r3, #32
 8002116:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800211a:	2300      	movs	r3, #0
 800211c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8002120:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8002124:	2001      	movs	r0, #1
 8002126:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800212a <I2C_IsAcknowledgeFailed>:
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800212a:	6803      	ldr	r3, [r0, #0]
{
 800212c:	b570      	push	{r4, r5, r6, lr}
 800212e:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002130:	6998      	ldr	r0, [r3, #24]
 8002132:	f010 0010 	ands.w	r0, r0, #16
{
 8002136:	460d      	mov	r5, r1
 8002138:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800213a:	d116      	bne.n	800216a <I2C_IsAcknowledgeFailed+0x40>
 800213c:	bd70      	pop	{r4, r5, r6, pc}
      if (Timeout != HAL_MAX_DELAY)
 800213e:	1c69      	adds	r1, r5, #1
 8002140:	d014      	beq.n	800216c <I2C_IsAcknowledgeFailed+0x42>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002142:	f7fe ff2f 	bl	8000fa4 <HAL_GetTick>
 8002146:	1b80      	subs	r0, r0, r6
 8002148:	4285      	cmp	r5, r0
 800214a:	d300      	bcc.n	800214e <I2C_IsAcknowledgeFailed+0x24>
 800214c:	b96d      	cbnz	r5, 800216a <I2C_IsAcknowledgeFailed+0x40>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800214e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002150:	f043 0320 	orr.w	r3, r3, #32
 8002154:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8002156:	2320      	movs	r3, #32
 8002158:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800215c:	2300      	movs	r3, #0
 800215e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8002162:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_ERROR;
 8002166:	2001      	movs	r0, #1
}
 8002168:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800216a:	6823      	ldr	r3, [r4, #0]
 800216c:	6999      	ldr	r1, [r3, #24]
 800216e:	068a      	lsls	r2, r1, #26
 8002170:	d5e5      	bpl.n	800213e <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002172:	2210      	movs	r2, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002174:	2520      	movs	r5, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002176:	61da      	str	r2, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8002178:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800217a:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 800217c:	f7ff ff82 	bl	8002084 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8002180:	6822      	ldr	r2, [r4, #0]
 8002182:	6853      	ldr	r3, [r2, #4]
 8002184:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8002188:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 800218c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8002190:	f023 0301 	bic.w	r3, r3, #1
 8002194:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002196:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002198:	f043 0304 	orr.w	r3, r3, #4
 800219c:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800219e:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 80021a2:	e7db      	b.n	800215c <I2C_IsAcknowledgeFailed+0x32>

080021a4 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 80021a4:	b570      	push	{r4, r5, r6, lr}
 80021a6:	4604      	mov	r4, r0
 80021a8:	460d      	mov	r5, r1
 80021aa:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80021ac:	6823      	ldr	r3, [r4, #0]
 80021ae:	699b      	ldr	r3, [r3, #24]
 80021b0:	079b      	lsls	r3, r3, #30
 80021b2:	d501      	bpl.n	80021b8 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
 80021b4:	2000      	movs	r0, #0
 80021b6:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80021b8:	4632      	mov	r2, r6
 80021ba:	4629      	mov	r1, r5
 80021bc:	4620      	mov	r0, r4
 80021be:	f7ff ffb4 	bl	800212a <I2C_IsAcknowledgeFailed>
 80021c2:	b9a0      	cbnz	r0, 80021ee <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
 80021c4:	1c6a      	adds	r2, r5, #1
 80021c6:	d0f1      	beq.n	80021ac <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80021c8:	f7fe feec 	bl	8000fa4 <HAL_GetTick>
 80021cc:	1b80      	subs	r0, r0, r6
 80021ce:	4285      	cmp	r5, r0
 80021d0:	d301      	bcc.n	80021d6 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 80021d2:	2d00      	cmp	r5, #0
 80021d4:	d1ea      	bne.n	80021ac <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80021d6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80021d8:	f043 0320 	orr.w	r3, r3, #32
 80021dc:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 80021de:	2320      	movs	r3, #32
 80021e0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80021e4:	2300      	movs	r3, #0
 80021e6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 80021ea:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 80021ee:	2001      	movs	r0, #1
}
 80021f0:	bd70      	pop	{r4, r5, r6, pc}
	...

080021f4 <I2C_RequestMemoryRead>:
{
 80021f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80021f6:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80021f8:	461f      	mov	r7, r3
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 80021fa:	4b16      	ldr	r3, [pc, #88]	; (8002254 <I2C_RequestMemoryRead+0x60>)
 80021fc:	9300      	str	r3, [sp, #0]
{
 80021fe:	4605      	mov	r5, r0
 8002200:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8002202:	2300      	movs	r3, #0
 8002204:	b2fa      	uxtb	r2, r7
 8002206:	f7ff ff4b 	bl	80020a0 <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800220a:	4632      	mov	r2, r6
 800220c:	9908      	ldr	r1, [sp, #32]
 800220e:	4628      	mov	r0, r5
 8002210:	f7ff ffc8 	bl	80021a4 <I2C_WaitOnTXISFlagUntilTimeout>
 8002214:	b110      	cbz	r0, 800221c <I2C_RequestMemoryRead+0x28>
    return HAL_ERROR;
 8002216:	2001      	movs	r0, #1
}
 8002218:	b003      	add	sp, #12
 800221a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800221c:	2f01      	cmp	r7, #1
 800221e:	682b      	ldr	r3, [r5, #0]
 8002220:	d10c      	bne.n	800223c <I2C_RequestMemoryRead+0x48>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8002222:	b2e4      	uxtb	r4, r4
 8002224:	629c      	str	r4, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8002226:	9b08      	ldr	r3, [sp, #32]
 8002228:	9600      	str	r6, [sp, #0]
 800222a:	2200      	movs	r2, #0
 800222c:	2140      	movs	r1, #64	; 0x40
 800222e:	4628      	mov	r0, r5
 8002230:	f7ff ff50 	bl	80020d4 <I2C_WaitOnFlagUntilTimeout>
    return HAL_ERROR;
 8002234:	3000      	adds	r0, #0
 8002236:	bf18      	it	ne
 8002238:	2001      	movne	r0, #1
 800223a:	e7ed      	b.n	8002218 <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800223c:	0a22      	lsrs	r2, r4, #8
 800223e:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002240:	9908      	ldr	r1, [sp, #32]
 8002242:	4632      	mov	r2, r6
 8002244:	4628      	mov	r0, r5
 8002246:	f7ff ffad 	bl	80021a4 <I2C_WaitOnTXISFlagUntilTimeout>
 800224a:	2800      	cmp	r0, #0
 800224c:	d1e3      	bne.n	8002216 <I2C_RequestMemoryRead+0x22>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800224e:	682b      	ldr	r3, [r5, #0]
 8002250:	e7e7      	b.n	8002222 <I2C_RequestMemoryRead+0x2e>
 8002252:	bf00      	nop
 8002254:	80002000 	.word	0x80002000

08002258 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8002258:	b570      	push	{r4, r5, r6, lr}
 800225a:	4604      	mov	r4, r0
 800225c:	460d      	mov	r5, r1
 800225e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002260:	6823      	ldr	r3, [r4, #0]
 8002262:	699b      	ldr	r3, [r3, #24]
 8002264:	069b      	lsls	r3, r3, #26
 8002266:	d501      	bpl.n	800226c <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
 8002268:	2000      	movs	r0, #0
 800226a:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800226c:	4632      	mov	r2, r6
 800226e:	4629      	mov	r1, r5
 8002270:	4620      	mov	r0, r4
 8002272:	f7ff ff5a 	bl	800212a <I2C_IsAcknowledgeFailed>
 8002276:	b990      	cbnz	r0, 800229e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002278:	f7fe fe94 	bl	8000fa4 <HAL_GetTick>
 800227c:	1b80      	subs	r0, r0, r6
 800227e:	4285      	cmp	r5, r0
 8002280:	d301      	bcc.n	8002286 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 8002282:	2d00      	cmp	r5, #0
 8002284:	d1ec      	bne.n	8002260 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002286:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002288:	f043 0320 	orr.w	r3, r3, #32
 800228c:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800228e:	2320      	movs	r3, #32
 8002290:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002294:	2300      	movs	r3, #0
 8002296:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 800229a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 800229e:	2001      	movs	r0, #1
}
 80022a0:	bd70      	pop	{r4, r5, r6, pc}

080022a2 <HAL_I2C_Init>:
{
 80022a2:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 80022a4:	4604      	mov	r4, r0
 80022a6:	2800      	cmp	r0, #0
 80022a8:	d04a      	beq.n	8002340 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 80022aa:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80022ae:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80022b2:	b91b      	cbnz	r3, 80022bc <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
 80022b4:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 80022b8:	f00f fd50 	bl	8011d5c <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 80022bc:	2324      	movs	r3, #36	; 0x24
 80022be:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 80022c2:	6823      	ldr	r3, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80022c4:	68e1      	ldr	r1, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 80022c6:	681a      	ldr	r2, [r3, #0]
 80022c8:	f022 0201 	bic.w	r2, r2, #1
 80022cc:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 80022ce:	6862      	ldr	r2, [r4, #4]
 80022d0:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80022d4:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80022d6:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80022d8:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80022da:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80022de:	609a      	str	r2, [r3, #8]
 80022e0:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80022e2:	d124      	bne.n	800232e <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80022e4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80022e8:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80022ea:	685a      	ldr	r2, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80022ec:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80022ee:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80022f2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80022f6:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80022f8:	68da      	ldr	r2, [r3, #12]
 80022fa:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80022fe:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8002300:	6922      	ldr	r2, [r4, #16]
 8002302:	430a      	orrs	r2, r1
 8002304:	69a1      	ldr	r1, [r4, #24]
 8002306:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800230a:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800230c:	6a21      	ldr	r1, [r4, #32]
 800230e:	69e2      	ldr	r2, [r4, #28]
 8002310:	430a      	orrs	r2, r1
 8002312:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8002314:	681a      	ldr	r2, [r3, #0]
 8002316:	f042 0201 	orr.w	r2, r2, #1
 800231a:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800231c:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800231e:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002320:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8002322:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8002326:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8002328:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  return HAL_OK;
 800232c:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800232e:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8002332:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8002334:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8002336:	bf04      	itt	eq
 8002338:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 800233c:	605a      	streq	r2, [r3, #4]
 800233e:	e7d4      	b.n	80022ea <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 8002340:	2001      	movs	r0, #1
}
 8002342:	bd10      	pop	{r4, pc}

08002344 <HAL_I2C_Mem_Read>:
{
 8002344:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002348:	469b      	mov	fp, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 800234a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 800234e:	b085      	sub	sp, #20
  if (hi2c->State == HAL_I2C_STATE_READY)
 8002350:	2b20      	cmp	r3, #32
{
 8002352:	4604      	mov	r4, r0
 8002354:	460f      	mov	r7, r1
 8002356:	9203      	str	r2, [sp, #12]
 8002358:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
 800235c:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
  if (hi2c->State == HAL_I2C_STATE_READY)
 8002360:	f040 80a9 	bne.w	80024b6 <HAL_I2C_Mem_Read+0x172>
    if ((pData == NULL) || (Size == 0U))
 8002364:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8002366:	b113      	cbz	r3, 800236e <HAL_I2C_Mem_Read+0x2a>
 8002368:	f1ba 0f00 	cmp.w	sl, #0
 800236c:	d106      	bne.n	800237c <HAL_I2C_Mem_Read+0x38>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800236e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002372:	6463      	str	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8002374:	2001      	movs	r0, #1
}
 8002376:	b005      	add	sp, #20
 8002378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 800237c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8002380:	2b01      	cmp	r3, #1
 8002382:	f000 8098 	beq.w	80024b6 <HAL_I2C_Mem_Read+0x172>
 8002386:	2501      	movs	r5, #1
 8002388:	f880 5040 	strb.w	r5, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 800238c:	f7fe fe0a 	bl	8000fa4 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002390:	2319      	movs	r3, #25
 8002392:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
 8002394:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002396:	462a      	mov	r2, r5
 8002398:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800239c:	4620      	mov	r0, r4
 800239e:	f7ff fe99 	bl	80020d4 <I2C_WaitOnFlagUntilTimeout>
 80023a2:	4681      	mov	r9, r0
 80023a4:	2800      	cmp	r0, #0
 80023a6:	d1e5      	bne.n	8002374 <HAL_I2C_Mem_Read+0x30>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80023a8:	2322      	movs	r3, #34	; 0x22
 80023aa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80023ae:	2340      	movs	r3, #64	; 0x40
 80023b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->pBuffPtr  = pData;
 80023b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80023b6:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 80023b8:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferISR   = NULL;
 80023ba:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 80023bc:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80023c0:	9601      	str	r6, [sp, #4]
 80023c2:	f8cd 8000 	str.w	r8, [sp]
 80023c6:	465b      	mov	r3, fp
 80023c8:	9a03      	ldr	r2, [sp, #12]
 80023ca:	4639      	mov	r1, r7
 80023cc:	4620      	mov	r0, r4
 80023ce:	f7ff ff11 	bl	80021f4 <I2C_RequestMemoryRead>
 80023d2:	b110      	cbz	r0, 80023da <HAL_I2C_Mem_Read+0x96>
      __HAL_UNLOCK(hi2c);
 80023d4:	f884 9040 	strb.w	r9, [r4, #64]	; 0x40
 80023d8:	e7cc      	b.n	8002374 <HAL_I2C_Mem_Read+0x30>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80023da:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80023dc:	b29b      	uxth	r3, r3
 80023de:	2bff      	cmp	r3, #255	; 0xff
 80023e0:	4b36      	ldr	r3, [pc, #216]	; (80024bc <HAL_I2C_Mem_Read+0x178>)
 80023e2:	d958      	bls.n	8002496 <HAL_I2C_Mem_Read+0x152>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80023e4:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80023e6:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80023e8:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80023ea:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80023ee:	4639      	mov	r1, r7
 80023f0:	4620      	mov	r0, r4
 80023f2:	f7ff fe55 	bl	80020a0 <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80023f6:	9600      	str	r6, [sp, #0]
 80023f8:	4643      	mov	r3, r8
 80023fa:	2200      	movs	r2, #0
 80023fc:	2104      	movs	r1, #4
 80023fe:	4620      	mov	r0, r4
 8002400:	f7ff fe68 	bl	80020d4 <I2C_WaitOnFlagUntilTimeout>
 8002404:	2800      	cmp	r0, #0
 8002406:	d1b5      	bne.n	8002374 <HAL_I2C_Mem_Read+0x30>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8002408:	6822      	ldr	r2, [r4, #0]
 800240a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800240c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800240e:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8002410:	6a63      	ldr	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8002412:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->pBuffPtr++;
 8002414:	3301      	adds	r3, #1
 8002416:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8002418:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800241a:	3b01      	subs	r3, #1
 800241c:	b29b      	uxth	r3, r3
 800241e:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002420:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8002422:	3a01      	subs	r2, #1
 8002424:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002426:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8002428:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800242a:	b1ab      	cbz	r3, 8002458 <HAL_I2C_Mem_Read+0x114>
 800242c:	b9a2      	cbnz	r2, 8002458 <HAL_I2C_Mem_Read+0x114>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800242e:	9600      	str	r6, [sp, #0]
 8002430:	4643      	mov	r3, r8
 8002432:	2180      	movs	r1, #128	; 0x80
 8002434:	4620      	mov	r0, r4
 8002436:	f7ff fe4d 	bl	80020d4 <I2C_WaitOnFlagUntilTimeout>
 800243a:	2800      	cmp	r0, #0
 800243c:	d19a      	bne.n	8002374 <HAL_I2C_Mem_Read+0x30>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800243e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8002440:	b29b      	uxth	r3, r3
 8002442:	2bff      	cmp	r3, #255	; 0xff
 8002444:	d92f      	bls.n	80024a6 <HAL_I2C_Mem_Read+0x162>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8002446:	22ff      	movs	r2, #255	; 0xff
 8002448:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800244a:	9000      	str	r0, [sp, #0]
 800244c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8002450:	4639      	mov	r1, r7
 8002452:	4620      	mov	r0, r4
 8002454:	f7ff fe24 	bl	80020a0 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U);
 8002458:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800245a:	b29b      	uxth	r3, r3
 800245c:	2b00      	cmp	r3, #0
 800245e:	d1ca      	bne.n	80023f6 <HAL_I2C_Mem_Read+0xb2>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002460:	4632      	mov	r2, r6
 8002462:	4641      	mov	r1, r8
 8002464:	4620      	mov	r0, r4
 8002466:	f7ff fef7 	bl	8002258 <I2C_WaitOnSTOPFlagUntilTimeout>
 800246a:	2800      	cmp	r0, #0
 800246c:	d182      	bne.n	8002374 <HAL_I2C_Mem_Read+0x30>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800246e:	6823      	ldr	r3, [r4, #0]
 8002470:	2120      	movs	r1, #32
 8002472:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8002474:	685a      	ldr	r2, [r3, #4]
 8002476:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 800247a:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 800247e:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8002482:	f022 0201 	bic.w	r2, r2, #1
 8002486:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8002488:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800248c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8002490:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8002494:	e76f      	b.n	8002376 <HAL_I2C_Mem_Read+0x32>
      hi2c->XferSize = hi2c->XferCount;
 8002496:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8002498:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 800249a:	b292      	uxth	r2, r2
 800249c:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 800249e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80024a2:	b2d2      	uxtb	r2, r2
 80024a4:	e7a3      	b.n	80023ee <HAL_I2C_Mem_Read+0xaa>
          hi2c->XferSize = hi2c->XferCount;
 80024a6:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80024a8:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 80024aa:	b292      	uxth	r2, r2
 80024ac:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80024ae:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80024b2:	b2d2      	uxtb	r2, r2
 80024b4:	e7cc      	b.n	8002450 <HAL_I2C_Mem_Read+0x10c>
    return HAL_BUSY;
 80024b6:	2002      	movs	r0, #2
 80024b8:	e75d      	b.n	8002376 <HAL_I2C_Mem_Read+0x32>
 80024ba:	bf00      	nop
 80024bc:	80002400 	.word	0x80002400

080024c0 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80024c0:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 80024c4:	b2d2      	uxtb	r2, r2
 80024c6:	2a20      	cmp	r2, #32
{
 80024c8:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80024ca:	d11d      	bne.n	8002508 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80024cc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80024d0:	2b01      	cmp	r3, #1
 80024d2:	d019      	beq.n	8002508 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 80024d4:	2324      	movs	r3, #36	; 0x24
 80024d6:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80024da:	6803      	ldr	r3, [r0, #0]
 80024dc:	681c      	ldr	r4, [r3, #0]
 80024de:	f024 0401 	bic.w	r4, r4, #1
 80024e2:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80024e4:	681c      	ldr	r4, [r3, #0]
 80024e6:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 80024ea:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80024ec:	681c      	ldr	r4, [r3, #0]
 80024ee:	4321      	orrs	r1, r4
 80024f0:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80024f2:	6819      	ldr	r1, [r3, #0]
 80024f4:	f041 0101 	orr.w	r1, r1, #1
 80024f8:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80024fa:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80024fc:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8002500:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8002504:	4618      	mov	r0, r3
 8002506:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8002508:	2002      	movs	r0, #2
  }
}
 800250a:	bd10      	pop	{r4, pc}

0800250c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800250c:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800250e:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 8002512:	b2e4      	uxtb	r4, r4
 8002514:	2c20      	cmp	r4, #32
 8002516:	d11c      	bne.n	8002552 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002518:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800251c:	2b01      	cmp	r3, #1
 800251e:	d018      	beq.n	8002552 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8002520:	2324      	movs	r3, #36	; 0x24
 8002522:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8002526:	6803      	ldr	r3, [r0, #0]
 8002528:	681a      	ldr	r2, [r3, #0]
 800252a:	f022 0201 	bic.w	r2, r2, #1
 800252e:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8002530:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8002532:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8002536:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 800253a:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800253c:	681a      	ldr	r2, [r3, #0]
 800253e:	f042 0201 	orr.w	r2, r2, #1
 8002542:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002544:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8002546:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800254a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 800254e:	4618      	mov	r0, r3
 8002550:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8002552:	2002      	movs	r0, #2
  }
}
 8002554:	bd10      	pop	{r4, pc}

08002556 <LTDC_SetConfig>:
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 8002556:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t tmp1 = 0;
  uint32_t tmp2 = 0;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800255a:	01d2      	lsls	r2, r2, #7
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 800255c:	6804      	ldr	r4, [r0, #0]
 800255e:	684f      	ldr	r7, [r1, #4]
 8002560:	68e5      	ldr	r5, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8002562:	f8d1 e000 	ldr.w	lr, [r1]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
  tmp2 = (pLayerCfg->Alpha0 << 24);  
 8002566:	f8d1 9018 	ldr.w	r9, [r1, #24]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800256a:	3284      	adds	r2, #132	; 0x84
 800256c:	18a3      	adds	r3, r4, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 800256e:	f10e 0601 	add.w	r6, lr, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8002572:	6858      	ldr	r0, [r3, #4]
 8002574:	f000 20f0 	and.w	r0, r0, #4026593280	; 0xf000f000
 8002578:	6058      	str	r0, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 800257a:	68e0      	ldr	r0, [r4, #12]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 800257c:	f3c5 450b 	ubfx	r5, r5, #16, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8002580:	f3c0 400b 	ubfx	r0, r0, #16, #12
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8002584:	443d      	add	r5, r7
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8002586:	4430      	add	r0, r6
 8002588:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800258c:	6058      	str	r0, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 800258e:	68e0      	ldr	r0, [r4, #12]
 8002590:	68cd      	ldr	r5, [r1, #12]
 8002592:	f3c0 000a 	ubfx	r0, r0, #0, #11
 8002596:	4405      	add	r5, r0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8002598:	6898      	ldr	r0, [r3, #8]
 800259a:	f000 20f0 	and.w	r0, r0, #4026593280	; 0xf000f000
 800259e:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
 80025a0:	68e6      	ldr	r6, [r4, #12]
 80025a2:	6888      	ldr	r0, [r1, #8]
 80025a4:	f3c6 060a 	ubfx	r6, r6, #0, #11
 80025a8:	3001      	adds	r0, #1
 80025aa:	4430      	add	r0, r6
 80025ac:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 80025b0:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80025b2:	6918      	ldr	r0, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80025b4:	690e      	ldr	r6, [r1, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80025b6:	f020 0007 	bic.w	r0, r0, #7
 80025ba:	6118      	str	r0, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80025bc:	f04f 0c00 	mov.w	ip, #0
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80025c0:	611e      	str	r6, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80025c2:	699d      	ldr	r5, [r3, #24]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
 80025c4:	f891 0032 	ldrb.w	r0, [r1, #50]	; 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
 80025c8:	f891 8031 	ldrb.w	r8, [r1, #49]	; 0x31
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80025cc:	f8c3 c018 	str.w	ip, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
 80025d0:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 80025d4:	ea45 6509 	orr.w	r5, r5, r9, lsl #24
 80025d8:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
 80025dc:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 80025e0:	619d      	str	r5, [r3, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 80025e2:	6958      	ldr	r0, [r3, #20]
 80025e4:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
 80025e8:	6158      	str	r0, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80025ea:	6948      	ldr	r0, [r1, #20]
 80025ec:	6158      	str	r0, [r3, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80025ee:	69d8      	ldr	r0, [r3, #28]
 80025f0:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
 80025f4:	f020 0007 	bic.w	r0, r0, #7
 80025f8:	61d8      	str	r0, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80025fa:	6a08      	ldr	r0, [r1, #32]
 80025fc:	69cd      	ldr	r5, [r1, #28]
 80025fe:	4305      	orrs	r5, r0
 8002600:	61dd      	str	r5, [r3, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8002602:	6a98      	ldr	r0, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8002604:	6a48      	ldr	r0, [r1, #36]	; 0x24
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8002606:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 800260a:	6298      	str	r0, [r3, #40]	; 0x28

  if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 800260c:	b31e      	cbz	r6, 8002656 <LTDC_SetConfig+0x100>
  {
    tmp = 4;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 800260e:	2e01      	cmp	r6, #1
 8002610:	d023      	beq.n	800265a <LTDC_SetConfig+0x104>
  {
    tmp = 3;
  }
  else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8002612:	1eb0      	subs	r0, r6, #2
 8002614:	2802      	cmp	r0, #2
 8002616:	d922      	bls.n	800265e <LTDC_SetConfig+0x108>
    (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
      (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 8002618:	2e07      	cmp	r6, #7
  {
    tmp = 2;
  }
  else
  {
    tmp = 1;
 800261a:	bf0c      	ite	eq
 800261c:	2002      	moveq	r0, #2
 800261e:	2001      	movne	r0, #1
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8002620:	6add      	ldr	r5, [r3, #44]	; 0x2c
 8002622:	f005 25e0 	and.w	r5, r5, #3758153728	; 0xe000e000
 8002626:	62dd      	str	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8002628:	6a8d      	ldr	r5, [r1, #40]	; 0x28

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 800262a:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 800262c:	eba7 070e 	sub.w	r7, r7, lr
 8002630:	4345      	muls	r5, r0
 8002632:	4378      	muls	r0, r7
 8002634:	3003      	adds	r0, #3
 8002636:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800263a:	62d8      	str	r0, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 800263c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800263e:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
 8002642:	f020 0007 	bic.w	r0, r0, #7
 8002646:	6318      	str	r0, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8002648:	6319      	str	r1, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */  
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 800264a:	58a3      	ldr	r3, [r4, r2]
 800264c:	f043 0301 	orr.w	r3, r3, #1
 8002650:	50a3      	str	r3, [r4, r2]
 8002652:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tmp = 4;
 8002656:	2004      	movs	r0, #4
 8002658:	e7e2      	b.n	8002620 <LTDC_SetConfig+0xca>
    tmp = 3;
 800265a:	2003      	movs	r0, #3
 800265c:	e7e0      	b.n	8002620 <LTDC_SetConfig+0xca>
    tmp = 2;
 800265e:	2002      	movs	r0, #2
 8002660:	e7de      	b.n	8002620 <LTDC_SetConfig+0xca>
	...

08002664 <HAL_LTDC_Init>:
{
 8002664:	b538      	push	{r3, r4, r5, lr}
  if(hltdc == NULL)
 8002666:	4604      	mov	r4, r0
 8002668:	2800      	cmp	r0, #0
 800266a:	d063      	beq.n	8002734 <HAL_LTDC_Init+0xd0>
  if(hltdc->State == HAL_LTDC_STATE_RESET)
 800266c:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
 8002670:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002674:	b91b      	cbnz	r3, 800267e <HAL_LTDC_Init+0x1a>
    hltdc->Lock = HAL_UNLOCKED;
 8002676:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
    HAL_LTDC_MspInit(hltdc);
 800267a:	f00f f9b3 	bl	80119e4 <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 800267e:	2302      	movs	r3, #2
 8002680:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8002684:	6823      	ldr	r3, [r4, #0]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8002686:	68a0      	ldr	r0, [r4, #8]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8002688:	699a      	ldr	r2, [r3, #24]
 800268a:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800268e:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8002690:	6862      	ldr	r2, [r4, #4]
 8002692:	6999      	ldr	r1, [r3, #24]
 8002694:	4302      	orrs	r2, r0
 8002696:	68e0      	ldr	r0, [r4, #12]
 8002698:	4302      	orrs	r2, r0
  hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 800269a:	6920      	ldr	r0, [r4, #16]
 800269c:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 800269e:	430a      	orrs	r2, r1
 80026a0:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 80026a2:	689a      	ldr	r2, [r3, #8]
 80026a4:	4924      	ldr	r1, [pc, #144]	; (8002738 <HAL_LTDC_Init+0xd4>)
  tmp = (hltdc->Init.HorizontalSync << 16);
 80026a6:	6960      	ldr	r0, [r4, #20]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 80026a8:	400a      	ands	r2, r1
 80026aa:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 80026ac:	689a      	ldr	r2, [r3, #8]
 80026ae:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80026b2:	69a0      	ldr	r0, [r4, #24]
 80026b4:	4302      	orrs	r2, r0
 80026b6:	609a      	str	r2, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 80026b8:	68da      	ldr	r2, [r3, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16);
 80026ba:	69e0      	ldr	r0, [r4, #28]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 80026bc:	400a      	ands	r2, r1
 80026be:	60da      	str	r2, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 80026c0:	68da      	ldr	r2, [r3, #12]
 80026c2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80026c6:	6a20      	ldr	r0, [r4, #32]
 80026c8:	4302      	orrs	r2, r0
 80026ca:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 80026cc:	691a      	ldr	r2, [r3, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16);
 80026ce:	6a60      	ldr	r0, [r4, #36]	; 0x24
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 80026d0:	400a      	ands	r2, r1
 80026d2:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 80026d4:	691a      	ldr	r2, [r3, #16]
 80026d6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80026da:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80026dc:	4302      	orrs	r2, r0
 80026de:	611a      	str	r2, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 80026e0:	695a      	ldr	r2, [r3, #20]
 80026e2:	4011      	ands	r1, r2
 80026e4:	6159      	str	r1, [r3, #20]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 80026e6:	695a      	ldr	r2, [r3, #20]
  tmp = (hltdc->Init.TotalWidth << 16);
 80026e8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 80026ea:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80026ee:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80026f0:	430a      	orrs	r2, r1
 80026f2:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 80026f4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
 80026f6:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
 80026fa:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 80026fe:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
 8002702:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8002704:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002706:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 800270a:	430a      	orrs	r2, r1
 800270c:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 8002710:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8002714:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8002716:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002718:	f042 0206 	orr.w	r2, r2, #6
 800271c:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
 800271e:	699a      	ldr	r2, [r3, #24]
 8002720:	f042 0201 	orr.w	r2, r2, #1
 8002724:	619a      	str	r2, [r3, #24]
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 8002726:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
 8002728:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 800272a:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 800272e:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  return HAL_OK;
 8002732:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002734:	2001      	movs	r0, #1
}
 8002736:	bd38      	pop	{r3, r4, r5, pc}
 8002738:	f000f800 	.word	0xf000f800

0800273c <HAL_LTDC_ConfigLayer>:
{   
 800273c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
 800273e:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002742:	2b01      	cmp	r3, #1
{   
 8002744:	4606      	mov	r6, r0
 8002746:	468e      	mov	lr, r1
 8002748:	4694      	mov	ip, r2
 800274a:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hltdc);
 800274e:	d01d      	beq.n	800278c <HAL_LTDC_ConfigLayer+0x50>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8002750:	2434      	movs	r4, #52	; 0x34
 8002752:	460d      	mov	r5, r1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002754:	f886 00a1 	strb.w	r0, [r6, #161]	; 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8002758:	fb04 6402 	mla	r4, r4, r2, r6
 800275c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  __HAL_LOCK(hltdc);
 800275e:	2701      	movs	r7, #1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8002760:	3438      	adds	r4, #56	; 0x38
  __HAL_LOCK(hltdc);
 8002762:	f886 70a0 	strb.w	r7, [r6, #160]	; 0xa0
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8002766:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002768:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800276a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800276c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800276e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002770:	682b      	ldr	r3, [r5, #0]
 8002772:	6023      	str	r3, [r4, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002774:	4630      	mov	r0, r6
 8002776:	4662      	mov	r2, ip
 8002778:	4671      	mov	r1, lr
 800277a:	f7ff feec 	bl	8002556 <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 800277e:	6833      	ldr	r3, [r6, #0]
  __HAL_UNLOCK(hltdc);
 8002780:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002782:	625f      	str	r7, [r3, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
 8002784:	f886 70a1 	strb.w	r7, [r6, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8002788:	f886 00a0 	strb.w	r0, [r6, #160]	; 0xa0
}
 800278c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800278e <HAL_LTDC_SetAddress>:
  __HAL_LOCK(hltdc);
 800278e:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002792:	2b01      	cmp	r3, #1
{
 8002794:	b570      	push	{r4, r5, r6, lr}
 8002796:	f04f 0302 	mov.w	r3, #2
 800279a:	4604      	mov	r4, r0
  __HAL_LOCK(hltdc);
 800279c:	d015      	beq.n	80027ca <HAL_LTDC_SetAddress+0x3c>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 800279e:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1
  pLayerCfg->FBStartAdress = Address;
 80027a2:	2334      	movs	r3, #52	; 0x34
 80027a4:	4353      	muls	r3, r2
 80027a6:	18c6      	adds	r6, r0, r3
  __HAL_LOCK(hltdc);
 80027a8:	2501      	movs	r5, #1
 80027aa:	f880 50a0 	strb.w	r5, [r0, #160]	; 0xa0
  pLayerCfg->FBStartAdress = Address;
 80027ae:	65f1      	str	r1, [r6, #92]	; 0x5c
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
 80027b0:	f103 0138 	add.w	r1, r3, #56	; 0x38
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 80027b4:	4401      	add	r1, r0
 80027b6:	f7ff fece 	bl	8002556 <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 80027ba:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hltdc);
 80027bc:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 80027be:	625d      	str	r5, [r3, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
 80027c0:	f884 50a1 	strb.w	r5, [r4, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 80027c4:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0
  return HAL_OK;
 80027c8:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hltdc);
 80027ca:	4618      	mov	r0, r3
}
 80027cc:	bd70      	pop	{r4, r5, r6, pc}

080027ce <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80027ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80027d2:	4604      	mov	r4, r0
{
 80027d4:	b08a      	sub	sp, #40	; 0x28
  if (hpcd == NULL)
 80027d6:	2800      	cmp	r0, #0
 80027d8:	d074      	beq.n	80028c4 <HAL_PCD_Init+0xf6>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80027da:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
 80027de:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80027e2:	b91b      	cbnz	r3, 80027ec <HAL_PCD_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 80027e4:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 80027e8:	f00f fb5e 	bl	8011ea8 <HAL_PCD_MspInit>
  }

  hpcd->State = HAL_PCD_STATE_BUSY;

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80027ec:	4625      	mov	r5, r4
  hpcd->State = HAL_PCD_STATE_BUSY;
 80027ee:	2303      	movs	r3, #3
  __HAL_PCD_DISABLE(hpcd);
 80027f0:	f855 0b10 	ldr.w	r0, [r5], #16
  hpcd->State = HAL_PCD_STATE_BUSY;
 80027f4:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
  __HAL_PCD_DISABLE(hpcd);
 80027f8:	f002 fd07 	bl	800520a <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  (void)USB_CoreInit(hpcd->Instance, hpcd->Init);
 80027fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80027fe:	466e      	mov	r6, sp
 8002800:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8002802:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002804:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8002806:	e895 0003 	ldmia.w	r5, {r0, r1}
 800280a:	e886 0003 	stmia.w	r6, {r0, r1}
 800280e:	f104 0804 	add.w	r8, r4, #4
 8002812:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 8002816:	6820      	ldr	r0, [r4, #0]
 8002818:	f002 fcc2 	bl	80051a0 <USB_CoreInit>

  /* Force Device Mode*/
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 800281c:	2100      	movs	r1, #0
 800281e:	6820      	ldr	r0, [r4, #0]
 8002820:	f002 fcf9 	bl	8005216 <USB_SetCurrentMode>
 8002824:	2100      	movs	r1, #0
 8002826:	4622      	mov	r2, r4
 8002828:	4623      	mov	r3, r4
 800282a:	f104 0510 	add.w	r5, r4, #16

  /* Init endpoints structures */
  for (i = 0U; i < 15U; i++)
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800282e:	2601      	movs	r6, #1
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002830:	4608      	mov	r0, r1
    hpcd->IN_ep[i].num = i;
 8002832:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 8002836:	f8a3 1042 	strh.w	r1, [r3, #66]	; 0x42
 800283a:	3101      	adds	r1, #1
  for (i = 0U; i < 15U; i++)
 800283c:	290f      	cmp	r1, #15
    hpcd->IN_ep[i].is_in = 1U;
 800283e:	f883 603d 	strb.w	r6, [r3, #61]	; 0x3d
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002842:	f883 003f 	strb.w	r0, [r3, #63]	; 0x3f
    hpcd->IN_ep[i].maxpacket = 0U;
 8002846:	6458      	str	r0, [r3, #68]	; 0x44
    hpcd->IN_ep[i].xfer_buff = 0U;
 8002848:	6498      	str	r0, [r3, #72]	; 0x48
    hpcd->IN_ep[i].xfer_len = 0U;
 800284a:	6518      	str	r0, [r3, #80]	; 0x50
 800284c:	f103 031c 	add.w	r3, r3, #28
  for (i = 0U; i < 15U; i++)
 8002850:	d1ef      	bne.n	8002832 <HAL_PCD_Init+0x64>
 8002852:	2300      	movs	r3, #0
  }

  for (i = 0U; i < 15U; i++)
  {
    hpcd->OUT_ep[i].is_in = 0U;
 8002854:	461f      	mov	r7, r3
    hpcd->OUT_ep[i].num = i;
 8002856:	f882 31fc 	strb.w	r3, [r2, #508]	; 0x1fc
 800285a:	3301      	adds	r3, #1
  for (i = 0U; i < 15U; i++)
 800285c:	2b0f      	cmp	r3, #15
    hpcd->OUT_ep[i].is_in = 0U;
 800285e:	f882 71fd 	strb.w	r7, [r2, #509]	; 0x1fd
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8002862:	f882 71ff 	strb.w	r7, [r2, #511]	; 0x1ff
    hpcd->OUT_ep[i].maxpacket = 0U;
 8002866:	f8c2 7204 	str.w	r7, [r2, #516]	; 0x204
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800286a:	f8c2 7208 	str.w	r7, [r2, #520]	; 0x208
    hpcd->OUT_ep[i].xfer_len = 0U;
 800286e:	f8c2 7210 	str.w	r7, [r2, #528]	; 0x210
 8002872:	f102 021c 	add.w	r2, r2, #28
  for (i = 0U; i < 15U; i++)
 8002876:	d1ee      	bne.n	8002856 <HAL_PCD_Init+0x88>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 8002878:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800287a:	466e      	mov	r6, sp
 800287c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800287e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002880:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8002882:	e895 0003 	ldmia.w	r5, {r0, r1}
 8002886:	e886 0003 	stmia.w	r6, {r0, r1}
 800288a:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 800288e:	6820      	ldr	r0, [r4, #0]
 8002890:	f002 fd02 	bl	8005298 <USB_DevInit>

  hpcd->USB_Address = 0U;
  hpcd->State = HAL_PCD_STATE_READY;
 8002894:	2301      	movs	r3, #1
  hpcd->USB_Address = 0U;
 8002896:	f884 7038 	strb.w	r7, [r4, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 800289a:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 800289e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80028a0:	2b01      	cmp	r3, #1
 80028a2:	d102      	bne.n	80028aa <HAL_PCD_Init+0xdc>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80028a4:	4620      	mov	r0, r4
 80028a6:	f000 fc27 	bl	80030f8 <HAL_PCDEx_ActivateLPM>
  }

  /* Activate Battery charging */
  if (hpcd->Init.battery_charging_enable == 1U)
 80028aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80028ac:	2b01      	cmp	r3, #1
 80028ae:	d102      	bne.n	80028b6 <HAL_PCD_Init+0xe8>
  {
    (void)HAL_PCDEx_ActivateBCD(hpcd);
 80028b0:	4620      	mov	r0, r4
 80028b2:	f000 fc34 	bl	800311e <HAL_PCDEx_ActivateBCD>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 80028b6:	6820      	ldr	r0, [r4, #0]
 80028b8:	f002 ffc8 	bl	800584c <USB_DevDisconnect>

  return HAL_OK;
 80028bc:	2000      	movs	r0, #0
}
 80028be:	b00a      	add	sp, #40	; 0x28
 80028c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 80028c4:	2001      	movs	r0, #1
 80028c6:	e7fa      	b.n	80028be <HAL_PCD_Init+0xf0>

080028c8 <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 80028c8:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 80028cc:	2b01      	cmp	r3, #1
{
 80028ce:	b510      	push	{r4, lr}
 80028d0:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 80028d2:	d00c      	beq.n	80028ee <HAL_PCD_Start+0x26>
 80028d4:	2301      	movs	r3, #1
 80028d6:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  (void)USB_DevConnect(hpcd->Instance);
 80028da:	6800      	ldr	r0, [r0, #0]
 80028dc:	f002 ffaa 	bl	8005834 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80028e0:	6820      	ldr	r0, [r4, #0]
 80028e2:	f002 fc8c 	bl	80051fe <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 80028e6:	2000      	movs	r0, #0
 80028e8:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 80028ec:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80028ee:	2002      	movs	r0, #2
}
 80028f0:	bd10      	pop	{r4, pc}
	...

080028f4 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80028f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80028f8:	f8d0 9000 	ldr.w	r9, [r0]
{
 80028fc:	b085      	sub	sp, #20
 80028fe:	4604      	mov	r4, r0
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8002900:	4648      	mov	r0, r9
  uint32_t gSNPSiD = *(uint32_t *) TempReg;
 8002902:	f8d9 8040 	ldr.w	r8, [r9, #64]	; 0x40
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8002906:	f002 ffdc 	bl	80058c2 <USB_GetMode>
 800290a:	9000      	str	r0, [sp, #0]
 800290c:	2800      	cmp	r0, #0
 800290e:	f040 8154 	bne.w	8002bba <HAL_PCD_IRQHandler+0x2c6>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8002912:	6820      	ldr	r0, [r4, #0]
 8002914:	f002 ffa6 	bl	8005864 <USB_ReadInterrupts>
 8002918:	2800      	cmp	r0, #0
 800291a:	f000 814e 	beq.w	8002bba <HAL_PCD_IRQHandler+0x2c6>
    {
      return;
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800291e:	6820      	ldr	r0, [r4, #0]
 8002920:	f002 ffa0 	bl	8005864 <USB_ReadInterrupts>
 8002924:	0780      	lsls	r0, r0, #30
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8002926:	bf48      	it	mi
 8002928:	6822      	ldrmi	r2, [r4, #0]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800292a:	6820      	ldr	r0, [r4, #0]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800292c:	bf42      	ittt	mi
 800292e:	6953      	ldrmi	r3, [r2, #20]
 8002930:	f003 0302 	andmi.w	r3, r3, #2
 8002934:	6153      	strmi	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8002936:	f002 ff95 	bl	8005864 <USB_ReadInterrupts>
 800293a:	f410 2b00 	ands.w	fp, r0, #524288	; 0x80000
 800293e:	d00b      	beq.n	8002958 <HAL_PCD_IRQHandler+0x64>
    {
      epnum = 0U;

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8002940:	6820      	ldr	r0, [r4, #0]
 8002942:	f002 ff93 	bl	800586c <USB_ReadDevAllOutEpInterrupt>
 8002946:	f509 6630 	add.w	r6, r9, #2816	; 0xb00
 800294a:	4605      	mov	r5, r0

      while (ep_intr != 0U)
 800294c:	46b2      	mov	sl, r6
      epnum = 0U;
 800294e:	f04f 0b00 	mov.w	fp, #0
      while (ep_intr != 0U)
 8002952:	2d00      	cmp	r5, #0
 8002954:	f040 8134 	bne.w	8002bc0 <HAL_PCD_IRQHandler+0x2cc>
        epnum++;
        ep_intr >>= 1U;
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8002958:	6820      	ldr	r0, [r4, #0]
 800295a:	f002 ff83 	bl	8005864 <USB_ReadInterrupts>
 800295e:	0347      	lsls	r7, r0, #13
 8002960:	d50c      	bpl.n	800297c <HAL_PCD_IRQHandler+0x88>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8002962:	6820      	ldr	r0, [r4, #0]
 8002964:	f002 ff8a 	bl	800587c <USB_ReadDevAllInEpInterrupt>
 8002968:	4625      	mov	r5, r4
 800296a:	9001      	str	r0, [sp, #4]
 800296c:	f509 6810 	add.w	r8, r9, #2304	; 0x900

      epnum = 0U;
 8002970:	f04f 0b00 	mov.w	fp, #0

      while (ep_intr != 0U)
 8002974:	9b01      	ldr	r3, [sp, #4]
 8002976:	2b00      	cmp	r3, #0
 8002978:	f040 8164 	bne.w	8002c44 <HAL_PCD_IRQHandler+0x350>
        ep_intr >>= 1U;
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800297c:	6820      	ldr	r0, [r4, #0]
 800297e:	f002 ff71 	bl	8005864 <USB_ReadInterrupts>
 8002982:	2800      	cmp	r0, #0
 8002984:	da15      	bge.n	80029b2 <HAL_PCD_IRQHandler+0xbe>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8002986:	f8d9 3804 	ldr.w	r3, [r9, #2052]	; 0x804
 800298a:	f023 0301 	bic.w	r3, r3, #1
 800298e:	f8c9 3804 	str.w	r3, [r9, #2052]	; 0x804

      if (hpcd->LPM_State == LPM_L1)
 8002992:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 8002996:	2b01      	cmp	r3, #1
 8002998:	f040 81cf 	bne.w	8002d3a <HAL_PCD_IRQHandler+0x446>
      {
        hpcd->LPM_State = LPM_L0;
 800299c:	2100      	movs	r1, #0
 800299e:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 80029a2:	4620      	mov	r0, r4
 80029a4:	f00f fbe6 	bl	8012174 <HAL_PCDEx_LPM_Callback>
#else
        HAL_PCD_ResumeCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 80029a8:	6822      	ldr	r2, [r4, #0]
 80029aa:	6953      	ldr	r3, [r2, #20]
 80029ac:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80029b0:	6153      	str	r3, [r2, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80029b2:	6820      	ldr	r0, [r4, #0]
 80029b4:	f002 ff56 	bl	8005864 <USB_ReadInterrupts>
 80029b8:	0505      	lsls	r5, r0, #20
 80029ba:	d50b      	bpl.n	80029d4 <HAL_PCD_IRQHandler+0xe0>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80029bc:	f8d9 3808 	ldr.w	r3, [r9, #2056]	; 0x808
 80029c0:	07d8      	lsls	r0, r3, #31
 80029c2:	d502      	bpl.n	80029ca <HAL_PCD_IRQHandler+0xd6>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 80029c4:	4620      	mov	r0, r4
 80029c6:	f00f fad9 	bl	8011f7c <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80029ca:	6822      	ldr	r2, [r4, #0]
 80029cc:	6953      	ldr	r3, [r2, #20]
 80029ce:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80029d2:	6153      	str	r3, [r2, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 80029d4:	6820      	ldr	r0, [r4, #0]
 80029d6:	f002 ff45 	bl	8005864 <USB_ReadInterrupts>
 80029da:	0101      	lsls	r1, r0, #4
 80029dc:	d514      	bpl.n	8002a08 <HAL_PCD_IRQHandler+0x114>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 80029de:	6823      	ldr	r3, [r4, #0]
 80029e0:	695a      	ldr	r2, [r3, #20]
 80029e2:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 80029e6:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
 80029e8:	f894 23f4 	ldrb.w	r2, [r4, #1012]	; 0x3f4
 80029ec:	2a00      	cmp	r2, #0
 80029ee:	f040 81a8 	bne.w	8002d42 <HAL_PCD_IRQHandler+0x44e>
      {
        hpcd->LPM_State = LPM_L1;
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80029f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
        hpcd->LPM_State = LPM_L1;
 80029f4:	2101      	movs	r1, #1
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80029f6:	f3c3 0383 	ubfx	r3, r3, #2, #4
        hpcd->LPM_State = LPM_L1;
 80029fa:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80029fe:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8002a02:	4620      	mov	r0, r4
 8002a04:	f00f fbb6 	bl	8012174 <HAL_PCDEx_LPM_Callback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8002a08:	6820      	ldr	r0, [r4, #0]
 8002a0a:	f002 ff2b 	bl	8005864 <USB_ReadInterrupts>
 8002a0e:	04c2      	lsls	r2, r0, #19
 8002a10:	d534      	bpl.n	8002a7c <HAL_PCD_IRQHandler+0x188>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8002a12:	f509 6500 	add.w	r5, r9, #2048	; 0x800
 8002a16:	686b      	ldr	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8002a18:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8002a1a:	f023 0301 	bic.w	r3, r3, #1
 8002a1e:	606b      	str	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8002a20:	2110      	movs	r1, #16
 8002a22:	f002 fc0f 	bl	8005244 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002a26:	6860      	ldr	r0, [r4, #4]
 8002a28:	f509 6310 	add.w	r3, r9, #2304	; 0x900
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8002a2c:	f64f 317f 	movw	r1, #64383	; 0xfb7f
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002a30:	9a00      	ldr	r2, [sp, #0]
 8002a32:	4282      	cmp	r2, r0
 8002a34:	f040 8189 	bne.w	8002d4a <HAL_PCD_IRQHandler+0x456>
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8002a38:	69eb      	ldr	r3, [r5, #28]
 8002a3a:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8002a3e:	61eb      	str	r3, [r5, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8002a40:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002a42:	2b00      	cmp	r3, #0
 8002a44:	f000 819a 	beq.w	8002d7c <HAL_PCD_IRQHandler+0x488>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8002a48:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8002a4c:	f043 030b 	orr.w	r3, r3, #11
 8002a50:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8002a54:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002a56:	f043 030b 	orr.w	r3, r3, #11
 8002a5a:	646b      	str	r3, [r5, #68]	; 0x44
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8002a5c:	f8d9 3800 	ldr.w	r3, [r9, #2048]	; 0x800

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8002a60:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8002a62:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8002a66:	f8c9 3800 	str.w	r3, [r9, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8002a6a:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8002a6e:	f002 ff47 	bl	8005900 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8002a72:	6822      	ldr	r2, [r4, #0]
 8002a74:	6953      	ldr	r3, [r2, #20]
 8002a76:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002a7a:	6153      	str	r3, [r2, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8002a7c:	6820      	ldr	r0, [r4, #0]
 8002a7e:	f002 fef1 	bl	8005864 <USB_ReadInterrupts>
 8002a82:	0483      	lsls	r3, r0, #18
 8002a84:	d520      	bpl.n	8002ac8 <HAL_PCD_IRQHandler+0x1d4>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8002a86:	6820      	ldr	r0, [r4, #0]
 8002a88:	f002 ff1f 	bl	80058ca <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8002a8c:	6822      	ldr	r2, [r4, #0]
 8002a8e:	68d3      	ldr	r3, [r2, #12]
 8002a90:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8002a94:	60d3      	str	r3, [r2, #12]
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8002a96:	2303      	movs	r3, #3
 8002a98:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE;
 8002a9a:	2340      	movs	r3, #64	; 0x40
 8002a9c:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
        latency to the Data FIFO */

        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 8002a9e:	f000 ff9d 	bl	80039dc <HAL_RCC_GetHCLKFreq>

        if ((hclk >= 14200000U) && (hclk < 15000000U))
 8002aa2:	4bb3      	ldr	r3, [pc, #716]	; (8002d70 <HAL_PCD_IRQHandler+0x47c>)
 8002aa4:	4ab3      	ldr	r2, [pc, #716]	; (8002d74 <HAL_PCD_IRQHandler+0x480>)
 8002aa6:	4403      	add	r3, r0
 8002aa8:	4293      	cmp	r3, r2
 8002aaa:	6823      	ldr	r3, [r4, #0]
 8002aac:	f200 816f 	bhi.w	8002d8e <HAL_PCD_IRQHandler+0x49a>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002ab0:	68da      	ldr	r2, [r3, #12]
 8002ab2:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
        }

        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-200 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10) & USB_OTG_GUSBCFG_TRDT);
 8002ab6:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8002ab8:	4620      	mov	r0, r4
 8002aba:	f00f fa52 	bl	8011f62 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8002abe:	6822      	ldr	r2, [r4, #0]
 8002ac0:	6953      	ldr	r3, [r2, #20]
 8002ac2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002ac6:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8002ac8:	6820      	ldr	r0, [r4, #0]
 8002aca:	f002 fecb 	bl	8005864 <USB_ReadInterrupts>
 8002ace:	06c7      	lsls	r7, r0, #27
 8002ad0:	d52b      	bpl.n	8002b2a <HAL_PCD_IRQHandler+0x236>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002ad2:	6822      	ldr	r2, [r4, #0]
 8002ad4:	6993      	ldr	r3, [r2, #24]
 8002ad6:	f023 0310 	bic.w	r3, r3, #16
 8002ada:	6193      	str	r3, [r2, #24]

      temp = USBx->GRXSTSP;
 8002adc:	f8d9 5020 	ldr.w	r5, [r9, #32]

      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];

      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8002ae0:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8002ae4:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8002ae6:	f005 070f 	and.w	r7, r5, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8002aea:	f040 81a0 	bne.w	8002e2e <HAL_PCD_IRQHandler+0x53a>
      {
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8002aee:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8002af2:	421d      	tst	r5, r3
 8002af4:	d014      	beq.n	8002b20 <HAL_PCD_IRQHandler+0x22c>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff, (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));
 8002af6:	261c      	movs	r6, #28
 8002af8:	fb06 4607 	mla	r6, r6, r7, r4
 8002afc:	f3c5 150a 	ubfx	r5, r5, #4, #11
 8002b00:	462a      	mov	r2, r5
 8002b02:	f8d6 1208 	ldr.w	r1, [r6, #520]	; 0x208
 8002b06:	4648      	mov	r0, r9
 8002b08:	f002 fe1e 	bl	8005748 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8002b0c:	f8d6 3208 	ldr.w	r3, [r6, #520]	; 0x208
 8002b10:	442b      	add	r3, r5
 8002b12:	f8c6 3208 	str.w	r3, [r6, #520]	; 0x208
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8002b16:	f8d6 3214 	ldr.w	r3, [r6, #532]	; 0x214
 8002b1a:	441d      	add	r5, r3
 8002b1c:	f8c6 5214 	str.w	r5, [r6, #532]	; 0x214
      }
      else
      {
        /* ... */
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002b20:	6822      	ldr	r2, [r4, #0]
 8002b22:	6993      	ldr	r3, [r2, #24]
 8002b24:	f043 0310 	orr.w	r3, r3, #16
 8002b28:	6193      	str	r3, [r2, #24]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8002b2a:	6820      	ldr	r0, [r4, #0]
 8002b2c:	f002 fe9a 	bl	8005864 <USB_ReadInterrupts>
 8002b30:	0706      	lsls	r6, r0, #28
 8002b32:	d507      	bpl.n	8002b44 <HAL_PCD_IRQHandler+0x250>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8002b34:	4620      	mov	r0, r4
 8002b36:	f00f fa10 	bl	8011f5a <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8002b3a:	6822      	ldr	r2, [r4, #0]
 8002b3c:	6953      	ldr	r3, [r2, #20]
 8002b3e:	f003 0308 	and.w	r3, r3, #8
 8002b42:	6153      	str	r3, [r2, #20]
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8002b44:	6820      	ldr	r0, [r4, #0]
 8002b46:	f002 fe8d 	bl	8005864 <USB_ReadInterrupts>
 8002b4a:	02c5      	lsls	r5, r0, #11
 8002b4c:	d509      	bpl.n	8002b62 <HAL_PCD_IRQHandler+0x26e>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8002b4e:	fa5f f18b 	uxtb.w	r1, fp
 8002b52:	4620      	mov	r0, r4
 8002b54:	f00f fa48 	bl	8011fe8 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8002b58:	6822      	ldr	r2, [r4, #0]
 8002b5a:	6953      	ldr	r3, [r2, #20]
 8002b5c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002b60:	6153      	str	r3, [r2, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002b62:	6820      	ldr	r0, [r4, #0]
 8002b64:	f002 fe7e 	bl	8005864 <USB_ReadInterrupts>
 8002b68:	0280      	lsls	r0, r0, #10
 8002b6a:	d509      	bpl.n	8002b80 <HAL_PCD_IRQHandler+0x28c>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8002b6c:	fa5f f18b 	uxtb.w	r1, fp
 8002b70:	4620      	mov	r0, r4
 8002b72:	f00f fa35 	bl	8011fe0 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002b76:	6822      	ldr	r2, [r4, #0]
 8002b78:	6953      	ldr	r3, [r2, #20]
 8002b7a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002b7e:	6153      	str	r3, [r2, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8002b80:	6820      	ldr	r0, [r4, #0]
 8002b82:	f002 fe6f 	bl	8005864 <USB_ReadInterrupts>
 8002b86:	0041      	lsls	r1, r0, #1
 8002b88:	d507      	bpl.n	8002b9a <HAL_PCD_IRQHandler+0x2a6>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8002b8a:	4620      	mov	r0, r4
 8002b8c:	f00f fa30 	bl	8011ff0 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8002b90:	6822      	ldr	r2, [r4, #0]
 8002b92:	6953      	ldr	r3, [r2, #20]
 8002b94:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8002b98:	6153      	str	r3, [r2, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8002b9a:	6820      	ldr	r0, [r4, #0]
 8002b9c:	f002 fe62 	bl	8005864 <USB_ReadInterrupts>
 8002ba0:	0742      	lsls	r2, r0, #29
 8002ba2:	d50a      	bpl.n	8002bba <HAL_PCD_IRQHandler+0x2c6>
    {
      temp = hpcd->Instance->GOTGINT;
 8002ba4:	6823      	ldr	r3, [r4, #0]
 8002ba6:	685d      	ldr	r5, [r3, #4]

      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8002ba8:	076b      	lsls	r3, r5, #29
 8002baa:	d502      	bpl.n	8002bb2 <HAL_PCD_IRQHandler+0x2be>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8002bac:	4620      	mov	r0, r4
 8002bae:	f00f fa23 	bl	8011ff8 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
 8002bb2:	6823      	ldr	r3, [r4, #0]
 8002bb4:	685a      	ldr	r2, [r3, #4]
 8002bb6:	4315      	orrs	r5, r2
 8002bb8:	605d      	str	r5, [r3, #4]
    }
  }
}
 8002bba:	b005      	add	sp, #20
 8002bbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((ep_intr & 0x1U) != 0U)
 8002bc0:	07e9      	lsls	r1, r5, #31
 8002bc2:	d52e      	bpl.n	8002c22 <HAL_PCD_IRQHandler+0x32e>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8002bc4:	fa5f f28b 	uxtb.w	r2, fp
 8002bc8:	4611      	mov	r1, r2
 8002bca:	6820      	ldr	r0, [r4, #0]
 8002bcc:	9201      	str	r2, [sp, #4]
 8002bce:	f002 fe5d 	bl	800588c <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8002bd2:	07c2      	lsls	r2, r0, #31
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8002bd4:	4607      	mov	r7, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8002bd6:	d50d      	bpl.n	8002bf4 <HAL_PCD_IRQHandler+0x300>
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8002bd8:	4b67      	ldr	r3, [pc, #412]	; (8002d78 <HAL_PCD_IRQHandler+0x484>)
 8002bda:	9a01      	ldr	r2, [sp, #4]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8002bdc:	2101      	movs	r1, #1
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8002bde:	4598      	cmp	r8, r3
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8002be0:	f8ca 1008 	str.w	r1, [sl, #8]
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8002be4:	d129      	bne.n	8002c3a <HAL_PCD_IRQHandler+0x346>
              if ((USBx_OUTEP(0U)->DOEPINT & (1U << 15)) != 0U)
 8002be6:	68b1      	ldr	r1, [r6, #8]
 8002be8:	040b      	lsls	r3, r1, #16
 8002bea:	d520      	bpl.n	8002c2e <HAL_PCD_IRQHandler+0x33a>
                CLEAR_OUT_EP_INTR(epnum, (1U << 15));
 8002bec:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002bf0:	f8ca 2008 	str.w	r2, [sl, #8]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8002bf4:	0739      	lsls	r1, r7, #28
 8002bf6:	d50f      	bpl.n	8002c18 <HAL_PCD_IRQHandler+0x324>
            if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8002bf8:	4b5f      	ldr	r3, [pc, #380]	; (8002d78 <HAL_PCD_IRQHandler+0x484>)
 8002bfa:	4598      	cmp	r8, r3
 8002bfc:	d106      	bne.n	8002c0c <HAL_PCD_IRQHandler+0x318>
              if ((USBx_OUTEP(0U)->DOEPINT & (1U << 15)) != 0U)
 8002bfe:	68b2      	ldr	r2, [r6, #8]
 8002c00:	0412      	lsls	r2, r2, #16
                CLEAR_OUT_EP_INTR(epnum, (1U << 15));
 8002c02:	bf44      	itt	mi
 8002c04:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
 8002c08:	f8ca 2008 	strmi.w	r2, [sl, #8]
            HAL_PCD_SetupStageCallback(hpcd);
 8002c0c:	4620      	mov	r0, r4
 8002c0e:	f00f f98d 	bl	8011f2c <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8002c12:	2308      	movs	r3, #8
 8002c14:	f8ca 3008 	str.w	r3, [sl, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8002c18:	06fb      	lsls	r3, r7, #27
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8002c1a:	bf44      	itt	mi
 8002c1c:	2310      	movmi	r3, #16
 8002c1e:	f8ca 3008 	strmi.w	r3, [sl, #8]
        epnum++;
 8002c22:	f10b 0b01 	add.w	fp, fp, #1
        ep_intr >>= 1U;
 8002c26:	086d      	lsrs	r5, r5, #1
 8002c28:	f10a 0a20 	add.w	sl, sl, #32
 8002c2c:	e691      	b.n	8002952 <HAL_PCD_IRQHandler+0x5e>
                if ((USBx_OUTEP(0U)->DOEPINT & (1U << 5)) != 0U)
 8002c2e:	68b1      	ldr	r1, [r6, #8]
 8002c30:	0688      	lsls	r0, r1, #26
                  CLEAR_OUT_EP_INTR(epnum, (1U << 5));
 8002c32:	bf44      	itt	mi
 8002c34:	2120      	movmi	r1, #32
 8002c36:	f8ca 1008 	strmi.w	r1, [sl, #8]
              HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8002c3a:	4611      	mov	r1, r2
 8002c3c:	4620      	mov	r0, r4
 8002c3e:	f00f f97b 	bl	8011f38 <HAL_PCD_DataOutStageCallback>
 8002c42:	e7d7      	b.n	8002bf4 <HAL_PCD_IRQHandler+0x300>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8002c44:	9b01      	ldr	r3, [sp, #4]
 8002c46:	07de      	lsls	r6, r3, #31
 8002c48:	d56e      	bpl.n	8002d28 <HAL_PCD_IRQHandler+0x434>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8002c4a:	fa5f fa8b 	uxtb.w	sl, fp
 8002c4e:	4651      	mov	r1, sl
 8002c50:	6820      	ldr	r0, [r4, #0]
 8002c52:	f002 fe24 	bl	800589e <USB_ReadDevInEPInterrupt>
 8002c56:	4606      	mov	r6, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8002c58:	07f0      	lsls	r0, r6, #31
 8002c5a:	d510      	bpl.n	8002c7e <HAL_PCD_IRQHandler+0x38a>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002c5c:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & 0xFU));
 8002c60:	2001      	movs	r0, #1
 8002c62:	f00b 020f 	and.w	r2, fp, #15
 8002c66:	fa00 f202 	lsl.w	r2, r0, r2
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002c6a:	ea23 0302 	bic.w	r3, r3, r2
 8002c6e:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8002c72:	4651      	mov	r1, sl
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8002c74:	f8c8 0008 	str.w	r0, [r8, #8]
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8002c78:	4620      	mov	r0, r4
 8002c7a:	f00f f966 	bl	8011f4a <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8002c7e:	0731      	lsls	r1, r6, #28
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8002c80:	bf44      	itt	mi
 8002c82:	2308      	movmi	r3, #8
 8002c84:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8002c88:	06f2      	lsls	r2, r6, #27
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8002c8a:	bf44      	itt	mi
 8002c8c:	2310      	movmi	r3, #16
 8002c8e:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8002c92:	0673      	lsls	r3, r6, #25
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8002c94:	bf44      	itt	mi
 8002c96:	2340      	movmi	r3, #64	; 0x40
 8002c98:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8002c9c:	07b7      	lsls	r7, r6, #30
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8002c9e:	bf44      	itt	mi
 8002ca0:	2302      	movmi	r3, #2
 8002ca2:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8002ca6:	0636      	lsls	r6, r6, #24
 8002ca8:	d53e      	bpl.n	8002d28 <HAL_PCD_IRQHandler+0x434>
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 8002caa:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002cac:	6d2e      	ldr	r6, [r5, #80]	; 0x50
 8002cae:	42b3      	cmp	r3, r6
 8002cb0:	d83a      	bhi.n	8002d28 <HAL_PCD_IRQHandler+0x434>
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 8002cb2:	1af6      	subs	r6, r6, r3
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;
 8002cb4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8002cb6:	6822      	ldr	r2, [r4, #0]
 8002cb8:	9202      	str	r2, [sp, #8]
  len32b = (len + 3U) / 4U;
 8002cba:	429e      	cmp	r6, r3
 8002cbc:	bf28      	it	cs
 8002cbe:	461e      	movcs	r6, r3

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8002cc0:	f502 6310 	add.w	r3, r2, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 8002cc4:	3603      	adds	r6, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8002cc6:	eb03 134b 	add.w	r3, r3, fp, lsl #5
  len32b = (len + 3U) / 4U;
 8002cca:	08b6      	lsrs	r6, r6, #2
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8002ccc:	9303      	str	r3, [sp, #12]
 8002cce:	9b03      	ldr	r3, [sp, #12]
 8002cd0:	6d2f      	ldr	r7, [r5, #80]	; 0x50
 8002cd2:	699b      	ldr	r3, [r3, #24]
 8002cd4:	b29b      	uxth	r3, r3
 8002cd6:	42b3      	cmp	r3, r6
 8002cd8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002cda:	d923      	bls.n	8002d24 <HAL_PCD_IRQHandler+0x430>
 8002cdc:	429f      	cmp	r7, r3
 8002cde:	d921      	bls.n	8002d24 <HAL_PCD_IRQHandler+0x430>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8002ce0:	b967      	cbnz	r7, 8002cfc <HAL_PCD_IRQHandler+0x408>
  }

  if (ep->xfer_len <= ep->xfer_count)
  {
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002ce2:	9b02      	ldr	r3, [sp, #8]
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
 8002ce4:	2201      	movs	r2, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002ce6:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
 8002cea:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << epnum);
 8002cee:	fa02 f20b 	lsl.w	r2, r2, fp
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002cf2:	ea23 0302 	bic.w	r3, r3, r2
 8002cf6:	f8ca 3034 	str.w	r3, [sl, #52]	; 0x34
 8002cfa:	e015      	b.n	8002d28 <HAL_PCD_IRQHandler+0x434>
    len = ep->xfer_len - ep->xfer_count;
 8002cfc:	1aff      	subs	r7, r7, r3
 8002cfe:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len);
 8002d00:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 8002d02:	9802      	ldr	r0, [sp, #8]
 8002d04:	429f      	cmp	r7, r3
 8002d06:	bf28      	it	cs
 8002d08:	461f      	movcs	r7, r3
 8002d0a:	b2bb      	uxth	r3, r7
 8002d0c:	4652      	mov	r2, sl
 8002d0e:	f002 fc45 	bl	800559c <USB_WritePacket>
    ep->xfer_buff  += len;
 8002d12:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8002d14:	443b      	add	r3, r7
 8002d16:	64ab      	str	r3, [r5, #72]	; 0x48
    ep->xfer_count += len;
 8002d18:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    len32b = (len + 3U) / 4U;
 8002d1a:	1cfe      	adds	r6, r7, #3
    ep->xfer_count += len;
 8002d1c:	441f      	add	r7, r3
    len32b = (len + 3U) / 4U;
 8002d1e:	08b6      	lsrs	r6, r6, #2
    ep->xfer_count += len;
 8002d20:	656f      	str	r7, [r5, #84]	; 0x54
 8002d22:	e7d4      	b.n	8002cce <HAL_PCD_IRQHandler+0x3da>
  if (ep->xfer_len <= ep->xfer_count)
 8002d24:	429f      	cmp	r7, r3
 8002d26:	d9dc      	bls.n	8002ce2 <HAL_PCD_IRQHandler+0x3ee>
        ep_intr >>= 1U;
 8002d28:	9b01      	ldr	r3, [sp, #4]
 8002d2a:	085b      	lsrs	r3, r3, #1
        epnum++;
 8002d2c:	f10b 0b01 	add.w	fp, fp, #1
        ep_intr >>= 1U;
 8002d30:	9301      	str	r3, [sp, #4]
 8002d32:	351c      	adds	r5, #28
 8002d34:	f108 0820 	add.w	r8, r8, #32
 8002d38:	e61c      	b.n	8002974 <HAL_PCD_IRQHandler+0x80>
        HAL_PCD_ResumeCallback(hpcd);
 8002d3a:	4620      	mov	r0, r4
 8002d3c:	f00f f936 	bl	8011fac <HAL_PCD_ResumeCallback>
 8002d40:	e632      	b.n	80029a8 <HAL_PCD_IRQHandler+0xb4>
        HAL_PCD_SuspendCallback(hpcd);
 8002d42:	4620      	mov	r0, r4
 8002d44:	f00f f91a 	bl	8011f7c <HAL_PCD_SuspendCallback>
 8002d48:	e65e      	b.n	8002a08 <HAL_PCD_IRQHandler+0x114>
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8002d4a:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8002d4c:	681a      	ldr	r2, [r3, #0]
 8002d4e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002d52:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8002d54:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8002d58:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8002d5c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002d60:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002d64:	9a00      	ldr	r2, [sp, #0]
 8002d66:	3201      	adds	r2, #1
 8002d68:	9200      	str	r2, [sp, #0]
 8002d6a:	3320      	adds	r3, #32
 8002d6c:	e660      	b.n	8002a30 <HAL_PCD_IRQHandler+0x13c>
 8002d6e:	bf00      	nop
 8002d70:	ff275340 	.word	0xff275340
 8002d74:	000c34ff 	.word	0x000c34ff
 8002d78:	4f54310a 	.word	0x4f54310a
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8002d7c:	696b      	ldr	r3, [r5, #20]
 8002d7e:	f043 030b 	orr.w	r3, r3, #11
 8002d82:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8002d84:	692b      	ldr	r3, [r5, #16]
 8002d86:	f043 030b 	orr.w	r3, r3, #11
 8002d8a:	612b      	str	r3, [r5, #16]
 8002d8c:	e666      	b.n	8002a5c <HAL_PCD_IRQHandler+0x168>
        else if ((hclk >= 15000000U) && (hclk < 16000000U))
 8002d8e:	4a2f      	ldr	r2, [pc, #188]	; (8002e4c <HAL_PCD_IRQHandler+0x558>)
 8002d90:	492f      	ldr	r1, [pc, #188]	; (8002e50 <HAL_PCD_IRQHandler+0x55c>)
 8002d92:	4402      	add	r2, r0
 8002d94:	428a      	cmp	r2, r1
 8002d96:	d803      	bhi.n	8002da0 <HAL_PCD_IRQHandler+0x4ac>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002d98:	68da      	ldr	r2, [r3, #12]
 8002d9a:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 8002d9e:	e68a      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8002da0:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 8002da4:	492b      	ldr	r1, [pc, #172]	; (8002e54 <HAL_PCD_IRQHandler+0x560>)
 8002da6:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 8002daa:	428a      	cmp	r2, r1
 8002dac:	d803      	bhi.n	8002db6 <HAL_PCD_IRQHandler+0x4c2>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002dae:	68da      	ldr	r2, [r3, #12]
 8002db0:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 8002db4:	e67f      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8002db6:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 8002dba:	4927      	ldr	r1, [pc, #156]	; (8002e58 <HAL_PCD_IRQHandler+0x564>)
 8002dbc:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 8002dc0:	428a      	cmp	r2, r1
 8002dc2:	d803      	bhi.n	8002dcc <HAL_PCD_IRQHandler+0x4d8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002dc4:	68da      	ldr	r2, [r3, #12]
 8002dc6:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 8002dca:	e674      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8002dcc:	4a23      	ldr	r2, [pc, #140]	; (8002e5c <HAL_PCD_IRQHandler+0x568>)
 8002dce:	4924      	ldr	r1, [pc, #144]	; (8002e60 <HAL_PCD_IRQHandler+0x56c>)
 8002dd0:	4402      	add	r2, r0
 8002dd2:	428a      	cmp	r2, r1
 8002dd4:	d803      	bhi.n	8002dde <HAL_PCD_IRQHandler+0x4ea>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002dd6:	68da      	ldr	r2, [r3, #12]
 8002dd8:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 8002ddc:	e66b      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8002dde:	4a21      	ldr	r2, [pc, #132]	; (8002e64 <HAL_PCD_IRQHandler+0x570>)
 8002de0:	4921      	ldr	r1, [pc, #132]	; (8002e68 <HAL_PCD_IRQHandler+0x574>)
 8002de2:	4402      	add	r2, r0
 8002de4:	428a      	cmp	r2, r1
 8002de6:	d803      	bhi.n	8002df0 <HAL_PCD_IRQHandler+0x4fc>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10) & USB_OTG_GUSBCFG_TRDT);
 8002de8:	68da      	ldr	r2, [r3, #12]
 8002dea:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 8002dee:	e662      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8002df0:	4a1e      	ldr	r2, [pc, #120]	; (8002e6c <HAL_PCD_IRQHandler+0x578>)
 8002df2:	491f      	ldr	r1, [pc, #124]	; (8002e70 <HAL_PCD_IRQHandler+0x57c>)
 8002df4:	4402      	add	r2, r0
 8002df6:	428a      	cmp	r2, r1
 8002df8:	d803      	bhi.n	8002e02 <HAL_PCD_IRQHandler+0x50e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10) & USB_OTG_GUSBCFG_TRDT);
 8002dfa:	68da      	ldr	r2, [r3, #12]
 8002dfc:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8002e00:	e659      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8002e02:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 8002e06:	491b      	ldr	r1, [pc, #108]	; (8002e74 <HAL_PCD_IRQHandler+0x580>)
 8002e08:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8002e0c:	428a      	cmp	r2, r1
 8002e0e:	d803      	bhi.n	8002e18 <HAL_PCD_IRQHandler+0x524>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10) & USB_OTG_GUSBCFG_TRDT);
 8002e10:	68da      	ldr	r2, [r3, #12]
 8002e12:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002e16:	e64e      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
        else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8002e18:	4a17      	ldr	r2, [pc, #92]	; (8002e78 <HAL_PCD_IRQHandler+0x584>)
 8002e1a:	4918      	ldr	r1, [pc, #96]	; (8002e7c <HAL_PCD_IRQHandler+0x588>)
 8002e1c:	4402      	add	r2, r0
 8002e1e:	428a      	cmp	r2, r1
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10) & USB_OTG_GUSBCFG_TRDT);
 8002e20:	68da      	ldr	r2, [r3, #12]
 8002e22:	bf94      	ite	ls
 8002e24:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10) & USB_OTG_GUSBCFG_TRDT);
 8002e28:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 8002e2c:	e643      	b.n	8002ab6 <HAL_PCD_IRQHandler+0x1c2>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8002e2e:	2b06      	cmp	r3, #6
 8002e30:	f47f ae76 	bne.w	8002b20 <HAL_PCD_IRQHandler+0x22c>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8002e34:	2208      	movs	r2, #8
 8002e36:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8002e3a:	4648      	mov	r0, r9
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8002e3c:	261c      	movs	r6, #28
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8002e3e:	f002 fc83 	bl	8005748 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8002e42:	fb06 4607 	mla	r6, r6, r7, r4
 8002e46:	f3c5 150a 	ubfx	r5, r5, #4, #11
 8002e4a:	e664      	b.n	8002b16 <HAL_PCD_IRQHandler+0x222>
 8002e4c:	ff1b1e40 	.word	0xff1b1e40
 8002e50:	000f423f 	.word	0x000f423f
 8002e54:	00124f7f 	.word	0x00124f7f
 8002e58:	0013d61f 	.word	0x0013d61f
 8002e5c:	fee5b660 	.word	0xfee5b660
 8002e60:	0016e35f 	.word	0x0016e35f
 8002e64:	feced300 	.word	0xfeced300
 8002e68:	001b773f 	.word	0x001b773f
 8002e6c:	feb35bc0 	.word	0xfeb35bc0
 8002e70:	002191bf 	.word	0x002191bf
 8002e74:	0038751f 	.word	0x0038751f
 8002e78:	fe5954e0 	.word	0xfe5954e0
 8002e7c:	00419cdf 	.word	0x00419cdf

08002e80 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8002e80:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8002e84:	2a01      	cmp	r2, #1
{
 8002e86:	b510      	push	{r4, lr}
 8002e88:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8002e8a:	d00b      	beq.n	8002ea4 <HAL_PCD_SetAddress+0x24>
 8002e8c:	2201      	movs	r2, #1
 8002e8e:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc
  hpcd->USB_Address = address;
 8002e92:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8002e96:	6800      	ldr	r0, [r0, #0]
 8002e98:	f002 fcbc 	bl	8005814 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8002e9c:	2000      	movs	r0, #0
 8002e9e:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8002ea2:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8002ea4:	2002      	movs	r0, #2
}
 8002ea6:	bd10      	pop	{r4, pc}

08002ea8 <HAL_PCD_EP_Open>:
{
 8002ea8:	b570      	push	{r4, r5, r6, lr}
 8002eaa:	4604      	mov	r4, r0
 8002eac:	f001 000f 	and.w	r0, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8002eb0:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002eb4:	f04f 061c 	mov.w	r6, #28
 8002eb8:	b2c5      	uxtb	r5, r0
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002eba:	fb06 4105 	mla	r1, r6, r5, r4
    ep->is_in = 1U;
 8002ebe:	bf15      	itete	ne
 8002ec0:	fb06 4505 	mlane	r5, r6, r5, r4
    ep->is_in = 0U;
 8002ec4:	fb06 4505 	mlaeq	r5, r6, r5, r4
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002ec8:	313c      	addne	r1, #60	; 0x3c
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8002eca:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 1U;
 8002ece:	bf15      	itete	ne
 8002ed0:	2601      	movne	r6, #1
    ep->is_in = 0U;
 8002ed2:	2600      	moveq	r6, #0
    ep->is_in = 1U;
 8002ed4:	f885 603d 	strbne.w	r6, [r5, #61]	; 0x3d
    ep->is_in = 0U;
 8002ed8:	f885 61fd 	strbeq.w	r6, [r5, #509]	; 0x1fd
  ep->maxpacket = ep_mps;
 8002edc:	608a      	str	r2, [r1, #8]
  if (ep->is_in != 0U)
 8002ede:	784a      	ldrb	r2, [r1, #1]
  ep->type = ep_type;
 8002ee0:	70cb      	strb	r3, [r1, #3]
  ep->num = ep_addr & 0xFU;
 8002ee2:	b2c0      	uxtb	r0, r0
 8002ee4:	7008      	strb	r0, [r1, #0]
  if (ep->is_in != 0U)
 8002ee6:	b102      	cbz	r2, 8002eea <HAL_PCD_EP_Open+0x42>
    ep->tx_fifo_num = ep->num;
 8002ee8:	80c8      	strh	r0, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8002eea:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8002eec:	bf04      	itt	eq
 8002eee:	2300      	moveq	r3, #0
 8002ef0:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8002ef2:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8002ef6:	2b01      	cmp	r3, #1
 8002ef8:	d009      	beq.n	8002f0e <HAL_PCD_EP_Open+0x66>
 8002efa:	2301      	movs	r3, #1
 8002efc:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8002f00:	6820      	ldr	r0, [r4, #0]
 8002f02:	f002 fa65 	bl	80053d0 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8002f06:	2000      	movs	r0, #0
 8002f08:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return ret;
 8002f0c:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hpcd);
 8002f0e:	2002      	movs	r0, #2
}
 8002f10:	bd70      	pop	{r4, r5, r6, pc}

08002f12 <HAL_PCD_EP_Close>:
{
 8002f12:	f001 030f 	and.w	r3, r1, #15
 8002f16:	b2da      	uxtb	r2, r3
 8002f18:	b510      	push	{r4, lr}
 8002f1a:	4604      	mov	r4, r0
 8002f1c:	201c      	movs	r0, #28
  if ((ep_addr & 0x80U) == 0x80U)
 8002f1e:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002f22:	fb00 4102 	mla	r1, r0, r2, r4
 8002f26:	bf19      	ittee	ne
 8002f28:	313c      	addne	r1, #60	; 0x3c
    ep->is_in = 1U;
 8002f2a:	fb00 4202 	mlane	r2, r0, r2, r4
    ep->is_in = 0U;
 8002f2e:	fb00 4202 	mlaeq	r2, r0, r2, r4
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8002f32:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 1U;
 8002f36:	bf15      	itete	ne
 8002f38:	2001      	movne	r0, #1
    ep->is_in = 0U;
 8002f3a:	2000      	moveq	r0, #0
    ep->is_in = 1U;
 8002f3c:	f882 003d 	strbne.w	r0, [r2, #61]	; 0x3d
    ep->is_in = 0U;
 8002f40:	f882 01fd 	strbeq.w	r0, [r2, #509]	; 0x1fd
  ep->num   = ep_addr & 0xFU;
 8002f44:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8002f46:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8002f4a:	2b01      	cmp	r3, #1
 8002f4c:	d009      	beq.n	8002f62 <HAL_PCD_EP_Close+0x50>
 8002f4e:	2301      	movs	r3, #1
 8002f50:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8002f54:	6820      	ldr	r0, [r4, #0]
 8002f56:	f002 fa7d 	bl	8005454 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8002f5a:	2000      	movs	r0, #0
 8002f5c:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 8002f60:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8002f62:	2002      	movs	r0, #2
}
 8002f64:	bd10      	pop	{r4, pc}

08002f66 <HAL_PCD_EP_Receive>:
{
 8002f66:	b538      	push	{r3, r4, r5, lr}
 8002f68:	f001 050f 	and.w	r5, r1, #15
  ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8002f6c:	241c      	movs	r4, #28
 8002f6e:	fb04 0105 	mla	r1, r4, r5, r0
  ep->xfer_buff = pBuf;
 8002f72:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 8002f76:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
  ep->xfer_len = len;
 8002f7a:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->xfer_count = 0U;
 8002f7e:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 8002f80:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
  ep->xfer_count = 0U;
 8002f84:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
  ep->is_in = 0U;
 8002f88:	f884 31fd 	strb.w	r3, [r4, #509]	; 0x1fd
  ep->num = ep_addr & 0xFU;
 8002f8c:	f884 51fc 	strb.w	r5, [r4, #508]	; 0x1fc
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8002f90:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0xFU) == 0U)
 8002f92:	b91d      	cbnz	r5, 8002f9c <HAL_PCD_EP_Receive+0x36>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8002f94:	f002 fa90 	bl	80054b8 <USB_EP0StartXfer>
}
 8002f98:	2000      	movs	r0, #0
 8002f9a:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8002f9c:	f002 fb0e 	bl	80055bc <USB_EPStartXfer>
 8002fa0:	e7fa      	b.n	8002f98 <HAL_PCD_EP_Receive+0x32>

08002fa2 <HAL_PCD_EP_Transmit>:
{
 8002fa2:	b538      	push	{r3, r4, r5, lr}
 8002fa4:	f001 050f 	and.w	r5, r1, #15
  ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002fa8:	241c      	movs	r4, #28
 8002faa:	fb04 0105 	mla	r1, r4, r5, r0
  ep->xfer_buff = pBuf;
 8002fae:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002fb2:	313c      	adds	r1, #60	; 0x3c
  ep->xfer_len = len;
 8002fb4:	6523      	str	r3, [r4, #80]	; 0x50
  ep->xfer_count = 0U;
 8002fb6:	2300      	movs	r3, #0
 8002fb8:	6563      	str	r3, [r4, #84]	; 0x54
  ep->is_in = 1U;
 8002fba:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 8002fbc:	64a2      	str	r2, [r4, #72]	; 0x48
  ep->is_in = 1U;
 8002fbe:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  ep->num = ep_addr & 0xFU;
 8002fc2:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8002fc6:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0xFU) == 0U)
 8002fc8:	b91d      	cbnz	r5, 8002fd2 <HAL_PCD_EP_Transmit+0x30>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8002fca:	f002 fa75 	bl	80054b8 <USB_EP0StartXfer>
}
 8002fce:	2000      	movs	r0, #0
 8002fd0:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8002fd2:	f002 faf3 	bl	80055bc <USB_EPStartXfer>
 8002fd6:	e7fa      	b.n	8002fce <HAL_PCD_EP_Transmit+0x2c>

08002fd8 <HAL_PCD_EP_SetStall>:
{
 8002fd8:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0xFU) > hpcd->Init.dev_endpoints)
 8002fda:	6843      	ldr	r3, [r0, #4]
 8002fdc:	f001 050f 	and.w	r5, r1, #15
 8002fe0:	429d      	cmp	r5, r3
{
 8002fe2:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & 0xFU) > hpcd->Init.dev_endpoints)
 8002fe4:	d82d      	bhi.n	8003042 <HAL_PCD_EP_SetStall+0x6a>
  if ((0x80U & ep_addr) == 0x80U)
 8002fe6:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002fea:	f04f 021c 	mov.w	r2, #28
 8002fee:	d01e      	beq.n	800302e <HAL_PCD_EP_SetStall+0x56>
    ep->is_in = 1U;
 8002ff0:	fb02 0105 	mla	r1, r2, r5, r0
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002ff4:	fb02 0305 	mla	r3, r2, r5, r0
    ep->is_in = 1U;
 8002ff8:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 8002ffa:	333c      	adds	r3, #60	; 0x3c
    ep->is_in = 1U;
 8002ffc:	f881 203d 	strb.w	r2, [r1, #61]	; 0x3d
  ep->is_stall = 1U;
 8003000:	2201      	movs	r2, #1
 8003002:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & 0xFU;
 8003004:	701d      	strb	r5, [r3, #0]
  __HAL_LOCK(hpcd);
 8003006:	f894 13bc 	ldrb.w	r1, [r4, #956]	; 0x3bc
 800300a:	4291      	cmp	r1, r2
 800300c:	d01b      	beq.n	8003046 <HAL_PCD_EP_SetStall+0x6e>
 800300e:	f884 23bc 	strb.w	r2, [r4, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8003012:	4619      	mov	r1, r3
 8003014:	6820      	ldr	r0, [r4, #0]
 8003016:	f002 fba5 	bl	8005764 <USB_EPSetStall>
  if ((ep_addr & 0xFU) == 0U)
 800301a:	b925      	cbnz	r5, 8003026 <HAL_PCD_EP_SetStall+0x4e>
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 800301c:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8003020:	6820      	ldr	r0, [r4, #0]
 8003022:	f002 fc6d 	bl	8005900 <USB_EP0_OutStart>
  __HAL_UNLOCK(hpcd);
 8003026:	2000      	movs	r0, #0
 8003028:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
 800302c:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->OUT_ep[ep_addr];
 800302e:	fb02 0301 	mla	r3, r2, r1, r0
    ep->is_in = 0U;
 8003032:	fb02 0101 	mla	r1, r2, r1, r0
 8003036:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 8003038:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
    ep->is_in = 0U;
 800303c:	f881 21fd 	strb.w	r2, [r1, #509]	; 0x1fd
 8003040:	e7de      	b.n	8003000 <HAL_PCD_EP_SetStall+0x28>
    return HAL_ERROR;
 8003042:	2001      	movs	r0, #1
 8003044:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd);
 8003046:	2002      	movs	r0, #2
}
 8003048:	bd38      	pop	{r3, r4, r5, pc}

0800304a <HAL_PCD_EP_ClrStall>:
{
 800304a:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800304c:	6843      	ldr	r3, [r0, #4]
 800304e:	f001 020f 	and.w	r2, r1, #15
 8003052:	429a      	cmp	r2, r3
{
 8003054:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8003056:	d826      	bhi.n	80030a6 <HAL_PCD_EP_ClrStall+0x5c>
 8003058:	231c      	movs	r3, #28
  if ((0x80U & ep_addr) == 0x80U)
 800305a:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & 0xFU];
 800305e:	fb03 0102 	mla	r1, r3, r2, r0
 8003062:	bf19      	ittee	ne
 8003064:	313c      	addne	r1, #60	; 0x3c
    ep->is_in = 1U;
 8003066:	fb03 0302 	mlane	r3, r3, r2, r0
    ep = &hpcd->OUT_ep[ep_addr & 0xFU];
 800306a:	f501 71fe 	addeq.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 800306e:	fb03 4302 	mlaeq	r3, r3, r2, r4
    ep->is_in = 1U;
 8003072:	bf14      	ite	ne
 8003074:	2001      	movne	r0, #1
    ep->is_in = 0U;
 8003076:	2000      	moveq	r0, #0
  ep->is_stall = 0U;
 8003078:	f04f 0500 	mov.w	r5, #0
    ep->is_in = 1U;
 800307c:	bf14      	ite	ne
 800307e:	f883 003d 	strbne.w	r0, [r3, #61]	; 0x3d
    ep->is_in = 0U;
 8003082:	f883 01fd 	strbeq.w	r0, [r3, #509]	; 0x1fd
  ep->is_stall = 0U;
 8003086:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & 0xFU;
 8003088:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 800308a:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 800308e:	2b01      	cmp	r3, #1
 8003090:	d00b      	beq.n	80030aa <HAL_PCD_EP_ClrStall+0x60>
 8003092:	2301      	movs	r3, #1
 8003094:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8003098:	6820      	ldr	r0, [r4, #0]
 800309a:	f002 fb90 	bl	80057be <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 800309e:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  return HAL_OK;
 80030a2:	4628      	mov	r0, r5
 80030a4:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80030a6:	2001      	movs	r0, #1
 80030a8:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd);
 80030aa:	2002      	movs	r0, #2
}
 80030ac:	bd38      	pop	{r3, r4, r5, pc}

080030ae <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 80030ae:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80030b0:	6804      	ldr	r4, [r0, #0]
 80030b2:	6a63      	ldr	r3, [r4, #36]	; 0x24

  if (fifo == 0U)
 80030b4:	b921      	cbnz	r1, 80030c0 <HAL_PCDEx_SetTxFiFo+0x12>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80030b6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80030ba:	62a3      	str	r3, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 80030bc:	2000      	movs	r0, #0
 80030be:	bd70      	pop	{r4, r5, r6, pc}
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80030c0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 80030c2:	1e4d      	subs	r5, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80030c4:	eb03 4310 	add.w	r3, r3, r0, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80030c8:	2000      	movs	r0, #0
 80030ca:	1c46      	adds	r6, r0, #1
 80030cc:	b2c0      	uxtb	r0, r0
 80030ce:	4285      	cmp	r5, r0
 80030d0:	d806      	bhi.n	80030e0 <HAL_PCDEx_SetTxFiFo+0x32>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 80030d2:	313f      	adds	r1, #63	; 0x3f
 80030d4:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 80030d8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80030dc:	6063      	str	r3, [r4, #4]
 80030de:	e7ed      	b.n	80030bc <HAL_PCDEx_SetTxFiFo+0xe>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80030e0:	3040      	adds	r0, #64	; 0x40
 80030e2:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80030e6:	6840      	ldr	r0, [r0, #4]
 80030e8:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 80030ec:	4630      	mov	r0, r6
 80030ee:	e7ec      	b.n	80030ca <HAL_PCDEx_SetTxFiFo+0x1c>

080030f0 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 80030f0:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 80030f2:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 80030f4:	6259      	str	r1, [r3, #36]	; 0x24
}
 80030f6:	4770      	bx	lr

080030f8 <HAL_PCDEx_ActivateLPM>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80030f8:	6802      	ldr	r2, [r0, #0]
{
 80030fa:	4603      	mov	r3, r0

  hpcd->lpm_active = 1U;
 80030fc:	2101      	movs	r1, #1
 80030fe:	f8c0 13fc 	str.w	r1, [r0, #1020]	; 0x3fc
  hpcd->LPM_State = LPM_L0;
 8003102:	2000      	movs	r0, #0
 8003104:	f883 03f4 	strb.w	r0, [r3, #1012]	; 0x3f4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8003108:	6993      	ldr	r3, [r2, #24]
 800310a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800310e:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8003110:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8003112:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003116:	f043 0303 	orr.w	r3, r3, #3
 800311a:	6553      	str	r3, [r2, #84]	; 0x54

  return HAL_OK;
}
 800311c:	4770      	bx	lr

0800311e <HAL_PCDEx_ActivateBCD>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateBCD(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800311e:	6802      	ldr	r2, [r0, #0]

  hpcd->battery_charging_active = 1U;
 8003120:	2301      	movs	r3, #1
 8003122:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  USBx->GCCFG |= (USB_OTG_GCCFG_BCDEN);
 8003126:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8003128:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800312c:	6393      	str	r3, [r2, #56]	; 0x38

  return HAL_OK;
}
 800312e:	2000      	movs	r0, #0
 8003130:	4770      	bx	lr
	...

08003134 <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8003134:	4b07      	ldr	r3, [pc, #28]	; (8003154 <HAL_PWREx_GetVoltageRange+0x20>)
 8003136:	6818      	ldr	r0, [r3, #0]
 8003138:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800313c:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8003140:	d007      	beq.n	8003152 <HAL_PWREx_GetVoltageRange+0x1e>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8003142:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003146:	f413 7f80 	tst.w	r3, #256	; 0x100
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
    }
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
 800314a:	bf14      	ite	ne
 800314c:	f44f 7000 	movne.w	r0, #512	; 0x200
 8003150:	2000      	moveq	r0, #0
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8003152:	4770      	bx	lr
 8003154:	40007000 	.word	0x40007000

08003158 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8003158:	4b29      	ldr	r3, [pc, #164]	; (8003200 <HAL_PWREx_ControlVoltageScaling+0xa8>)

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800315a:	681a      	ldr	r2, [r3, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 800315c:	bb28      	cbnz	r0, 80031aa <HAL_PWREx_ControlVoltageScaling+0x52>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800315e:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8003162:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8003166:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800316a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800316e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8003172:	d119      	bne.n	80031a8 <HAL_PWREx_ControlVoltageScaling+0x50>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8003174:	681a      	ldr	r2, [r3, #0]
 8003176:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 800317a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800317e:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8003180:	4a20      	ldr	r2, [pc, #128]	; (8003204 <HAL_PWREx_ControlVoltageScaling+0xac>)
 8003182:	6811      	ldr	r1, [r2, #0]
 8003184:	2232      	movs	r2, #50	; 0x32
 8003186:	434a      	muls	r2, r1
 8003188:	491f      	ldr	r1, [pc, #124]	; (8003208 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 800318a:	fbb2 f2f1 	udiv	r2, r2, r1
 800318e:	4619      	mov	r1, r3
 8003190:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8003192:	6958      	ldr	r0, [r3, #20]
 8003194:	0540      	lsls	r0, r0, #21
 8003196:	d500      	bpl.n	800319a <HAL_PWREx_ControlVoltageScaling+0x42>
 8003198:	b922      	cbnz	r2, 80031a4 <HAL_PWREx_ControlVoltageScaling+0x4c>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 800319a:	694b      	ldr	r3, [r1, #20]
 800319c:	055b      	lsls	r3, r3, #21
 800319e:	d52d      	bpl.n	80031fc <HAL_PWREx_ControlVoltageScaling+0xa4>
      {
        return HAL_TIMEOUT;
 80031a0:	2003      	movs	r0, #3
 80031a2:	4770      	bx	lr
        wait_loop_index--;
 80031a4:	3a01      	subs	r2, #1
 80031a6:	e7f4      	b.n	8003192 <HAL_PWREx_ControlVoltageScaling+0x3a>
 80031a8:	4770      	bx	lr
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80031aa:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80031ae:	d120      	bne.n	80031f2 <HAL_PWREx_ControlVoltageScaling+0x9a>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80031b0:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 80031b4:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80031b8:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80031bc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80031c0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80031c4:	d11a      	bne.n	80031fc <HAL_PWREx_ControlVoltageScaling+0xa4>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80031c6:	681a      	ldr	r2, [r3, #0]
 80031c8:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80031cc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80031d0:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 80031d2:	4a0c      	ldr	r2, [pc, #48]	; (8003204 <HAL_PWREx_ControlVoltageScaling+0xac>)
 80031d4:	6811      	ldr	r1, [r2, #0]
 80031d6:	2232      	movs	r2, #50	; 0x32
 80031d8:	434a      	muls	r2, r1
 80031da:	490b      	ldr	r1, [pc, #44]	; (8003208 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 80031dc:	fbb2 f2f1 	udiv	r2, r2, r1
 80031e0:	4619      	mov	r1, r3
 80031e2:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80031e4:	6958      	ldr	r0, [r3, #20]
 80031e6:	0540      	lsls	r0, r0, #21
 80031e8:	d5d7      	bpl.n	800319a <HAL_PWREx_ControlVoltageScaling+0x42>
 80031ea:	2a00      	cmp	r2, #0
 80031ec:	d0d5      	beq.n	800319a <HAL_PWREx_ControlVoltageScaling+0x42>
      {
        wait_loop_index--;
 80031ee:	3a01      	subs	r2, #1
 80031f0:	e7f8      	b.n	80031e4 <HAL_PWREx_ControlVoltageScaling+0x8c>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80031f2:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80031f6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80031fa:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 80031fc:	2000      	movs	r0, #0
}
 80031fe:	4770      	bx	lr
 8003200:	40007000 	.word	0x40007000
 8003204:	200001a0 	.word	0x200001a0
 8003208:	000f4240 	.word	0x000f4240

0800320c <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 800320c:	4a02      	ldr	r2, [pc, #8]	; (8003218 <HAL_PWREx_EnableVddUSB+0xc>)
 800320e:	6853      	ldr	r3, [r2, #4]
 8003210:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003214:	6053      	str	r3, [r2, #4]
 8003216:	4770      	bx	lr
 8003218:	40007000 	.word	0x40007000

0800321c <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 800321c:	4a02      	ldr	r2, [pc, #8]	; (8003228 <HAL_PWREx_EnableVddIO2+0xc>)
 800321e:	6853      	ldr	r3, [r2, #4]
 8003220:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8003224:	6053      	str	r3, [r2, #4]
 8003226:	4770      	bx	lr
 8003228:	40007000 	.word	0x40007000

0800322c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 800322c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800322e:	4d1c      	ldr	r5, [pc, #112]	; (80032a0 <RCC_SetFlashLatencyFromMSIRange+0x74>)
 8003230:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8003232:	00da      	lsls	r2, r3, #3
{
 8003234:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8003236:	d518      	bpl.n	800326a <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8003238:	f7ff ff7c 	bl	8003134 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 800323c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8003240:	d123      	bne.n	800328a <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if(msirange > RCC_MSIRANGE_8)
 8003242:	2c80      	cmp	r4, #128	; 0x80
 8003244:	d928      	bls.n	8003298 <RCC_SetFlashLatencyFromMSIRange+0x6c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8003246:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8003248:	bf8c      	ite	hi
 800324a:	2002      	movhi	r0, #2
 800324c:	2001      	movls	r0, #1
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 800324e:	4a15      	ldr	r2, [pc, #84]	; (80032a4 <RCC_SetFlashLatencyFromMSIRange+0x78>)
 8003250:	6813      	ldr	r3, [r2, #0]
 8003252:	f023 030f 	bic.w	r3, r3, #15
 8003256:	4303      	orrs	r3, r0
 8003258:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 800325a:	6813      	ldr	r3, [r2, #0]
 800325c:	f003 030f 	and.w	r3, r3, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8003260:	1a18      	subs	r0, r3, r0
 8003262:	bf18      	it	ne
 8003264:	2001      	movne	r0, #1
 8003266:	b003      	add	sp, #12
 8003268:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 800326a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800326c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003270:	65ab      	str	r3, [r5, #88]	; 0x58
 8003272:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8003274:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003278:	9301      	str	r3, [sp, #4]
 800327a:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 800327c:	f7ff ff5a 	bl	8003134 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8003280:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8003282:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003286:	65ab      	str	r3, [r5, #88]	; 0x58
 8003288:	e7d8      	b.n	800323c <RCC_SetFlashLatencyFromMSIRange+0x10>
    if(msirange >= RCC_MSIRANGE_8)
 800328a:	2c7f      	cmp	r4, #127	; 0x7f
 800328c:	d806      	bhi.n	800329c <RCC_SetFlashLatencyFromMSIRange+0x70>
      if(msirange == RCC_MSIRANGE_7)
 800328e:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
 8003292:	4258      	negs	r0, r3
 8003294:	4158      	adcs	r0, r3
 8003296:	e7da      	b.n	800324e <RCC_SetFlashLatencyFromMSIRange+0x22>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8003298:	2000      	movs	r0, #0
 800329a:	e7d8      	b.n	800324e <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 800329c:	2002      	movs	r0, #2
 800329e:	e7d6      	b.n	800324e <RCC_SetFlashLatencyFromMSIRange+0x22>
 80032a0:	40021000 	.word	0x40021000
 80032a4:	40022000 	.word	0x40022000

080032a8 <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80032a8:	4b23      	ldr	r3, [pc, #140]	; (8003338 <HAL_RCC_GetSysClockFreq+0x90>)
 80032aa:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80032ac:	68d9      	ldr	r1, [r3, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 80032ae:	f012 020c 	ands.w	r2, r2, #12
 80032b2:	d005      	beq.n	80032c0 <HAL_RCC_GetSysClockFreq+0x18>
 80032b4:	2a0c      	cmp	r2, #12
 80032b6:	d115      	bne.n	80032e4 <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80032b8:	f001 0103 	and.w	r1, r1, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 80032bc:	2901      	cmp	r1, #1
 80032be:	d118      	bne.n	80032f2 <HAL_RCC_GetSysClockFreq+0x4a>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80032c0:	6819      	ldr	r1, [r3, #0]
    msirange = MSIRangeTable[msirange];
 80032c2:	481e      	ldr	r0, [pc, #120]	; (800333c <HAL_RCC_GetSysClockFreq+0x94>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80032c4:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80032c6:	bf55      	itete	pl
 80032c8:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80032cc:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80032ce:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80032d2:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 80032d6:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 80032da:	b112      	cbz	r2, 80032e2 <HAL_RCC_GetSysClockFreq+0x3a>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 80032dc:	2a0c      	cmp	r2, #12
 80032de:	d009      	beq.n	80032f4 <HAL_RCC_GetSysClockFreq+0x4c>
 80032e0:	2000      	movs	r0, #0
}
 80032e2:	4770      	bx	lr
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 80032e4:	2a04      	cmp	r2, #4
 80032e6:	d024      	beq.n	8003332 <HAL_RCC_GetSysClockFreq+0x8a>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 80032e8:	2a08      	cmp	r2, #8
 80032ea:	4815      	ldr	r0, [pc, #84]	; (8003340 <HAL_RCC_GetSysClockFreq+0x98>)
 80032ec:	bf18      	it	ne
 80032ee:	2000      	movne	r0, #0
 80032f0:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80032f2:	2000      	movs	r0, #0
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80032f4:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80032f6:	68da      	ldr	r2, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80032f8:	f001 0103 	and.w	r1, r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80032fc:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
 8003300:	2902      	cmp	r1, #2
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8003302:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 8003306:	d005      	beq.n	8003314 <HAL_RCC_GetSysClockFreq+0x6c>
 8003308:	2903      	cmp	r1, #3
 800330a:	d003      	beq.n	8003314 <HAL_RCC_GetSysClockFreq+0x6c>
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800330c:	68d9      	ldr	r1, [r3, #12]
 800330e:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8003312:	e003      	b.n	800331c <HAL_RCC_GetSysClockFreq+0x74>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8003314:	68d9      	ldr	r1, [r3, #12]
 8003316:	480a      	ldr	r0, [pc, #40]	; (8003340 <HAL_RCC_GetSysClockFreq+0x98>)
 8003318:	f3c1 2106 	ubfx	r1, r1, #8, #7
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800331c:	68db      	ldr	r3, [r3, #12]
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800331e:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8003322:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8003326:	3301      	adds	r3, #1
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8003328:	4348      	muls	r0, r1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800332a:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 800332c:	fbb0 f0f3 	udiv	r0, r0, r3
 8003330:	4770      	bx	lr
 8003332:	4803      	ldr	r0, [pc, #12]	; (8003340 <HAL_RCC_GetSysClockFreq+0x98>)
 8003334:	4770      	bx	lr
 8003336:	bf00      	nop
 8003338:	40021000 	.word	0x40021000
 800333c:	0801f5a4 	.word	0x0801f5a4
 8003340:	00f42400 	.word	0x00f42400

08003344 <HAL_RCC_OscConfig>:
{
 8003344:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(RCC_OscInitStruct == NULL)
 8003348:	4605      	mov	r5, r0
 800334a:	b908      	cbnz	r0, 8003350 <HAL_RCC_OscConfig+0xc>
      return HAL_ERROR;
 800334c:	2001      	movs	r0, #1
 800334e:	e046      	b.n	80033de <HAL_RCC_OscConfig+0x9a>
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003350:	4ca8      	ldr	r4, [pc, #672]	; (80035f4 <HAL_RCC_OscConfig+0x2b0>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003352:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003354:	68a6      	ldr	r6, [r4, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8003356:	68e7      	ldr	r7, [r4, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003358:	06d8      	lsls	r0, r3, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800335a:	f006 060c 	and.w	r6, r6, #12
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 800335e:	f007 0703 	and.w	r7, r7, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003362:	d572      	bpl.n	800344a <HAL_RCC_OscConfig+0x106>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8003364:	b11e      	cbz	r6, 800336e <HAL_RCC_OscConfig+0x2a>
 8003366:	2e0c      	cmp	r6, #12
 8003368:	d151      	bne.n	800340e <HAL_RCC_OscConfig+0xca>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 800336a:	2f01      	cmp	r7, #1
 800336c:	d14f      	bne.n	800340e <HAL_RCC_OscConfig+0xca>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800336e:	6823      	ldr	r3, [r4, #0]
 8003370:	0799      	lsls	r1, r3, #30
 8003372:	d502      	bpl.n	800337a <HAL_RCC_OscConfig+0x36>
 8003374:	69ab      	ldr	r3, [r5, #24]
 8003376:	2b00      	cmp	r3, #0
 8003378:	d0e8      	beq.n	800334c <HAL_RCC_OscConfig+0x8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800337a:	6823      	ldr	r3, [r4, #0]
 800337c:	6a28      	ldr	r0, [r5, #32]
 800337e:	071a      	lsls	r2, r3, #28
 8003380:	bf56      	itet	pl
 8003382:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
 8003386:	6823      	ldrmi	r3, [r4, #0]
 8003388:	091b      	lsrpl	r3, r3, #4
 800338a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800338e:	4283      	cmp	r3, r0
 8003390:	d228      	bcs.n	80033e4 <HAL_RCC_OscConfig+0xa0>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8003392:	f7ff ff4b 	bl	800322c <RCC_SetFlashLatencyFromMSIRange>
 8003396:	2800      	cmp	r0, #0
 8003398:	d1d8      	bne.n	800334c <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800339a:	6823      	ldr	r3, [r4, #0]
 800339c:	f043 0308 	orr.w	r3, r3, #8
 80033a0:	6023      	str	r3, [r4, #0]
 80033a2:	6823      	ldr	r3, [r4, #0]
 80033a4:	6a2a      	ldr	r2, [r5, #32]
 80033a6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80033aa:	4313      	orrs	r3, r2
 80033ac:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80033ae:	6863      	ldr	r3, [r4, #4]
 80033b0:	69ea      	ldr	r2, [r5, #28]
 80033b2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80033b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80033ba:	6063      	str	r3, [r4, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80033bc:	f7ff ff74 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 80033c0:	68a3      	ldr	r3, [r4, #8]
 80033c2:	4a8d      	ldr	r2, [pc, #564]	; (80035f8 <HAL_RCC_OscConfig+0x2b4>)
 80033c4:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80033c8:	5cd3      	ldrb	r3, [r2, r3]
 80033ca:	f003 031f 	and.w	r3, r3, #31
 80033ce:	40d8      	lsrs	r0, r3
 80033d0:	4b8a      	ldr	r3, [pc, #552]	; (80035fc <HAL_RCC_OscConfig+0x2b8>)
 80033d2:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick (TICK_INT_PRIORITY);
 80033d4:	2000      	movs	r0, #0
 80033d6:	f7fd fdb5 	bl	8000f44 <HAL_InitTick>
        if(status != HAL_OK)
 80033da:	2800      	cmp	r0, #0
 80033dc:	d035      	beq.n	800344a <HAL_RCC_OscConfig+0x106>
}
 80033de:	b003      	add	sp, #12
 80033e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80033e4:	6823      	ldr	r3, [r4, #0]
 80033e6:	f043 0308 	orr.w	r3, r3, #8
 80033ea:	6023      	str	r3, [r4, #0]
 80033ec:	6823      	ldr	r3, [r4, #0]
 80033ee:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80033f2:	4303      	orrs	r3, r0
 80033f4:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80033f6:	6863      	ldr	r3, [r4, #4]
 80033f8:	69ea      	ldr	r2, [r5, #28]
 80033fa:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80033fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003402:	6063      	str	r3, [r4, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8003404:	f7ff ff12 	bl	800322c <RCC_SetFlashLatencyFromMSIRange>
 8003408:	2800      	cmp	r0, #0
 800340a:	d0d7      	beq.n	80033bc <HAL_RCC_OscConfig+0x78>
 800340c:	e79e      	b.n	800334c <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800340e:	69ab      	ldr	r3, [r5, #24]
 8003410:	2b00      	cmp	r3, #0
 8003412:	d03a      	beq.n	800348a <HAL_RCC_OscConfig+0x146>
        __HAL_RCC_MSI_ENABLE();
 8003414:	6823      	ldr	r3, [r4, #0]
 8003416:	f043 0301 	orr.w	r3, r3, #1
 800341a:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 800341c:	f7fd fdc2 	bl	8000fa4 <HAL_GetTick>
 8003420:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8003422:	6823      	ldr	r3, [r4, #0]
 8003424:	079b      	lsls	r3, r3, #30
 8003426:	d528      	bpl.n	800347a <HAL_RCC_OscConfig+0x136>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003428:	6823      	ldr	r3, [r4, #0]
 800342a:	f043 0308 	orr.w	r3, r3, #8
 800342e:	6023      	str	r3, [r4, #0]
 8003430:	6823      	ldr	r3, [r4, #0]
 8003432:	6a2a      	ldr	r2, [r5, #32]
 8003434:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003438:	4313      	orrs	r3, r2
 800343a:	6023      	str	r3, [r4, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800343c:	6863      	ldr	r3, [r4, #4]
 800343e:	69ea      	ldr	r2, [r5, #28]
 8003440:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8003444:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003448:	6063      	str	r3, [r4, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800344a:	682b      	ldr	r3, [r5, #0]
 800344c:	07d9      	lsls	r1, r3, #31
 800344e:	d42d      	bmi.n	80034ac <HAL_RCC_OscConfig+0x168>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003450:	682b      	ldr	r3, [r5, #0]
 8003452:	079a      	lsls	r2, r3, #30
 8003454:	d46b      	bmi.n	800352e <HAL_RCC_OscConfig+0x1ea>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003456:	682b      	ldr	r3, [r5, #0]
 8003458:	0719      	lsls	r1, r3, #28
 800345a:	f100 80a0 	bmi.w	800359e <HAL_RCC_OscConfig+0x25a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800345e:	682b      	ldr	r3, [r5, #0]
 8003460:	075a      	lsls	r2, r3, #29
 8003462:	f100 80cd 	bmi.w	8003600 <HAL_RCC_OscConfig+0x2bc>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8003466:	682b      	ldr	r3, [r5, #0]
 8003468:	069a      	lsls	r2, r3, #26
 800346a:	f100 8136 	bmi.w	80036da <HAL_RCC_OscConfig+0x396>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800346e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8003470:	2b00      	cmp	r3, #0
 8003472:	f040 815c 	bne.w	800372e <HAL_RCC_OscConfig+0x3ea>
  return HAL_OK;
 8003476:	2000      	movs	r0, #0
 8003478:	e7b1      	b.n	80033de <HAL_RCC_OscConfig+0x9a>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800347a:	f7fd fd93 	bl	8000fa4 <HAL_GetTick>
 800347e:	eba0 0008 	sub.w	r0, r0, r8
 8003482:	2802      	cmp	r0, #2
 8003484:	d9cd      	bls.n	8003422 <HAL_RCC_OscConfig+0xde>
            return HAL_TIMEOUT;
 8003486:	2003      	movs	r0, #3
 8003488:	e7a9      	b.n	80033de <HAL_RCC_OscConfig+0x9a>
        __HAL_RCC_MSI_DISABLE();
 800348a:	6823      	ldr	r3, [r4, #0]
 800348c:	f023 0301 	bic.w	r3, r3, #1
 8003490:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8003492:	f7fd fd87 	bl	8000fa4 <HAL_GetTick>
 8003496:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8003498:	6823      	ldr	r3, [r4, #0]
 800349a:	0798      	lsls	r0, r3, #30
 800349c:	d5d5      	bpl.n	800344a <HAL_RCC_OscConfig+0x106>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800349e:	f7fd fd81 	bl	8000fa4 <HAL_GetTick>
 80034a2:	eba0 0008 	sub.w	r0, r0, r8
 80034a6:	2802      	cmp	r0, #2
 80034a8:	d9f6      	bls.n	8003498 <HAL_RCC_OscConfig+0x154>
 80034aa:	e7ec      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 80034ac:	2e08      	cmp	r6, #8
 80034ae:	d003      	beq.n	80034b8 <HAL_RCC_OscConfig+0x174>
 80034b0:	2e0c      	cmp	r6, #12
 80034b2:	d108      	bne.n	80034c6 <HAL_RCC_OscConfig+0x182>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSE)))
 80034b4:	2f03      	cmp	r7, #3
 80034b6:	d106      	bne.n	80034c6 <HAL_RCC_OscConfig+0x182>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80034b8:	6823      	ldr	r3, [r4, #0]
 80034ba:	039b      	lsls	r3, r3, #14
 80034bc:	d5c8      	bpl.n	8003450 <HAL_RCC_OscConfig+0x10c>
 80034be:	686b      	ldr	r3, [r5, #4]
 80034c0:	2b00      	cmp	r3, #0
 80034c2:	d1c5      	bne.n	8003450 <HAL_RCC_OscConfig+0x10c>
 80034c4:	e742      	b.n	800334c <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80034c6:	686b      	ldr	r3, [r5, #4]
 80034c8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80034cc:	d110      	bne.n	80034f0 <HAL_RCC_OscConfig+0x1ac>
 80034ce:	6823      	ldr	r3, [r4, #0]
 80034d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80034d4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80034d6:	f7fd fd65 	bl	8000fa4 <HAL_GetTick>
 80034da:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80034dc:	6823      	ldr	r3, [r4, #0]
 80034de:	0398      	lsls	r0, r3, #14
 80034e0:	d4b6      	bmi.n	8003450 <HAL_RCC_OscConfig+0x10c>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80034e2:	f7fd fd5f 	bl	8000fa4 <HAL_GetTick>
 80034e6:	eba0 0008 	sub.w	r0, r0, r8
 80034ea:	2864      	cmp	r0, #100	; 0x64
 80034ec:	d9f6      	bls.n	80034dc <HAL_RCC_OscConfig+0x198>
 80034ee:	e7ca      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80034f0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80034f4:	d104      	bne.n	8003500 <HAL_RCC_OscConfig+0x1bc>
 80034f6:	6823      	ldr	r3, [r4, #0]
 80034f8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80034fc:	6023      	str	r3, [r4, #0]
 80034fe:	e7e6      	b.n	80034ce <HAL_RCC_OscConfig+0x18a>
 8003500:	6822      	ldr	r2, [r4, #0]
 8003502:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003506:	6022      	str	r2, [r4, #0]
 8003508:	6822      	ldr	r2, [r4, #0]
 800350a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800350e:	6022      	str	r2, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8003510:	2b00      	cmp	r3, #0
 8003512:	d1e0      	bne.n	80034d6 <HAL_RCC_OscConfig+0x192>
        tickstart = HAL_GetTick();
 8003514:	f7fd fd46 	bl	8000fa4 <HAL_GetTick>
 8003518:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800351a:	6823      	ldr	r3, [r4, #0]
 800351c:	0399      	lsls	r1, r3, #14
 800351e:	d597      	bpl.n	8003450 <HAL_RCC_OscConfig+0x10c>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8003520:	f7fd fd40 	bl	8000fa4 <HAL_GetTick>
 8003524:	eba0 0008 	sub.w	r0, r0, r8
 8003528:	2864      	cmp	r0, #100	; 0x64
 800352a:	d9f6      	bls.n	800351a <HAL_RCC_OscConfig+0x1d6>
 800352c:	e7ab      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 800352e:	2e04      	cmp	r6, #4
 8003530:	d003      	beq.n	800353a <HAL_RCC_OscConfig+0x1f6>
 8003532:	2e0c      	cmp	r6, #12
 8003534:	d110      	bne.n	8003558 <HAL_RCC_OscConfig+0x214>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSI)))
 8003536:	2f02      	cmp	r7, #2
 8003538:	d10e      	bne.n	8003558 <HAL_RCC_OscConfig+0x214>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800353a:	6823      	ldr	r3, [r4, #0]
 800353c:	055a      	lsls	r2, r3, #21
 800353e:	d503      	bpl.n	8003548 <HAL_RCC_OscConfig+0x204>
 8003540:	68eb      	ldr	r3, [r5, #12]
 8003542:	2b00      	cmp	r3, #0
 8003544:	f43f af02 	beq.w	800334c <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003548:	6863      	ldr	r3, [r4, #4]
 800354a:	692a      	ldr	r2, [r5, #16]
 800354c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8003550:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8003554:	6063      	str	r3, [r4, #4]
 8003556:	e77e      	b.n	8003456 <HAL_RCC_OscConfig+0x112>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8003558:	68eb      	ldr	r3, [r5, #12]
 800355a:	b17b      	cbz	r3, 800357c <HAL_RCC_OscConfig+0x238>
        __HAL_RCC_HSI_ENABLE();
 800355c:	6823      	ldr	r3, [r4, #0]
 800355e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003562:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8003564:	f7fd fd1e 	bl	8000fa4 <HAL_GetTick>
 8003568:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800356a:	6823      	ldr	r3, [r4, #0]
 800356c:	055b      	lsls	r3, r3, #21
 800356e:	d4eb      	bmi.n	8003548 <HAL_RCC_OscConfig+0x204>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003570:	f7fd fd18 	bl	8000fa4 <HAL_GetTick>
 8003574:	1bc0      	subs	r0, r0, r7
 8003576:	2802      	cmp	r0, #2
 8003578:	d9f7      	bls.n	800356a <HAL_RCC_OscConfig+0x226>
 800357a:	e784      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_DISABLE();
 800357c:	6823      	ldr	r3, [r4, #0]
 800357e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003582:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8003584:	f7fd fd0e 	bl	8000fa4 <HAL_GetTick>
 8003588:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800358a:	6823      	ldr	r3, [r4, #0]
 800358c:	0558      	lsls	r0, r3, #21
 800358e:	f57f af62 	bpl.w	8003456 <HAL_RCC_OscConfig+0x112>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003592:	f7fd fd07 	bl	8000fa4 <HAL_GetTick>
 8003596:	1bc0      	subs	r0, r0, r7
 8003598:	2802      	cmp	r0, #2
 800359a:	d9f6      	bls.n	800358a <HAL_RCC_OscConfig+0x246>
 800359c:	e773      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800359e:	696b      	ldr	r3, [r5, #20]
 80035a0:	b19b      	cbz	r3, 80035ca <HAL_RCC_OscConfig+0x286>
      __HAL_RCC_LSI_ENABLE();
 80035a2:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80035a6:	f043 0301 	orr.w	r3, r3, #1
 80035aa:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 80035ae:	f7fd fcf9 	bl	8000fa4 <HAL_GetTick>
 80035b2:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80035b4:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80035b8:	079b      	lsls	r3, r3, #30
 80035ba:	f53f af50 	bmi.w	800345e <HAL_RCC_OscConfig+0x11a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80035be:	f7fd fcf1 	bl	8000fa4 <HAL_GetTick>
 80035c2:	1bc0      	subs	r0, r0, r7
 80035c4:	2802      	cmp	r0, #2
 80035c6:	d9f5      	bls.n	80035b4 <HAL_RCC_OscConfig+0x270>
 80035c8:	e75d      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_LSI_DISABLE();
 80035ca:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80035ce:	f023 0301 	bic.w	r3, r3, #1
 80035d2:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 80035d6:	f7fd fce5 	bl	8000fa4 <HAL_GetTick>
 80035da:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80035dc:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80035e0:	0798      	lsls	r0, r3, #30
 80035e2:	f57f af3c 	bpl.w	800345e <HAL_RCC_OscConfig+0x11a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80035e6:	f7fd fcdd 	bl	8000fa4 <HAL_GetTick>
 80035ea:	1bc0      	subs	r0, r0, r7
 80035ec:	2802      	cmp	r0, #2
 80035ee:	d9f5      	bls.n	80035dc <HAL_RCC_OscConfig+0x298>
 80035f0:	e749      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
 80035f2:	bf00      	nop
 80035f4:	40021000 	.word	0x40021000
 80035f8:	0801f58a 	.word	0x0801f58a
 80035fc:	200001a0 	.word	0x200001a0
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8003600:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003602:	00d9      	lsls	r1, r3, #3
 8003604:	d429      	bmi.n	800365a <HAL_RCC_OscConfig+0x316>
      __HAL_RCC_PWR_CLK_ENABLE();
 8003606:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003608:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800360c:	65a3      	str	r3, [r4, #88]	; 0x58
 800360e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003610:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003614:	9301      	str	r3, [sp, #4]
 8003616:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8003618:	f04f 0801 	mov.w	r8, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800361c:	4f71      	ldr	r7, [pc, #452]	; (80037e4 <HAL_RCC_OscConfig+0x4a0>)
 800361e:	683b      	ldr	r3, [r7, #0]
 8003620:	05da      	lsls	r2, r3, #23
 8003622:	d51d      	bpl.n	8003660 <HAL_RCC_OscConfig+0x31c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003624:	68ab      	ldr	r3, [r5, #8]
 8003626:	2b01      	cmp	r3, #1
 8003628:	d12b      	bne.n	8003682 <HAL_RCC_OscConfig+0x33e>
 800362a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800362e:	f043 0301 	orr.w	r3, r3, #1
 8003632:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      tickstart = HAL_GetTick();
 8003636:	f7fd fcb5 	bl	8000fa4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800363a:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800363e:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003640:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8003644:	0798      	lsls	r0, r3, #30
 8003646:	d542      	bpl.n	80036ce <HAL_RCC_OscConfig+0x38a>
    if(pwrclkchanged == SET)
 8003648:	f1b8 0f00 	cmp.w	r8, #0
 800364c:	f43f af0b 	beq.w	8003466 <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_PWR_CLK_DISABLE();
 8003650:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003652:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003656:	65a3      	str	r3, [r4, #88]	; 0x58
 8003658:	e705      	b.n	8003466 <HAL_RCC_OscConfig+0x122>
    FlagStatus       pwrclkchanged = RESET;
 800365a:	f04f 0800 	mov.w	r8, #0
 800365e:	e7dd      	b.n	800361c <HAL_RCC_OscConfig+0x2d8>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003660:	683b      	ldr	r3, [r7, #0]
 8003662:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003666:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8003668:	f7fd fc9c 	bl	8000fa4 <HAL_GetTick>
 800366c:	4681      	mov	r9, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800366e:	683b      	ldr	r3, [r7, #0]
 8003670:	05db      	lsls	r3, r3, #23
 8003672:	d4d7      	bmi.n	8003624 <HAL_RCC_OscConfig+0x2e0>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003674:	f7fd fc96 	bl	8000fa4 <HAL_GetTick>
 8003678:	eba0 0009 	sub.w	r0, r0, r9
 800367c:	2802      	cmp	r0, #2
 800367e:	d9f6      	bls.n	800366e <HAL_RCC_OscConfig+0x32a>
 8003680:	e701      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003682:	2b05      	cmp	r3, #5
 8003684:	d106      	bne.n	8003694 <HAL_RCC_OscConfig+0x350>
 8003686:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800368a:	f043 0304 	orr.w	r3, r3, #4
 800368e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8003692:	e7ca      	b.n	800362a <HAL_RCC_OscConfig+0x2e6>
 8003694:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8003698:	f022 0201 	bic.w	r2, r2, #1
 800369c:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 80036a0:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80036a4:	f022 0204 	bic.w	r2, r2, #4
 80036a8:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80036ac:	2b00      	cmp	r3, #0
 80036ae:	d1c2      	bne.n	8003636 <HAL_RCC_OscConfig+0x2f2>
      tickstart = HAL_GetTick();
 80036b0:	f7fd fc78 	bl	8000fa4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80036b4:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80036b8:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80036ba:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80036be:	0799      	lsls	r1, r3, #30
 80036c0:	d5c2      	bpl.n	8003648 <HAL_RCC_OscConfig+0x304>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80036c2:	f7fd fc6f 	bl	8000fa4 <HAL_GetTick>
 80036c6:	1bc0      	subs	r0, r0, r7
 80036c8:	4548      	cmp	r0, r9
 80036ca:	d9f6      	bls.n	80036ba <HAL_RCC_OscConfig+0x376>
 80036cc:	e6db      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80036ce:	f7fd fc69 	bl	8000fa4 <HAL_GetTick>
 80036d2:	1bc0      	subs	r0, r0, r7
 80036d4:	4548      	cmp	r0, r9
 80036d6:	d9b3      	bls.n	8003640 <HAL_RCC_OscConfig+0x2fc>
 80036d8:	e6d5      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80036da:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80036dc:	b19b      	cbz	r3, 8003706 <HAL_RCC_OscConfig+0x3c2>
      __HAL_RCC_HSI48_ENABLE();
 80036de:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80036e2:	f043 0301 	orr.w	r3, r3, #1
 80036e6:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 80036ea:	f7fd fc5b 	bl	8000fa4 <HAL_GetTick>
 80036ee:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 80036f0:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80036f4:	079b      	lsls	r3, r3, #30
 80036f6:	f53f aeba 	bmi.w	800346e <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80036fa:	f7fd fc53 	bl	8000fa4 <HAL_GetTick>
 80036fe:	1bc0      	subs	r0, r0, r7
 8003700:	2802      	cmp	r0, #2
 8003702:	d9f5      	bls.n	80036f0 <HAL_RCC_OscConfig+0x3ac>
 8003704:	e6bf      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
      __HAL_RCC_HSI48_DISABLE();
 8003706:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800370a:	f023 0301 	bic.w	r3, r3, #1
 800370e:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 8003712:	f7fd fc47 	bl	8000fa4 <HAL_GetTick>
 8003716:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8003718:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800371c:	0798      	lsls	r0, r3, #30
 800371e:	f57f aea6 	bpl.w	800346e <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8003722:	f7fd fc3f 	bl	8000fa4 <HAL_GetTick>
 8003726:	1bc0      	subs	r0, r0, r7
 8003728:	2802      	cmp	r0, #2
 800372a:	d9f5      	bls.n	8003718 <HAL_RCC_OscConfig+0x3d4>
 800372c:	e6ab      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
    if(sysclk_source != RCC_CFGR_SWS_PLL)
 800372e:	2e0c      	cmp	r6, #12
 8003730:	f43f ae0c 	beq.w	800334c <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8003734:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 8003736:	6823      	ldr	r3, [r4, #0]
 8003738:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800373c:	6023      	str	r3, [r4, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800373e:	d136      	bne.n	80037ae <HAL_RCC_OscConfig+0x46a>
        tickstart = HAL_GetTick();
 8003740:	f7fd fc30 	bl	8000fa4 <HAL_GetTick>
 8003744:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8003746:	6823      	ldr	r3, [r4, #0]
 8003748:	0199      	lsls	r1, r3, #6
 800374a:	d42a      	bmi.n	80037a2 <HAL_RCC_OscConfig+0x45e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800374c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800374e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8003750:	06db      	lsls	r3, r3, #27
 8003752:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003756:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003758:	4313      	orrs	r3, r2
 800375a:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800375c:	3a01      	subs	r2, #1
 800375e:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8003762:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8003764:	0852      	lsrs	r2, r2, #1
 8003766:	3a01      	subs	r2, #1
 8003768:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 800376c:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 800376e:	0852      	lsrs	r2, r2, #1
 8003770:	3a01      	subs	r2, #1
 8003772:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8003776:	60e3      	str	r3, [r4, #12]
        __HAL_RCC_PLL_ENABLE();
 8003778:	6823      	ldr	r3, [r4, #0]
 800377a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800377e:	6023      	str	r3, [r4, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8003780:	68e3      	ldr	r3, [r4, #12]
 8003782:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003786:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 8003788:	f7fd fc0c 	bl	8000fa4 <HAL_GetTick>
 800378c:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800378e:	6823      	ldr	r3, [r4, #0]
 8003790:	019a      	lsls	r2, r3, #6
 8003792:	f53f ae70 	bmi.w	8003476 <HAL_RCC_OscConfig+0x132>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003796:	f7fd fc05 	bl	8000fa4 <HAL_GetTick>
 800379a:	1b40      	subs	r0, r0, r5
 800379c:	2802      	cmp	r0, #2
 800379e:	d9f6      	bls.n	800378e <HAL_RCC_OscConfig+0x44a>
 80037a0:	e671      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80037a2:	f7fd fbff 	bl	8000fa4 <HAL_GetTick>
 80037a6:	1b80      	subs	r0, r0, r6
 80037a8:	2802      	cmp	r0, #2
 80037aa:	d9cc      	bls.n	8003746 <HAL_RCC_OscConfig+0x402>
 80037ac:	e66b      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 80037ae:	6823      	ldr	r3, [r4, #0]
 80037b0:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80037b4:	bf02      	ittt	eq
 80037b6:	68e3      	ldreq	r3, [r4, #12]
 80037b8:	f023 0303 	biceq.w	r3, r3, #3
 80037bc:	60e3      	streq	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 80037be:	68e3      	ldr	r3, [r4, #12]
 80037c0:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80037c4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80037c8:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80037ca:	f7fd fbeb 	bl	8000fa4 <HAL_GetTick>
 80037ce:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80037d0:	6823      	ldr	r3, [r4, #0]
 80037d2:	019b      	lsls	r3, r3, #6
 80037d4:	f57f ae4f 	bpl.w	8003476 <HAL_RCC_OscConfig+0x132>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80037d8:	f7fd fbe4 	bl	8000fa4 <HAL_GetTick>
 80037dc:	1b40      	subs	r0, r0, r5
 80037de:	2802      	cmp	r0, #2
 80037e0:	d9f6      	bls.n	80037d0 <HAL_RCC_OscConfig+0x48c>
 80037e2:	e650      	b.n	8003486 <HAL_RCC_OscConfig+0x142>
 80037e4:	40007000 	.word	0x40007000

080037e8 <HAL_RCC_ClockConfig>:
{
 80037e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80037ec:	460e      	mov	r6, r1
  if(RCC_ClkInitStruct == NULL)
 80037ee:	4605      	mov	r5, r0
 80037f0:	b910      	cbnz	r0, 80037f8 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 80037f2:	2001      	movs	r0, #1
 80037f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80037f8:	4a71      	ldr	r2, [pc, #452]	; (80039c0 <HAL_RCC_ClockConfig+0x1d8>)
 80037fa:	6813      	ldr	r3, [r2, #0]
 80037fc:	f003 030f 	and.w	r3, r3, #15
 8003800:	428b      	cmp	r3, r1
 8003802:	d334      	bcc.n	800386e <HAL_RCC_ClockConfig+0x86>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003804:	6829      	ldr	r1, [r5, #0]
 8003806:	f011 0701 	ands.w	r7, r1, #1
 800380a:	d13b      	bne.n	8003884 <HAL_RCC_ClockConfig+0x9c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800380c:	682a      	ldr	r2, [r5, #0]
 800380e:	0791      	lsls	r1, r2, #30
 8003810:	f140 80bb 	bpl.w	800398a <HAL_RCC_ClockConfig+0x1a2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003814:	496b      	ldr	r1, [pc, #428]	; (80039c4 <HAL_RCC_ClockConfig+0x1dc>)
 8003816:	68a8      	ldr	r0, [r5, #8]
 8003818:	688b      	ldr	r3, [r1, #8]
 800381a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800381e:	4303      	orrs	r3, r0
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8003820:	608b      	str	r3, [r1, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003822:	4967      	ldr	r1, [pc, #412]	; (80039c0 <HAL_RCC_ClockConfig+0x1d8>)
 8003824:	680b      	ldr	r3, [r1, #0]
 8003826:	f003 030f 	and.w	r3, r3, #15
 800382a:	429e      	cmp	r6, r3
 800382c:	f0c0 80b5 	bcc.w	800399a <HAL_RCC_ClockConfig+0x1b2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003830:	f012 0f04 	tst.w	r2, #4
 8003834:	4c63      	ldr	r4, [pc, #396]	; (80039c4 <HAL_RCC_ClockConfig+0x1dc>)
 8003836:	f040 80bc 	bne.w	80039b2 <HAL_RCC_ClockConfig+0x1ca>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800383a:	0713      	lsls	r3, r2, #28
 800383c:	d506      	bpl.n	800384c <HAL_RCC_ClockConfig+0x64>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800383e:	68a3      	ldr	r3, [r4, #8]
 8003840:	692a      	ldr	r2, [r5, #16]
 8003842:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8003846:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800384a:	60a3      	str	r3, [r4, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800384c:	f7ff fd2c 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8003850:	68a3      	ldr	r3, [r4, #8]
 8003852:	4a5d      	ldr	r2, [pc, #372]	; (80039c8 <HAL_RCC_ClockConfig+0x1e0>)
 8003854:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8003858:	5cd3      	ldrb	r3, [r2, r3]
 800385a:	f003 031f 	and.w	r3, r3, #31
 800385e:	40d8      	lsrs	r0, r3
 8003860:	4b5a      	ldr	r3, [pc, #360]	; (80039cc <HAL_RCC_ClockConfig+0x1e4>)
 8003862:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick (TICK_INT_PRIORITY);
 8003864:	2000      	movs	r0, #0
}
 8003866:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  status = HAL_InitTick (TICK_INT_PRIORITY);
 800386a:	f7fd bb6b 	b.w	8000f44 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800386e:	6813      	ldr	r3, [r2, #0]
 8003870:	f023 030f 	bic.w	r3, r3, #15
 8003874:	430b      	orrs	r3, r1
 8003876:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8003878:	6813      	ldr	r3, [r2, #0]
 800387a:	f003 030f 	and.w	r3, r3, #15
 800387e:	4299      	cmp	r1, r3
 8003880:	d1b7      	bne.n	80037f2 <HAL_RCC_ClockConfig+0xa>
 8003882:	e7bf      	b.n	8003804 <HAL_RCC_ClockConfig+0x1c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003884:	686b      	ldr	r3, [r5, #4]
 8003886:	4c4f      	ldr	r4, [pc, #316]	; (80039c4 <HAL_RCC_ClockConfig+0x1dc>)
 8003888:	2b03      	cmp	r3, #3
 800388a:	d168      	bne.n	800395e <HAL_RCC_ClockConfig+0x176>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800388c:	6823      	ldr	r3, [r4, #0]
 800388e:	019b      	lsls	r3, r3, #6
 8003890:	d5af      	bpl.n	80037f2 <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8003892:	68e3      	ldr	r3, [r4, #12]
 8003894:	f003 0303 	and.w	r3, r3, #3
 8003898:	2b01      	cmp	r3, #1
 800389a:	d11e      	bne.n	80038da <HAL_RCC_ClockConfig+0xf2>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 800389c:	6823      	ldr	r3, [r4, #0]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 800389e:	4a4c      	ldr	r2, [pc, #304]	; (80039d0 <HAL_RCC_ClockConfig+0x1e8>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80038a0:	071f      	lsls	r7, r3, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80038a2:	bf55      	itete	pl
 80038a4:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80038a8:	6823      	ldrmi	r3, [r4, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80038aa:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80038ae:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    msirange = MSIRangeTable[msirange];
 80038b2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80038b6:	68e7      	ldr	r7, [r4, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80038b8:	68e3      	ldr	r3, [r4, #12]
 80038ba:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80038be:	1c58      	adds	r0, r3, #1
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80038c0:	f007 0303 	and.w	r3, r7, #3

  switch (pllsource)
 80038c4:	2b02      	cmp	r3, #2
 80038c6:	d00a      	beq.n	80038de <HAL_RCC_ClockConfig+0xf6>
 80038c8:	2b03      	cmp	r3, #3
 80038ca:	d008      	beq.n	80038de <HAL_RCC_ClockConfig+0xf6>
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80038cc:	fbb2 f3f0 	udiv	r3, r2, r0
 80038d0:	68e7      	ldr	r7, [r4, #12]
 80038d2:	f3c7 2706 	ubfx	r7, r7, #8, #7
 80038d6:	437b      	muls	r3, r7
 80038d8:	e008      	b.n	80038ec <HAL_RCC_ClockConfig+0x104>
  uint32_t msirange = 0U;
 80038da:	2200      	movs	r2, #0
 80038dc:	e7eb      	b.n	80038b6 <HAL_RCC_ClockConfig+0xce>
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80038de:	68e2      	ldr	r2, [r4, #12]
 80038e0:	4b3c      	ldr	r3, [pc, #240]	; (80039d4 <HAL_RCC_ClockConfig+0x1ec>)
 80038e2:	fbb3 f3f0 	udiv	r3, r3, r0
 80038e6:	f3c2 2206 	ubfx	r2, r2, #8, #7
 80038ea:	4353      	muls	r3, r2
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80038ec:	68e2      	ldr	r2, [r4, #12]
 80038ee:	f3c2 6241 	ubfx	r2, r2, #25, #2
 80038f2:	3201      	adds	r2, #1
 80038f4:	0052      	lsls	r2, r2, #1
  sysclockfreq = pllvco/pllr;
 80038f6:	fbb3 f3f2 	udiv	r3, r3, r2
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 80038fa:	4a37      	ldr	r2, [pc, #220]	; (80039d8 <HAL_RCC_ClockConfig+0x1f0>)
 80038fc:	4293      	cmp	r3, r2
 80038fe:	d81c      	bhi.n	800393a <HAL_RCC_ClockConfig+0x152>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8003900:	2700      	movs	r7, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8003902:	68a3      	ldr	r3, [r4, #8]
 8003904:	686a      	ldr	r2, [r5, #4]
 8003906:	f023 0303 	bic.w	r3, r3, #3
 800390a:	4313      	orrs	r3, r2
 800390c:	60a3      	str	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800390e:	f7fd fb49 	bl	8000fa4 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003912:	f241 3988 	movw	r9, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8003916:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003918:	68a3      	ldr	r3, [r4, #8]
 800391a:	686a      	ldr	r2, [r5, #4]
 800391c:	f003 030c 	and.w	r3, r3, #12
 8003920:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8003924:	f43f af72 	beq.w	800380c <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003928:	f7fd fb3c 	bl	8000fa4 <HAL_GetTick>
 800392c:	eba0 0008 	sub.w	r0, r0, r8
 8003930:	4548      	cmp	r0, r9
 8003932:	d9f1      	bls.n	8003918 <HAL_RCC_ClockConfig+0x130>
        return HAL_TIMEOUT;
 8003934:	2003      	movs	r0, #3
}
 8003936:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 800393a:	68a3      	ldr	r3, [r4, #8]
 800393c:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8003940:	d107      	bne.n	8003952 <HAL_RCC_ClockConfig+0x16a>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8003942:	68a3      	ldr	r3, [r4, #8]
 8003944:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003948:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800394c:	60a3      	str	r3, [r4, #8]
        hpre = RCC_SYSCLK_DIV2;
 800394e:	2780      	movs	r7, #128	; 0x80
 8003950:	e7d7      	b.n	8003902 <HAL_RCC_ClockConfig+0x11a>
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 8003952:	0788      	lsls	r0, r1, #30
 8003954:	d5d4      	bpl.n	8003900 <HAL_RCC_ClockConfig+0x118>
 8003956:	68ab      	ldr	r3, [r5, #8]
 8003958:	2b00      	cmp	r3, #0
 800395a:	d1d1      	bne.n	8003900 <HAL_RCC_ClockConfig+0x118>
 800395c:	e7f1      	b.n	8003942 <HAL_RCC_ClockConfig+0x15a>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800395e:	2b02      	cmp	r3, #2
 8003960:	d10a      	bne.n	8003978 <HAL_RCC_ClockConfig+0x190>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8003962:	6823      	ldr	r3, [r4, #0]
 8003964:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8003968:	f43f af43 	beq.w	80037f2 <HAL_RCC_ClockConfig+0xa>
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 800396c:	f7ff fc9c 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8003970:	4b19      	ldr	r3, [pc, #100]	; (80039d8 <HAL_RCC_ClockConfig+0x1f0>)
 8003972:	4298      	cmp	r0, r3
 8003974:	d9c4      	bls.n	8003900 <HAL_RCC_ClockConfig+0x118>
 8003976:	e7e4      	b.n	8003942 <HAL_RCC_ClockConfig+0x15a>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8003978:	b91b      	cbnz	r3, 8003982 <HAL_RCC_ClockConfig+0x19a>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 800397a:	6823      	ldr	r3, [r4, #0]
 800397c:	f013 0f02 	tst.w	r3, #2
 8003980:	e7f2      	b.n	8003968 <HAL_RCC_ClockConfig+0x180>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8003982:	6823      	ldr	r3, [r4, #0]
 8003984:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8003988:	e7ee      	b.n	8003968 <HAL_RCC_ClockConfig+0x180>
    if(hpre == RCC_SYSCLK_DIV2)
 800398a:	2f80      	cmp	r7, #128	; 0x80
 800398c:	f47f af49 	bne.w	8003822 <HAL_RCC_ClockConfig+0x3a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8003990:	490c      	ldr	r1, [pc, #48]	; (80039c4 <HAL_RCC_ClockConfig+0x1dc>)
 8003992:	688b      	ldr	r3, [r1, #8]
 8003994:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003998:	e742      	b.n	8003820 <HAL_RCC_ClockConfig+0x38>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800399a:	680b      	ldr	r3, [r1, #0]
 800399c:	f023 030f 	bic.w	r3, r3, #15
 80039a0:	4333      	orrs	r3, r6
 80039a2:	600b      	str	r3, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80039a4:	680b      	ldr	r3, [r1, #0]
 80039a6:	f003 030f 	and.w	r3, r3, #15
 80039aa:	429e      	cmp	r6, r3
 80039ac:	f47f af21 	bne.w	80037f2 <HAL_RCC_ClockConfig+0xa>
 80039b0:	e73e      	b.n	8003830 <HAL_RCC_ClockConfig+0x48>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80039b2:	68a3      	ldr	r3, [r4, #8]
 80039b4:	68e9      	ldr	r1, [r5, #12]
 80039b6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80039ba:	430b      	orrs	r3, r1
 80039bc:	60a3      	str	r3, [r4, #8]
 80039be:	e73c      	b.n	800383a <HAL_RCC_ClockConfig+0x52>
 80039c0:	40022000 	.word	0x40022000
 80039c4:	40021000 	.word	0x40021000
 80039c8:	0801f58a 	.word	0x0801f58a
 80039cc:	200001a0 	.word	0x200001a0
 80039d0:	0801f5a4 	.word	0x0801f5a4
 80039d4:	00f42400 	.word	0x00f42400
 80039d8:	04c4b400 	.word	0x04c4b400

080039dc <HAL_RCC_GetHCLKFreq>:
}
 80039dc:	4b01      	ldr	r3, [pc, #4]	; (80039e4 <HAL_RCC_GetHCLKFreq+0x8>)
 80039de:	6818      	ldr	r0, [r3, #0]
 80039e0:	4770      	bx	lr
 80039e2:	bf00      	nop
 80039e4:	200001a0 	.word	0x200001a0

080039e8 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 80039e8:	4b05      	ldr	r3, [pc, #20]	; (8003a00 <HAL_RCC_GetPCLK1Freq+0x18>)
 80039ea:	4a06      	ldr	r2, [pc, #24]	; (8003a04 <HAL_RCC_GetPCLK1Freq+0x1c>)
 80039ec:	689b      	ldr	r3, [r3, #8]
 80039ee:	f3c3 2302 	ubfx	r3, r3, #8, #3
 80039f2:	5cd3      	ldrb	r3, [r2, r3]
 80039f4:	4a04      	ldr	r2, [pc, #16]	; (8003a08 <HAL_RCC_GetPCLK1Freq+0x20>)
 80039f6:	6810      	ldr	r0, [r2, #0]
 80039f8:	f003 031f 	and.w	r3, r3, #31
}
 80039fc:	40d8      	lsrs	r0, r3
 80039fe:	4770      	bx	lr
 8003a00:	40021000 	.word	0x40021000
 8003a04:	0801f59a 	.word	0x0801f59a
 8003a08:	200001a0 	.word	0x200001a0

08003a0c <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8003a0c:	4b05      	ldr	r3, [pc, #20]	; (8003a24 <HAL_RCC_GetPCLK2Freq+0x18>)
 8003a0e:	4a06      	ldr	r2, [pc, #24]	; (8003a28 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8003a10:	689b      	ldr	r3, [r3, #8]
 8003a12:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8003a16:	5cd3      	ldrb	r3, [r2, r3]
 8003a18:	4a04      	ldr	r2, [pc, #16]	; (8003a2c <HAL_RCC_GetPCLK2Freq+0x20>)
 8003a1a:	6810      	ldr	r0, [r2, #0]
 8003a1c:	f003 031f 	and.w	r3, r3, #31
}
 8003a20:	40d8      	lsrs	r0, r3
 8003a22:	4770      	bx	lr
 8003a24:	40021000 	.word	0x40021000
 8003a28:	0801f59a 	.word	0x0801f59a
 8003a2c:	200001a0 	.word	0x200001a0

08003a30 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8003a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003a32:	4b3f      	ldr	r3, [pc, #252]	; (8003b30 <RCCEx_PLLSAI1_Config+0x100>)
 8003a34:	68da      	ldr	r2, [r3, #12]
 8003a36:	f012 0f03 	tst.w	r2, #3
{
 8003a3a:	4605      	mov	r5, r0
 8003a3c:	460e      	mov	r6, r1
 8003a3e:	461c      	mov	r4, r3
 8003a40:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003a42:	d022      	beq.n	8003a8a <RCCEx_PLLSAI1_Config+0x5a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8003a44:	68db      	ldr	r3, [r3, #12]
 8003a46:	f003 0303 	and.w	r3, r3, #3
 8003a4a:	4283      	cmp	r3, r0
 8003a4c:	d130      	bne.n	8003ab0 <RCCEx_PLLSAI1_Config+0x80>
       ||
 8003a4e:	b37b      	cbz	r3, 8003ab0 <RCCEx_PLLSAI1_Config+0x80>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8003a50:	6823      	ldr	r3, [r4, #0]
 8003a52:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8003a56:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003a58:	f7fd faa4 	bl	8000fa4 <HAL_GetTick>
 8003a5c:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8003a5e:	6823      	ldr	r3, [r4, #0]
 8003a60:	011a      	lsls	r2, r3, #4
 8003a62:	d42e      	bmi.n	8003ac2 <RCCEx_PLLSAI1_Config+0x92>
 8003a64:	68af      	ldr	r7, [r5, #8]
 8003a66:	686b      	ldr	r3, [r5, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8003a68:	b396      	cbz	r6, 8003ad0 <RCCEx_PLLSAI1_Config+0xa0>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8003a6a:	2e01      	cmp	r6, #1
 8003a6c:	d14c      	bne.n	8003b08 <RCCEx_PLLSAI1_Config+0xd8>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003a6e:	6922      	ldr	r2, [r4, #16]
 8003a70:	4930      	ldr	r1, [pc, #192]	; (8003b34 <RCCEx_PLLSAI1_Config+0x104>)
 8003a72:	4011      	ands	r1, r2
 8003a74:	692a      	ldr	r2, [r5, #16]
 8003a76:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8003a7a:	3b01      	subs	r3, #1
 8003a7c:	0852      	lsrs	r2, r2, #1
 8003a7e:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 8003a82:	3a01      	subs	r2, #1
 8003a84:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8003a88:	e02d      	b.n	8003ae6 <RCCEx_PLLSAI1_Config+0xb6>
    switch(PllSai1->PLLSAI1Source)
 8003a8a:	2802      	cmp	r0, #2
 8003a8c:	d00c      	beq.n	8003aa8 <RCCEx_PLLSAI1_Config+0x78>
 8003a8e:	2803      	cmp	r0, #3
 8003a90:	d010      	beq.n	8003ab4 <RCCEx_PLLSAI1_Config+0x84>
 8003a92:	2801      	cmp	r0, #1
 8003a94:	d10c      	bne.n	8003ab0 <RCCEx_PLLSAI1_Config+0x80>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8003a96:	681b      	ldr	r3, [r3, #0]
 8003a98:	079f      	lsls	r7, r3, #30
 8003a9a:	d534      	bpl.n	8003b06 <RCCEx_PLLSAI1_Config+0xd6>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 8003a9c:	68e3      	ldr	r3, [r4, #12]
 8003a9e:	f023 0303 	bic.w	r3, r3, #3
 8003aa2:	4318      	orrs	r0, r3
 8003aa4:	60e0      	str	r0, [r4, #12]
 8003aa6:	e7d3      	b.n	8003a50 <RCCEx_PLLSAI1_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8003aa8:	681b      	ldr	r3, [r3, #0]
 8003aaa:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003aae:	d1f5      	bne.n	8003a9c <RCCEx_PLLSAI1_Config+0x6c>
 8003ab0:	2001      	movs	r0, #1
 8003ab2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8003ab4:	681a      	ldr	r2, [r3, #0]
 8003ab6:	0391      	lsls	r1, r2, #14
 8003ab8:	d4f0      	bmi.n	8003a9c <RCCEx_PLLSAI1_Config+0x6c>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003aba:	681b      	ldr	r3, [r3, #0]
 8003abc:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8003ac0:	e7f5      	b.n	8003aae <RCCEx_PLLSAI1_Config+0x7e>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8003ac2:	f7fd fa6f 	bl	8000fa4 <HAL_GetTick>
 8003ac6:	1bc0      	subs	r0, r0, r7
 8003ac8:	2802      	cmp	r0, #2
 8003aca:	d9c8      	bls.n	8003a5e <RCCEx_PLLSAI1_Config+0x2e>
        status = HAL_TIMEOUT;
 8003acc:	2003      	movs	r0, #3
 8003ace:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003ad0:	68e8      	ldr	r0, [r5, #12]
 8003ad2:	6926      	ldr	r6, [r4, #16]
 8003ad4:	4918      	ldr	r1, [pc, #96]	; (8003b38 <RCCEx_PLLSAI1_Config+0x108>)
 8003ad6:	06c2      	lsls	r2, r0, #27
 8003ad8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8003adc:	4031      	ands	r1, r6
 8003ade:	430a      	orrs	r2, r1
 8003ae0:	3b01      	subs	r3, #1
 8003ae2:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003ae6:	6123      	str	r3, [r4, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8003ae8:	6823      	ldr	r3, [r4, #0]
 8003aea:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003aee:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003af0:	f7fd fa58 	bl	8000fa4 <HAL_GetTick>
 8003af4:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8003af6:	6823      	ldr	r3, [r4, #0]
 8003af8:	011b      	lsls	r3, r3, #4
 8003afa:	d513      	bpl.n	8003b24 <RCCEx_PLLSAI1_Config+0xf4>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8003afc:	6923      	ldr	r3, [r4, #16]
 8003afe:	69aa      	ldr	r2, [r5, #24]
 8003b00:	4313      	orrs	r3, r2
 8003b02:	6123      	str	r3, [r4, #16]
 8003b04:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 8003b06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003b08:	6921      	ldr	r1, [r4, #16]
 8003b0a:	4a0c      	ldr	r2, [pc, #48]	; (8003b3c <RCCEx_PLLSAI1_Config+0x10c>)
 8003b0c:	400a      	ands	r2, r1
 8003b0e:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8003b12:	3b01      	subs	r3, #1
 8003b14:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8003b18:	696a      	ldr	r2, [r5, #20]
 8003b1a:	0852      	lsrs	r2, r2, #1
 8003b1c:	3a01      	subs	r2, #1
 8003b1e:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8003b22:	e7e0      	b.n	8003ae6 <RCCEx_PLLSAI1_Config+0xb6>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8003b24:	f7fd fa3e 	bl	8000fa4 <HAL_GetTick>
 8003b28:	1b80      	subs	r0, r0, r6
 8003b2a:	2802      	cmp	r0, #2
 8003b2c:	d9e3      	bls.n	8003af6 <RCCEx_PLLSAI1_Config+0xc6>
 8003b2e:	e7cd      	b.n	8003acc <RCCEx_PLLSAI1_Config+0x9c>
 8003b30:	40021000 	.word	0x40021000
 8003b34:	ff9f800f 	.word	0xff9f800f
 8003b38:	07ff800f 	.word	0x07ff800f
 8003b3c:	f9ff800f 	.word	0xf9ff800f

08003b40 <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 8003b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003b42:	4b3f      	ldr	r3, [pc, #252]	; (8003c40 <RCCEx_PLLSAI2_Config+0x100>)
 8003b44:	68da      	ldr	r2, [r3, #12]
 8003b46:	f012 0f03 	tst.w	r2, #3
{
 8003b4a:	4605      	mov	r5, r0
 8003b4c:	460e      	mov	r6, r1
 8003b4e:	461c      	mov	r4, r3
 8003b50:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8003b52:	d022      	beq.n	8003b9a <RCCEx_PLLSAI2_Config+0x5a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8003b54:	68db      	ldr	r3, [r3, #12]
 8003b56:	f003 0303 	and.w	r3, r3, #3
 8003b5a:	4283      	cmp	r3, r0
 8003b5c:	d130      	bne.n	8003bc0 <RCCEx_PLLSAI2_Config+0x80>
       ||
 8003b5e:	b37b      	cbz	r3, 8003bc0 <RCCEx_PLLSAI2_Config+0x80>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8003b60:	6823      	ldr	r3, [r4, #0]
 8003b62:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003b66:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003b68:	f7fd fa1c 	bl	8000fa4 <HAL_GetTick>
 8003b6c:	4607      	mov	r7, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8003b6e:	6823      	ldr	r3, [r4, #0]
 8003b70:	009a      	lsls	r2, r3, #2
 8003b72:	d42e      	bmi.n	8003bd2 <RCCEx_PLLSAI2_Config+0x92>
 8003b74:	68af      	ldr	r7, [r5, #8]
 8003b76:	686b      	ldr	r3, [r5, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8003b78:	b396      	cbz	r6, 8003be0 <RCCEx_PLLSAI2_Config+0xa0>
#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
      else if(Divider == DIVIDER_Q_UPDATE)
 8003b7a:	2e01      	cmp	r6, #1
 8003b7c:	d14c      	bne.n	8003c18 <RCCEx_PLLSAI2_Config+0xd8>
      {
        assert_param(IS_RCC_PLLSAI2Q_VALUE(PllSai2->PLLSAI2Q));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003b7e:	6962      	ldr	r2, [r4, #20]
 8003b80:	4930      	ldr	r1, [pc, #192]	; (8003c44 <RCCEx_PLLSAI2_Config+0x104>)
 8003b82:	4011      	ands	r1, r2
 8003b84:	692a      	ldr	r2, [r5, #16]
 8003b86:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8003b8a:	3b01      	subs	r3, #1
 8003b8c:	0852      	lsrs	r2, r2, #1
 8003b8e:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 8003b92:	3a01      	subs	r2, #1
 8003b94:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8003b98:	e02d      	b.n	8003bf6 <RCCEx_PLLSAI2_Config+0xb6>
    switch(PllSai2->PLLSAI2Source)
 8003b9a:	2802      	cmp	r0, #2
 8003b9c:	d00c      	beq.n	8003bb8 <RCCEx_PLLSAI2_Config+0x78>
 8003b9e:	2803      	cmp	r0, #3
 8003ba0:	d010      	beq.n	8003bc4 <RCCEx_PLLSAI2_Config+0x84>
 8003ba2:	2801      	cmp	r0, #1
 8003ba4:	d10c      	bne.n	8003bc0 <RCCEx_PLLSAI2_Config+0x80>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8003ba6:	681b      	ldr	r3, [r3, #0]
 8003ba8:	079f      	lsls	r7, r3, #30
 8003baa:	d534      	bpl.n	8003c16 <RCCEx_PLLSAI2_Config+0xd6>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 8003bac:	68e3      	ldr	r3, [r4, #12]
 8003bae:	f023 0303 	bic.w	r3, r3, #3
 8003bb2:	4318      	orrs	r0, r3
 8003bb4:	60e0      	str	r0, [r4, #12]
 8003bb6:	e7d3      	b.n	8003b60 <RCCEx_PLLSAI2_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8003bb8:	681b      	ldr	r3, [r3, #0]
 8003bba:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003bbe:	d1f5      	bne.n	8003bac <RCCEx_PLLSAI2_Config+0x6c>
 8003bc0:	2001      	movs	r0, #1
 8003bc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8003bc4:	681a      	ldr	r2, [r3, #0]
 8003bc6:	0391      	lsls	r1, r2, #14
 8003bc8:	d4f0      	bmi.n	8003bac <RCCEx_PLLSAI2_Config+0x6c>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003bca:	681b      	ldr	r3, [r3, #0]
 8003bcc:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8003bd0:	e7f5      	b.n	8003bbe <RCCEx_PLLSAI2_Config+0x7e>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8003bd2:	f7fd f9e7 	bl	8000fa4 <HAL_GetTick>
 8003bd6:	1bc0      	subs	r0, r0, r7
 8003bd8:	2802      	cmp	r0, #2
 8003bda:	d9c8      	bls.n	8003b6e <RCCEx_PLLSAI2_Config+0x2e>
        status = HAL_TIMEOUT;
 8003bdc:	2003      	movs	r0, #3
 8003bde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003be0:	68e8      	ldr	r0, [r5, #12]
 8003be2:	6966      	ldr	r6, [r4, #20]
 8003be4:	4918      	ldr	r1, [pc, #96]	; (8003c48 <RCCEx_PLLSAI2_Config+0x108>)
 8003be6:	06c2      	lsls	r2, r0, #27
 8003be8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8003bec:	4031      	ands	r1, r6
 8003bee:	430a      	orrs	r2, r1
 8003bf0:	3b01      	subs	r3, #1
 8003bf2:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
      else
      {
        assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003bf6:	6163      	str	r3, [r4, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 8003bf8:	6823      	ldr	r3, [r4, #0]
 8003bfa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003bfe:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003c00:	f7fd f9d0 	bl	8000fa4 <HAL_GetTick>
 8003c04:	4606      	mov	r6, r0

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8003c06:	6823      	ldr	r3, [r4, #0]
 8003c08:	009b      	lsls	r3, r3, #2
 8003c0a:	d513      	bpl.n	8003c34 <RCCEx_PLLSAI2_Config+0xf4>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8003c0c:	6963      	ldr	r3, [r4, #20]
 8003c0e:	69aa      	ldr	r2, [r5, #24]
 8003c10:	4313      	orrs	r3, r2
 8003c12:	6163      	str	r3, [r4, #20]
 8003c14:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 8003c16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8003c18:	6961      	ldr	r1, [r4, #20]
 8003c1a:	4a0c      	ldr	r2, [pc, #48]	; (8003c4c <RCCEx_PLLSAI2_Config+0x10c>)
 8003c1c:	400a      	ands	r2, r1
 8003c1e:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8003c22:	3b01      	subs	r3, #1
 8003c24:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8003c28:	696a      	ldr	r2, [r5, #20]
 8003c2a:	0852      	lsrs	r2, r2, #1
 8003c2c:	3a01      	subs	r2, #1
 8003c2e:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8003c32:	e7e0      	b.n	8003bf6 <RCCEx_PLLSAI2_Config+0xb6>
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8003c34:	f7fd f9b6 	bl	8000fa4 <HAL_GetTick>
 8003c38:	1b80      	subs	r0, r0, r6
 8003c3a:	2802      	cmp	r0, #2
 8003c3c:	d9e3      	bls.n	8003c06 <RCCEx_PLLSAI2_Config+0xc6>
 8003c3e:	e7cd      	b.n	8003bdc <RCCEx_PLLSAI2_Config+0x9c>
 8003c40:	40021000 	.word	0x40021000
 8003c44:	ff9f800f 	.word	0xff9f800f
 8003c48:	07ff800f 	.word	0x07ff800f
 8003c4c:	f9ff800f 	.word	0xf9ff800f

08003c50 <HAL_RCCEx_PeriphCLKConfig>:
{
 8003c50:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8003c54:	6805      	ldr	r5, [r0, #0]
 8003c56:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
{
 8003c5a:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8003c5c:	d023      	beq.n	8003ca6 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 8003c5e:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 8003c60:	2940      	cmp	r1, #64	; 0x40
 8003c62:	d014      	beq.n	8003c8e <HAL_RCCEx_PeriphCLKConfig+0x3e>
 8003c64:	d804      	bhi.n	8003c70 <HAL_RCCEx_PeriphCLKConfig+0x20>
 8003c66:	b1c1      	cbz	r1, 8003c9a <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8003c68:	2920      	cmp	r1, #32
 8003c6a:	d02b      	beq.n	8003cc4 <HAL_RCCEx_PeriphCLKConfig+0x74>
      ret = HAL_ERROR;
 8003c6c:	2501      	movs	r5, #1
 8003c6e:	e01a      	b.n	8003ca6 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 8003c70:	2960      	cmp	r1, #96	; 0x60
 8003c72:	d001      	beq.n	8003c78 <HAL_RCCEx_PeriphCLKConfig+0x28>
 8003c74:	2980      	cmp	r1, #128	; 0x80
 8003c76:	d1f9      	bne.n	8003c6c <HAL_RCCEx_PeriphCLKConfig+0x1c>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8003c78:	4a4e      	ldr	r2, [pc, #312]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8003c7a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8003c7c:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8003c80:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8003c84:	430b      	orrs	r3, r1
 8003c86:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8003c8a:	2500      	movs	r5, #0
 8003c8c:	e00b      	b.n	8003ca6 <HAL_RCCEx_PeriphCLKConfig+0x56>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8003c8e:	4a49      	ldr	r2, [pc, #292]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8003c90:	68d3      	ldr	r3, [r2, #12]
 8003c92:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003c96:	60d3      	str	r3, [r2, #12]
      break;
 8003c98:	e7ee      	b.n	8003c78 <HAL_RCCEx_PeriphCLKConfig+0x28>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8003c9a:	3004      	adds	r0, #4
 8003c9c:	f7ff fec8 	bl	8003a30 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003ca0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8003ca2:	2800      	cmp	r0, #0
 8003ca4:	d0e8      	beq.n	8003c78 <HAL_RCCEx_PeriphCLKConfig+0x28>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8003ca6:	6823      	ldr	r3, [r4, #0]
 8003ca8:	04db      	lsls	r3, r3, #19
 8003caa:	d509      	bpl.n	8003cc0 <HAL_RCCEx_PeriphCLKConfig+0x70>
    switch(PeriphClkInit->Sai2ClockSelection)
 8003cac:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8003cae:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8003cb2:	d014      	beq.n	8003cde <HAL_RCCEx_PeriphCLKConfig+0x8e>
 8003cb4:	d80b      	bhi.n	8003cce <HAL_RCCEx_PeriphCLKConfig+0x7e>
 8003cb6:	b1c1      	cbz	r1, 8003cea <HAL_RCCEx_PeriphCLKConfig+0x9a>
 8003cb8:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8003cbc:	d071      	beq.n	8003da2 <HAL_RCCEx_PeriphCLKConfig+0x152>
      ret = HAL_ERROR;
 8003cbe:	2501      	movs	r5, #1
 8003cc0:	462e      	mov	r6, r5
 8003cc2:	e021      	b.n	8003d08 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003cc4:	2100      	movs	r1, #0
 8003cc6:	3020      	adds	r0, #32
 8003cc8:	f7ff ff3a 	bl	8003b40 <RCCEx_PLLSAI2_Config>
 8003ccc:	e7e8      	b.n	8003ca0 <HAL_RCCEx_PeriphCLKConfig+0x50>
    switch(PeriphClkInit->Sai2ClockSelection)
 8003cce:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8003cd2:	d002      	beq.n	8003cda <HAL_RCCEx_PeriphCLKConfig+0x8a>
 8003cd4:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8003cd8:	d1f1      	bne.n	8003cbe <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8003cda:	462e      	mov	r6, r5
 8003cdc:	e009      	b.n	8003cf2 <HAL_RCCEx_PeriphCLKConfig+0xa2>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8003cde:	4a35      	ldr	r2, [pc, #212]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8003ce0:	68d3      	ldr	r3, [r2, #12]
 8003ce2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003ce6:	60d3      	str	r3, [r2, #12]
 8003ce8:	e7f7      	b.n	8003cda <HAL_RCCEx_PeriphCLKConfig+0x8a>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8003cea:	1d20      	adds	r0, r4, #4
 8003cec:	f7ff fea0 	bl	8003a30 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003cf0:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 8003cf2:	2e00      	cmp	r6, #0
 8003cf4:	d15b      	bne.n	8003dae <HAL_RCCEx_PeriphCLKConfig+0x15e>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8003cf6:	4a2f      	ldr	r2, [pc, #188]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8003cf8:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8003cfa:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8003cfe:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8003d02:	430b      	orrs	r3, r1
 8003d04:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003d08:	6823      	ldr	r3, [r4, #0]
 8003d0a:	039f      	lsls	r7, r3, #14
 8003d0c:	d565      	bpl.n	8003dda <HAL_RCCEx_PeriphCLKConfig+0x18a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8003d0e:	4f29      	ldr	r7, [pc, #164]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8003d10:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003d12:	00d8      	lsls	r0, r3, #3
 8003d14:	f140 81f3 	bpl.w	80040fe <HAL_RCCEx_PeriphCLKConfig+0x4ae>
    FlagStatus       pwrclkchanged = RESET;
 8003d18:	f04f 0800 	mov.w	r8, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003d1c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8003db8 <HAL_RCCEx_PeriphCLKConfig+0x168>
 8003d20:	f8d9 3000 	ldr.w	r3, [r9]
 8003d24:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003d28:	f8c9 3000 	str.w	r3, [r9]
    tickstart = HAL_GetTick();
 8003d2c:	f7fd f93a 	bl	8000fa4 <HAL_GetTick>
 8003d30:	4682      	mov	sl, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8003d32:	f8d9 3000 	ldr.w	r3, [r9]
 8003d36:	05d9      	lsls	r1, r3, #23
 8003d38:	d540      	bpl.n	8003dbc <HAL_RCCEx_PeriphCLKConfig+0x16c>
    if(ret == HAL_OK)
 8003d3a:	2e00      	cmp	r6, #0
 8003d3c:	f040 8197 	bne.w	800406e <HAL_RCCEx_PeriphCLKConfig+0x41e>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8003d40:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8003d44:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8003d48:	d015      	beq.n	8003d76 <HAL_RCCEx_PeriphCLKConfig+0x126>
 8003d4a:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8003d4e:	4293      	cmp	r3, r2
 8003d50:	d011      	beq.n	8003d76 <HAL_RCCEx_PeriphCLKConfig+0x126>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003d52:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 8003d56:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8003d5a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003d5e:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8003d62:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003d66:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 8003d6a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003d6e:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8003d72:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8003d76:	07da      	lsls	r2, r3, #31
 8003d78:	d509      	bpl.n	8003d8e <HAL_RCCEx_PeriphCLKConfig+0x13e>
        tickstart = HAL_GetTick();
 8003d7a:	f7fd f913 	bl	8000fa4 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003d7e:	f241 3a88 	movw	sl, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8003d82:	4681      	mov	r9, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003d84:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003d88:	079b      	lsls	r3, r3, #30
 8003d8a:	f140 8168 	bpl.w	800405e <HAL_RCCEx_PeriphCLKConfig+0x40e>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003d8e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003d92:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8003d96:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003d9a:	4313      	orrs	r3, r2
 8003d9c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8003da0:	e014      	b.n	8003dcc <HAL_RCCEx_PeriphCLKConfig+0x17c>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8003da2:	2100      	movs	r1, #0
 8003da4:	f104 0020 	add.w	r0, r4, #32
 8003da8:	f7ff feca 	bl	8003b40 <RCCEx_PLLSAI2_Config>
 8003dac:	e7a0      	b.n	8003cf0 <HAL_RCCEx_PeriphCLKConfig+0xa0>
 8003dae:	4635      	mov	r5, r6
 8003db0:	e7aa      	b.n	8003d08 <HAL_RCCEx_PeriphCLKConfig+0xb8>
 8003db2:	bf00      	nop
 8003db4:	40021000 	.word	0x40021000
 8003db8:	40007000 	.word	0x40007000
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003dbc:	f7fd f8f2 	bl	8000fa4 <HAL_GetTick>
 8003dc0:	eba0 000a 	sub.w	r0, r0, sl
 8003dc4:	2802      	cmp	r0, #2
 8003dc6:	d9b4      	bls.n	8003d32 <HAL_RCCEx_PeriphCLKConfig+0xe2>
        ret = HAL_TIMEOUT;
 8003dc8:	2503      	movs	r5, #3
 8003dca:	462e      	mov	r6, r5
    if(pwrclkchanged == SET)
 8003dcc:	f1b8 0f00 	cmp.w	r8, #0
 8003dd0:	d003      	beq.n	8003dda <HAL_RCCEx_PeriphCLKConfig+0x18a>
      __HAL_RCC_PWR_CLK_DISABLE();
 8003dd2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003dd4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003dd8:	65bb      	str	r3, [r7, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8003dda:	6823      	ldr	r3, [r4, #0]
 8003ddc:	07df      	lsls	r7, r3, #31
 8003dde:	d508      	bpl.n	8003df2 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8003de0:	49c0      	ldr	r1, [pc, #768]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003de2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8003de4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003de8:	f022 0203 	bic.w	r2, r2, #3
 8003dec:	4302      	orrs	r2, r0
 8003dee:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003df2:	0798      	lsls	r0, r3, #30
 8003df4:	d508      	bpl.n	8003e08 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8003df6:	49bb      	ldr	r1, [pc, #748]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003df8:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8003dfa:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003dfe:	f022 020c 	bic.w	r2, r2, #12
 8003e02:	4302      	orrs	r2, r0
 8003e04:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8003e08:	0759      	lsls	r1, r3, #29
 8003e0a:	d508      	bpl.n	8003e1e <HAL_RCCEx_PeriphCLKConfig+0x1ce>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8003e0c:	49b5      	ldr	r1, [pc, #724]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e0e:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8003e10:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e14:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8003e18:	4302      	orrs	r2, r0
 8003e1a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8003e1e:	071a      	lsls	r2, r3, #28
 8003e20:	d508      	bpl.n	8003e34 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8003e22:	49b0      	ldr	r1, [pc, #704]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e24:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8003e26:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e2a:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8003e2e:	4302      	orrs	r2, r0
 8003e30:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8003e34:	06df      	lsls	r7, r3, #27
 8003e36:	d508      	bpl.n	8003e4a <HAL_RCCEx_PeriphCLKConfig+0x1fa>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8003e38:	49aa      	ldr	r1, [pc, #680]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e3a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8003e3c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e40:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8003e44:	4302      	orrs	r2, r0
 8003e46:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8003e4a:	0698      	lsls	r0, r3, #26
 8003e4c:	d508      	bpl.n	8003e60 <HAL_RCCEx_PeriphCLKConfig+0x210>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003e4e:	49a5      	ldr	r1, [pc, #660]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e50:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8003e52:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e56:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8003e5a:	4302      	orrs	r2, r0
 8003e5c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8003e60:	0599      	lsls	r1, r3, #22
 8003e62:	d508      	bpl.n	8003e76 <HAL_RCCEx_PeriphCLKConfig+0x226>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8003e64:	499f      	ldr	r1, [pc, #636]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e66:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8003e68:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e6c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8003e70:	4302      	orrs	r2, r0
 8003e72:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8003e76:	055a      	lsls	r2, r3, #21
 8003e78:	d508      	bpl.n	8003e8c <HAL_RCCEx_PeriphCLKConfig+0x23c>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8003e7a:	499a      	ldr	r1, [pc, #616]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e7c:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8003e7e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e82:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8003e86:	4302      	orrs	r2, r0
 8003e88:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8003e8c:	065f      	lsls	r7, r3, #25
 8003e8e:	d508      	bpl.n	8003ea2 <HAL_RCCEx_PeriphCLKConfig+0x252>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8003e90:	4994      	ldr	r1, [pc, #592]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003e92:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8003e94:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003e98:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8003e9c:	4302      	orrs	r2, r0
 8003e9e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8003ea2:	0618      	lsls	r0, r3, #24
 8003ea4:	d508      	bpl.n	8003eb8 <HAL_RCCEx_PeriphCLKConfig+0x268>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8003ea6:	498f      	ldr	r1, [pc, #572]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003ea8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8003eaa:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003eae:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8003eb2:	4302      	orrs	r2, r0
 8003eb4:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8003eb8:	05d9      	lsls	r1, r3, #23
 8003eba:	d508      	bpl.n	8003ece <HAL_RCCEx_PeriphCLKConfig+0x27e>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8003ebc:	4989      	ldr	r1, [pc, #548]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003ebe:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8003ec0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003ec4:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8003ec8:	4302      	orrs	r2, r0
 8003eca:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8003ece:	02da      	lsls	r2, r3, #11
 8003ed0:	d508      	bpl.n	8003ee4 <HAL_RCCEx_PeriphCLKConfig+0x294>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8003ed2:	4984      	ldr	r1, [pc, #528]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003ed4:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8003ed6:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8003eda:	f022 0203 	bic.w	r2, r2, #3
 8003ede:	4302      	orrs	r2, r0
 8003ee0:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8003ee4:	049f      	lsls	r7, r3, #18
 8003ee6:	d510      	bpl.n	8003f0a <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8003ee8:	4a7e      	ldr	r2, [pc, #504]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003eea:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8003eec:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8003ef0:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8003ef4:	430b      	orrs	r3, r1
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8003ef6:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8003efa:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8003efe:	f040 80b8 	bne.w	8004072 <HAL_RCCEx_PeriphCLKConfig+0x422>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8003f02:	68d3      	ldr	r3, [r2, #12]
 8003f04:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003f08:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8003f0a:	6823      	ldr	r3, [r4, #0]
 8003f0c:	0318      	lsls	r0, r3, #12
 8003f0e:	d50f      	bpl.n	8003f30 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8003f10:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8003f12:	4b74      	ldr	r3, [pc, #464]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003f14:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8003f18:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8003f1c:	f040 80b6 	bne.w	800408c <HAL_RCCEx_PeriphCLKConfig+0x43c>
 8003f20:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003f24:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8003f28:	68da      	ldr	r2, [r3, #12]
 8003f2a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8003f2e:	60da      	str	r2, [r3, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8003f30:	6823      	ldr	r3, [r4, #0]
 8003f32:	0359      	lsls	r1, r3, #13
 8003f34:	d510      	bpl.n	8003f58 <HAL_RCCEx_PeriphCLKConfig+0x308>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8003f36:	4a6b      	ldr	r2, [pc, #428]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003f38:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8003f3a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8003f3e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8003f42:	430b      	orrs	r3, r1
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8003f44:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8003f48:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8003f4c:	f040 80bd 	bne.w	80040ca <HAL_RCCEx_PeriphCLKConfig+0x47a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8003f50:	68d3      	ldr	r3, [r2, #12]
 8003f52:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003f56:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8003f58:	6823      	ldr	r3, [r4, #0]
 8003f5a:	045a      	lsls	r2, r3, #17
 8003f5c:	d514      	bpl.n	8003f88 <HAL_RCCEx_PeriphCLKConfig+0x338>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8003f5e:	4961      	ldr	r1, [pc, #388]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003f60:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8003f64:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8003f68:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8003f6c:	4313      	orrs	r3, r2
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8003f6e:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8003f72:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8003f76:	d107      	bne.n	8003f88 <HAL_RCCEx_PeriphCLKConfig+0x338>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8003f78:	2102      	movs	r1, #2
 8003f7a:	1d20      	adds	r0, r4, #4
 8003f7c:	f7ff fd58 	bl	8003a30 <RCCEx_PLLSAI1_Config>
 8003f80:	4606      	mov	r6, r0
 8003f82:	2800      	cmp	r0, #0
 8003f84:	bf18      	it	ne
 8003f86:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8003f88:	6822      	ldr	r2, [r4, #0]
 8003f8a:	03d3      	lsls	r3, r2, #15
 8003f8c:	d509      	bpl.n	8003fa2 <HAL_RCCEx_PeriphCLKConfig+0x352>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8003f8e:	4955      	ldr	r1, [pc, #340]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003f90:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8003f94:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8003f98:	f023 0304 	bic.w	r3, r3, #4
 8003f9c:	4303      	orrs	r3, r0
 8003f9e:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8003fa2:	0297      	lsls	r7, r2, #10
 8003fa4:	d509      	bpl.n	8003fba <HAL_RCCEx_PeriphCLKConfig+0x36a>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8003fa6:	494f      	ldr	r1, [pc, #316]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003fa8:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8003fac:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8003fb0:	f023 0318 	bic.w	r3, r3, #24
 8003fb4:	4303      	orrs	r3, r0
 8003fb6:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8003fba:	0250      	lsls	r0, r2, #9
 8003fbc:	d51f      	bpl.n	8003ffe <HAL_RCCEx_PeriphCLKConfig+0x3ae>
    __HAL_RCC_PLLSAI2_DISABLE();
 8003fbe:	4f49      	ldr	r7, [pc, #292]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8003fc0:	683b      	ldr	r3, [r7, #0]
 8003fc2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003fc6:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8003fc8:	f7fc ffec 	bl	8000fa4 <HAL_GetTick>
 8003fcc:	4680      	mov	r8, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8003fce:	683b      	ldr	r3, [r7, #0]
 8003fd0:	0099      	lsls	r1, r3, #2
 8003fd2:	f100 8089 	bmi.w	80040e8 <HAL_RCCEx_PeriphCLKConfig+0x498>
    if(ret == HAL_OK)
 8003fd6:	2e00      	cmp	r6, #0
 8003fd8:	f040 808f 	bne.w	80040fa <HAL_RCCEx_PeriphCLKConfig+0x4aa>
      __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
 8003fdc:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003fe0:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8003fe4:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8003fe8:	4313      	orrs	r3, r2
 8003fea:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 8003fee:	2102      	movs	r1, #2
 8003ff0:	f104 0020 	add.w	r0, r4, #32
 8003ff4:	f7ff fda4 	bl	8003b40 <RCCEx_PLLSAI2_Config>
 8003ff8:	2800      	cmp	r0, #0
 8003ffa:	bf18      	it	ne
 8003ffc:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
 8003ffe:	6823      	ldr	r3, [r4, #0]
 8004000:	021a      	lsls	r2, r3, #8
 8004002:	d514      	bpl.n	800402e <HAL_RCCEx_PeriphCLKConfig+0x3de>
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8004004:	4937      	ldr	r1, [pc, #220]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8004006:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 800400a:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 800400e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004012:	4313      	orrs	r3, r2
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 8004014:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8004018:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 800401c:	d107      	bne.n	800402e <HAL_RCCEx_PeriphCLKConfig+0x3de>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_Q_UPDATE);
 800401e:	2101      	movs	r1, #1
 8004020:	f104 0020 	add.w	r0, r4, #32
 8004024:	f7ff fd8c 	bl	8003b40 <RCCEx_PLLSAI2_Config>
 8004028:	2800      	cmp	r0, #0
 800402a:	bf18      	it	ne
 800402c:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 800402e:	6823      	ldr	r3, [r4, #0]
 8004030:	01db      	lsls	r3, r3, #7
 8004032:	d510      	bpl.n	8004056 <HAL_RCCEx_PeriphCLKConfig+0x406>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8004034:	4a2b      	ldr	r2, [pc, #172]	; (80040e4 <HAL_RCCEx_PeriphCLKConfig+0x494>)
 8004036:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 800403a:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 800403e:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8004042:	430b      	orrs	r3, r1
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8004044:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8004048:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 800404c:	d103      	bne.n	8004056 <HAL_RCCEx_PeriphCLKConfig+0x406>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800404e:	68d3      	ldr	r3, [r2, #12]
 8004050:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004054:	60d3      	str	r3, [r2, #12]
}
 8004056:	4628      	mov	r0, r5
 8004058:	b002      	add	sp, #8
 800405a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800405e:	f7fc ffa1 	bl	8000fa4 <HAL_GetTick>
 8004062:	eba0 0009 	sub.w	r0, r0, r9
 8004066:	4550      	cmp	r0, sl
 8004068:	f67f ae8c 	bls.w	8003d84 <HAL_RCCEx_PeriphCLKConfig+0x134>
 800406c:	e6ac      	b.n	8003dc8 <HAL_RCCEx_PeriphCLKConfig+0x178>
 800406e:	4635      	mov	r5, r6
 8004070:	e6ac      	b.n	8003dcc <HAL_RCCEx_PeriphCLKConfig+0x17c>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8004072:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8004076:	f47f af48 	bne.w	8003f0a <HAL_RCCEx_PeriphCLKConfig+0x2ba>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800407a:	2101      	movs	r1, #1
 800407c:	1d20      	adds	r0, r4, #4
 800407e:	f7ff fcd7 	bl	8003a30 <RCCEx_PLLSAI1_Config>
 8004082:	4606      	mov	r6, r0
 8004084:	2800      	cmp	r0, #0
 8004086:	bf18      	it	ne
 8004088:	4605      	movne	r5, r0
 800408a:	e73e      	b.n	8003f0a <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800408c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8004090:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 8004094:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8004098:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 800409c:	430a      	orrs	r2, r1
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 800409e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80040a2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80040a6:	d103      	bne.n	80040b0 <HAL_RCCEx_PeriphCLKConfig+0x460>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80040a8:	68da      	ldr	r2, [r3, #12]
 80040aa:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80040ae:	e73e      	b.n	8003f2e <HAL_RCCEx_PeriphCLKConfig+0x2de>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80040b0:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 80040b4:	f47f af3c 	bne.w	8003f30 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80040b8:	2101      	movs	r1, #1
 80040ba:	1d20      	adds	r0, r4, #4
 80040bc:	f7ff fcb8 	bl	8003a30 <RCCEx_PLLSAI1_Config>
 80040c0:	4606      	mov	r6, r0
 80040c2:	2800      	cmp	r0, #0
 80040c4:	bf18      	it	ne
 80040c6:	4605      	movne	r5, r0
 80040c8:	e732      	b.n	8003f30 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80040ca:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 80040ce:	f47f af43 	bne.w	8003f58 <HAL_RCCEx_PeriphCLKConfig+0x308>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80040d2:	2101      	movs	r1, #1
 80040d4:	1d20      	adds	r0, r4, #4
 80040d6:	f7ff fcab 	bl	8003a30 <RCCEx_PLLSAI1_Config>
 80040da:	4606      	mov	r6, r0
 80040dc:	2800      	cmp	r0, #0
 80040de:	bf18      	it	ne
 80040e0:	4605      	movne	r5, r0
 80040e2:	e739      	b.n	8003f58 <HAL_RCCEx_PeriphCLKConfig+0x308>
 80040e4:	40021000 	.word	0x40021000
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80040e8:	f7fc ff5c 	bl	8000fa4 <HAL_GetTick>
 80040ec:	eba0 0008 	sub.w	r0, r0, r8
 80040f0:	2802      	cmp	r0, #2
 80040f2:	f67f af6c 	bls.w	8003fce <HAL_RCCEx_PeriphCLKConfig+0x37e>
        ret = HAL_TIMEOUT;
 80040f6:	2503      	movs	r5, #3
 80040f8:	e781      	b.n	8003ffe <HAL_RCCEx_PeriphCLKConfig+0x3ae>
 80040fa:	4635      	mov	r5, r6
 80040fc:	e77f      	b.n	8003ffe <HAL_RCCEx_PeriphCLKConfig+0x3ae>
      __HAL_RCC_PWR_CLK_ENABLE();
 80040fe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004100:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004104:	65bb      	str	r3, [r7, #88]	; 0x58
 8004106:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004108:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800410c:	9301      	str	r3, [sp, #4]
 800410e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8004110:	f04f 0801 	mov.w	r8, #1
 8004114:	e602      	b.n	8003d1c <HAL_RCCEx_PeriphCLKConfig+0xcc>
 8004116:	bf00      	nop

08004118 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8004118:	b570      	push	{r4, r5, r6, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800411a:	4604      	mov	r4, r0
 800411c:	2800      	cmp	r0, #0
 800411e:	d04a      	beq.n	80041b6 <HAL_SPI_Init+0x9e>
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8004120:	2300      	movs	r3, #0
 8004122:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8004124:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8004128:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800412c:	b91b      	cbnz	r3, 8004136 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800412e:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8004132:	f00d fcc7 	bl	8011ac4 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8004136:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8004138:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 800413a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 800413e:	680b      	ldr	r3, [r1, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004140:	68e2      	ldr	r2, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 8004142:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004146:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 800414a:	600b      	str	r3, [r1, #0]
 800414c:	f04f 0300 	mov.w	r3, #0
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004150:	d92e      	bls.n	80041b0 <HAL_SPI_Init+0x98>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8004152:	4618      	mov	r0, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8004154:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8004158:	bf18      	it	ne
 800415a:	62a3      	strne	r3, [r4, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800415c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800415e:	b92b      	cbnz	r3, 800416c <HAL_SPI_Init+0x54>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004160:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8004164:	bf8c      	ite	hi
 8004166:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8004168:	2301      	movls	r3, #1
 800416a:	6323      	str	r3, [r4, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800416c:	68a6      	ldr	r6, [r4, #8]
 800416e:	6863      	ldr	r3, [r4, #4]
 8004170:	69a5      	ldr	r5, [r4, #24]
 8004172:	4333      	orrs	r3, r6
 8004174:	6926      	ldr	r6, [r4, #16]
 8004176:	4333      	orrs	r3, r6
 8004178:	6966      	ldr	r6, [r4, #20]
 800417a:	4333      	orrs	r3, r6
 800417c:	69e6      	ldr	r6, [r4, #28]
 800417e:	4333      	orrs	r3, r6
 8004180:	6a26      	ldr	r6, [r4, #32]
 8004182:	4333      	orrs	r3, r6
 8004184:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8004186:	4333      	orrs	r3, r6
 8004188:	f405 7600 	and.w	r6, r5, #512	; 0x200
 800418c:	4333      	orrs	r3, r6
 800418e:	600b      	str	r3, [r1, #0]
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8004190:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004192:	431a      	orrs	r2, r3
 8004194:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004196:	0c2d      	lsrs	r5, r5, #16
 8004198:	431a      	orrs	r2, r3
 800419a:	f005 0504 	and.w	r5, r5, #4
 800419e:	432a      	orrs	r2, r5
 80041a0:	4302      	orrs	r2, r0
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;
 80041a2:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80041a4:	2000      	movs	r0, #0
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80041a6:	604a      	str	r2, [r1, #4]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80041a8:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80041aa:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

	
  return HAL_OK;
 80041ae:	bd70      	pop	{r4, r5, r6, pc}
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80041b0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80041b4:	e7d0      	b.n	8004158 <HAL_SPI_Init+0x40>
    return HAL_ERROR;
 80041b6:	2001      	movs	r0, #1
}
 80041b8:	bd70      	pop	{r4, r5, r6, pc}
	...

080041bc <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80041bc:	6a03      	ldr	r3, [r0, #32]
 80041be:	f023 0301 	bic.w	r3, r3, #1
 80041c2:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80041c4:	6a03      	ldr	r3, [r0, #32]
{
 80041c6:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80041c8:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80041ca:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80041cc:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80041ce:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80041d2:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80041d6:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80041d8:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 80041da:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 80041de:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80041e0:	4d1b      	ldr	r5, [pc, #108]	; (8004250 <TIM_OC1_SetConfig+0x94>)
 80041e2:	42a8      	cmp	r0, r5
 80041e4:	d00f      	beq.n	8004206 <TIM_OC1_SetConfig+0x4a>
 80041e6:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80041ea:	42a8      	cmp	r0, r5
 80041ec:	d00b      	beq.n	8004206 <TIM_OC1_SetConfig+0x4a>
 80041ee:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 80041f2:	42a8      	cmp	r0, r5
 80041f4:	d007      	beq.n	8004206 <TIM_OC1_SetConfig+0x4a>
 80041f6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80041fa:	42a8      	cmp	r0, r5
 80041fc:	d003      	beq.n	8004206 <TIM_OC1_SetConfig+0x4a>
 80041fe:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004202:	42a8      	cmp	r0, r5
 8004204:	d11e      	bne.n	8004244 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8004206:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8004208:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 800420c:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800420e:	4d10      	ldr	r5, [pc, #64]	; (8004250 <TIM_OC1_SetConfig+0x94>)
 8004210:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 8004212:	f023 0304 	bic.w	r3, r3, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004216:	d00f      	beq.n	8004238 <TIM_OC1_SetConfig+0x7c>
 8004218:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800421c:	42a8      	cmp	r0, r5
 800421e:	d00b      	beq.n	8004238 <TIM_OC1_SetConfig+0x7c>
 8004220:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004224:	42a8      	cmp	r0, r5
 8004226:	d007      	beq.n	8004238 <TIM_OC1_SetConfig+0x7c>
 8004228:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800422c:	42a8      	cmp	r0, r5
 800422e:	d003      	beq.n	8004238 <TIM_OC1_SetConfig+0x7c>
 8004230:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004234:	42a8      	cmp	r0, r5
 8004236:	d105      	bne.n	8004244 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8004238:	f424 7540 	bic.w	r5, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800423c:	698e      	ldr	r6, [r1, #24]
 800423e:	694c      	ldr	r4, [r1, #20]
 8004240:	4334      	orrs	r4, r6
 8004242:	432c      	orrs	r4, r5
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004244:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004246:	6182      	str	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8004248:	684a      	ldr	r2, [r1, #4]
 800424a:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800424c:	6203      	str	r3, [r0, #32]
 800424e:	bd70      	pop	{r4, r5, r6, pc}
 8004250:	40012c00 	.word	0x40012c00

08004254 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004254:	6a03      	ldr	r3, [r0, #32]
 8004256:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800425a:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800425c:	6a03      	ldr	r3, [r0, #32]
{
 800425e:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004260:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004262:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8004264:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8004266:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800426a:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800426e:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8004270:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 8004272:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8004276:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800427a:	4d16      	ldr	r5, [pc, #88]	; (80042d4 <TIM_OC3_SetConfig+0x80>)
 800427c:	42a8      	cmp	r0, r5
 800427e:	d003      	beq.n	8004288 <TIM_OC3_SetConfig+0x34>
 8004280:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004284:	42a8      	cmp	r0, r5
 8004286:	d10d      	bne.n	80042a4 <TIM_OC3_SetConfig+0x50>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004288:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 800428a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800428e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004292:	4d10      	ldr	r5, [pc, #64]	; (80042d4 <TIM_OC3_SetConfig+0x80>)
 8004294:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC3NE;
 8004296:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800429a:	d00e      	beq.n	80042ba <TIM_OC3_SetConfig+0x66>
 800429c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80042a0:	42a8      	cmp	r0, r5
 80042a2:	d00a      	beq.n	80042ba <TIM_OC3_SetConfig+0x66>
 80042a4:	4d0c      	ldr	r5, [pc, #48]	; (80042d8 <TIM_OC3_SetConfig+0x84>)
 80042a6:	42a8      	cmp	r0, r5
 80042a8:	d007      	beq.n	80042ba <TIM_OC3_SetConfig+0x66>
 80042aa:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80042ae:	42a8      	cmp	r0, r5
 80042b0:	d003      	beq.n	80042ba <TIM_OC3_SetConfig+0x66>
 80042b2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80042b6:	42a8      	cmp	r0, r5
 80042b8:	d106      	bne.n	80042c8 <TIM_OC3_SetConfig+0x74>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80042ba:	f424 5540 	bic.w	r5, r4, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80042be:	698e      	ldr	r6, [r1, #24]
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 80042c0:	694c      	ldr	r4, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80042c2:	4334      	orrs	r4, r6
 80042c4:	ea45 1404 	orr.w	r4, r5, r4, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80042c8:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80042ca:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 80042cc:	684a      	ldr	r2, [r1, #4]
 80042ce:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80042d0:	6203      	str	r3, [r0, #32]
 80042d2:	bd70      	pop	{r4, r5, r6, pc}
 80042d4:	40012c00 	.word	0x40012c00
 80042d8:	40014000 	.word	0x40014000

080042dc <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80042dc:	6a03      	ldr	r3, [r0, #32]
 80042de:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80042e2:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80042e4:	6a03      	ldr	r3, [r0, #32]
{
 80042e6:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80042e8:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80042ea:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80042ec:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80042ee:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80042f2:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80042f6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80042fa:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 80042fc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8004300:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004304:	4d0e      	ldr	r5, [pc, #56]	; (8004340 <TIM_OC4_SetConfig+0x64>)
 8004306:	42a8      	cmp	r0, r5
 8004308:	d00f      	beq.n	800432a <TIM_OC4_SetConfig+0x4e>
 800430a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800430e:	42a8      	cmp	r0, r5
 8004310:	d00b      	beq.n	800432a <TIM_OC4_SetConfig+0x4e>
 8004312:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004316:	42a8      	cmp	r0, r5
 8004318:	d007      	beq.n	800432a <TIM_OC4_SetConfig+0x4e>
 800431a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800431e:	42a8      	cmp	r0, r5
 8004320:	d003      	beq.n	800432a <TIM_OC4_SetConfig+0x4e>
 8004322:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004326:	42a8      	cmp	r0, r5
 8004328:	d104      	bne.n	8004334 <TIM_OC4_SetConfig+0x58>

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800432a:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 800432c:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8004330:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004334:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004336:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8004338:	684a      	ldr	r2, [r1, #4]
 800433a:	6402      	str	r2, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800433c:	6203      	str	r3, [r0, #32]
 800433e:	bd30      	pop	{r4, r5, pc}
 8004340:	40012c00 	.word	0x40012c00

08004344 <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8004344:	6a03      	ldr	r3, [r0, #32]
 8004346:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800434a:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800434c:	6a03      	ldr	r3, [r0, #32]
{
 800434e:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004350:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8004352:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8004354:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8004356:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800435a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 800435e:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8004360:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 8004362:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8004366:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800436a:	4d0f      	ldr	r5, [pc, #60]	; (80043a8 <TIM_OC5_SetConfig+0x64>)
 800436c:	42a8      	cmp	r0, r5
 800436e:	d00f      	beq.n	8004390 <TIM_OC5_SetConfig+0x4c>
 8004370:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004374:	42a8      	cmp	r0, r5
 8004376:	d00b      	beq.n	8004390 <TIM_OC5_SetConfig+0x4c>
 8004378:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 800437c:	42a8      	cmp	r0, r5
 800437e:	d007      	beq.n	8004390 <TIM_OC5_SetConfig+0x4c>
 8004380:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004384:	42a8      	cmp	r0, r5
 8004386:	d003      	beq.n	8004390 <TIM_OC5_SetConfig+0x4c>
 8004388:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800438c:	42a8      	cmp	r0, r5
 800438e:	d104      	bne.n	800439a <TIM_OC5_SetConfig+0x56>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8004390:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 8004392:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8004396:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800439a:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800439c:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800439e:	684a      	ldr	r2, [r1, #4]
 80043a0:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80043a2:	6203      	str	r3, [r0, #32]
 80043a4:	bd30      	pop	{r4, r5, pc}
 80043a6:	bf00      	nop
 80043a8:	40012c00 	.word	0x40012c00

080043ac <TIM_OC6_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80043ac:	6a03      	ldr	r3, [r0, #32]
 80043ae:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80043b2:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80043b4:	6a03      	ldr	r3, [r0, #32]
{
 80043b6:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80043b8:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 80043ba:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80043bc:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 80043be:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80043c2:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80043c6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80043ca:	688d      	ldr	r5, [r1, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 80043cc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80043d0:	ea43 5305 	orr.w	r3, r3, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80043d4:	4d0e      	ldr	r5, [pc, #56]	; (8004410 <TIM_OC6_SetConfig+0x64>)
 80043d6:	42a8      	cmp	r0, r5
 80043d8:	d00f      	beq.n	80043fa <TIM_OC6_SetConfig+0x4e>
 80043da:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80043de:	42a8      	cmp	r0, r5
 80043e0:	d00b      	beq.n	80043fa <TIM_OC6_SetConfig+0x4e>
 80043e2:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 80043e6:	42a8      	cmp	r0, r5
 80043e8:	d007      	beq.n	80043fa <TIM_OC6_SetConfig+0x4e>
 80043ea:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80043ee:	42a8      	cmp	r0, r5
 80043f0:	d003      	beq.n	80043fa <TIM_OC6_SetConfig+0x4e>
 80043f2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80043f6:	42a8      	cmp	r0, r5
 80043f8:	d104      	bne.n	8004404 <TIM_OC6_SetConfig+0x58>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80043fa:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 80043fc:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8004400:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004404:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8004406:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8004408:	684a      	ldr	r2, [r1, #4]
 800440a:	65c2      	str	r2, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800440c:	6203      	str	r3, [r0, #32]
 800440e:	bd30      	pop	{r4, r5, pc}
 8004410:	40012c00 	.word	0x40012c00

08004414 <HAL_TIM_Base_Start>:
  htim->State = HAL_TIM_STATE_BUSY;
 8004414:	2302      	movs	r3, #2
{
 8004416:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
 8004418:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(htim))
 800441c:	6803      	ldr	r3, [r0, #0]
 800441e:	4c09      	ldr	r4, [pc, #36]	; (8004444 <HAL_TIM_Base_Start+0x30>)
 8004420:	6899      	ldr	r1, [r3, #8]
 8004422:	4021      	ands	r1, r4
 8004424:	2906      	cmp	r1, #6
 8004426:	d008      	beq.n	800443a <HAL_TIM_Base_Start+0x26>
 8004428:	689a      	ldr	r2, [r3, #8]
 800442a:	4022      	ands	r2, r4
 800442c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    __HAL_TIM_ENABLE(htim);
 8004430:	bf1e      	ittt	ne
 8004432:	681a      	ldrne	r2, [r3, #0]
 8004434:	f042 0201 	orrne.w	r2, r2, #1
 8004438:	601a      	strne	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 800443a:	2301      	movs	r3, #1
 800443c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8004440:	2000      	movs	r0, #0
 8004442:	bd10      	pop	{r4, pc}
 8004444:	00010007 	.word	0x00010007

08004448 <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004448:	6803      	ldr	r3, [r0, #0]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(htim))
 800444a:	480a      	ldr	r0, [pc, #40]	; (8004474 <HAL_TIM_Base_Start_IT+0x2c>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800444c:	68da      	ldr	r2, [r3, #12]
 800444e:	f042 0201 	orr.w	r2, r2, #1
 8004452:	60da      	str	r2, [r3, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(htim))
 8004454:	6899      	ldr	r1, [r3, #8]
 8004456:	4001      	ands	r1, r0
 8004458:	2906      	cmp	r1, #6
 800445a:	d008      	beq.n	800446e <HAL_TIM_Base_Start_IT+0x26>
 800445c:	689a      	ldr	r2, [r3, #8]
 800445e:	4002      	ands	r2, r0
 8004460:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    __HAL_TIM_ENABLE(htim);
 8004464:	bf1e      	ittt	ne
 8004466:	681a      	ldrne	r2, [r3, #0]
 8004468:	f042 0201 	orrne.w	r2, r2, #1
 800446c:	601a      	strne	r2, [r3, #0]
}
 800446e:	2000      	movs	r0, #0
 8004470:	4770      	bx	lr
 8004472:	bf00      	nop
 8004474:	00010007 	.word	0x00010007

08004478 <HAL_TIM_PeriodElapsedCallback>:
 8004478:	4770      	bx	lr

0800447a <HAL_TIM_OC_DelayElapsedCallback>:
 800447a:	4770      	bx	lr

0800447c <HAL_TIM_IC_CaptureCallback>:
 800447c:	4770      	bx	lr

0800447e <HAL_TIM_PWM_PulseFinishedCallback>:
 800447e:	4770      	bx	lr

08004480 <HAL_TIM_TriggerCallback>:
 8004480:	4770      	bx	lr

08004482 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8004482:	6803      	ldr	r3, [r0, #0]
 8004484:	691a      	ldr	r2, [r3, #16]
 8004486:	0791      	lsls	r1, r2, #30
{
 8004488:	b510      	push	{r4, lr}
 800448a:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800448c:	d50f      	bpl.n	80044ae <HAL_TIM_IRQHandler+0x2c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800448e:	68da      	ldr	r2, [r3, #12]
 8004490:	0792      	lsls	r2, r2, #30
 8004492:	d50c      	bpl.n	80044ae <HAL_TIM_IRQHandler+0x2c>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8004494:	f06f 0202 	mvn.w	r2, #2
 8004498:	611a      	str	r2, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800449a:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800449c:	2201      	movs	r2, #1
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800449e:	0799      	lsls	r1, r3, #30
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80044a0:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80044a2:	f000 8085 	beq.w	80045b0 <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
 80044a6:	f7ff ffe9 	bl	800447c <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80044aa:	2300      	movs	r3, #0
 80044ac:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80044ae:	6823      	ldr	r3, [r4, #0]
 80044b0:	691a      	ldr	r2, [r3, #16]
 80044b2:	0752      	lsls	r2, r2, #29
 80044b4:	d510      	bpl.n	80044d8 <HAL_TIM_IRQHandler+0x56>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 80044b6:	68da      	ldr	r2, [r3, #12]
 80044b8:	0750      	lsls	r0, r2, #29
 80044ba:	d50d      	bpl.n	80044d8 <HAL_TIM_IRQHandler+0x56>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80044bc:	f06f 0204 	mvn.w	r2, #4
 80044c0:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80044c2:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80044c4:	2202      	movs	r2, #2
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80044c6:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80044ca:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 80044cc:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80044ce:	d075      	beq.n	80045bc <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
 80044d0:	f7ff ffd4 	bl	800447c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80044d4:	2300      	movs	r3, #0
 80044d6:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80044d8:	6823      	ldr	r3, [r4, #0]
 80044da:	691a      	ldr	r2, [r3, #16]
 80044dc:	0711      	lsls	r1, r2, #28
 80044de:	d50f      	bpl.n	8004500 <HAL_TIM_IRQHandler+0x7e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 80044e0:	68da      	ldr	r2, [r3, #12]
 80044e2:	0712      	lsls	r2, r2, #28
 80044e4:	d50c      	bpl.n	8004500 <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80044e6:	f06f 0208 	mvn.w	r2, #8
 80044ea:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80044ec:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80044ee:	2204      	movs	r2, #4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80044f0:	079b      	lsls	r3, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80044f2:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 80044f4:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80044f6:	d067      	beq.n	80045c8 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 80044f8:	f7ff ffc0 	bl	800447c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80044fc:	2300      	movs	r3, #0
 80044fe:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8004500:	6823      	ldr	r3, [r4, #0]
 8004502:	691a      	ldr	r2, [r3, #16]
 8004504:	06d0      	lsls	r0, r2, #27
 8004506:	d510      	bpl.n	800452a <HAL_TIM_IRQHandler+0xa8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8004508:	68da      	ldr	r2, [r3, #12]
 800450a:	06d1      	lsls	r1, r2, #27
 800450c:	d50d      	bpl.n	800452a <HAL_TIM_IRQHandler+0xa8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800450e:	f06f 0210 	mvn.w	r2, #16
 8004512:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004514:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8004516:	2208      	movs	r2, #8
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004518:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800451c:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 800451e:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004520:	d058      	beq.n	80045d4 <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_IC_CaptureCallback(htim);
 8004522:	f7ff ffab 	bl	800447c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004526:	2300      	movs	r3, #0
 8004528:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800452a:	6823      	ldr	r3, [r4, #0]
 800452c:	691a      	ldr	r2, [r3, #16]
 800452e:	07d2      	lsls	r2, r2, #31
 8004530:	d508      	bpl.n	8004544 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8004532:	68da      	ldr	r2, [r3, #12]
 8004534:	07d0      	lsls	r0, r2, #31
 8004536:	d505      	bpl.n	8004544 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8004538:	f06f 0201 	mvn.w	r2, #1
 800453c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800453e:	4620      	mov	r0, r4
 8004540:	f7ff ff9a 	bl	8004478 <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8004544:	6823      	ldr	r3, [r4, #0]
 8004546:	691a      	ldr	r2, [r3, #16]
 8004548:	0611      	lsls	r1, r2, #24
 800454a:	d508      	bpl.n	800455e <HAL_TIM_IRQHandler+0xdc>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800454c:	68da      	ldr	r2, [r3, #12]
 800454e:	0612      	lsls	r2, r2, #24
 8004550:	d505      	bpl.n	800455e <HAL_TIM_IRQHandler+0xdc>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8004552:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8004556:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8004558:	4620      	mov	r0, r4
 800455a:	f000 fa96 	bl	8004a8a <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800455e:	6823      	ldr	r3, [r4, #0]
 8004560:	691a      	ldr	r2, [r3, #16]
 8004562:	05d0      	lsls	r0, r2, #23
 8004564:	d508      	bpl.n	8004578 <HAL_TIM_IRQHandler+0xf6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8004566:	68da      	ldr	r2, [r3, #12]
 8004568:	0611      	lsls	r1, r2, #24
 800456a:	d505      	bpl.n	8004578 <HAL_TIM_IRQHandler+0xf6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800456c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8004570:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8004572:	4620      	mov	r0, r4
 8004574:	f000 fa8a 	bl	8004a8c <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8004578:	6823      	ldr	r3, [r4, #0]
 800457a:	691a      	ldr	r2, [r3, #16]
 800457c:	0652      	lsls	r2, r2, #25
 800457e:	d508      	bpl.n	8004592 <HAL_TIM_IRQHandler+0x110>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8004580:	68da      	ldr	r2, [r3, #12]
 8004582:	0650      	lsls	r0, r2, #25
 8004584:	d505      	bpl.n	8004592 <HAL_TIM_IRQHandler+0x110>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8004586:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800458a:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800458c:	4620      	mov	r0, r4
 800458e:	f7ff ff77 	bl	8004480 <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8004592:	6823      	ldr	r3, [r4, #0]
 8004594:	691a      	ldr	r2, [r3, #16]
 8004596:	0691      	lsls	r1, r2, #26
 8004598:	d522      	bpl.n	80045e0 <HAL_TIM_IRQHandler+0x15e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800459a:	68da      	ldr	r2, [r3, #12]
 800459c:	0692      	lsls	r2, r2, #26
 800459e:	d51f      	bpl.n	80045e0 <HAL_TIM_IRQHandler+0x15e>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80045a0:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 80045a4:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80045a6:	611a      	str	r2, [r3, #16]
}
 80045a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
 80045ac:	f000 ba6c 	b.w	8004a88 <HAL_TIMEx_CommutationCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80045b0:	f7ff ff63 	bl	800447a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80045b4:	4620      	mov	r0, r4
 80045b6:	f7ff ff62 	bl	800447e <HAL_TIM_PWM_PulseFinishedCallback>
 80045ba:	e776      	b.n	80044aa <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80045bc:	f7ff ff5d 	bl	800447a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80045c0:	4620      	mov	r0, r4
 80045c2:	f7ff ff5c 	bl	800447e <HAL_TIM_PWM_PulseFinishedCallback>
 80045c6:	e785      	b.n	80044d4 <HAL_TIM_IRQHandler+0x52>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80045c8:	f7ff ff57 	bl	800447a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80045cc:	4620      	mov	r0, r4
 80045ce:	f7ff ff56 	bl	800447e <HAL_TIM_PWM_PulseFinishedCallback>
 80045d2:	e793      	b.n	80044fc <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80045d4:	f7ff ff51 	bl	800447a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80045d8:	4620      	mov	r0, r4
 80045da:	f7ff ff50 	bl	800447e <HAL_TIM_PWM_PulseFinishedCallback>
 80045de:	e7a2      	b.n	8004526 <HAL_TIM_IRQHandler+0xa4>
 80045e0:	bd10      	pop	{r4, pc}
	...

080045e4 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80045e4:	4a30      	ldr	r2, [pc, #192]	; (80046a8 <TIM_Base_SetConfig+0xc4>)
  tmpcr1 = TIMx->CR1;
 80045e6:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80045e8:	4290      	cmp	r0, r2
 80045ea:	d012      	beq.n	8004612 <TIM_Base_SetConfig+0x2e>
 80045ec:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80045f0:	d00f      	beq.n	8004612 <TIM_Base_SetConfig+0x2e>
 80045f2:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80045f6:	4290      	cmp	r0, r2
 80045f8:	d00b      	beq.n	8004612 <TIM_Base_SetConfig+0x2e>
 80045fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80045fe:	4290      	cmp	r0, r2
 8004600:	d007      	beq.n	8004612 <TIM_Base_SetConfig+0x2e>
 8004602:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004606:	4290      	cmp	r0, r2
 8004608:	d003      	beq.n	8004612 <TIM_Base_SetConfig+0x2e>
 800460a:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 800460e:	4290      	cmp	r0, r2
 8004610:	d119      	bne.n	8004646 <TIM_Base_SetConfig+0x62>
    tmpcr1 |= Structure->CounterMode;
 8004612:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004614:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8004618:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800461a:	4a23      	ldr	r2, [pc, #140]	; (80046a8 <TIM_Base_SetConfig+0xc4>)
 800461c:	4290      	cmp	r0, r2
 800461e:	d01d      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 8004620:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004624:	d01a      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 8004626:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 800462a:	4290      	cmp	r0, r2
 800462c:	d016      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 800462e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004632:	4290      	cmp	r0, r2
 8004634:	d012      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 8004636:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800463a:	4290      	cmp	r0, r2
 800463c:	d00e      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 800463e:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 8004642:	4290      	cmp	r0, r2
 8004644:	d00a      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 8004646:	4a19      	ldr	r2, [pc, #100]	; (80046ac <TIM_Base_SetConfig+0xc8>)
 8004648:	4290      	cmp	r0, r2
 800464a:	d007      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 800464c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004650:	4290      	cmp	r0, r2
 8004652:	d003      	beq.n	800465c <TIM_Base_SetConfig+0x78>
 8004654:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004658:	4290      	cmp	r0, r2
 800465a:	d103      	bne.n	8004664 <TIM_Base_SetConfig+0x80>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800465c:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 800465e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004662:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004664:	694a      	ldr	r2, [r1, #20]
 8004666:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800466a:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 800466c:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800466e:	688b      	ldr	r3, [r1, #8]
 8004670:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004672:	680b      	ldr	r3, [r1, #0]
 8004674:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8004676:	4b0c      	ldr	r3, [pc, #48]	; (80046a8 <TIM_Base_SetConfig+0xc4>)
 8004678:	4298      	cmp	r0, r3
 800467a:	d00f      	beq.n	800469c <TIM_Base_SetConfig+0xb8>
 800467c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004680:	4298      	cmp	r0, r3
 8004682:	d00b      	beq.n	800469c <TIM_Base_SetConfig+0xb8>
 8004684:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004688:	4298      	cmp	r0, r3
 800468a:	d007      	beq.n	800469c <TIM_Base_SetConfig+0xb8>
 800468c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004690:	4298      	cmp	r0, r3
 8004692:	d003      	beq.n	800469c <TIM_Base_SetConfig+0xb8>
 8004694:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004698:	4298      	cmp	r0, r3
 800469a:	d101      	bne.n	80046a0 <TIM_Base_SetConfig+0xbc>
    TIMx->RCR = Structure->RepetitionCounter;
 800469c:	690b      	ldr	r3, [r1, #16]
 800469e:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 80046a0:	2301      	movs	r3, #1
 80046a2:	6143      	str	r3, [r0, #20]
 80046a4:	4770      	bx	lr
 80046a6:	bf00      	nop
 80046a8:	40012c00 	.word	0x40012c00
 80046ac:	40014000 	.word	0x40014000

080046b0 <HAL_TIM_Base_Init>:
{
 80046b0:	b510      	push	{r4, lr}
  if (htim == NULL)
 80046b2:	4604      	mov	r4, r0
 80046b4:	b1a0      	cbz	r0, 80046e0 <HAL_TIM_Base_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
 80046b6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80046ba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80046be:	b91b      	cbnz	r3, 80046c8 <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 80046c0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80046c4:	f00d fa94 	bl	8011bf0 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 80046c8:	2302      	movs	r3, #2
 80046ca:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80046ce:	6820      	ldr	r0, [r4, #0]
 80046d0:	1d21      	adds	r1, r4, #4
 80046d2:	f7ff ff87 	bl	80045e4 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 80046d6:	2301      	movs	r3, #1
 80046d8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80046dc:	2000      	movs	r0, #0
 80046de:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80046e0:	2001      	movs	r0, #1
}
 80046e2:	bd10      	pop	{r4, pc}

080046e4 <HAL_TIM_OC_Init>:
{
 80046e4:	b510      	push	{r4, lr}
  if (htim == NULL)
 80046e6:	4604      	mov	r4, r0
 80046e8:	b1a0      	cbz	r0, 8004714 <HAL_TIM_OC_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
 80046ea:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80046ee:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80046f2:	b91b      	cbnz	r3, 80046fc <HAL_TIM_OC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 80046f4:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_OC_MspInit(htim);
 80046f8:	f00d fadc 	bl	8011cb4 <HAL_TIM_OC_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 80046fc:	2302      	movs	r3, #2
 80046fe:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8004702:	6820      	ldr	r0, [r4, #0]
 8004704:	1d21      	adds	r1, r4, #4
 8004706:	f7ff ff6d 	bl	80045e4 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 800470a:	2301      	movs	r3, #1
 800470c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8004710:	2000      	movs	r0, #0
 8004712:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8004714:	2001      	movs	r0, #1
}
 8004716:	bd10      	pop	{r4, pc}

08004718 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004718:	6a03      	ldr	r3, [r0, #32]
 800471a:	f023 0310 	bic.w	r3, r3, #16
 800471e:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8004720:	6a03      	ldr	r3, [r0, #32]
{
 8004722:	b570      	push	{r4, r5, r6, lr}
  tmpcr2 =  TIMx->CR2;
 8004724:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8004726:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004728:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800472a:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800472e:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004732:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8004736:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 8004738:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800473c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8004740:	4d16      	ldr	r5, [pc, #88]	; (800479c <TIM_OC2_SetConfig+0x84>)
 8004742:	42a8      	cmp	r0, r5
 8004744:	d003      	beq.n	800474e <TIM_OC2_SetConfig+0x36>
 8004746:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800474a:	42a8      	cmp	r0, r5
 800474c:	d10d      	bne.n	800476a <TIM_OC2_SetConfig+0x52>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800474e:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8004750:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8004754:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004758:	4d10      	ldr	r5, [pc, #64]	; (800479c <TIM_OC2_SetConfig+0x84>)
 800475a:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 800475c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004760:	d00e      	beq.n	8004780 <TIM_OC2_SetConfig+0x68>
 8004762:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004766:	42a8      	cmp	r0, r5
 8004768:	d00a      	beq.n	8004780 <TIM_OC2_SetConfig+0x68>
 800476a:	4d0d      	ldr	r5, [pc, #52]	; (80047a0 <TIM_OC2_SetConfig+0x88>)
 800476c:	42a8      	cmp	r0, r5
 800476e:	d007      	beq.n	8004780 <TIM_OC2_SetConfig+0x68>
 8004770:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004774:	42a8      	cmp	r0, r5
 8004776:	d003      	beq.n	8004780 <TIM_OC2_SetConfig+0x68>
 8004778:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800477c:	42a8      	cmp	r0, r5
 800477e:	d106      	bne.n	800478e <TIM_OC2_SetConfig+0x76>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8004780:	f424 6540 	bic.w	r5, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004784:	698e      	ldr	r6, [r1, #24]
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8004786:	694c      	ldr	r4, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004788:	4334      	orrs	r4, r6
 800478a:	ea45 0484 	orr.w	r4, r5, r4, lsl #2
  TIMx->CR2 = tmpcr2;
 800478e:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8004790:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8004792:	684a      	ldr	r2, [r1, #4]
 8004794:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8004796:	6203      	str	r3, [r0, #32]
 8004798:	bd70      	pop	{r4, r5, r6, pc}
 800479a:	bf00      	nop
 800479c:	40012c00 	.word	0x40012c00
 80047a0:	40014000 	.word	0x40014000

080047a4 <HAL_TIM_OC_ConfigChannel>:
  __HAL_LOCK(htim);
 80047a4:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80047a8:	2b01      	cmp	r3, #1
{
 80047aa:	b510      	push	{r4, lr}
 80047ac:	4604      	mov	r4, r0
 80047ae:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 80047b2:	d010      	beq.n	80047d6 <HAL_TIM_OC_ConfigChannel+0x32>
 80047b4:	2301      	movs	r3, #1
  switch (Channel)
 80047b6:	2a08      	cmp	r2, #8
  __HAL_LOCK(htim);
 80047b8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 80047bc:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  switch (Channel)
 80047c0:	d01c      	beq.n	80047fc <HAL_TIM_OC_ConfigChannel+0x58>
 80047c2:	d809      	bhi.n	80047d8 <HAL_TIM_OC_ConfigChannel+0x34>
 80047c4:	b192      	cbz	r2, 80047ec <HAL_TIM_OC_ConfigChannel+0x48>
 80047c6:	2a04      	cmp	r2, #4
 80047c8:	d014      	beq.n	80047f4 <HAL_TIM_OC_ConfigChannel+0x50>
  htim->State = HAL_TIM_STATE_READY;
 80047ca:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 80047cc:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 80047ce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 80047d2:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 80047d6:	bd10      	pop	{r4, pc}
  switch (Channel)
 80047d8:	2a10      	cmp	r2, #16
 80047da:	d013      	beq.n	8004804 <HAL_TIM_OC_ConfigChannel+0x60>
 80047dc:	2a14      	cmp	r2, #20
 80047de:	d015      	beq.n	800480c <HAL_TIM_OC_ConfigChannel+0x68>
 80047e0:	2a0c      	cmp	r2, #12
 80047e2:	d1f2      	bne.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80047e4:	6820      	ldr	r0, [r4, #0]
 80047e6:	f7ff fd79 	bl	80042dc <TIM_OC4_SetConfig>
      break;
 80047ea:	e7ee      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80047ec:	6820      	ldr	r0, [r4, #0]
 80047ee:	f7ff fce5 	bl	80041bc <TIM_OC1_SetConfig>
      break;
 80047f2:	e7ea      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80047f4:	6820      	ldr	r0, [r4, #0]
 80047f6:	f7ff ff8f 	bl	8004718 <TIM_OC2_SetConfig>
      break;
 80047fa:	e7e6      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80047fc:	6820      	ldr	r0, [r4, #0]
 80047fe:	f7ff fd29 	bl	8004254 <TIM_OC3_SetConfig>
      break;
 8004802:	e7e2      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8004804:	6820      	ldr	r0, [r4, #0]
 8004806:	f7ff fd9d 	bl	8004344 <TIM_OC5_SetConfig>
      break;
 800480a:	e7de      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800480c:	6820      	ldr	r0, [r4, #0]
 800480e:	f7ff fdcd 	bl	80043ac <TIM_OC6_SetConfig>
      break;
 8004812:	e7da      	b.n	80047ca <HAL_TIM_OC_ConfigChannel+0x26>

08004814 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8004814:	b510      	push	{r4, lr}
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8004816:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004818:	430a      	orrs	r2, r1
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800481a:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800481e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8004822:	4323      	orrs	r3, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8004824:	6083      	str	r3, [r0, #8]
 8004826:	bd10      	pop	{r4, pc}

08004828 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8004828:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800482c:	2b01      	cmp	r3, #1
{
 800482e:	b570      	push	{r4, r5, r6, lr}
 8004830:	4604      	mov	r4, r0
 8004832:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 8004836:	d017      	beq.n	8004868 <HAL_TIM_ConfigClockSource+0x40>
  htim->State = HAL_TIM_STATE_BUSY;
 8004838:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 800483c:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(htim);
 800483e:	2301      	movs	r3, #1
 8004840:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 8004844:	6882      	ldr	r2, [r0, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8004846:	4b48      	ldr	r3, [pc, #288]	; (8004968 <HAL_TIM_ConfigClockSource+0x140>)
 8004848:	4013      	ands	r3, r2
  htim->Instance->SMCR = tmpsmcr;
 800484a:	6083      	str	r3, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
 800484c:	680b      	ldr	r3, [r1, #0]
 800484e:	2b40      	cmp	r3, #64	; 0x40
 8004850:	d072      	beq.n	8004938 <HAL_TIM_ConfigClockSource+0x110>
 8004852:	d815      	bhi.n	8004880 <HAL_TIM_ConfigClockSource+0x58>
 8004854:	2b10      	cmp	r3, #16
 8004856:	d00c      	beq.n	8004872 <HAL_TIM_ConfigClockSource+0x4a>
 8004858:	d807      	bhi.n	800486a <HAL_TIM_ConfigClockSource+0x42>
 800485a:	b153      	cbz	r3, 8004872 <HAL_TIM_ConfigClockSource+0x4a>
  htim->State = HAL_TIM_STATE_READY;
 800485c:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 800485e:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8004860:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8004864:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8004868:	bd70      	pop	{r4, r5, r6, pc}
  switch (sClockSourceConfig->ClockSource)
 800486a:	2b20      	cmp	r3, #32
 800486c:	d001      	beq.n	8004872 <HAL_TIM_ConfigClockSource+0x4a>
 800486e:	2b30      	cmp	r3, #48	; 0x30
 8004870:	d1f4      	bne.n	800485c <HAL_TIM_ConfigClockSource+0x34>
  tmpsmcr = TIMx->SMCR;
 8004872:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004874:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 8004878:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800487c:	4313      	orrs	r3, r2
 800487e:	e033      	b.n	80048e8 <HAL_TIM_ConfigClockSource+0xc0>
  switch (sClockSourceConfig->ClockSource)
 8004880:	2b70      	cmp	r3, #112	; 0x70
 8004882:	d033      	beq.n	80048ec <HAL_TIM_ConfigClockSource+0xc4>
 8004884:	d81b      	bhi.n	80048be <HAL_TIM_ConfigClockSource+0x96>
 8004886:	2b50      	cmp	r3, #80	; 0x50
 8004888:	d03f      	beq.n	800490a <HAL_TIM_ConfigClockSource+0xe2>
 800488a:	2b60      	cmp	r3, #96	; 0x60
 800488c:	d1e6      	bne.n	800485c <HAL_TIM_ConfigClockSource+0x34>
      TIM_TI2_ConfigInputStage(htim->Instance,
 800488e:	684d      	ldr	r5, [r1, #4]
 8004890:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004892:	6a01      	ldr	r1, [r0, #32]
 8004894:	f021 0110 	bic.w	r1, r1, #16
 8004898:	6201      	str	r1, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 800489a:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 800489c:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800489e:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80048a2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 80048a6:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 80048aa:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 80048ae:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 80048b0:	6203      	str	r3, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 80048b2:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 80048b4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 80048b8:	f043 0367 	orr.w	r3, r3, #103	; 0x67
 80048bc:	e014      	b.n	80048e8 <HAL_TIM_ConfigClockSource+0xc0>
  switch (sClockSourceConfig->ClockSource)
 80048be:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80048c2:	d00c      	beq.n	80048de <HAL_TIM_ConfigClockSource+0xb6>
 80048c4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80048c8:	d1c8      	bne.n	800485c <HAL_TIM_ConfigClockSource+0x34>
      TIM_ETR_SetConfig(htim->Instance,
 80048ca:	68cb      	ldr	r3, [r1, #12]
 80048cc:	684a      	ldr	r2, [r1, #4]
 80048ce:	6889      	ldr	r1, [r1, #8]
 80048d0:	f7ff ffa0 	bl	8004814 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80048d4:	6822      	ldr	r2, [r4, #0]
 80048d6:	6893      	ldr	r3, [r2, #8]
 80048d8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80048dc:	e013      	b.n	8004906 <HAL_TIM_ConfigClockSource+0xde>
      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 80048de:	6883      	ldr	r3, [r0, #8]
 80048e0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80048e4:	f023 0307 	bic.w	r3, r3, #7
  TIMx->SMCR = tmpsmcr;
 80048e8:	6083      	str	r3, [r0, #8]
 80048ea:	e7b7      	b.n	800485c <HAL_TIM_ConfigClockSource+0x34>
      TIM_ETR_SetConfig(htim->Instance,
 80048ec:	68cb      	ldr	r3, [r1, #12]
 80048ee:	684a      	ldr	r2, [r1, #4]
 80048f0:	6889      	ldr	r1, [r1, #8]
 80048f2:	f7ff ff8f 	bl	8004814 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 80048f6:	6822      	ldr	r2, [r4, #0]
 80048f8:	6893      	ldr	r3, [r2, #8]
      tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 80048fa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80048fe:	f023 0377 	bic.w	r3, r3, #119	; 0x77
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8004902:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8004906:	6093      	str	r3, [r2, #8]
      break;
 8004908:	e7a8      	b.n	800485c <HAL_TIM_ConfigClockSource+0x34>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800490a:	684a      	ldr	r2, [r1, #4]
 800490c:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 800490e:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004910:	6a05      	ldr	r5, [r0, #32]
 8004912:	f025 0501 	bic.w	r5, r5, #1
 8004916:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004918:	6983      	ldr	r3, [r0, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800491a:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800491e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8004922:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 8004926:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 8004928:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 800492a:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 800492c:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800492e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004932:	f043 0357 	orr.w	r3, r3, #87	; 0x57
 8004936:	e7d7      	b.n	80048e8 <HAL_TIM_ConfigClockSource+0xc0>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8004938:	684a      	ldr	r2, [r1, #4]
 800493a:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 800493c:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800493e:	6a05      	ldr	r5, [r0, #32]
 8004940:	f025 0501 	bic.w	r5, r5, #1
 8004944:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004946:	6983      	ldr	r3, [r0, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004948:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800494c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8004950:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 8004954:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 8004956:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004958:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 800495a:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800495c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004960:	f043 0347 	orr.w	r3, r3, #71	; 0x47
 8004964:	e7c0      	b.n	80048e8 <HAL_TIM_ConfigClockSource+0xc0>
 8004966:	bf00      	nop
 8004968:	fffe0088 	.word	0xfffe0088

0800496c <TIM_CCxChannelCmd>:
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800496c:	6a03      	ldr	r3, [r0, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800496e:	f001 011f 	and.w	r1, r1, #31
{
 8004972:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8004974:	2401      	movs	r4, #1
 8004976:	408c      	lsls	r4, r1
  TIMx->CCER &= ~tmp;
 8004978:	ea23 0304 	bic.w	r3, r3, r4
 800497c:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800497e:	6a03      	ldr	r3, [r0, #32]
 8004980:	408a      	lsls	r2, r1
 8004982:	431a      	orrs	r2, r3
 8004984:	6202      	str	r2, [r0, #32]
 8004986:	bd10      	pop	{r4, pc}

08004988 <HAL_TIM_PWM_Start_IT>:
{
 8004988:	b510      	push	{r4, lr}
 800498a:	4604      	mov	r4, r0
  switch (Channel)
 800498c:	290c      	cmp	r1, #12
 800498e:	d80d      	bhi.n	80049ac <HAL_TIM_PWM_Start_IT+0x24>
 8004990:	e8df f001 	tbb	[pc, r1]
 8004994:	0c0c0c07 	.word	0x0c0c0c07
 8004998:	0c0c0c34 	.word	0x0c0c0c34
 800499c:	0c0c0c39 	.word	0x0c0c0c39
 80049a0:	3e          	.byte	0x3e
 80049a1:	00          	.byte	0x00
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80049a2:	6802      	ldr	r2, [r0, #0]
 80049a4:	68d3      	ldr	r3, [r2, #12]
 80049a6:	f043 0302 	orr.w	r3, r3, #2
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 80049aa:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80049ac:	2201      	movs	r2, #1
 80049ae:	6820      	ldr	r0, [r4, #0]
 80049b0:	f7ff ffdc 	bl	800496c <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80049b4:	6823      	ldr	r3, [r4, #0]
 80049b6:	4a1b      	ldr	r2, [pc, #108]	; (8004a24 <HAL_TIM_PWM_Start_IT+0x9c>)
 80049b8:	4293      	cmp	r3, r2
 80049ba:	d02e      	beq.n	8004a1a <HAL_TIM_PWM_Start_IT+0x92>
 80049bc:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80049c0:	4293      	cmp	r3, r2
 80049c2:	d02a      	beq.n	8004a1a <HAL_TIM_PWM_Start_IT+0x92>
 80049c4:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 80049c8:	4293      	cmp	r3, r2
 80049ca:	d026      	beq.n	8004a1a <HAL_TIM_PWM_Start_IT+0x92>
 80049cc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80049d0:	4293      	cmp	r3, r2
 80049d2:	d022      	beq.n	8004a1a <HAL_TIM_PWM_Start_IT+0x92>
 80049d4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80049d8:	4293      	cmp	r3, r2
 80049da:	d01e      	beq.n	8004a1a <HAL_TIM_PWM_Start_IT+0x92>
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(htim))
 80049dc:	6899      	ldr	r1, [r3, #8]
 80049de:	4812      	ldr	r0, [pc, #72]	; (8004a28 <HAL_TIM_PWM_Start_IT+0xa0>)
 80049e0:	4001      	ands	r1, r0
 80049e2:	2906      	cmp	r1, #6
 80049e4:	d008      	beq.n	80049f8 <HAL_TIM_PWM_Start_IT+0x70>
 80049e6:	689a      	ldr	r2, [r3, #8]
 80049e8:	4002      	ands	r2, r0
 80049ea:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80049ee:	d003      	beq.n	80049f8 <HAL_TIM_PWM_Start_IT+0x70>
    __HAL_TIM_ENABLE(htim);
 80049f0:	681a      	ldr	r2, [r3, #0]
 80049f2:	f042 0201 	orr.w	r2, r2, #1
 80049f6:	601a      	str	r2, [r3, #0]
}
 80049f8:	2000      	movs	r0, #0
 80049fa:	bd10      	pop	{r4, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 80049fc:	6802      	ldr	r2, [r0, #0]
 80049fe:	68d3      	ldr	r3, [r2, #12]
 8004a00:	f043 0304 	orr.w	r3, r3, #4
 8004a04:	e7d1      	b.n	80049aa <HAL_TIM_PWM_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8004a06:	6802      	ldr	r2, [r0, #0]
 8004a08:	68d3      	ldr	r3, [r2, #12]
 8004a0a:	f043 0308 	orr.w	r3, r3, #8
 8004a0e:	e7cc      	b.n	80049aa <HAL_TIM_PWM_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8004a10:	6802      	ldr	r2, [r0, #0]
 8004a12:	68d3      	ldr	r3, [r2, #12]
 8004a14:	f043 0310 	orr.w	r3, r3, #16
 8004a18:	e7c7      	b.n	80049aa <HAL_TIM_PWM_Start_IT+0x22>
    __HAL_TIM_MOE_ENABLE(htim);
 8004a1a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004a1c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8004a20:	645a      	str	r2, [r3, #68]	; 0x44
 8004a22:	e7db      	b.n	80049dc <HAL_TIM_PWM_Start_IT+0x54>
 8004a24:	40012c00 	.word	0x40012c00
 8004a28:	00010007 	.word	0x00010007

08004a2c <HAL_TIM_OC_Start_IT>:
 8004a2c:	f7ff bfac 	b.w	8004988 <HAL_TIM_PWM_Start_IT>

08004a30 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8004a30:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8004a34:	2b01      	cmp	r3, #1
{
 8004a36:	b530      	push	{r4, r5, lr}
 8004a38:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 8004a3c:	d01f      	beq.n	8004a7e <HAL_TIMEx_MasterConfigSynchronization+0x4e>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8004a3e:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8004a40:	4d10      	ldr	r5, [pc, #64]	; (8004a84 <HAL_TIMEx_MasterConfigSynchronization+0x54>)
  htim->State = HAL_TIM_STATE_BUSY;
 8004a42:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8004a46:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 8004a48:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 8004a4a:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8004a4c:	d003      	beq.n	8004a56 <HAL_TIMEx_MasterConfigSynchronization+0x26>
 8004a4e:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004a52:	42aa      	cmp	r2, r5
 8004a54:	d103      	bne.n	8004a5e <HAL_TIMEx_MasterConfigSynchronization+0x2e>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8004a56:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8004a58:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8004a5c:	432b      	orrs	r3, r5
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8004a5e:	680d      	ldr	r5, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8004a60:	6889      	ldr	r1, [r1, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 8004a62:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8004a66:	432b      	orrs	r3, r5
  tmpsmcr &= ~TIM_SMCR_MSM;
 8004a68:	f024 0480 	bic.w	r4, r4, #128	; 0x80

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8004a6c:	6053      	str	r3, [r2, #4]
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8004a6e:	4321      	orrs	r1, r4

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8004a70:	2301      	movs	r3, #1
  htim->Instance->SMCR = tmpsmcr;
 8004a72:	6091      	str	r1, [r2, #8]
  htim->State = HAL_TIM_STATE_READY;
 8004a74:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8004a78:	2300      	movs	r3, #0
 8004a7a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  __HAL_LOCK(htim);
 8004a7e:	4618      	mov	r0, r3

  return HAL_OK;
}
 8004a80:	bd30      	pop	{r4, r5, pc}
 8004a82:	bf00      	nop
 8004a84:	40012c00 	.word	0x40012c00

08004a88 <HAL_TIMEx_CommutationCallback>:
 8004a88:	4770      	bx	lr

08004a8a <HAL_TIMEx_BreakCallback>:
 8004a8a:	4770      	bx	lr

08004a8c <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8004a8c:	4770      	bx	lr
	...

08004a90 <UART_SetConfig>:
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;
  
  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if(UART_INSTANCE_LOWPOWER(huart))
 8004a90:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004a92:	69c1      	ldr	r1, [r0, #28]
 8004a94:	6882      	ldr	r2, [r0, #8]
{
 8004a96:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 8004a9a:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004a9c:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004a9e:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004aa0:	4302      	orrs	r2, r0
 8004aa2:	6960      	ldr	r0, [r4, #20]
 8004aa4:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004aa6:	48bd      	ldr	r0, [pc, #756]	; (8004d9c <UART_SetConfig+0x30c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004aa8:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004aaa:	4028      	ands	r0, r5
 8004aac:	4302      	orrs	r2, r0
 8004aae:	601a      	str	r2, [r3, #0]
  
  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8004ab0:	685a      	ldr	r2, [r3, #4]
 8004ab2:	68e0      	ldr	r0, [r4, #12]
 8004ab4:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8004ab8:	4302      	orrs	r2, r0
 8004aba:	605a      	str	r2, [r3, #4]
  *   to huart->Init.OneBitSampling (not applicable to LPUART)
  * - set TXFTCFG bit according to huart->Init.TxFifoThreshold value
  * - set RXFTCFG bit according to huart->Init.RxFifoThreshold value */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8004abc:	4ab8      	ldr	r2, [pc, #736]	; (8004da0 <UART_SetConfig+0x310>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8004abe:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8004ac0:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 8004ac2:	bf1c      	itt	ne
 8004ac4:	6a22      	ldrne	r2, [r4, #32]
 8004ac6:	4310      	orrne	r0, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8004ac8:	689a      	ldr	r2, [r3, #8]
 8004aca:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 8004ace:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8004ad2:	4302      	orrs	r2, r0
 8004ad4:	609a      	str	r2, [r3, #8]
  
#if defined(USART_PRESC_PRESCALER)
  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8004ad6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8004ad8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004ada:	f020 000f 	bic.w	r0, r0, #15
 8004ade:	4310      	orrs	r0, r2
 8004ae0:	62d8      	str	r0, [r3, #44]	; 0x2c
#endif
  
  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004ae2:	48b0      	ldr	r0, [pc, #704]	; (8004da4 <UART_SetConfig+0x314>)
 8004ae4:	4283      	cmp	r3, r0
 8004ae6:	d117      	bne.n	8004b18 <UART_SetConfig+0x88>
 8004ae8:	4baf      	ldr	r3, [pc, #700]	; (8004da8 <UART_SetConfig+0x318>)
 8004aea:	48b0      	ldr	r0, [pc, #704]	; (8004dac <UART_SetConfig+0x31c>)
 8004aec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004af0:	f003 0303 	and.w	r3, r3, #3
 8004af4:	5cc3      	ldrb	r3, [r0, r3]
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004af6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004afa:	f040 81a7 	bne.w	8004e4c <UART_SetConfig+0x3bc>
  {
    switch (clocksource)
 8004afe:	2b08      	cmp	r3, #8
 8004b00:	d849      	bhi.n	8004b96 <UART_SetConfig+0x106>
 8004b02:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004b06:	017f      	.short	0x017f
 8004b08:	016800d0 	.word	0x016800d0
 8004b0c:	01780048 	.word	0x01780048
 8004b10:	00480048 	.word	0x00480048
 8004b14:	002d0048 	.word	0x002d0048
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004b18:	48a5      	ldr	r0, [pc, #660]	; (8004db0 <UART_SetConfig+0x320>)
 8004b1a:	4283      	cmp	r3, r0
 8004b1c:	d106      	bne.n	8004b2c <UART_SetConfig+0x9c>
 8004b1e:	4ba2      	ldr	r3, [pc, #648]	; (8004da8 <UART_SetConfig+0x318>)
 8004b20:	48a4      	ldr	r0, [pc, #656]	; (8004db4 <UART_SetConfig+0x324>)
 8004b22:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004b26:	f003 030c 	and.w	r3, r3, #12
 8004b2a:	e7e3      	b.n	8004af4 <UART_SetConfig+0x64>
 8004b2c:	48a2      	ldr	r0, [pc, #648]	; (8004db8 <UART_SetConfig+0x328>)
 8004b2e:	4283      	cmp	r3, r0
 8004b30:	d11d      	bne.n	8004b6e <UART_SetConfig+0xde>
 8004b32:	4b9d      	ldr	r3, [pc, #628]	; (8004da8 <UART_SetConfig+0x318>)
 8004b34:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004b38:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8004b3c:	2b10      	cmp	r3, #16
 8004b3e:	f000 8157 	beq.w	8004df0 <UART_SetConfig+0x360>
 8004b42:	d804      	bhi.n	8004b4e <UART_SetConfig+0xbe>
 8004b44:	2b00      	cmp	r3, #0
 8004b46:	f000 8159 	beq.w	8004dfc <UART_SetConfig+0x36c>
 8004b4a:	2310      	movs	r3, #16
 8004b4c:	e7d3      	b.n	8004af6 <UART_SetConfig+0x66>
 8004b4e:	2b20      	cmp	r3, #32
 8004b50:	f000 813e 	beq.w	8004dd0 <UART_SetConfig+0x340>
 8004b54:	2b30      	cmp	r3, #48	; 0x30
 8004b56:	d1f8      	bne.n	8004b4a <UART_SetConfig+0xba>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004b58:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004b5c:	f040 80d0 	bne.w	8004d00 <UART_SetConfig+0x270>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
#endif
      break;
    case UART_CLOCKSOURCE_LSE:
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004b60:	4b96      	ldr	r3, [pc, #600]	; (8004dbc <UART_SetConfig+0x32c>)
 8004b62:	6861      	ldr	r1, [r4, #4]
 8004b64:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004b68:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004b6c:	e138      	b.n	8004de0 <UART_SetConfig+0x350>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004b6e:	4894      	ldr	r0, [pc, #592]	; (8004dc0 <UART_SetConfig+0x330>)
 8004b70:	4283      	cmp	r3, r0
 8004b72:	d12d      	bne.n	8004bd0 <UART_SetConfig+0x140>
 8004b74:	f500 30e2 	add.w	r0, r0, #115712	; 0x1c400
 8004b78:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004b7c:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
 8004b80:	2840      	cmp	r0, #64	; 0x40
 8004b82:	f000 80fd 	beq.w	8004d80 <UART_SetConfig+0x2f0>
 8004b86:	d812      	bhi.n	8004bae <UART_SetConfig+0x11e>
 8004b88:	2800      	cmp	r0, #0
 8004b8a:	f000 80c0 	beq.w	8004d0e <UART_SetConfig+0x27e>
  if(UART_INSTANCE_LOWPOWER(huart))
 8004b8e:	4884      	ldr	r0, [pc, #528]	; (8004da0 <UART_SetConfig+0x310>)
 8004b90:	4283      	cmp	r3, r0
 8004b92:	f040 8156 	bne.w	8004e42 <UART_SetConfig+0x3b2>
      ret = HAL_ERROR;
 8004b96:	2301      	movs	r3, #1
    }
  }
  
#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 8004b98:	2201      	movs	r2, #1
 8004b9a:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
  huart->NbRxDataToProcess = 1;
 8004b9e:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
#endif
    
  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8004ba2:	2200      	movs	r2, #0
 8004ba4:	6722      	str	r2, [r4, #112]	; 0x70
  huart->TxISR = NULL;
 8004ba6:	6762      	str	r2, [r4, #116]	; 0x74
  
  return ret;
}
 8004ba8:	4618      	mov	r0, r3
 8004baa:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004bae:	2880      	cmp	r0, #128	; 0x80
 8004bb0:	f000 80bb 	beq.w	8004d2a <UART_SetConfig+0x29a>
 8004bb4:	28c0      	cmp	r0, #192	; 0xc0
 8004bb6:	d1ea      	bne.n	8004b8e <UART_SetConfig+0xfe>
  if(UART_INSTANCE_LOWPOWER(huart))
 8004bb8:	4879      	ldr	r0, [pc, #484]	; (8004da0 <UART_SetConfig+0x310>)
 8004bba:	4283      	cmp	r3, r0
 8004bbc:	d1cc      	bne.n	8004b58 <UART_SetConfig+0xc8>
      lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE/UARTPrescTable[huart->Init.ClockPrescaler]);
 8004bbe:	4b7f      	ldr	r3, [pc, #508]	; (8004dbc <UART_SetConfig+0x32c>)
 8004bc0:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
 8004bc4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
      break;
 8004bc8:	2208      	movs	r2, #8
      lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE/UARTPrescTable[huart->Init.ClockPrescaler]);
 8004bca:	fbb3 f3f0 	udiv	r3, r3, r0
      break;
 8004bce:	e0aa      	b.n	8004d26 <UART_SetConfig+0x296>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004bd0:	487c      	ldr	r0, [pc, #496]	; (8004dc4 <UART_SetConfig+0x334>)
 8004bd2:	4283      	cmp	r3, r0
 8004bd4:	d111      	bne.n	8004bfa <UART_SetConfig+0x16a>
 8004bd6:	f500 30e0 	add.w	r0, r0, #114688	; 0x1c000
 8004bda:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004bde:	f400 7040 	and.w	r0, r0, #768	; 0x300
 8004be2:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8004be6:	f000 80cb 	beq.w	8004d80 <UART_SetConfig+0x2f0>
 8004bea:	d9cd      	bls.n	8004b88 <UART_SetConfig+0xf8>
 8004bec:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8004bf0:	f000 809b 	beq.w	8004d2a <UART_SetConfig+0x29a>
 8004bf4:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
 8004bf8:	e7dd      	b.n	8004bb6 <UART_SetConfig+0x126>
 8004bfa:	4869      	ldr	r0, [pc, #420]	; (8004da0 <UART_SetConfig+0x310>)
 8004bfc:	4283      	cmp	r3, r0
 8004bfe:	d1a4      	bne.n	8004b4a <UART_SetConfig+0xba>
 8004c00:	f500 30c8 	add.w	r0, r0, #102400	; 0x19000
 8004c04:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004c08:	f400 6040 	and.w	r0, r0, #3072	; 0xc00
 8004c0c:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8004c10:	f000 80b6 	beq.w	8004d80 <UART_SetConfig+0x2f0>
 8004c14:	d9b8      	bls.n	8004b88 <UART_SetConfig+0xf8>
 8004c16:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8004c1a:	f000 8086 	beq.w	8004d2a <UART_SetConfig+0x29a>
 8004c1e:	f5b0 6f40 	cmp.w	r0, #3072	; 0xc00
 8004c22:	e7c8      	b.n	8004bb6 <UART_SetConfig+0x126>
          usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c24:	f7fe fee0 	bl	80039e8 <HAL_RCC_GetPCLK1Freq>
          usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c28:	4b64      	ldr	r3, [pc, #400]	; (8004dbc <UART_SetConfig+0x32c>)
 8004c2a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004c2c:	6865      	ldr	r5, [r4, #4]
 8004c2e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8004c32:	2300      	movs	r3, #0
 8004c34:	e005      	b.n	8004c42 <UART_SetConfig+0x1b2>
          usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c36:	4b61      	ldr	r3, [pc, #388]	; (8004dbc <UART_SetConfig+0x32c>)
 8004c38:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004c3a:	4863      	ldr	r0, [pc, #396]	; (8004dc8 <UART_SetConfig+0x338>)
 8004c3c:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8004c40:	2300      	movs	r3, #0
          usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c42:	2100      	movs	r1, #0
 8004c44:	f7fb fff6 	bl	8000c34 <__aeabi_uldivmod>
 8004c48:	020f      	lsls	r7, r1, #8
 8004c4a:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 8004c4e:	0206      	lsls	r6, r0, #8
 8004c50:	0868      	lsrs	r0, r5, #1
 8004c52:	eb16 0b00 	adds.w	fp, r6, r0
 8004c56:	f147 0c00 	adc.w	ip, r7, #0
 8004c5a:	462a      	mov	r2, r5
 8004c5c:	2300      	movs	r3, #0
 8004c5e:	4658      	mov	r0, fp
 8004c60:	4661      	mov	r1, ip
          usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c62:	f7fb ffe7 	bl	8000c34 <__aeabi_uldivmod>
          break;
 8004c66:	2300      	movs	r3, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8004c68:	4a58      	ldr	r2, [pc, #352]	; (8004dcc <UART_SetConfig+0x33c>)
 8004c6a:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 8004c6e:	4291      	cmp	r1, r2
 8004c70:	d891      	bhi.n	8004b96 <UART_SetConfig+0x106>
          huart->Instance->BRR = usartdiv;
 8004c72:	6822      	ldr	r2, [r4, #0]
 8004c74:	60d0      	str	r0, [r2, #12]
 8004c76:	e78f      	b.n	8004b98 <UART_SetConfig+0x108>
          usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c78:	f7fe fb16 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8004c7c:	e7d4      	b.n	8004c28 <UART_SetConfig+0x198>
          usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004c7e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004c80:	4b4e      	ldr	r3, [pc, #312]	; (8004dbc <UART_SetConfig+0x32c>)
 8004c82:	0868      	lsrs	r0, r5, #1
 8004c84:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004c88:	2100      	movs	r1, #0
 8004c8a:	462a      	mov	r2, r5
 8004c8c:	f44f 7580 	mov.w	r5, #256	; 0x100
 8004c90:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 8004c94:	fbb6 f6f3 	udiv	r6, r6, r3
 8004c98:	2300      	movs	r3, #0
 8004c9a:	fbe6 0105 	umlal	r0, r1, r6, r5
 8004c9e:	e7e0      	b.n	8004c62 <UART_SetConfig+0x1d2>
          ret = HAL_ERROR;
 8004ca0:	2301      	movs	r3, #1
  uint32_t usartdiv                   = 0x00000000U;
 8004ca2:	2000      	movs	r0, #0
 8004ca4:	e7e0      	b.n	8004c68 <UART_SetConfig+0x1d8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004ca6:	f7fe feb1 	bl	8003a0c <HAL_RCC_GetPCLK2Freq>
 8004caa:	e0ad      	b.n	8004e08 <UART_SetConfig+0x378>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004cac:	f7fe fe9c 	bl	80039e8 <HAL_RCC_GetPCLK1Freq>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004cb0:	6862      	ldr	r2, [r4, #4]
 8004cb2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004cb4:	4b41      	ldr	r3, [pc, #260]	; (8004dbc <UART_SetConfig+0x32c>)
 8004cb6:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8004cba:	fbb0 f0f3 	udiv	r0, r0, r3
 8004cbe:	eb00 0052 	add.w	r0, r0, r2, lsr #1
 8004cc2:	fbb0 f0f2 	udiv	r0, r0, r2
 8004cc6:	b280      	uxth	r0, r0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004cc8:	f1a0 0210 	sub.w	r2, r0, #16
 8004ccc:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8004cd0:	429a      	cmp	r2, r3
 8004cd2:	f63f af60 	bhi.w	8004b96 <UART_SetConfig+0x106>
      huart->Instance->BRR = usartdiv;
 8004cd6:	6823      	ldr	r3, [r4, #0]
 8004cd8:	60d8      	str	r0, [r3, #12]
 8004cda:	e0b0      	b.n	8004e3e <UART_SetConfig+0x3ae>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004cdc:	f7fe fe96 	bl	8003a0c <HAL_RCC_GetPCLK2Freq>
 8004ce0:	e7e6      	b.n	8004cb0 <UART_SetConfig+0x220>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004ce2:	4936      	ldr	r1, [pc, #216]	; (8004dbc <UART_SetConfig+0x32c>)
 8004ce4:	6863      	ldr	r3, [r4, #4]
 8004ce6:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 8004cea:	4837      	ldr	r0, [pc, #220]	; (8004dc8 <UART_SetConfig+0x338>)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004cec:	fbb0 f0f2 	udiv	r0, r0, r2
 8004cf0:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8004cf4:	fbb0 f0f3 	udiv	r0, r0, r3
 8004cf8:	e7e5      	b.n	8004cc6 <UART_SetConfig+0x236>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004cfa:	f7fe fad5 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8004cfe:	e7d7      	b.n	8004cb0 <UART_SetConfig+0x220>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004d00:	492e      	ldr	r1, [pc, #184]	; (8004dbc <UART_SetConfig+0x32c>)
 8004d02:	6863      	ldr	r3, [r4, #4]
 8004d04:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 8004d08:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004d0c:	e7ee      	b.n	8004cec <UART_SetConfig+0x25c>
  if(UART_INSTANCE_LOWPOWER(huart))
 8004d0e:	4a24      	ldr	r2, [pc, #144]	; (8004da0 <UART_SetConfig+0x310>)
 8004d10:	4293      	cmp	r3, r2
 8004d12:	d173      	bne.n	8004dfc <UART_SetConfig+0x36c>
      lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq()/UARTPrescTable[huart->Init.ClockPrescaler]);
 8004d14:	f7fe fe68 	bl	80039e8 <HAL_RCC_GetPCLK1Freq>
 8004d18:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004d1a:	4b28      	ldr	r3, [pc, #160]	; (8004dbc <UART_SetConfig+0x32c>)
 8004d1c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004d20:	fbb0 f3f3 	udiv	r3, r0, r3
      break;
 8004d24:	2200      	movs	r2, #0
    if (lpuart_ker_ck_pres != 0U)
 8004d26:	b953      	cbnz	r3, 8004d3e <UART_SetConfig+0x2ae>
 8004d28:	e736      	b.n	8004b98 <UART_SetConfig+0x108>
  if(UART_INSTANCE_LOWPOWER(huart))
 8004d2a:	481d      	ldr	r0, [pc, #116]	; (8004da0 <UART_SetConfig+0x310>)
 8004d2c:	4283      	cmp	r3, r0
 8004d2e:	d14f      	bne.n	8004dd0 <UART_SetConfig+0x340>
      lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE/UARTPrescTable[huart->Init.ClockPrescaler]);
 8004d30:	4b22      	ldr	r3, [pc, #136]	; (8004dbc <UART_SetConfig+0x32c>)
 8004d32:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
 8004d36:	4b24      	ldr	r3, [pc, #144]	; (8004dc8 <UART_SetConfig+0x338>)
 8004d38:	fbb3 f3f0 	udiv	r3, r3, r0
 8004d3c:	2202      	movs	r2, #2
      if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
 8004d3e:	6865      	ldr	r5, [r4, #4]
 8004d40:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8004d44:	4299      	cmp	r1, r3
 8004d46:	f63f af26 	bhi.w	8004b96 <UART_SetConfig+0x106>
 8004d4a:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8004d4e:	f63f af22 	bhi.w	8004b96 <UART_SetConfig+0x106>
        switch (clocksource)
 8004d52:	2a08      	cmp	r2, #8
 8004d54:	d8a4      	bhi.n	8004ca0 <UART_SetConfig+0x210>
 8004d56:	a301      	add	r3, pc, #4	; (adr r3, 8004d5c <UART_SetConfig+0x2cc>)
 8004d58:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 8004d5c:	08004c25 	.word	0x08004c25
 8004d60:	08004ca1 	.word	0x08004ca1
 8004d64:	08004c37 	.word	0x08004c37
 8004d68:	08004ca1 	.word	0x08004ca1
 8004d6c:	08004c79 	.word	0x08004c79
 8004d70:	08004ca1 	.word	0x08004ca1
 8004d74:	08004ca1 	.word	0x08004ca1
 8004d78:	08004ca1 	.word	0x08004ca1
 8004d7c:	08004c7f 	.word	0x08004c7f
  if(UART_INSTANCE_LOWPOWER(huart))
 8004d80:	4a07      	ldr	r2, [pc, #28]	; (8004da0 <UART_SetConfig+0x310>)
 8004d82:	4293      	cmp	r3, r2
 8004d84:	d134      	bne.n	8004df0 <UART_SetConfig+0x360>
      lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq()/UARTPrescTable[huart->Init.ClockPrescaler]);
 8004d86:	f7fe fa8f 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8004d8a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004d8c:	4b0b      	ldr	r3, [pc, #44]	; (8004dbc <UART_SetConfig+0x32c>)
 8004d8e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004d92:	fbb0 f3f3 	udiv	r3, r0, r3
      break;
 8004d96:	2204      	movs	r2, #4
 8004d98:	e7c5      	b.n	8004d26 <UART_SetConfig+0x296>
 8004d9a:	bf00      	nop
 8004d9c:	cfff69f3 	.word	0xcfff69f3
 8004da0:	40008000 	.word	0x40008000
 8004da4:	40013800 	.word	0x40013800
 8004da8:	40021000 	.word	0x40021000
 8004dac:	08012bc8 	.word	0x08012bc8
 8004db0:	40004400 	.word	0x40004400
 8004db4:	08012bcc 	.word	0x08012bcc
 8004db8:	40004800 	.word	0x40004800
 8004dbc:	08012bda 	.word	0x08012bda
 8004dc0:	40004c00 	.word	0x40004c00
 8004dc4:	40005000 	.word	0x40005000
 8004dc8:	00f42400 	.word	0x00f42400
 8004dcc:	000ffcff 	.word	0x000ffcff
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004dd0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004dd4:	d185      	bne.n	8004ce2 <UART_SetConfig+0x252>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004dd6:	4b29      	ldr	r3, [pc, #164]	; (8004e7c <UART_SetConfig+0x3ec>)
 8004dd8:	6861      	ldr	r1, [r4, #4]
 8004dda:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004dde:	4828      	ldr	r0, [pc, #160]	; (8004e80 <UART_SetConfig+0x3f0>)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004de0:	fbb0 f3f3 	udiv	r3, r0, r3
 8004de4:	0848      	lsrs	r0, r1, #1
 8004de6:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8004dea:	fbb0 f0f1 	udiv	r0, r0, r1
 8004dee:	e017      	b.n	8004e20 <UART_SetConfig+0x390>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004df0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004df4:	d181      	bne.n	8004cfa <UART_SetConfig+0x26a>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004df6:	f7fe fa57 	bl	80032a8 <HAL_RCC_GetSysClockFreq>
 8004dfa:	e005      	b.n	8004e08 <UART_SetConfig+0x378>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004dfc:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004e00:	f47f af54 	bne.w	8004cac <UART_SetConfig+0x21c>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004e04:	f7fe fdf0 	bl	80039e8 <HAL_RCC_GetPCLK1Freq>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8004e08:	6862      	ldr	r2, [r4, #4]
 8004e0a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004e0c:	4b1b      	ldr	r3, [pc, #108]	; (8004e7c <UART_SetConfig+0x3ec>)
 8004e0e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8004e12:	fbb0 f3f3 	udiv	r3, r0, r3
 8004e16:	0850      	lsrs	r0, r2, #1
 8004e18:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8004e1c:	fbb0 f0f2 	udiv	r0, r0, r2
 8004e20:	b280      	uxth	r0, r0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004e22:	f1a0 0210 	sub.w	r2, r0, #16
 8004e26:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8004e2a:	429a      	cmp	r2, r3
 8004e2c:	f63f aeb3 	bhi.w	8004b96 <UART_SetConfig+0x106>
      brrtemp = usartdiv & 0xFFF0U;
 8004e30:	f020 030f 	bic.w	r3, r0, #15
      huart->Instance->BRR = brrtemp;
 8004e34:	6822      	ldr	r2, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004e36:	f3c0 0042 	ubfx	r0, r0, #1, #3
      huart->Instance->BRR = brrtemp;
 8004e3a:	4318      	orrs	r0, r3
 8004e3c:	60d0      	str	r0, [r2, #12]
 8004e3e:	2300      	movs	r3, #0
 8004e40:	e6aa      	b.n	8004b98 <UART_SetConfig+0x108>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004e42:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004e46:	f43f aea6 	beq.w	8004b96 <UART_SetConfig+0x106>
 8004e4a:	2310      	movs	r3, #16
    switch (clocksource)
 8004e4c:	2b08      	cmp	r3, #8
 8004e4e:	f63f aea2 	bhi.w	8004b96 <UART_SetConfig+0x106>
 8004e52:	a101      	add	r1, pc, #4	; (adr r1, 8004e58 <UART_SetConfig+0x3c8>)
 8004e54:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8004e58:	08004cad 	.word	0x08004cad
 8004e5c:	08004cdd 	.word	0x08004cdd
 8004e60:	08004ce3 	.word	0x08004ce3
 8004e64:	08004b97 	.word	0x08004b97
 8004e68:	08004cfb 	.word	0x08004cfb
 8004e6c:	08004b97 	.word	0x08004b97
 8004e70:	08004b97 	.word	0x08004b97
 8004e74:	08004b97 	.word	0x08004b97
 8004e78:	08004d01 	.word	0x08004d01
 8004e7c:	08012bda 	.word	0x08012bda
 8004e80:	00f42400 	.word	0x00f42400

08004e84 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
  
  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004e84:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004e86:	07da      	lsls	r2, r3, #31
{
 8004e88:	b510      	push	{r4, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004e8a:	d506      	bpl.n	8004e9a <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8004e8c:	6801      	ldr	r1, [r0, #0]
 8004e8e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8004e90:	684a      	ldr	r2, [r1, #4]
 8004e92:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8004e96:	4322      	orrs	r2, r4
 8004e98:	604a      	str	r2, [r1, #4]
  }
  
  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8004e9a:	079c      	lsls	r4, r3, #30
 8004e9c:	d506      	bpl.n	8004eac <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8004e9e:	6801      	ldr	r1, [r0, #0]
 8004ea0:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004ea2:	684a      	ldr	r2, [r1, #4]
 8004ea4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004ea8:	4322      	orrs	r2, r4
 8004eaa:	604a      	str	r2, [r1, #4]
  }
  
  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8004eac:	0759      	lsls	r1, r3, #29
 8004eae:	d506      	bpl.n	8004ebe <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8004eb0:	6801      	ldr	r1, [r0, #0]
 8004eb2:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8004eb4:	684a      	ldr	r2, [r1, #4]
 8004eb6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004eba:	4322      	orrs	r2, r4
 8004ebc:	604a      	str	r2, [r1, #4]
  }
  
  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8004ebe:	071a      	lsls	r2, r3, #28
 8004ec0:	d506      	bpl.n	8004ed0 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8004ec2:	6801      	ldr	r1, [r0, #0]
 8004ec4:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8004ec6:	684a      	ldr	r2, [r1, #4]
 8004ec8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004ecc:	4322      	orrs	r2, r4
 8004ece:	604a      	str	r2, [r1, #4]
  }
  
  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8004ed0:	06dc      	lsls	r4, r3, #27
 8004ed2:	d506      	bpl.n	8004ee2 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8004ed4:	6801      	ldr	r1, [r0, #0]
 8004ed6:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8004ed8:	688a      	ldr	r2, [r1, #8]
 8004eda:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8004ede:	4322      	orrs	r2, r4
 8004ee0:	608a      	str	r2, [r1, #8]
  }
  
  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8004ee2:	0699      	lsls	r1, r3, #26
 8004ee4:	d506      	bpl.n	8004ef4 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8004ee6:	6801      	ldr	r1, [r0, #0]
 8004ee8:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8004eea:	688a      	ldr	r2, [r1, #8]
 8004eec:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8004ef0:	4322      	orrs	r2, r4
 8004ef2:	608a      	str	r2, [r1, #8]
  }
  
  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8004ef4:	065a      	lsls	r2, r3, #25
 8004ef6:	d50f      	bpl.n	8004f18 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8004ef8:	6801      	ldr	r1, [r0, #0]
 8004efa:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8004efc:	684a      	ldr	r2, [r1, #4]
 8004efe:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8004f02:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8004f04:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8004f08:	604a      	str	r2, [r1, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8004f0a:	d105      	bne.n	8004f18 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8004f0c:	684a      	ldr	r2, [r1, #4]
 8004f0e:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8004f10:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8004f14:	4322      	orrs	r2, r4
 8004f16:	604a      	str	r2, [r1, #4]
    }
  }
  
  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8004f18:	061b      	lsls	r3, r3, #24
 8004f1a:	d506      	bpl.n	8004f2a <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8004f1c:	6802      	ldr	r2, [r0, #0]
 8004f1e:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8004f20:	6853      	ldr	r3, [r2, #4]
 8004f22:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8004f26:	430b      	orrs	r3, r1
 8004f28:	6053      	str	r3, [r2, #4]
 8004f2a:	bd10      	pop	{r4, pc}

08004f2c <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8004f2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f30:	9d06      	ldr	r5, [sp, #24]
 8004f32:	4604      	mov	r4, r0
 8004f34:	460f      	mov	r7, r1
 8004f36:	4616      	mov	r6, r2
 8004f38:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004f3a:	6821      	ldr	r1, [r4, #0]
 8004f3c:	69ca      	ldr	r2, [r1, #28]
 8004f3e:	ea37 0302 	bics.w	r3, r7, r2
 8004f42:	bf0c      	ite	eq
 8004f44:	2201      	moveq	r2, #1
 8004f46:	2200      	movne	r2, #0
 8004f48:	42b2      	cmp	r2, r6
 8004f4a:	d002      	beq.n	8004f52 <UART_WaitOnFlagUntilTimeout+0x26>
        
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8004f4c:	2000      	movs	r0, #0
}
 8004f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 8004f52:	1c6b      	adds	r3, r5, #1
 8004f54:	d0f2      	beq.n	8004f3c <UART_WaitOnFlagUntilTimeout+0x10>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8004f56:	b99d      	cbnz	r5, 8004f80 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 8004f58:	6823      	ldr	r3, [r4, #0]
 8004f5a:	681a      	ldr	r2, [r3, #0]
 8004f5c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8004f60:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004f62:	689a      	ldr	r2, [r3, #8]
 8004f64:	f022 0201 	bic.w	r2, r2, #1
 8004f68:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8004f6a:	2320      	movs	r3, #32
 8004f6c:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
        huart->RxState = HAL_UART_STATE_READY;
 8004f70:	f884 3082 	strb.w	r3, [r4, #130]	; 0x82
        __HAL_UNLOCK(huart);
 8004f74:	2300      	movs	r3, #0
 8004f76:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
 8004f7a:	2003      	movs	r0, #3
 8004f7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8004f80:	f7fc f810 	bl	8000fa4 <HAL_GetTick>
 8004f84:	eba0 0008 	sub.w	r0, r0, r8
 8004f88:	4285      	cmp	r5, r0
 8004f8a:	d2d6      	bcs.n	8004f3a <UART_WaitOnFlagUntilTimeout+0xe>
 8004f8c:	e7e4      	b.n	8004f58 <UART_WaitOnFlagUntilTimeout+0x2c>

08004f8e <UART_CheckIdleState>:
{
 8004f8e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8004f90:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004f92:	2600      	movs	r6, #0
 8004f94:	f8c0 6084 	str.w	r6, [r0, #132]	; 0x84
  tickstart = HAL_GetTick();
 8004f98:	f7fc f804 	bl	8000fa4 <HAL_GetTick>
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004f9c:	6823      	ldr	r3, [r4, #0]
 8004f9e:	681b      	ldr	r3, [r3, #0]
 8004fa0:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8004fa2:	4605      	mov	r5, r0
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004fa4:	d417      	bmi.n	8004fd6 <UART_CheckIdleState+0x48>
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8004fa6:	6823      	ldr	r3, [r4, #0]
 8004fa8:	681b      	ldr	r3, [r3, #0]
 8004faa:	075b      	lsls	r3, r3, #29
 8004fac:	d50a      	bpl.n	8004fc4 <UART_CheckIdleState+0x36>
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004fae:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8004fb2:	9300      	str	r3, [sp, #0]
 8004fb4:	2200      	movs	r2, #0
 8004fb6:	462b      	mov	r3, r5
 8004fb8:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8004fbc:	4620      	mov	r0, r4
 8004fbe:	f7ff ffb5 	bl	8004f2c <UART_WaitOnFlagUntilTimeout>
 8004fc2:	b9a0      	cbnz	r0, 8004fee <UART_CheckIdleState+0x60>
  huart->gState= HAL_UART_STATE_READY;
 8004fc4:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8004fc6:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8004fc8:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
  __HAL_UNLOCK(huart);
 8004fcc:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState= HAL_UART_STATE_READY;
 8004fd0:	f884 3082 	strb.w	r3, [r4, #130]	; 0x82
  return HAL_OK;
 8004fd4:	e00c      	b.n	8004ff0 <UART_CheckIdleState+0x62>
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004fd6:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8004fda:	9300      	str	r3, [sp, #0]
 8004fdc:	4632      	mov	r2, r6
 8004fde:	4603      	mov	r3, r0
 8004fe0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8004fe4:	4620      	mov	r0, r4
 8004fe6:	f7ff ffa1 	bl	8004f2c <UART_WaitOnFlagUntilTimeout>
 8004fea:	2800      	cmp	r0, #0
 8004fec:	d0db      	beq.n	8004fa6 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 8004fee:	2003      	movs	r0, #3
}
 8004ff0:	b002      	add	sp, #8
 8004ff2:	bd70      	pop	{r4, r5, r6, pc}

08004ff4 <HAL_UART_Init>:
{
 8004ff4:	b510      	push	{r4, lr}
  if(huart == NULL)
 8004ff6:	4604      	mov	r4, r0
 8004ff8:	b360      	cbz	r0, 8005054 <HAL_UART_Init+0x60>
  if(huart->gState == HAL_UART_STATE_RESET)
 8004ffa:	f890 3081 	ldrb.w	r3, [r0, #129]	; 0x81
 8004ffe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005002:	b91b      	cbnz	r3, 800500c <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8005004:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8005008:	f00c fd88 	bl	8011b1c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 800500c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800500e:	2324      	movs	r3, #36	; 0x24
 8005010:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
  __HAL_UART_DISABLE(huart);
 8005014:	6813      	ldr	r3, [r2, #0]
 8005016:	f023 0301 	bic.w	r3, r3, #1
 800501a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800501c:	4620      	mov	r0, r4
 800501e:	f7ff fd37 	bl	8004a90 <UART_SetConfig>
 8005022:	2801      	cmp	r0, #1
 8005024:	d016      	beq.n	8005054 <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8005026:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005028:	b113      	cbz	r3, 8005030 <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
 800502a:	4620      	mov	r0, r4
 800502c:	f7ff ff2a 	bl	8004e84 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005030:	6823      	ldr	r3, [r4, #0]
 8005032:	685a      	ldr	r2, [r3, #4]
 8005034:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005038:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800503a:	689a      	ldr	r2, [r3, #8]
 800503c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005040:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8005042:	681a      	ldr	r2, [r3, #0]
 8005044:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8005048:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 800504a:	601a      	str	r2, [r3, #0]
}
 800504c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8005050:	f7ff bf9d 	b.w	8004f8e <UART_CheckIdleState>
}
 8005054:	2001      	movs	r0, #1
 8005056:	bd10      	pop	{r4, pc}

08005058 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 8005058:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t rx_fifo_depth;
  uint8_t tx_fifo_depth;
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  uint8_t numerator[] = {1, 1, 1, 3, 7, 1};
 800505a:	2203      	movs	r2, #3
 800505c:	f88d 2003 	strb.w	r2, [sp, #3]
 8005060:	2207      	movs	r2, #7
 8005062:	f88d 2004 	strb.w	r2, [sp, #4]
  uint8_t denominator[] = {8, 4, 2, 4, 8, 1};
 8005066:	2208      	movs	r2, #8
 8005068:	f88d 2008 	strb.w	r2, [sp, #8]
 800506c:	f88d 200c 	strb.w	r2, [sp, #12]
  
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8005070:	6e82      	ldr	r2, [r0, #104]	; 0x68
  uint8_t numerator[] = {1, 1, 1, 3, 7, 1};
 8005072:	2301      	movs	r3, #1
  uint8_t denominator[] = {8, 4, 2, 4, 8, 1};
 8005074:	2104      	movs	r1, #4
 8005076:	2402      	movs	r4, #2
  uint8_t numerator[] = {1, 1, 1, 3, 7, 1};
 8005078:	f88d 3000 	strb.w	r3, [sp]
 800507c:	f88d 3001 	strb.w	r3, [sp, #1]
 8005080:	f88d 3002 	strb.w	r3, [sp, #2]
 8005084:	f88d 3005 	strb.w	r3, [sp, #5]
  uint8_t denominator[] = {8, 4, 2, 4, 8, 1};
 8005088:	f88d 1009 	strb.w	r1, [sp, #9]
 800508c:	f88d 400a 	strb.w	r4, [sp, #10]
 8005090:	f88d 100b 	strb.w	r1, [sp, #11]
 8005094:	f88d 300d 	strb.w	r3, [sp, #13]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8005098:	b92a      	cbnz	r2, 80050a6 <UARTEx_SetNbDataToProcess+0x4e>
  {
    huart->NbTxDataToProcess = 1;
 800509a:	f8a0 3064 	strh.w	r3, [r0, #100]	; 0x64
    rx_fifo_depth = 8; /* RX Fifo size */
    tx_fifo_depth = 8; /* TX Fifo size */
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
    huart->NbTxDataToProcess = (uint8_t)(tx_fifo_depth * numerator[tx_fifo_threshold])/denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = (uint8_t)(rx_fifo_depth * numerator[rx_fifo_threshold])/denominator[rx_fifo_threshold];
 800509e:	f8a0 3062 	strh.w	r3, [r0, #98]	; 0x62
  }
}
 80050a2:	b004      	add	sp, #16
 80050a4:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80050a6:	6803      	ldr	r3, [r0, #0]
 80050a8:	689a      	ldr	r2, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80050aa:	6899      	ldr	r1, [r3, #8]
    huart->NbTxDataToProcess = (uint8_t)(tx_fifo_depth * numerator[tx_fifo_threshold])/denominator[tx_fifo_threshold];
 80050ac:	ab04      	add	r3, sp, #16
 80050ae:	eb03 7151 	add.w	r1, r3, r1, lsr #29
    huart->NbRxDataToProcess = (uint8_t)(rx_fifo_depth * numerator[rx_fifo_threshold])/denominator[rx_fifo_threshold];
 80050b2:	f3c2 6242 	ubfx	r2, r2, #25, #3
    huart->NbTxDataToProcess = (uint8_t)(tx_fifo_depth * numerator[tx_fifo_threshold])/denominator[tx_fifo_threshold];
 80050b6:	f811 3c10 	ldrb.w	r3, [r1, #-16]
 80050ba:	f811 1c08 	ldrb.w	r1, [r1, #-8]
 80050be:	00db      	lsls	r3, r3, #3
 80050c0:	b2db      	uxtb	r3, r3
 80050c2:	fbb3 f3f1 	udiv	r3, r3, r1
 80050c6:	f8a0 3064 	strh.w	r3, [r0, #100]	; 0x64
    huart->NbRxDataToProcess = (uint8_t)(rx_fifo_depth * numerator[rx_fifo_threshold])/denominator[rx_fifo_threshold];
 80050ca:	ab04      	add	r3, sp, #16
 80050cc:	441a      	add	r2, r3
 80050ce:	f812 3c10 	ldrb.w	r3, [r2, #-16]
 80050d2:	f812 2c08 	ldrb.w	r2, [r2, #-8]
 80050d6:	00db      	lsls	r3, r3, #3
 80050d8:	b2db      	uxtb	r3, r3
 80050da:	fbb3 f3f2 	udiv	r3, r3, r2
 80050de:	e7de      	b.n	800509e <UARTEx_SetNbDataToProcess+0x46>

080050e0 <HAL_UARTEx_SetTxFifoThreshold>:
{
 80050e0:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 80050e2:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 80050e6:	2b01      	cmp	r3, #1
{
 80050e8:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 80050ea:	d01b      	beq.n	8005124 <HAL_UARTEx_SetTxFifoThreshold+0x44>
 80050ec:	2301      	movs	r3, #1
 80050ee:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 80050f2:	2324      	movs	r3, #36	; 0x24
 80050f4:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80050f8:	6803      	ldr	r3, [r0, #0]
 80050fa:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 80050fc:	681a      	ldr	r2, [r3, #0]
 80050fe:	f022 0201 	bic.w	r2, r2, #1
 8005102:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8005104:	689a      	ldr	r2, [r3, #8]
 8005106:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 800510a:	4311      	orrs	r1, r2
 800510c:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 800510e:	f7ff ffa3 	bl	8005058 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8005112:	6803      	ldr	r3, [r0, #0]
 8005114:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8005116:	2320      	movs	r3, #32
 8005118:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
  __HAL_UNLOCK(huart);
 800511c:	2000      	movs	r0, #0
 800511e:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  return HAL_OK;
 8005122:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8005124:	2002      	movs	r0, #2
}
 8005126:	bd38      	pop	{r3, r4, r5, pc}

08005128 <HAL_UARTEx_SetRxFifoThreshold>:
{
 8005128:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 800512a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800512e:	2b01      	cmp	r3, #1
{
 8005130:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8005132:	d01b      	beq.n	800516c <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8005134:	2301      	movs	r3, #1
 8005136:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 800513a:	2324      	movs	r3, #36	; 0x24
 800513c:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8005140:	6803      	ldr	r3, [r0, #0]
 8005142:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8005144:	681a      	ldr	r2, [r3, #0]
 8005146:	f022 0201 	bic.w	r2, r2, #1
 800514a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800514c:	689a      	ldr	r2, [r3, #8]
 800514e:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 8005152:	4311      	orrs	r1, r2
 8005154:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8005156:	f7ff ff7f 	bl	8005058 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800515a:	6803      	ldr	r3, [r0, #0]
 800515c:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 800515e:	2320      	movs	r3, #32
 8005160:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
  __HAL_UNLOCK(huart);
 8005164:	2000      	movs	r0, #0
 8005166:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  return HAL_OK;
 800516a:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 800516c:	2002      	movs	r0, #2
}
 800516e:	bd38      	pop	{r3, r4, r5, pc}

08005170 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8005170:	4b0a      	ldr	r3, [pc, #40]	; (800519c <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8005172:	3b01      	subs	r3, #1
 8005174:	d101      	bne.n	800517a <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 8005176:	2003      	movs	r0, #3
 8005178:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800517a:	6902      	ldr	r2, [r0, #16]
 800517c:	2a00      	cmp	r2, #0
 800517e:	daf8      	bge.n	8005172 <USB_CoreReset+0x2>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8005180:	6903      	ldr	r3, [r0, #16]
 8005182:	4a06      	ldr	r2, [pc, #24]	; (800519c <USB_CoreReset+0x2c>)
 8005184:	f043 0301 	orr.w	r3, r3, #1
 8005188:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 800518a:	3a01      	subs	r2, #1
 800518c:	d0f3      	beq.n	8005176 <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800518e:	6903      	ldr	r3, [r0, #16]
 8005190:	f013 0301 	ands.w	r3, r3, #1
 8005194:	d1f9      	bne.n	800518a <USB_CoreReset+0x1a>

  return HAL_OK;
 8005196:	4618      	mov	r0, r3
}
 8005198:	4770      	bx	lr
 800519a:	bf00      	nop
 800519c:	00030d41 	.word	0x00030d41

080051a0 <USB_CoreInit>:
{
 80051a0:	b084      	sub	sp, #16
 80051a2:	b538      	push	{r3, r4, r5, lr}
 80051a4:	ad05      	add	r5, sp, #20
 80051a6:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80051aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80051ac:	2b01      	cmp	r3, #1
{
 80051ae:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80051b0:	d11b      	bne.n	80051ea <USB_CoreInit+0x4a>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80051b2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80051b4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80051b8:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80051ba:	68c3      	ldr	r3, [r0, #12]
 80051bc:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 80051c0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80051c4:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80051c6:	68c3      	ldr	r3, [r0, #12]
 80051c8:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80051cc:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80051ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80051d0:	2b01      	cmp	r3, #1
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80051d2:	bf02      	ittt	eq
 80051d4:	68c3      	ldreq	r3, [r0, #12]
 80051d6:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 80051da:	60c3      	streq	r3, [r0, #12]
    (void)USB_CoreReset(USBx);
 80051dc:	f7ff ffc8 	bl	8005170 <USB_CoreReset>
}
 80051e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80051e4:	2000      	movs	r0, #0
 80051e6:	b004      	add	sp, #16
 80051e8:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80051ea:	68c3      	ldr	r3, [r0, #12]
 80051ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80051f0:	60c3      	str	r3, [r0, #12]
    (void)USB_CoreReset(USBx);
 80051f2:	f7ff ffbd 	bl	8005170 <USB_CoreReset>
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 80051f6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80051fa:	63a3      	str	r3, [r4, #56]	; 0x38
 80051fc:	e7f0      	b.n	80051e0 <USB_CoreInit+0x40>

080051fe <USB_EnableGlobalInt>:
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80051fe:	6883      	ldr	r3, [r0, #8]
 8005200:	f043 0301 	orr.w	r3, r3, #1
 8005204:	6083      	str	r3, [r0, #8]
}
 8005206:	2000      	movs	r0, #0
 8005208:	4770      	bx	lr

0800520a <USB_DisableGlobalInt>:
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800520a:	6883      	ldr	r3, [r0, #8]
 800520c:	f023 0301 	bic.w	r3, r3, #1
 8005210:	6083      	str	r3, [r0, #8]
}
 8005212:	2000      	movs	r0, #0
 8005214:	4770      	bx	lr

08005216 <USB_SetCurrentMode>:
{
 8005216:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8005218:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800521a:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800521c:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8005220:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8005222:	d108      	bne.n	8005236 <USB_SetCurrentMode+0x20>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8005224:	68c3      	ldr	r3, [r0, #12]
 8005226:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800522a:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 800522c:	2032      	movs	r0, #50	; 0x32
 800522e:	f7fb febf 	bl	8000fb0 <HAL_Delay>
  return HAL_OK;
 8005232:	2000      	movs	r0, #0
 8005234:	bd08      	pop	{r3, pc}
  else if (mode == USB_DEVICE_MODE)
 8005236:	b919      	cbnz	r1, 8005240 <USB_SetCurrentMode+0x2a>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8005238:	68c3      	ldr	r3, [r0, #12]
 800523a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800523e:	e7f4      	b.n	800522a <USB_SetCurrentMode+0x14>
    return HAL_ERROR;
 8005240:	2001      	movs	r0, #1
}
 8005242:	bd08      	pop	{r3, pc}

08005244 <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8005244:	0189      	lsls	r1, r1, #6
 8005246:	f041 0120 	orr.w	r1, r1, #32
 800524a:	4a06      	ldr	r2, [pc, #24]	; (8005264 <USB_FlushTxFifo+0x20>)
 800524c:	6101      	str	r1, [r0, #16]
    if (++count > 200000U)
 800524e:	3a01      	subs	r2, #1
 8005250:	d005      	beq.n	800525e <USB_FlushTxFifo+0x1a>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8005252:	6903      	ldr	r3, [r0, #16]
 8005254:	f013 0320 	ands.w	r3, r3, #32
 8005258:	d1f9      	bne.n	800524e <USB_FlushTxFifo+0xa>
  return HAL_OK;
 800525a:	4618      	mov	r0, r3
 800525c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800525e:	2003      	movs	r0, #3
}
 8005260:	4770      	bx	lr
 8005262:	bf00      	nop
 8005264:	00030d41 	.word	0x00030d41

08005268 <USB_FlushRxFifo>:
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8005268:	2310      	movs	r3, #16
 800526a:	4a06      	ldr	r2, [pc, #24]	; (8005284 <USB_FlushRxFifo+0x1c>)
 800526c:	6103      	str	r3, [r0, #16]
    if (++count > 200000U)
 800526e:	3a01      	subs	r2, #1
 8005270:	d005      	beq.n	800527e <USB_FlushRxFifo+0x16>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8005272:	6903      	ldr	r3, [r0, #16]
 8005274:	f013 0310 	ands.w	r3, r3, #16
 8005278:	d1f9      	bne.n	800526e <USB_FlushRxFifo+0x6>
  return HAL_OK;
 800527a:	4618      	mov	r0, r3
 800527c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800527e:	2003      	movs	r0, #3
}
 8005280:	4770      	bx	lr
 8005282:	bf00      	nop
 8005284:	00030d41 	.word	0x00030d41

08005288 <USB_SetDevSpeed>:
  USBx_DEVICE->DCFG |= speed;
 8005288:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800528c:	4319      	orrs	r1, r3
 800528e:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 8005292:	2000      	movs	r0, #0
 8005294:	4770      	bx	lr
	...

08005298 <USB_DevInit>:
{
 8005298:	b084      	sub	sp, #16
 800529a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800529e:	4604      	mov	r4, r0
 80052a0:	a807      	add	r0, sp, #28
 80052a2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  for (i = 0U; i < 15U; i++)
 80052a6:	2300      	movs	r3, #0
 80052a8:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80052aa:	4688      	mov	r8, r1
    USBx->DIEPTXF[i] = 0U;
 80052ac:	4619      	mov	r1, r3
 80052ae:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80052b2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  for (i = 0U; i < 15U; i++)
 80052b6:	3301      	adds	r3, #1
 80052b8:	2b0f      	cmp	r3, #15
    USBx->DIEPTXF[i] = 0U;
 80052ba:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < 15U; i++)
 80052bc:	d1f7      	bne.n	80052ae <USB_DevInit+0x16>
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 80052be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80052c0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80052c4:	63a3      	str	r3, [r4, #56]	; 0x38
  if (cfg.vbus_sensing_enable == 0U)
 80052c6:	b95f      	cbnz	r7, 80052e0 <USB_DevInit+0x48>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 80052c8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80052ca:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80052ce:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 80052d0:	6823      	ldr	r3, [r4, #0]
 80052d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80052d6:	6023      	str	r3, [r4, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 80052d8:	6823      	ldr	r3, [r4, #0]
 80052da:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80052de:	6023      	str	r3, [r4, #0]
  USBx_PCGCCTL = 0U;
 80052e0:	2500      	movs	r5, #0
 80052e2:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80052e6:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 80052ea:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 80052ee:	2103      	movs	r1, #3
 80052f0:	4620      	mov	r0, r4
 80052f2:	f7ff ffc9 	bl	8005288 <USB_SetDevSpeed>
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80052f6:	f504 6600 	add.w	r6, r4, #2048	; 0x800
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
 80052fa:	2110      	movs	r1, #16
 80052fc:	4620      	mov	r0, r4
 80052fe:	f7ff ffa1 	bl	8005244 <USB_FlushTxFifo>
  (void)USB_FlushRxFifo(USBx);
 8005302:	4620      	mov	r0, r4
 8005304:	f7ff ffb0 	bl	8005268 <USB_FlushRxFifo>
  USBx_DEVICE->DIEPMSK = 0U;
 8005308:	6135      	str	r5, [r6, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800530a:	462b      	mov	r3, r5
  USBx_DEVICE->DOEPMSK = 0U;
 800530c:	6175      	str	r5, [r6, #20]
      USBx_INEP(i)->DIEPCTL = 0U;
 800530e:	4629      	mov	r1, r5
  USBx_DEVICE->DAINTMSK = 0U;
 8005310:	61f5      	str	r5, [r6, #28]
 8005312:	f504 6210 	add.w	r2, r4, #2304	; 0x900
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8005316:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 800531a:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800531e:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005322:	4543      	cmp	r3, r8
 8005324:	d12f      	bne.n	8005386 <USB_DevInit+0xee>
 8005326:	2100      	movs	r1, #0
 8005328:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800532c:	4608      	mov	r0, r1
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800532e:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8005332:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8005336:	f64f 3c7f 	movw	ip, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800533a:	428b      	cmp	r3, r1
 800533c:	d134      	bne.n	80053a8 <USB_DevInit+0x110>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800533e:	6933      	ldr	r3, [r6, #16]
 8005340:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005344:	6133      	str	r3, [r6, #16]
  USBx->GINTMSK = 0U;
 8005346:	2300      	movs	r3, #0
 8005348:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 800534a:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 800534e:	6163      	str	r3, [r4, #20]
  USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8005350:	69a3      	ldr	r3, [r4, #24]
 8005352:	f043 0310 	orr.w	r3, r3, #16
 8005356:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8005358:	69a2      	ldr	r2, [r4, #24]
 800535a:	4b1c      	ldr	r3, [pc, #112]	; (80053cc <USB_DevInit+0x134>)
 800535c:	4313      	orrs	r3, r2
 800535e:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 8005360:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005362:	b11b      	cbz	r3, 800536c <USB_DevInit+0xd4>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8005364:	69a3      	ldr	r3, [r4, #24]
 8005366:	f043 0308 	orr.w	r3, r3, #8
 800536a:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 800536c:	2f01      	cmp	r7, #1
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 800536e:	bf01      	itttt	eq
 8005370:	69a3      	ldreq	r3, [r4, #24]
 8005372:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 8005376:	f043 0304 	orreq.w	r3, r3, #4
 800537a:	61a3      	streq	r3, [r4, #24]
}
 800537c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005380:	2000      	movs	r0, #0
 8005382:	b004      	add	sp, #16
 8005384:	4770      	bx	lr
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005386:	f8d2 c000 	ldr.w	ip, [r2]
 800538a:	f1bc 0f00 	cmp.w	ip, #0
 800538e:	da09      	bge.n	80053a4 <USB_DevInit+0x10c>
      if (i == 0U)
 8005390:	b933      	cbnz	r3, 80053a0 <USB_DevInit+0x108>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8005392:	6015      	str	r5, [r2, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8005394:	6111      	str	r1, [r2, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005396:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8005398:	f8c2 e008 	str.w	lr, [r2, #8]
 800539c:	3220      	adds	r2, #32
 800539e:	e7c0      	b.n	8005322 <USB_DevInit+0x8a>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 80053a0:	6010      	str	r0, [r2, #0]
 80053a2:	e7f7      	b.n	8005394 <USB_DevInit+0xfc>
      USBx_INEP(i)->DIEPCTL = 0U;
 80053a4:	6011      	str	r1, [r2, #0]
 80053a6:	e7f5      	b.n	8005394 <USB_DevInit+0xfc>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80053a8:	f8d2 8000 	ldr.w	r8, [r2]
 80053ac:	f1b8 0f00 	cmp.w	r8, #0
 80053b0:	da0a      	bge.n	80053c8 <USB_DevInit+0x130>
      if (i == 0U)
 80053b2:	b939      	cbnz	r1, 80053c4 <USB_DevInit+0x12c>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 80053b4:	f8c2 e000 	str.w	lr, [r2]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 80053b8:	6110      	str	r0, [r2, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80053ba:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 80053bc:	f8c2 c008 	str.w	ip, [r2, #8]
 80053c0:	3220      	adds	r2, #32
 80053c2:	e7ba      	b.n	800533a <USB_DevInit+0xa2>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 80053c4:	6015      	str	r5, [r2, #0]
 80053c6:	e7f7      	b.n	80053b8 <USB_DevInit+0x120>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80053c8:	6010      	str	r0, [r2, #0]
 80053ca:	e7f5      	b.n	80053b8 <USB_DevInit+0x120>
 80053cc:	803c3800 	.word	0x803c3800

080053d0 <USB_ActivateEndpoint>:
{
 80053d0:	b570      	push	{r4, r5, r6, lr}
  if (ep->is_in == 1U)
 80053d2:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80053d4:	780c      	ldrb	r4, [r1, #0]
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 80053d6:	f8d0 681c 	ldr.w	r6, [r0, #2076]	; 0x81c
 80053da:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  if (ep->is_in == 1U)
 80053de:	2a01      	cmp	r2, #1
 80053e0:	f004 050f 	and.w	r5, r4, #15
 80053e4:	d11b      	bne.n	800541e <USB_ActivateEndpoint+0x4e>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 80053e6:	40aa      	lsls	r2, r5
 80053e8:	4332      	orrs	r2, r6
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 80053ea:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU));
 80053ee:	61da      	str	r2, [r3, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 80053f0:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80053f4:	041a      	lsls	r2, r3, #16
 80053f6:	d410      	bmi.n	800541a <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80053f8:	688b      	ldr	r3, [r1, #8]
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80053fa:	78c9      	ldrb	r1, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80053fc:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8005400:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8005404:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005408:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800540c:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8005410:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8005414:	4313      	orrs	r3, r2
 8005416:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800541a:	2000      	movs	r0, #0
 800541c:	bd70      	pop	{r4, r5, r6, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16);
 800541e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8005422:	40aa      	lsls	r2, r5
 8005424:	4332      	orrs	r2, r6
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8005426:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16);
 800542a:	61da      	str	r2, [r3, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800542c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8005430:	041b      	lsls	r3, r3, #16
 8005432:	d4f2      	bmi.n	800541a <USB_ActivateEndpoint+0x4a>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005434:	688b      	ldr	r3, [r1, #8]
                                    ((uint32_t)ep->type << 18) |
 8005436:	78c9      	ldrb	r1, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005438:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 800543c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8005440:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005444:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005448:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 800544c:	4313      	orrs	r3, r2
 800544e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8005452:	e7e2      	b.n	800541a <USB_ActivateEndpoint+0x4a>

08005454 <USB_DeactivateEndpoint>:
{
 8005454:	b530      	push	{r4, r5, lr}
  if (ep->is_in == 1U)
 8005456:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8005458:	780c      	ldrb	r4, [r1, #0]
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 800545a:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
 800545e:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  if (ep->is_in == 1U)
 8005462:	2b01      	cmp	r3, #1
 8005464:	f004 050f 	and.w	r5, r4, #15
 8005468:	d110      	bne.n	800548c <USB_DeactivateEndpoint+0x38>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 800546a:	40ab      	lsls	r3, r5
 800546c:	43db      	mvns	r3, r3
 800546e:	4019      	ands	r1, r3
 8005470:	63d1      	str	r1, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 8005472:	69d1      	ldr	r1, [r2, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8005474:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & 0xFU)));
 8005478:	400b      	ands	r3, r1
 800547a:	61d3      	str	r3, [r2, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 800547c:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8005480:	4b0b      	ldr	r3, [pc, #44]	; (80054b0 <USB_DeactivateEndpoint+0x5c>)
 8005482:	4013      	ands	r3, r2
 8005484:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8005488:	2000      	movs	r0, #0
 800548a:	bd30      	pop	{r4, r5, pc}
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 800548c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005490:	40ab      	lsls	r3, r5
 8005492:	43db      	mvns	r3, r3
 8005494:	4019      	ands	r1, r3
 8005496:	63d1      	str	r1, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 8005498:	69d1      	ldr	r1, [r2, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 800549a:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & 0xFU)) << 16));
 800549e:	400b      	ands	r3, r1
 80054a0:	61d3      	str	r3, [r2, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 80054a2:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 80054a6:	4b03      	ldr	r3, [pc, #12]	; (80054b4 <USB_DeactivateEndpoint+0x60>)
 80054a8:	4013      	ands	r3, r2
 80054aa:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80054ae:	e7eb      	b.n	8005488 <USB_DeactivateEndpoint+0x34>
 80054b0:	ec337800 	.word	0xec337800
 80054b4:	eff37800 	.word	0xeff37800

080054b8 <USB_EP0StartXfer>:
{
 80054b8:	b570      	push	{r4, r5, r6, lr}
  if (ep->is_in == 1U)
 80054ba:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80054bc:	780a      	ldrb	r2, [r1, #0]
 80054be:	694d      	ldr	r5, [r1, #20]
 80054c0:	4e35      	ldr	r6, [pc, #212]	; (8005598 <USB_EP0StartXfer+0xe0>)
  if (ep->is_in == 1U)
 80054c2:	2b01      	cmp	r3, #1
 80054c4:	f04f 0320 	mov.w	r3, #32
 80054c8:	d145      	bne.n	8005556 <USB_EP0StartXfer+0x9e>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80054ca:	fb13 0302 	smlabb	r3, r3, r2, r0
    if (ep->xfer_len == 0U)
 80054ce:	bb45      	cbnz	r5, 8005522 <USB_EP0StartXfer+0x6a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80054d0:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 80054d4:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80054d8:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80054dc:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80054e0:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 80054e4:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80054e8:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80054ec:	f8d3 4910 	ldr.w	r4, [r3, #2320]	; 0x910
 80054f0:	4026      	ands	r6, r4
 80054f2:	f8c3 6910 	str.w	r6, [r3, #2320]	; 0x910
    if (ep->xfer_len > 0U)
 80054f6:	694b      	ldr	r3, [r1, #20]
 80054f8:	b14b      	cbz	r3, 800550e <USB_EP0StartXfer+0x56>
      USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & 0xFU);
 80054fa:	780b      	ldrb	r3, [r1, #0]
 80054fc:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8005500:	f003 010f 	and.w	r1, r3, #15
 8005504:	2301      	movs	r3, #1
 8005506:	408b      	lsls	r3, r1
 8005508:	432b      	orrs	r3, r5
 800550a:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800550e:	eb00 1042 	add.w	r0, r0, r2, lsl #5
 8005512:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 8005516:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 800551a:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
}
 800551e:	2000      	movs	r0, #0
 8005520:	bd70      	pop	{r4, r5, r6, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005522:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005526:	691c      	ldr	r4, [r3, #16]
 8005528:	4026      	ands	r6, r4
 800552a:	611e      	str	r6, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800552c:	691c      	ldr	r4, [r3, #16]
 800552e:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8005532:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8005536:	611c      	str	r4, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 8005538:	688c      	ldr	r4, [r1, #8]
 800553a:	42a5      	cmp	r5, r4
        ep->xfer_len = ep->maxpacket;
 800553c:	bf88      	it	hi
 800553e:	614c      	strhi	r4, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005540:	691c      	ldr	r4, [r3, #16]
 8005542:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8005546:	611c      	str	r4, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005548:	694c      	ldr	r4, [r1, #20]
 800554a:	691d      	ldr	r5, [r3, #16]
 800554c:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8005550:	432c      	orrs	r4, r5
 8005552:	611c      	str	r4, [r3, #16]
 8005554:	e7cf      	b.n	80054f6 <USB_EP0StartXfer+0x3e>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8005556:	fb13 0002 	smlabb	r0, r3, r2, r0
 800555a:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 800555e:	691a      	ldr	r2, [r3, #16]
 8005560:	4032      	ands	r2, r6
 8005562:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8005564:	691a      	ldr	r2, [r3, #16]
 8005566:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 800556a:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 800556e:	611a      	str	r2, [r3, #16]
 8005570:	688a      	ldr	r2, [r1, #8]
    if (ep->xfer_len > 0U)
 8005572:	b105      	cbz	r5, 8005576 <USB_EP0StartXfer+0xbe>
      ep->xfer_len = ep->maxpacket;
 8005574:	614a      	str	r2, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005576:	6919      	ldr	r1, [r3, #16]
 8005578:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 800557c:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 800557e:	6919      	ldr	r1, [r3, #16]
 8005580:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8005584:	430a      	orrs	r2, r1
 8005586:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8005588:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800558c:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005590:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8005594:	e7c3      	b.n	800551e <USB_EP0StartXfer+0x66>
 8005596:	bf00      	nop
 8005598:	fff80000 	.word	0xfff80000

0800559c <USB_WritePacket>:
  count32b = ((uint32_t)len + 3U) / 4U;
 800559c:	3303      	adds	r3, #3
    USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 800559e:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 80055a2:	f023 0303 	bic.w	r3, r3, #3
 80055a6:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80055aa:	440b      	add	r3, r1
  for (i = 0U; i < count32b; i++)
 80055ac:	4299      	cmp	r1, r3
 80055ae:	d101      	bne.n	80055b4 <USB_WritePacket+0x18>
}
 80055b0:	2000      	movs	r0, #0
 80055b2:	4770      	bx	lr
    USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 80055b4:	f851 0b04 	ldr.w	r0, [r1], #4
 80055b8:	6010      	str	r0, [r2, #0]
 80055ba:	e7f7      	b.n	80055ac <USB_WritePacket+0x10>

080055bc <USB_EPStartXfer>:
{
 80055bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 80055be:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80055c0:	780d      	ldrb	r5, [r1, #0]
 80055c2:	4e5f      	ldr	r6, [pc, #380]	; (8005740 <USB_EPStartXfer+0x184>)
  if (ep->is_in == 1U)
 80055c4:	2b01      	cmp	r3, #1
 80055c6:	f04f 0220 	mov.w	r2, #32
 80055ca:	694b      	ldr	r3, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80055cc:	fb12 0205 	smlabb	r2, r2, r5, r0
  if (ep->is_in == 1U)
 80055d0:	d169      	bne.n	80056a6 <USB_EPStartXfer+0xea>
    if (ep->xfer_len == 0U)
 80055d2:	bb83      	cbnz	r3, 8005636 <USB_EPStartXfer+0x7a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80055d4:	f502 6410 	add.w	r4, r2, #2304	; 0x900
 80055d8:	f8d2 2910 	ldr.w	r2, [r2, #2320]	; 0x910
 80055dc:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 80055e0:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 80055e4:	6122      	str	r2, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80055e6:	6922      	ldr	r2, [r4, #16]
 80055e8:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80055ec:	6122      	str	r2, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80055ee:	6922      	ldr	r2, [r4, #16]
 80055f0:	4016      	ands	r6, r2
 80055f2:	6126      	str	r6, [r4, #16]
    if (ep->type != EP_TYPE_ISOC)
 80055f4:	78ce      	ldrb	r6, [r1, #3]
 80055f6:	2e01      	cmp	r6, #1
 80055f8:	f000 8094 	beq.w	8005724 <USB_EPStartXfer+0x168>
      if (ep->xfer_len > 0U)
 80055fc:	b153      	cbz	r3, 8005614 <USB_EPStartXfer+0x58>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & 0xFU);
 80055fe:	780a      	ldrb	r2, [r1, #0]
 8005600:	f8d0 e834 	ldr.w	lr, [r0, #2100]	; 0x834
 8005604:	f002 040f 	and.w	r4, r2, #15
 8005608:	2201      	movs	r2, #1
 800560a:	40a2      	lsls	r2, r4
 800560c:	ea42 020e 	orr.w	r2, r2, lr
 8005610:	f8c0 2834 	str.w	r2, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005614:	eb00 1245 	add.w	r2, r0, r5, lsl #5
    if (ep->type == EP_TYPE_ISOC)
 8005618:	2e01      	cmp	r6, #1
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800561a:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 800561e:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8005622:	f8c2 4900 	str.w	r4, [r2, #2304]	; 0x900
    if (ep->type == EP_TYPE_ISOC)
 8005626:	d104      	bne.n	8005632 <USB_EPStartXfer+0x76>
      (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len);
 8005628:	780a      	ldrb	r2, [r1, #0]
 800562a:	68c9      	ldr	r1, [r1, #12]
 800562c:	b29b      	uxth	r3, r3
 800562e:	f7ff ffb5 	bl	800559c <USB_WritePacket>
}
 8005632:	2000      	movs	r0, #0
 8005634:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005636:	f8d2 4910 	ldr.w	r4, [r2, #2320]	; 0x910
 800563a:	4034      	ands	r4, r6
 800563c:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005640:	f8d2 4910 	ldr.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8005644:	688e      	ldr	r6, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005646:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800564a:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800564e:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8005652:	199c      	adds	r4, r3, r6
 8005654:	3c01      	subs	r4, #1
 8005656:	fbb4 f6f6 	udiv	r6, r4, r6
 800565a:	4c3a      	ldr	r4, [pc, #232]	; (8005744 <USB_EPStartXfer+0x188>)
 800565c:	f8d2 7910 	ldr.w	r7, [r2, #2320]	; 0x910
 8005660:	ea04 44c6 	and.w	r4, r4, r6, lsl #19
 8005664:	433c      	orrs	r4, r7
 8005666:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800566a:	f8d2 6910 	ldr.w	r6, [r2, #2320]	; 0x910
 800566e:	f3c3 0412 	ubfx	r4, r3, #0, #19
 8005672:	4334      	orrs	r4, r6
 8005674:	f8c2 4910 	str.w	r4, [r2, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 8005678:	78cc      	ldrb	r4, [r1, #3]
 800567a:	2c01      	cmp	r4, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800567c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 8005680:	d1b8      	bne.n	80055f4 <USB_EPStartXfer+0x38>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8005682:	6914      	ldr	r4, [r2, #16]
 8005684:	f024 44c0 	bic.w	r4, r4, #1610612736	; 0x60000000
 8005688:	6114      	str	r4, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800568a:	6914      	ldr	r4, [r2, #16]
 800568c:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8005690:	6114      	str	r4, [r2, #16]
 8005692:	e7af      	b.n	80055f4 <USB_EPStartXfer+0x38>
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005694:	fb12 0205 	smlabb	r2, r2, r5, r0
 8005698:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 800569c:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80056a0:	f8c2 4900 	str.w	r4, [r2, #2304]	; 0x900
 80056a4:	e7b6      	b.n	8005614 <USB_EPStartXfer+0x58>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80056a6:	f502 6530 	add.w	r5, r2, #2816	; 0xb00
 80056aa:	692c      	ldr	r4, [r5, #16]
 80056ac:	4034      	ands	r4, r6
 80056ae:	612c      	str	r4, [r5, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 80056b0:	692c      	ldr	r4, [r5, #16]
 80056b2:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80056b6:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80056ba:	612c      	str	r4, [r5, #16]
 80056bc:	688c      	ldr	r4, [r1, #8]
    if (ep->xfer_len == 0U)
 80056be:	b9fb      	cbnz	r3, 8005700 <USB_EPStartXfer+0x144>
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80056c0:	692b      	ldr	r3, [r5, #16]
 80056c2:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80056c6:	431c      	orrs	r4, r3
 80056c8:	612c      	str	r4, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80056ca:	692b      	ldr	r3, [r5, #16]
 80056cc:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80056d0:	612b      	str	r3, [r5, #16]
    if (ep->type == EP_TYPE_ISOC)
 80056d2:	78cb      	ldrb	r3, [r1, #3]
 80056d4:	2b01      	cmp	r3, #1
 80056d6:	d10c      	bne.n	80056f2 <USB_EPStartXfer+0x136>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80056d8:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80056dc:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80056e0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80056e4:	bf0c      	ite	eq
 80056e6:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 80056ea:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 80056ee:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80056f2:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80056f6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80056fa:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  return HAL_OK;
 80056fe:	e798      	b.n	8005632 <USB_EPStartXfer+0x76>
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8005700:	4e10      	ldr	r6, [pc, #64]	; (8005744 <USB_EPStartXfer+0x188>)
 8005702:	692f      	ldr	r7, [r5, #16]
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8005704:	4423      	add	r3, r4
 8005706:	3b01      	subs	r3, #1
 8005708:	fbb3 f3f4 	udiv	r3, r3, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 800570c:	ea06 46c3 	and.w	r6, r6, r3, lsl #19
 8005710:	433e      	orrs	r6, r7
 8005712:	612e      	str	r6, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 8005714:	b29b      	uxth	r3, r3
 8005716:	692e      	ldr	r6, [r5, #16]
 8005718:	435c      	muls	r4, r3
 800571a:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800571e:	4334      	orrs	r4, r6
 8005720:	612c      	str	r4, [r5, #16]
 8005722:	e7d6      	b.n	80056d2 <USB_EPStartXfer+0x116>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005724:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 8005728:	f412 7f80 	tst.w	r2, #256	; 0x100
 800572c:	f04f 0220 	mov.w	r2, #32
 8005730:	d0b0      	beq.n	8005694 <USB_EPStartXfer+0xd8>
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005732:	fb12 0205 	smlabb	r2, r2, r5, r0
 8005736:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900
 800573a:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 800573e:	e7af      	b.n	80056a0 <USB_EPStartXfer+0xe4>
 8005740:	fff80000 	.word	0xfff80000
 8005744:	1ff80000 	.word	0x1ff80000

08005748 <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 8005748:	3203      	adds	r2, #3
 800574a:	f022 0203 	bic.w	r2, r2, #3
 800574e:	440a      	add	r2, r1
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 8005750:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  for (i = 0U; i < count32b; i++)
 8005754:	4291      	cmp	r1, r2
 8005756:	d101      	bne.n	800575c <USB_ReadPacket+0x14>
}
 8005758:	4608      	mov	r0, r1
 800575a:	4770      	bx	lr
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 800575c:	6803      	ldr	r3, [r0, #0]
 800575e:	f841 3b04 	str.w	r3, [r1], #4
 8005762:	e7f7      	b.n	8005754 <USB_ReadPacket+0xc>

08005764 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 8005764:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8005766:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 8005768:	2b01      	cmp	r3, #1
 800576a:	f04f 0320 	mov.w	r3, #32
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800576e:	fb13 0002 	smlabb	r0, r3, r2, r0
  if (ep->is_in == 1U)
 8005772:	d112      	bne.n	800579a <USB_EPSetStall+0x36>
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8005774:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8005778:	2b00      	cmp	r3, #0
 800577a:	db06      	blt.n	800578a <USB_EPSetStall+0x26>
 800577c:	b12a      	cbz	r2, 800578a <USB_EPSetStall+0x26>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 800577e:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8005782:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8005786:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800578a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800578e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005792:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8005796:	2000      	movs	r0, #0
 8005798:	4770      	bx	lr
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800579a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800579e:	2b00      	cmp	r3, #0
 80057a0:	db06      	blt.n	80057b0 <USB_EPSetStall+0x4c>
 80057a2:	b12a      	cbz	r2, 80057b0 <USB_EPSetStall+0x4c>
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 80057a4:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80057a8:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80057ac:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 80057b0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80057b4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80057b8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80057bc:	e7eb      	b.n	8005796 <USB_EPSetStall+0x32>

080057be <USB_EPClearStall>:
  if (ep->is_in == 1U)
 80057be:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80057c0:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 80057c2:	2b01      	cmp	r3, #1
 80057c4:	f04f 0320 	mov.w	r3, #32
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80057c8:	fb13 0002 	smlabb	r0, r3, r2, r0
  if (ep->is_in == 1U)
 80057cc:	d111      	bne.n	80057f2 <USB_EPClearStall+0x34>
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80057ce:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80057d2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80057d6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80057da:	78cb      	ldrb	r3, [r1, #3]
 80057dc:	3b02      	subs	r3, #2
 80057de:	2b01      	cmp	r3, #1
 80057e0:	d805      	bhi.n	80057ee <USB_EPClearStall+0x30>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80057e2:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80057e6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80057ea:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80057ee:	2000      	movs	r0, #0
 80057f0:	4770      	bx	lr
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80057f2:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80057f6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80057fa:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80057fe:	78cb      	ldrb	r3, [r1, #3]
 8005800:	3b02      	subs	r3, #2
 8005802:	2b01      	cmp	r3, #1
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8005804:	bf9e      	ittt	ls
 8005806:	f8d0 3b00 	ldrls.w	r3, [r0, #2816]	; 0xb00
 800580a:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
 800580e:	f8c0 3b00 	strls.w	r3, [r0, #2816]	; 0xb00
 8005812:	e7ec      	b.n	80057ee <USB_EPClearStall+0x30>

08005814 <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8005814:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8005818:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800581c:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8005820:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8005824:	0109      	lsls	r1, r1, #4
 8005826:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800582a:	4319      	orrs	r1, r3
 800582c:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 8005830:	2000      	movs	r0, #0
 8005832:	4770      	bx	lr

08005834 <USB_DevConnect>:
{
 8005834:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8005836:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800583a:	f023 0302 	bic.w	r3, r3, #2
 800583e:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8005842:	2003      	movs	r0, #3
 8005844:	f7fb fbb4 	bl	8000fb0 <HAL_Delay>
}
 8005848:	2000      	movs	r0, #0
 800584a:	bd08      	pop	{r3, pc}

0800584c <USB_DevDisconnect>:
{
 800584c:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 800584e:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8005852:	f043 0302 	orr.w	r3, r3, #2
 8005856:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 800585a:	2003      	movs	r0, #3
 800585c:	f7fb fba8 	bl	8000fb0 <HAL_Delay>
}
 8005860:	2000      	movs	r0, #0
 8005862:	bd08      	pop	{r3, pc}

08005864 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8005864:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 8005866:	6980      	ldr	r0, [r0, #24]
}
 8005868:	4010      	ands	r0, r2
 800586a:	4770      	bx	lr

0800586c <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 800586c:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8005870:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005874:	69c0      	ldr	r0, [r0, #28]
 8005876:	4018      	ands	r0, r3
}
 8005878:	0c00      	lsrs	r0, r0, #16
 800587a:	4770      	bx	lr

0800587c <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 800587c:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8005880:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005884:	69c0      	ldr	r0, [r0, #28]
 8005886:	4018      	ands	r0, r3
}
 8005888:	b280      	uxth	r0, r0
 800588a:	4770      	bx	lr

0800588c <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 800588c:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8005890:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8005894:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8005898:	6940      	ldr	r0, [r0, #20]
}
 800589a:	4010      	ands	r0, r2
 800589c:	4770      	bx	lr

0800589e <USB_ReadDevInEPInterrupt>:
{
 800589e:	b510      	push	{r4, lr}
  msk = USBx_DEVICE->DIEPMSK;
 80058a0:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 80058a4:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80058a8:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 80058ac:	f001 010f 	and.w	r1, r1, #15
 80058b0:	40cb      	lsrs	r3, r1
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80058b2:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 80058b6:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80058b8:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> (epnum & 0xFU)) & 0x1U) << 7;
 80058ba:	b2db      	uxtb	r3, r3
 80058bc:	4323      	orrs	r3, r4
}
 80058be:	4018      	ands	r0, r3
 80058c0:	bd10      	pop	{r4, pc}

080058c2 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 80058c2:	6940      	ldr	r0, [r0, #20]
}
 80058c4:	f000 0001 	and.w	r0, r0, #1
 80058c8:	4770      	bx	lr

080058ca <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 80058ca:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80058ce:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 80058d2:	f023 0307 	bic.w	r3, r3, #7
 80058d6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 80058da:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 80058de:	689a      	ldr	r2, [r3, #8]
 80058e0:	f002 0206 	and.w	r2, r2, #6
 80058e4:	2a04      	cmp	r2, #4
    USBx_INEP(0U)->DIEPCTL |= 3U;
 80058e6:	bf02      	ittt	eq
 80058e8:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 80058ec:	f042 0203 	orreq.w	r2, r2, #3
 80058f0:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 80058f4:	685a      	ldr	r2, [r3, #4]
 80058f6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80058fa:	605a      	str	r2, [r3, #4]
}
 80058fc:	2000      	movs	r0, #0
 80058fe:	4770      	bx	lr

08005900 <USB_EP0_OutStart>:
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8005900:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8005904:	2000      	movs	r0, #0
 8005906:	6118      	str	r0, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005908:	691a      	ldr	r2, [r3, #16]
 800590a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800590e:	611a      	str	r2, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8005910:	691a      	ldr	r2, [r3, #16]
 8005912:	f042 0218 	orr.w	r2, r2, #24
 8005916:	611a      	str	r2, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8005918:	691a      	ldr	r2, [r3, #16]
 800591a:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800591e:	611a      	str	r2, [r3, #16]
}
 8005920:	4770      	bx	lr
	...

08005924 <USBD_CUSTOM_HID_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_CfgFSDesc);
 8005924:	2329      	movs	r3, #41	; 0x29
 8005926:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_CfgFSDesc;
}
 8005928:	4800      	ldr	r0, [pc, #0]	; (800592c <USBD_CUSTOM_HID_GetFSCfgDesc+0x8>)
 800592a:	4770      	bx	lr
 800592c:	2000003c 	.word	0x2000003c

08005930 <USBD_CUSTOM_HID_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_CfgHSDesc);
 8005930:	2329      	movs	r3, #41	; 0x29
 8005932:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_CfgHSDesc;
}
 8005934:	4800      	ldr	r0, [pc, #0]	; (8005938 <USBD_CUSTOM_HID_GetHSCfgDesc+0x8>)
 8005936:	4770      	bx	lr
 8005938:	20000068 	.word	0x20000068

0800593c <USBD_CUSTOM_HID_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CUSTOM_HID_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_OtherSpeedCfgDesc);
 800593c:	2329      	movs	r3, #41	; 0x29
 800593e:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_OtherSpeedCfgDesc;
}
 8005940:	4800      	ldr	r0, [pc, #0]	; (8005944 <USBD_CUSTOM_HID_GetOtherSpeedCfgDesc+0x8>)
 8005942:	4770      	bx	lr
 8005944:	200000ac 	.word	0x200000ac

08005948 <USBD_CUSTOM_HID_DataIn>:
static uint8_t  USBD_CUSTOM_HID_DataIn (USBD_HandleTypeDef *pdev,
                                        uint8_t epnum)
{
  /* Ensure that the FIFO is empty before a new transfer, this condition could
  be caused by  a new transfer before the end of the previous transfer */
  ((USBD_CUSTOM_HID_HandleTypeDef *)pdev->pClassData)->state = CUSTOM_HID_IDLE;
 8005948:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
 800594c:	2000      	movs	r0, #0
 800594e:	7718      	strb	r0, [r3, #28]

  return USBD_OK;
}
 8005950:	4770      	bx	lr

08005952 <USBD_CUSTOM_HID_EP0_RxReady>:
  *         Handles control request data.
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CUSTOM_HID_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8005952:	b510      	push	{r4, lr}
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 8005954:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290

  if (hhid->IsReportAvailable == 1U)
 8005958:	69a3      	ldr	r3, [r4, #24]
 800595a:	2b01      	cmp	r3, #1
 800595c:	d107      	bne.n	800596e <USBD_CUSTOM_HID_EP0_RxReady+0x1c>
  {
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 800595e:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 8005962:	7861      	ldrb	r1, [r4, #1]
 8005964:	68db      	ldr	r3, [r3, #12]
 8005966:	7820      	ldrb	r0, [r4, #0]
 8005968:	4798      	blx	r3
                                                              hhid->Report_buf[1]);
    hhid->IsReportAvailable = 0U;
 800596a:	2300      	movs	r3, #0
 800596c:	61a3      	str	r3, [r4, #24]
  }

  return USBD_OK;
}
 800596e:	2000      	movs	r0, #0
 8005970:	bd10      	pop	{r4, pc}
	...

08005974 <USBD_CUSTOM_HID_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_CUSTOM_HID_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_CUSTOM_HID_DeviceQualifierDesc);
 8005974:	230a      	movs	r3, #10
 8005976:	8003      	strh	r3, [r0, #0]
  return USBD_CUSTOM_HID_DeviceQualifierDesc;
}
 8005978:	4800      	ldr	r0, [pc, #0]	; (800597c <USBD_CUSTOM_HID_GetDeviceQualifierDesc+0x8>)
 800597a:	4770      	bx	lr
 800597c:	200000a0 	.word	0x200000a0

08005980 <USBD_CUSTOM_HID_DataOut>:
{
 8005980:	b538      	push	{r3, r4, r5, lr}
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 8005982:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 8005986:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 800598a:	7869      	ldrb	r1, [r5, #1]
 800598c:	68db      	ldr	r3, [r3, #12]
{
 800598e:	4604      	mov	r4, r0
  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->OutEvent(hhid->Report_buf[0],
 8005990:	7828      	ldrb	r0, [r5, #0]
 8005992:	4798      	blx	r3
  USBD_LL_PrepareReceive(pdev, CUSTOM_HID_EPOUT_ADDR , hhid->Report_buf,
 8005994:	230c      	movs	r3, #12
 8005996:	462a      	mov	r2, r5
 8005998:	2101      	movs	r1, #1
 800599a:	4620      	mov	r0, r4
 800599c:	f00c fbdc 	bl	8012158 <USBD_LL_PrepareReceive>
}
 80059a0:	2000      	movs	r0, #0
 80059a2:	bd38      	pop	{r3, r4, r5, pc}

080059a4 <USBD_CUSTOM_HID_Setup>:
{
 80059a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint16_t status_info = 0U;
 80059a6:	2500      	movs	r5, #0
 80059a8:	f8ad 5006 	strh.w	r5, [sp, #6]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059ac:	780d      	ldrb	r5, [r1, #0]
  USBD_CUSTOM_HID_HandleTypeDef *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev->pClassData;
 80059ae:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059b2:	f015 0560 	ands.w	r5, r5, #96	; 0x60
{
 80059b6:	4603      	mov	r3, r0
 80059b8:	460a      	mov	r2, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059ba:	d028      	beq.n	8005a0e <USBD_CUSTOM_HID_Setup+0x6a>
 80059bc:	2d20      	cmp	r5, #32
 80059be:	d161      	bne.n	8005a84 <USBD_CUSTOM_HID_Setup+0xe0>
    switch (req->bRequest)
 80059c0:	7849      	ldrb	r1, [r1, #1]
 80059c2:	3902      	subs	r1, #2
 80059c4:	2909      	cmp	r1, #9
 80059c6:	d85b      	bhi.n	8005a80 <USBD_CUSTOM_HID_Setup+0xdc>
 80059c8:	e8df f001 	tbb	[pc, r1]
 80059cc:	5a5a0a15 	.word	0x5a5a0a15
 80059d0:	195a5a5a 	.word	0x195a5a5a
 80059d4:	0511      	.short	0x0511
      hhid->Protocol = (uint8_t)(req->wValue);
 80059d6:	7893      	ldrb	r3, [r2, #2]
 80059d8:	60e3      	str	r3, [r4, #12]
  uint8_t ret = USBD_OK;
 80059da:	2000      	movs	r0, #0
}
 80059dc:	b003      	add	sp, #12
 80059de:	bd30      	pop	{r4, r5, pc}
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->Protocol, 1U);
 80059e0:	2201      	movs	r2, #1
 80059e2:	f104 010c 	add.w	r1, r4, #12
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->AltSetting, 1U);
 80059e6:	4618      	mov	r0, r3
 80059e8:	f000 fc04 	bl	80061f4 <USBD_CtlSendData>
 80059ec:	e7f5      	b.n	80059da <USBD_CUSTOM_HID_Setup+0x36>
      hhid->IdleState = (uint8_t)(req->wValue >> 8);
 80059ee:	8853      	ldrh	r3, [r2, #2]
 80059f0:	0a1b      	lsrs	r3, r3, #8
 80059f2:	6123      	str	r3, [r4, #16]
 80059f4:	e7f1      	b.n	80059da <USBD_CUSTOM_HID_Setup+0x36>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->IdleState, 1U);
 80059f6:	2201      	movs	r2, #1
 80059f8:	f104 0110 	add.w	r1, r4, #16
 80059fc:	e7f3      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
      hhid->IsReportAvailable = 1U;
 80059fe:	2101      	movs	r1, #1
 8005a00:	61a1      	str	r1, [r4, #24]
      USBD_CtlPrepareRx (pdev, hhid->Report_buf, req->wLength);
 8005a02:	88d2      	ldrh	r2, [r2, #6]
 8005a04:	4621      	mov	r1, r4
 8005a06:	4618      	mov	r0, r3
 8005a08:	f000 fc09 	bl	800621e <USBD_CtlPrepareRx>
 8005a0c:	e7e5      	b.n	80059da <USBD_CUSTOM_HID_Setup+0x36>
    switch (req->bRequest)
 8005a0e:	7849      	ldrb	r1, [r1, #1]
 8005a10:	290b      	cmp	r1, #11
 8005a12:	d835      	bhi.n	8005a80 <USBD_CUSTOM_HID_Setup+0xdc>
 8005a14:	e8df f001 	tbb	[pc, r1]
 8005a18:	34343406 	.word	0x34343406
 8005a1c:	340e3434 	.word	0x340e3434
 8005a20:	2d253434 	.word	0x2d253434
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005a24:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 8005a28:	2903      	cmp	r1, #3
 8005a2a:	d129      	bne.n	8005a80 <USBD_CUSTOM_HID_Setup+0xdc>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&status_info, 2U);
 8005a2c:	2202      	movs	r2, #2
 8005a2e:	f10d 0106 	add.w	r1, sp, #6
 8005a32:	e7d8      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
      if( req->wValue >> 8 == CUSTOM_HID_REPORT_DESC)
 8005a34:	8851      	ldrh	r1, [r2, #2]
 8005a36:	0a09      	lsrs	r1, r1, #8
 8005a38:	2922      	cmp	r1, #34	; 0x22
 8005a3a:	d107      	bne.n	8005a4c <USBD_CUSTOM_HID_Setup+0xa8>
        len = MIN(USBD_CUSTOM_HID_REPORT_DESC_SIZE , req->wLength);
 8005a3c:	88d2      	ldrh	r2, [r2, #6]
        pbuf =  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->pReport;
 8005a3e:	f8d3 1294 	ldr.w	r1, [r3, #660]	; 0x294
        len = MIN(USBD_CUSTOM_HID_REPORT_DESC_SIZE , req->wLength);
 8005a42:	2a21      	cmp	r2, #33	; 0x21
 8005a44:	bf28      	it	cs
 8005a46:	2221      	movcs	r2, #33	; 0x21
        pbuf =  ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->pReport;
 8005a48:	6809      	ldr	r1, [r1, #0]
 8005a4a:	e7cc      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
        if( req->wValue >> 8 == CUSTOM_HID_DESCRIPTOR_TYPE)
 8005a4c:	2921      	cmp	r1, #33	; 0x21
 8005a4e:	d105      	bne.n	8005a5c <USBD_CUSTOM_HID_Setup+0xb8>
          len = MIN(USB_CUSTOM_HID_DESC_SIZ , req->wLength);
 8005a50:	88d2      	ldrh	r2, [r2, #6]
          pbuf = USBD_CUSTOM_HID_Desc;
 8005a52:	490e      	ldr	r1, [pc, #56]	; (8005a8c <USBD_CUSTOM_HID_Setup+0xe8>)
          len = MIN(USB_CUSTOM_HID_DESC_SIZ , req->wLength);
 8005a54:	2a09      	cmp	r2, #9
 8005a56:	bf28      	it	cs
 8005a58:	2209      	movcs	r2, #9
 8005a5a:	e7c4      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
  uint8_t  *pbuf = NULL;
 8005a5c:	2100      	movs	r1, #0
  uint16_t len = 0U;
 8005a5e:	460a      	mov	r2, r1
 8005a60:	e7c1      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005a62:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 8005a66:	2903      	cmp	r1, #3
 8005a68:	d10a      	bne.n	8005a80 <USBD_CUSTOM_HID_Setup+0xdc>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hhid->AltSetting, 1U);
 8005a6a:	2201      	movs	r2, #1
 8005a6c:	f104 0114 	add.w	r1, r4, #20
 8005a70:	e7b9      	b.n	80059e6 <USBD_CUSTOM_HID_Setup+0x42>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005a72:	f893 1274 	ldrb.w	r1, [r3, #628]	; 0x274
 8005a76:	2903      	cmp	r1, #3
 8005a78:	d102      	bne.n	8005a80 <USBD_CUSTOM_HID_Setup+0xdc>
        hhid->AltSetting = (uint8_t)(req->wValue);
 8005a7a:	7893      	ldrb	r3, [r2, #2]
 8005a7c:	6163      	str	r3, [r4, #20]
 8005a7e:	e7ac      	b.n	80059da <USBD_CUSTOM_HID_Setup+0x36>
      USBD_CtlError (pdev, req);
 8005a80:	4611      	mov	r1, r2
 8005a82:	4618      	mov	r0, r3
    USBD_CtlError (pdev, req);
 8005a84:	f000 fb8f 	bl	80061a6 <USBD_CtlError>
    ret = USBD_FAIL;
 8005a88:	2002      	movs	r0, #2
    break;
 8005a8a:	e7a7      	b.n	80059dc <USBD_CUSTOM_HID_Setup+0x38>
 8005a8c:	20000094 	.word	0x20000094

08005a90 <USBD_CUSTOM_HID_DeInit>:
{
 8005a90:	b538      	push	{r3, r4, r5, lr}
 8005a92:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPIN_ADDR);
 8005a94:	2181      	movs	r1, #129	; 0x81
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 0U;
 8005a96:	2500      	movs	r5, #0
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPIN_ADDR);
 8005a98:	f00c fb04 	bl	80120a4 <USBD_LL_CloseEP>
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 0U;
 8005a9c:	62e5      	str	r5, [r4, #44]	; 0x2c
  USBD_LL_CloseEP(pdev, CUSTOM_HID_EPOUT_ADDR);
 8005a9e:	2101      	movs	r1, #1
 8005aa0:	4620      	mov	r0, r4
 8005aa2:	f00c faff 	bl	80120a4 <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 8005aa6:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_out[CUSTOM_HID_EPOUT_ADDR & 0xFU].is_used = 0U;
 8005aaa:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
  if(pdev->pClassData != NULL)
 8005aae:	b14b      	cbz	r3, 8005ac4 <USBD_CUSTOM_HID_DeInit+0x34>
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->DeInit();
 8005ab0:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8005ab4:	689b      	ldr	r3, [r3, #8]
 8005ab6:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8005ab8:	f8d4 0290 	ldr.w	r0, [r4, #656]	; 0x290
 8005abc:	f00c fb90 	bl	80121e0 <USBD_static_free>
    pdev->pClassData = NULL;
 8005ac0:	f8c4 5290 	str.w	r5, [r4, #656]	; 0x290
}
 8005ac4:	2000      	movs	r0, #0
 8005ac6:	bd38      	pop	{r3, r4, r5, pc}

08005ac8 <USBD_CUSTOM_HID_Init>:
{
 8005ac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005aca:	4605      	mov	r5, r0
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 1U;
 8005acc:	2401      	movs	r4, #1
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPIN_ADDR, USBD_EP_TYPE_INTR,
 8005ace:	2302      	movs	r3, #2
 8005ad0:	2203      	movs	r2, #3
 8005ad2:	2181      	movs	r1, #129	; 0x81
 8005ad4:	f00c fad6 	bl	8012084 <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPOUT_ADDR, USBD_EP_TYPE_INTR,
 8005ad8:	2302      	movs	r3, #2
 8005ada:	2203      	movs	r2, #3
 8005adc:	4621      	mov	r1, r4
  pdev->ep_in[CUSTOM_HID_EPIN_ADDR & 0xFU].is_used = 1U;
 8005ade:	62ec      	str	r4, [r5, #44]	; 0x2c
  USBD_LL_OpenEP(pdev, CUSTOM_HID_EPOUT_ADDR, USBD_EP_TYPE_INTR,
 8005ae0:	4628      	mov	r0, r5
 8005ae2:	f00c facf 	bl	8012084 <USBD_LL_OpenEP>
  pdev->ep_out[CUSTOM_HID_EPOUT_ADDR & 0xFU].is_used = 1U;
 8005ae6:	f8c5 4158 	str.w	r4, [r5, #344]	; 0x158
  pdev->pClassData = USBD_malloc(sizeof (USBD_CUSTOM_HID_HandleTypeDef));
 8005aea:	2020      	movs	r0, #32
 8005aec:	f00c fb74 	bl	80121d8 <USBD_static_malloc>
 8005af0:	4606      	mov	r6, r0
 8005af2:	f8c5 0290 	str.w	r0, [r5, #656]	; 0x290
  if(pdev->pClassData == NULL)
 8005af6:	b168      	cbz	r0, 8005b14 <USBD_CUSTOM_HID_Init+0x4c>
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->Init();
 8005af8:	f8d5 3294 	ldr.w	r3, [r5, #660]	; 0x294
    hhid->state = CUSTOM_HID_IDLE;
 8005afc:	2700      	movs	r7, #0
 8005afe:	7707      	strb	r7, [r0, #28]
    ((USBD_CUSTOM_HID_ItfTypeDef *)pdev->pUserData)->Init();
 8005b00:	685b      	ldr	r3, [r3, #4]
 8005b02:	4798      	blx	r3
    USBD_LL_PrepareReceive(pdev, CUSTOM_HID_EPOUT_ADDR, hhid->Report_buf,
 8005b04:	230c      	movs	r3, #12
 8005b06:	4632      	mov	r2, r6
 8005b08:	4621      	mov	r1, r4
 8005b0a:	4628      	mov	r0, r5
 8005b0c:	f00c fb24 	bl	8012158 <USBD_LL_PrepareReceive>
  uint8_t ret = 0U;
 8005b10:	4638      	mov	r0, r7
 8005b12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1U;
 8005b14:	4620      	mov	r0, r4
}
 8005b16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005b18 <USBD_CUSTOM_HID_RegisterInterface>:
uint8_t  USBD_CUSTOM_HID_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                             USBD_CUSTOM_HID_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;

  if(fops != NULL)
 8005b18:	b119      	cbz	r1, 8005b22 <USBD_CUSTOM_HID_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 8005b1a:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
    ret = USBD_OK;
 8005b1e:	2000      	movs	r0, #0
 8005b20:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 8005b22:	2002      	movs	r0, #2
  }

  return ret;
}
 8005b24:	4770      	bx	lr

08005b26 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8005b26:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8005b28:	b180      	cbz	r0, 8005b4c <USBD_Init+0x26>
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8005b2a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005b2e:	b113      	cbz	r3, 8005b36 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 8005b30:	2300      	movs	r3, #0
 8005b32:	f8c0 328c 	str.w	r3, [r0, #652]	; 0x28c
  }

  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8005b36:	b109      	cbz	r1, 8005b3c <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8005b38:	f8c0 1288 	str.w	r1, [r0, #648]	; 0x288
  }

  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8005b3c:	2301      	movs	r3, #1
 8005b3e:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  pdev->id = id;
 8005b42:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8005b44:	f00c fa5c 	bl	8012000 <USBD_LL_Init>

  return USBD_OK;
 8005b48:	2000      	movs	r0, #0
 8005b4a:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8005b4c:	2002      	movs	r0, #2
}
 8005b4e:	bd08      	pop	{r3, pc}

08005b50 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8005b50:	b119      	cbz	r1, 8005b5a <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8005b52:	f8c0 128c 	str.w	r1, [r0, #652]	; 0x28c
    status = USBD_OK;
 8005b56:	2000      	movs	r0, #0
 8005b58:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 8005b5a:	2002      	movs	r0, #2
  }

  return status;
}
 8005b5c:	4770      	bx	lr

08005b5e <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8005b5e:	b508      	push	{r3, lr}

  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 8005b60:	f00c fa82 	bl	8012068 <USBD_LL_Start>

  return USBD_OK;
}
 8005b64:	2000      	movs	r0, #0
 8005b66:	bd08      	pop	{r3, pc}

08005b68 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8005b68:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;

  if(pdev->pClass != NULL)
 8005b6a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005b6e:	b90b      	cbnz	r3, 8005b74 <USBD_SetClassConfig+0xc>
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8005b70:	2002      	movs	r0, #2
 8005b72:	bd08      	pop	{r3, pc}
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0U)
 8005b74:	681b      	ldr	r3, [r3, #0]
 8005b76:	4798      	blx	r3
 8005b78:	2800      	cmp	r0, #0
 8005b7a:	d1f9      	bne.n	8005b70 <USBD_SetClassConfig+0x8>
      ret = USBD_OK;
    }
  }

  return ret;
}
 8005b7c:	bd08      	pop	{r3, pc}

08005b7e <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8005b7e:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 8005b80:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005b84:	685b      	ldr	r3, [r3, #4]
 8005b86:	4798      	blx	r3
  return USBD_OK;
}
 8005b88:	2000      	movs	r0, #0
 8005b8a:	bd08      	pop	{r3, pc}

08005b8c <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8005b8c:	b538      	push	{r3, r4, r5, lr}
 8005b8e:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 8005b90:	f500 7520 	add.w	r5, r0, #640	; 0x280
 8005b94:	4628      	mov	r0, r5
 8005b96:	f000 faf2 	bl	800617e <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8005b9a:	2301      	movs	r3, #1

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 8005b9c:	f894 1280 	ldrb.w	r1, [r4, #640]	; 0x280
  pdev->ep0_state = USBD_EP0_SETUP;
 8005ba0:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
  pdev->ep0_data_len = pdev->request.wLength;
 8005ba4:	f8b4 3286 	ldrh.w	r3, [r4, #646]	; 0x286
 8005ba8:	f8c4 3270 	str.w	r3, [r4, #624]	; 0x270
  switch (pdev->request.bmRequest & 0x1FU)
 8005bac:	f001 031f 	and.w	r3, r1, #31
 8005bb0:	2b01      	cmp	r3, #1
 8005bb2:	d00e      	beq.n	8005bd2 <USBD_LL_SetupStage+0x46>
 8005bb4:	d307      	bcc.n	8005bc6 <USBD_LL_SetupStage+0x3a>
 8005bb6:	2b02      	cmp	r3, #2
 8005bb8:	d010      	beq.n	8005bdc <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:
    USBD_StdEPReq(pdev, &pdev->request);
    break;

  default:
    USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8005bba:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8005bbe:	4620      	mov	r0, r4
 8005bc0:	f00c fa7e 	bl	80120c0 <USBD_LL_StallEP>
    break;
 8005bc4:	e003      	b.n	8005bce <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 8005bc6:	4629      	mov	r1, r5
 8005bc8:	4620      	mov	r0, r4
 8005bca:	f000 f901 	bl	8005dd0 <USBD_StdDevReq>
  }

  return USBD_OK;
}
 8005bce:	2000      	movs	r0, #0
 8005bd0:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8005bd2:	4629      	mov	r1, r5
 8005bd4:	4620      	mov	r0, r4
 8005bd6:	f000 fa25 	bl	8006024 <USBD_StdItfReq>
    break;
 8005bda:	e7f8      	b.n	8005bce <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);
 8005bdc:	4629      	mov	r1, r5
 8005bde:	4620      	mov	r0, r4
 8005be0:	f000 fa45 	bl	800606e <USBD_StdEPReq>
    break;
 8005be4:	e7f3      	b.n	8005bce <USBD_LL_SetupStage+0x42>

08005be6 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8005be6:	b570      	push	{r4, r5, r6, lr}
 8005be8:	4605      	mov	r5, r0
 8005bea:	4616      	mov	r6, r2
  USBD_EndpointTypeDef    *pep;

  if(epnum == 0U)
 8005bec:	bb39      	cbnz	r1, 8005c3e <USBD_LL_DataOutStage+0x58>
  {
    pep = &pdev->ep_out[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8005bee:	f8d0 326c 	ldr.w	r3, [r0, #620]	; 0x26c
 8005bf2:	2b03      	cmp	r3, #3
 8005bf4:	d11e      	bne.n	8005c34 <USBD_LL_DataOutStage+0x4e>
    {
      if(pep->rem_length > pep->maxpacket)
 8005bf6:	f8d0 314c 	ldr.w	r3, [r0, #332]	; 0x14c
 8005bfa:	f8d0 2150 	ldr.w	r2, [r0, #336]	; 0x150
 8005bfe:	4293      	cmp	r3, r2
 8005c00:	d90b      	bls.n	8005c1a <USBD_LL_DataOutStage+0x34>
      {
        pep->rem_length -=  pep->maxpacket;
 8005c02:	1a9b      	subs	r3, r3, r2

        USBD_CtlContinueRx (pdev,
 8005c04:	429a      	cmp	r2, r3
        pep->rem_length -=  pep->maxpacket;
 8005c06:	f8c0 314c 	str.w	r3, [r0, #332]	; 0x14c
        USBD_CtlContinueRx (pdev,
 8005c0a:	bf8c      	ite	hi
 8005c0c:	b29a      	uxthhi	r2, r3
 8005c0e:	b292      	uxthls	r2, r2
 8005c10:	4631      	mov	r1, r6
 8005c12:	f000 fb13 	bl	800623c <USBD_CtlContinueRx>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8005c16:	2000      	movs	r0, #0
    pdev->pClass->DataOut(pdev, epnum);
 8005c18:	bd70      	pop	{r4, r5, r6, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8005c1a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005c1e:	691b      	ldr	r3, [r3, #16]
 8005c20:	b123      	cbz	r3, 8005c2c <USBD_LL_DataOutStage+0x46>
 8005c22:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8005c26:	2a03      	cmp	r2, #3
 8005c28:	d100      	bne.n	8005c2c <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev);
 8005c2a:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8005c2c:	4628      	mov	r0, r5
 8005c2e:	f000 fb0d 	bl	800624c <USBD_CtlSendStatus>
 8005c32:	e7f0      	b.n	8005c16 <USBD_LL_DataOutStage+0x30>
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 8005c34:	2b05      	cmp	r3, #5
 8005c36:	d1ee      	bne.n	8005c16 <USBD_LL_DataOutStage+0x30>
        USBD_LL_StallEP(pdev, 0U);
 8005c38:	f00c fa42 	bl	80120c0 <USBD_LL_StallEP>
 8005c3c:	e7eb      	b.n	8005c16 <USBD_LL_DataOutStage+0x30>
  else if((pdev->pClass->DataOut != NULL) &&
 8005c3e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005c42:	699b      	ldr	r3, [r3, #24]
 8005c44:	b12b      	cbz	r3, 8005c52 <USBD_LL_DataOutStage+0x6c>
 8005c46:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8005c4a:	2a03      	cmp	r2, #3
 8005c4c:	d101      	bne.n	8005c52 <USBD_LL_DataOutStage+0x6c>
    pdev->pClass->DataOut(pdev, epnum);
 8005c4e:	4798      	blx	r3
 8005c50:	e7e1      	b.n	8005c16 <USBD_LL_DataOutStage+0x30>
    return USBD_FAIL;
 8005c52:	2002      	movs	r0, #2
}
 8005c54:	bd70      	pop	{r4, r5, r6, pc}

08005c56 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev, uint8_t epnum,
                                       uint8_t *pdata)
{
 8005c56:	b570      	push	{r4, r5, r6, lr}
 8005c58:	4613      	mov	r3, r2
 8005c5a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if(epnum == 0U)
 8005c5c:	460e      	mov	r6, r1
 8005c5e:	2900      	cmp	r1, #0
 8005c60:	d148      	bne.n	8005cf4 <USBD_LL_DataInStage+0x9e>
  {
    pep = &pdev->ep_in[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8005c62:	f8d0 226c 	ldr.w	r2, [r0, #620]	; 0x26c
 8005c66:	2a02      	cmp	r2, #2
 8005c68:	d13d      	bne.n	8005ce6 <USBD_LL_DataInStage+0x90>
    {
      if(pep->rem_length > pep->maxpacket)
 8005c6a:	6a05      	ldr	r5, [r0, #32]
 8005c6c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8005c6e:	4295      	cmp	r5, r2
 8005c70:	d914      	bls.n	8005c9c <USBD_LL_DataInStage+0x46>
      {
        pep->rem_length -= pep->maxpacket;
 8005c72:	1aaa      	subs	r2, r5, r2
 8005c74:	6202      	str	r2, [r0, #32]

        USBD_CtlContinueSendData (pdev, pdata, (uint16_t)pep->rem_length);
 8005c76:	4619      	mov	r1, r3
 8005c78:	b292      	uxth	r2, r2
 8005c7a:	f000 fac8 	bl	800620e <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8005c7e:	4633      	mov	r3, r6
        {
          USBD_CtlContinueSendData(pdev, NULL, 0U);
          pdev->ep0_data_len = 0U;

          /* Prepare endpoint for premature end of transfer */
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8005c80:	461a      	mov	r2, r3
 8005c82:	4619      	mov	r1, r3
 8005c84:	4620      	mov	r0, r4
 8005c86:	f00c fa67 	bl	8012158 <USBD_LL_PrepareReceive>
      {
        USBD_LL_StallEP(pdev, 0x80U);
      }
    }

    if (pdev->dev_test_mode == 1U)
 8005c8a:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
 8005c8e:	2b01      	cmp	r3, #1
 8005c90:	f04f 0000 	mov.w	r0, #0
 8005c94:	d13a      	bne.n	8005d0c <USBD_LL_DataInStage+0xb6>
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 8005c96:	f884 0278 	strb.w	r0, [r4, #632]	; 0x278
 8005c9a:	bd70      	pop	{r4, r5, r6, pc}
        if((pep->total_length % pep->maxpacket == 0U) &&
 8005c9c:	69c3      	ldr	r3, [r0, #28]
 8005c9e:	fbb3 f5f2 	udiv	r5, r3, r2
 8005ca2:	fb02 3515 	mls	r5, r2, r5, r3
 8005ca6:	b965      	cbnz	r5, 8005cc2 <USBD_LL_DataInStage+0x6c>
 8005ca8:	429a      	cmp	r2, r3
 8005caa:	d80a      	bhi.n	8005cc2 <USBD_LL_DataInStage+0x6c>
           (pep->total_length >= pep->maxpacket) &&
 8005cac:	f8d0 2270 	ldr.w	r2, [r0, #624]	; 0x270
 8005cb0:	4293      	cmp	r3, r2
 8005cb2:	d206      	bcs.n	8005cc2 <USBD_LL_DataInStage+0x6c>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 8005cb4:	462a      	mov	r2, r5
 8005cb6:	f000 faaa 	bl	800620e <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 8005cba:	f8c4 5270 	str.w	r5, [r4, #624]	; 0x270
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8005cbe:	462b      	mov	r3, r5
 8005cc0:	e7de      	b.n	8005c80 <USBD_LL_DataInStage+0x2a>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8005cc2:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8005cc6:	68db      	ldr	r3, [r3, #12]
 8005cc8:	b12b      	cbz	r3, 8005cd6 <USBD_LL_DataInStage+0x80>
 8005cca:	f894 2274 	ldrb.w	r2, [r4, #628]	; 0x274
 8005cce:	2a03      	cmp	r2, #3
 8005cd0:	d101      	bne.n	8005cd6 <USBD_LL_DataInStage+0x80>
            pdev->pClass->EP0_TxSent(pdev);
 8005cd2:	4620      	mov	r0, r4
 8005cd4:	4798      	blx	r3
          USBD_LL_StallEP(pdev, 0x80U);
 8005cd6:	2180      	movs	r1, #128	; 0x80
 8005cd8:	4620      	mov	r0, r4
 8005cda:	f00c f9f1 	bl	80120c0 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 8005cde:	4620      	mov	r0, r4
 8005ce0:	f000 fabf 	bl	8006262 <USBD_CtlReceiveStatus>
 8005ce4:	e7d1      	b.n	8005c8a <USBD_LL_DataInStage+0x34>
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 8005ce6:	f032 0304 	bics.w	r3, r2, #4
 8005cea:	d1ce      	bne.n	8005c8a <USBD_LL_DataInStage+0x34>
        USBD_LL_StallEP(pdev, 0x80U);
 8005cec:	2180      	movs	r1, #128	; 0x80
 8005cee:	f00c f9e7 	bl	80120c0 <USBD_LL_StallEP>
 8005cf2:	e7ca      	b.n	8005c8a <USBD_LL_DataInStage+0x34>
    }
  }
  else if((pdev->pClass->DataIn != NULL) &&
 8005cf4:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005cf8:	695b      	ldr	r3, [r3, #20]
 8005cfa:	b133      	cbz	r3, 8005d0a <USBD_LL_DataInStage+0xb4>
 8005cfc:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8005d00:	2a03      	cmp	r2, #3
 8005d02:	d102      	bne.n	8005d0a <USBD_LL_DataInStage+0xb4>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum);
 8005d04:	4798      	blx	r3
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8005d06:	2000      	movs	r0, #0
    pdev->pClass->DataIn(pdev, epnum);
 8005d08:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_FAIL;
 8005d0a:	2002      	movs	r0, #2
}
 8005d0c:	bd70      	pop	{r4, r5, r6, pc}

08005d0e <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8005d0e:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005d10:	2200      	movs	r2, #0
{
 8005d12:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005d14:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8005d16:	2501      	movs	r5, #1

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005d18:	2640      	movs	r6, #64	; 0x40
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005d1a:	2340      	movs	r3, #64	; 0x40
 8005d1c:	f00c f9b2 	bl	8012084 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005d20:	4633      	mov	r3, r6
 8005d22:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8005d24:	f8c4 5144 	str.w	r5, [r4, #324]	; 0x144
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005d28:	f8c4 6150 	str.w	r6, [r4, #336]	; 0x150
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005d2c:	2200      	movs	r2, #0
 8005d2e:	4620      	mov	r0, r4
 8005d30:	f00c f9a8 	bl	8012084 <USBD_LL_OpenEP>
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
  pdev->dev_config= 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 8005d34:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8005d38:	61a5      	str	r5, [r4, #24]
  pdev->ep0_state = USBD_EP0_IDLE;
 8005d3a:	2100      	movs	r1, #0
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8005d3c:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005d3e:	f884 5274 	strb.w	r5, [r4, #628]	; 0x274
  pdev->ep0_state = USBD_EP0_IDLE;
 8005d42:	f8c4 126c 	str.w	r1, [r4, #620]	; 0x26c
  pdev->dev_config= 0U;
 8005d46:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 8005d48:	f8c4 127c 	str.w	r1, [r4, #636]	; 0x27c
  if (pdev->pClassData)
 8005d4c:	b123      	cbz	r3, 8005d58 <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8005d4e:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8005d52:	4620      	mov	r0, r4
 8005d54:	685b      	ldr	r3, [r3, #4]
 8005d56:	4798      	blx	r3
  }

  return USBD_OK;
}
 8005d58:	2000      	movs	r0, #0
 8005d5a:	bd70      	pop	{r4, r5, r6, pc}

08005d5c <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8005d5c:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8005d5e:	2000      	movs	r0, #0
 8005d60:	4770      	bx	lr

08005d62 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8005d62:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8005d66:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8005d6a:	2304      	movs	r3, #4
 8005d6c:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  return USBD_OK;
}
 8005d70:	2000      	movs	r0, #0
 8005d72:	4770      	bx	lr

08005d74 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;
 8005d74:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
 8005d78:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  return USBD_OK;
}
 8005d7c:	2000      	movs	r0, #0
 8005d7e:	4770      	bx	lr

08005d80 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8005d80:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8005d82:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8005d86:	2a03      	cmp	r2, #3
 8005d88:	d104      	bne.n	8005d94 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8005d8a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005d8e:	69db      	ldr	r3, [r3, #28]
 8005d90:	b103      	cbz	r3, 8005d94 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8005d92:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8005d94:	2000      	movs	r0, #0
 8005d96:	bd08      	pop	{r3, pc}

08005d98 <USBD_LL_IsoINIncomplete>:
 8005d98:	2000      	movs	r0, #0
 8005d9a:	4770      	bx	lr

08005d9c <USBD_LL_IsoOUTIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 8005d9c:	2000      	movs	r0, #0
 8005d9e:	4770      	bx	lr

08005da0 <USBD_LL_DevConnected>:
{
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
}
 8005da0:	2000      	movs	r0, #0
 8005da2:	4770      	bx	lr

08005da4 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8005da4:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005da6:	2201      	movs	r2, #1
 8005da8:	f880 2274 	strb.w	r2, [r0, #628]	; 0x274
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8005dac:	f8d0 228c 	ldr.w	r2, [r0, #652]	; 0x28c
 8005db0:	7901      	ldrb	r1, [r0, #4]
 8005db2:	6852      	ldr	r2, [r2, #4]
 8005db4:	4790      	blx	r2

  return USBD_OK;
}
 8005db6:	2000      	movs	r0, #0
 8005db8:	bd08      	pop	{r3, pc}

08005dba <USBD_CtlError.constprop.1>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8005dba:	b510      	push	{r4, lr}
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80U);
 8005dbc:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8005dbe:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80U);
 8005dc0:	f00c f97e 	bl	80120c0 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8005dc4:	4620      	mov	r0, r4
 8005dc6:	2100      	movs	r1, #0
}
 8005dc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0U);
 8005dcc:	f00c b978 	b.w	80120c0 <USBD_LL_StallEP>

08005dd0 <USBD_StdDevReq>:
{
 8005dd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005dd2:	780b      	ldrb	r3, [r1, #0]
 8005dd4:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8005dd8:	2b20      	cmp	r3, #32
{
 8005dda:	4604      	mov	r4, r0
 8005ddc:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005dde:	d014      	beq.n	8005e0a <USBD_StdDevReq+0x3a>
 8005de0:	2b40      	cmp	r3, #64	; 0x40
 8005de2:	d012      	beq.n	8005e0a <USBD_StdDevReq+0x3a>
 8005de4:	2b00      	cmp	r3, #0
 8005de6:	f040 809c 	bne.w	8005f22 <USBD_StdDevReq+0x152>
    switch (req->bRequest)
 8005dea:	784b      	ldrb	r3, [r1, #1]
 8005dec:	2b09      	cmp	r3, #9
 8005dee:	f200 8097 	bhi.w	8005f20 <USBD_StdDevReq+0x150>
 8005df2:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005df6:	00ef      	.short	0x00ef
 8005df8:	00950109 	.word	0x00950109
 8005dfc:	00950102 	.word	0x00950102
 8005e00:	00130089 	.word	0x00130089
 8005e04:	00da0095 	.word	0x00da0095
 8005e08:	00a7      	.short	0x00a7
    pdev->pClass->Setup(pdev, req);
 8005e0a:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8005e0e:	4629      	mov	r1, r5
 8005e10:	689b      	ldr	r3, [r3, #8]
 8005e12:	4620      	mov	r0, r4
 8005e14:	4798      	blx	r3
}
 8005e16:	2000      	movs	r0, #0
 8005e18:	b003      	add	sp, #12
 8005e1a:	bd30      	pop	{r4, r5, pc}
  switch (req->wValue >> 8)
 8005e1c:	8849      	ldrh	r1, [r1, #2]
 8005e1e:	0a0b      	lsrs	r3, r1, #8
 8005e20:	3b01      	subs	r3, #1
 8005e22:	2b0e      	cmp	r3, #14
 8005e24:	d87c      	bhi.n	8005f20 <USBD_StdDevReq+0x150>
 8005e26:	e8df f003 	tbb	[pc, r3]
 8005e2a:	2824      	.short	0x2824
 8005e2c:	5c7b7b35 	.word	0x5c7b7b35
 8005e30:	7b7b7b65 	.word	0x7b7b7b65
 8005e34:	7b7b7b7b 	.word	0x7b7b7b7b
 8005e38:	08          	.byte	0x08
 8005e39:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 8005e3a:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005e3e:	69db      	ldr	r3, [r3, #28]
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8005e40:	7c20      	ldrb	r0, [r4, #16]
 8005e42:	f10d 0106 	add.w	r1, sp, #6
 8005e46:	4798      	blx	r3
  if((len != 0U) && (req->wLength != 0U))
 8005e48:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8005e4c:	b152      	cbz	r2, 8005e64 <USBD_StdDevReq+0x94>
 8005e4e:	88eb      	ldrh	r3, [r5, #6]
 8005e50:	b143      	cbz	r3, 8005e64 <USBD_StdDevReq+0x94>
    len = MIN(len, req->wLength);
 8005e52:	429a      	cmp	r2, r3
 8005e54:	bf28      	it	cs
 8005e56:	461a      	movcs	r2, r3
    USBD_CtlSendData (pdev, pbuf, len);
 8005e58:	4601      	mov	r1, r0
 8005e5a:	4620      	mov	r0, r4
    len = MIN(len, req->wLength);
 8005e5c:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, pbuf, len);
 8005e60:	f000 f9c8 	bl	80061f4 <USBD_CtlSendData>
  if(req->wLength == 0U)
 8005e64:	88eb      	ldrh	r3, [r5, #6]
 8005e66:	2b00      	cmp	r3, #0
 8005e68:	d1d5      	bne.n	8005e16 <USBD_StdDevReq+0x46>
    USBD_CtlSendStatus(pdev);
 8005e6a:	4620      	mov	r0, r4
 8005e6c:	f000 f9ee 	bl	800624c <USBD_CtlSendStatus>
 8005e70:	e7d1      	b.n	8005e16 <USBD_StdDevReq+0x46>
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8005e72:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005e76:	681b      	ldr	r3, [r3, #0]
 8005e78:	e7e2      	b.n	8005e40 <USBD_StdDevReq+0x70>
    if(pdev->dev_speed == USBD_SPEED_HIGH )
 8005e7a:	7c02      	ldrb	r2, [r0, #16]
 8005e7c:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005e80:	b932      	cbnz	r2, 8005e90 <USBD_StdDevReq+0xc0>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8005e82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8005e84:	f10d 0006 	add.w	r0, sp, #6
 8005e88:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8005e8a:	2302      	movs	r3, #2
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8005e8c:	7043      	strb	r3, [r0, #1]
 8005e8e:	e7db      	b.n	8005e48 <USBD_StdDevReq+0x78>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8005e90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005e92:	e7f7      	b.n	8005e84 <USBD_StdDevReq+0xb4>
    switch ((uint8_t)(req->wValue))
 8005e94:	b2c9      	uxtb	r1, r1
 8005e96:	2905      	cmp	r1, #5
 8005e98:	d81c      	bhi.n	8005ed4 <USBD_StdDevReq+0x104>
 8005e9a:	e8df f001 	tbb	[pc, r1]
 8005e9e:	0703      	.short	0x0703
 8005ea0:	17130f0b 	.word	0x17130f0b
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8005ea4:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005ea8:	685b      	ldr	r3, [r3, #4]
 8005eaa:	e7c9      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8005eac:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005eb0:	689b      	ldr	r3, [r3, #8]
 8005eb2:	e7c5      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8005eb4:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005eb8:	68db      	ldr	r3, [r3, #12]
 8005eba:	e7c1      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8005ebc:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005ec0:	691b      	ldr	r3, [r3, #16]
 8005ec2:	e7bd      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8005ec4:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005ec8:	695b      	ldr	r3, [r3, #20]
 8005eca:	e7b9      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8005ecc:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8005ed0:	699b      	ldr	r3, [r3, #24]
 8005ed2:	e7b5      	b.n	8005e40 <USBD_StdDevReq+0x70>
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
 8005ed4:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005ed8:	f10d 0206 	add.w	r2, sp, #6
 8005edc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005ede:	4798      	blx	r3
 8005ee0:	e7b2      	b.n	8005e48 <USBD_StdDevReq+0x78>
    if(pdev->dev_speed == USBD_SPEED_HIGH)
 8005ee2:	7c03      	ldrb	r3, [r0, #16]
 8005ee4:	b9e3      	cbnz	r3, 8005f20 <USBD_StdDevReq+0x150>
      pbuf = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8005ee6:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005eea:	f10d 0006 	add.w	r0, sp, #6
 8005eee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005ef0:	4798      	blx	r3
 8005ef2:	e7a9      	b.n	8005e48 <USBD_StdDevReq+0x78>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )
 8005ef4:	7c03      	ldrb	r3, [r0, #16]
 8005ef6:	b99b      	cbnz	r3, 8005f20 <USBD_StdDevReq+0x150>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8005ef8:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8005efc:	f10d 0006 	add.w	r0, sp, #6
 8005f00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f02:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8005f04:	2307      	movs	r3, #7
 8005f06:	e7c1      	b.n	8005e8c <USBD_StdDevReq+0xbc>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8005f08:	888b      	ldrh	r3, [r1, #4]
 8005f0a:	b94b      	cbnz	r3, 8005f20 <USBD_StdDevReq+0x150>
 8005f0c:	88cb      	ldrh	r3, [r1, #6]
 8005f0e:	b93b      	cbnz	r3, 8005f20 <USBD_StdDevReq+0x150>
 8005f10:	884d      	ldrh	r5, [r1, #2]
 8005f12:	2d7f      	cmp	r5, #127	; 0x7f
 8005f14:	d804      	bhi.n	8005f20 <USBD_StdDevReq+0x150>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005f16:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8005f1a:	2b03      	cmp	r3, #3
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8005f1c:	b2e9      	uxtb	r1, r5
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005f1e:	d103      	bne.n	8005f28 <USBD_StdDevReq+0x158>
      USBD_CtlError(pdev, req);
 8005f20:	4620      	mov	r0, r4
    USBD_CtlError(pdev, req);
 8005f22:	f7ff ff4a 	bl	8005dba <USBD_CtlError.constprop.1>
    break;
 8005f26:	e776      	b.n	8005e16 <USBD_StdDevReq+0x46>
      pdev->dev_address = dev_addr;
 8005f28:	f880 1276 	strb.w	r1, [r0, #630]	; 0x276
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8005f2c:	f00c f8f8 	bl	8012120 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8005f30:	4620      	mov	r0, r4
 8005f32:	f000 f98b 	bl	800624c <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8005f36:	b11d      	cbz	r5, 8005f40 <USBD_StdDevReq+0x170>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8005f38:	2302      	movs	r3, #2
        pdev->dev_state = USBD_STATE_DEFAULT;
 8005f3a:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 8005f3e:	e76a      	b.n	8005e16 <USBD_StdDevReq+0x46>
 8005f40:	2301      	movs	r3, #1
 8005f42:	e7fa      	b.n	8005f3a <USBD_StdDevReq+0x16a>
  cfgidx = (uint8_t)(req->wValue);
 8005f44:	7889      	ldrb	r1, [r1, #2]
 8005f46:	4d36      	ldr	r5, [pc, #216]	; (8006020 <USBD_StdDevReq+0x250>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8005f48:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 8005f4a:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8005f4c:	d8e8      	bhi.n	8005f20 <USBD_StdDevReq+0x150>
    switch (pdev->dev_state)
 8005f4e:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8005f52:	2b02      	cmp	r3, #2
 8005f54:	d008      	beq.n	8005f68 <USBD_StdDevReq+0x198>
 8005f56:	2b03      	cmp	r3, #3
 8005f58:	d015      	beq.n	8005f86 <USBD_StdDevReq+0x1b6>
      USBD_CtlError(pdev, req);
 8005f5a:	f7ff ff2e 	bl	8005dba <USBD_CtlError.constprop.1>
      USBD_ClrClassConfig(pdev, cfgidx);
 8005f5e:	7829      	ldrb	r1, [r5, #0]
 8005f60:	4620      	mov	r0, r4
 8005f62:	f7ff fe0c 	bl	8005b7e <USBD_ClrClassConfig>
 8005f66:	e756      	b.n	8005e16 <USBD_StdDevReq+0x46>
      if (cfgidx)
 8005f68:	2900      	cmp	r1, #0
 8005f6a:	f43f af7e 	beq.w	8005e6a <USBD_StdDevReq+0x9a>
        pdev->dev_config = cfgidx;
 8005f6e:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8005f70:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 8005f72:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8005f74:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8005f78:	4620      	mov	r0, r4
 8005f7a:	f7ff fdf5 	bl	8005b68 <USBD_SetClassConfig>
 8005f7e:	2802      	cmp	r0, #2
 8005f80:	f47f af73 	bne.w	8005e6a <USBD_StdDevReq+0x9a>
 8005f84:	e7cc      	b.n	8005f20 <USBD_StdDevReq+0x150>
      if (cfgidx == 0U)
 8005f86:	b931      	cbnz	r1, 8005f96 <USBD_StdDevReq+0x1c6>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8005f88:	2302      	movs	r3, #2
 8005f8a:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        pdev->dev_config = cfgidx;
 8005f8e:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev, cfgidx);
 8005f90:	f7ff fdf5 	bl	8005b7e <USBD_ClrClassConfig>
 8005f94:	e769      	b.n	8005e6a <USBD_StdDevReq+0x9a>
      else if (cfgidx != pdev->dev_config)
 8005f96:	6841      	ldr	r1, [r0, #4]
 8005f98:	2901      	cmp	r1, #1
 8005f9a:	f43f af66 	beq.w	8005e6a <USBD_StdDevReq+0x9a>
        USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8005f9e:	b2c9      	uxtb	r1, r1
 8005fa0:	f7ff fded 	bl	8005b7e <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8005fa4:	7829      	ldrb	r1, [r5, #0]
 8005fa6:	6061      	str	r1, [r4, #4]
 8005fa8:	e7e6      	b.n	8005f78 <USBD_StdDevReq+0x1a8>
  if (req->wLength != 1U)
 8005faa:	88ca      	ldrh	r2, [r1, #6]
 8005fac:	2a01      	cmp	r2, #1
 8005fae:	d1b7      	bne.n	8005f20 <USBD_StdDevReq+0x150>
    switch (pdev->dev_state)
 8005fb0:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8005fb4:	2b00      	cmp	r3, #0
 8005fb6:	d0b3      	beq.n	8005f20 <USBD_StdDevReq+0x150>
 8005fb8:	2b02      	cmp	r3, #2
 8005fba:	d903      	bls.n	8005fc4 <USBD_StdDevReq+0x1f4>
 8005fbc:	2b03      	cmp	r3, #3
 8005fbe:	d1af      	bne.n	8005f20 <USBD_StdDevReq+0x150>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8005fc0:	1d01      	adds	r1, r0, #4
 8005fc2:	e003      	b.n	8005fcc <USBD_StdDevReq+0x1fc>
      pdev->dev_default_config = 0U;
 8005fc4:	4601      	mov	r1, r0
 8005fc6:	2300      	movs	r3, #0
 8005fc8:	f841 3f08 	str.w	r3, [r1, #8]!
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8005fcc:	4620      	mov	r0, r4
 8005fce:	f000 f911 	bl	80061f4 <USBD_CtlSendData>
 8005fd2:	e720      	b.n	8005e16 <USBD_StdDevReq+0x46>
  switch (pdev->dev_state)
 8005fd4:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8005fd8:	3b01      	subs	r3, #1
 8005fda:	2b02      	cmp	r3, #2
 8005fdc:	d8a0      	bhi.n	8005f20 <USBD_StdDevReq+0x150>
    if(req->wLength != 0x2U)
 8005fde:	88cb      	ldrh	r3, [r1, #6]
 8005fe0:	2b02      	cmp	r3, #2
 8005fe2:	d19d      	bne.n	8005f20 <USBD_StdDevReq+0x150>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 8005fe4:	2301      	movs	r3, #1
 8005fe6:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup)
 8005fe8:	f8d0 327c 	ldr.w	r3, [r0, #636]	; 0x27c
 8005fec:	b10b      	cbz	r3, 8005ff2 <USBD_StdDevReq+0x222>
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 8005fee:	2303      	movs	r3, #3
 8005ff0:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8005ff2:	2202      	movs	r2, #2
 8005ff4:	f104 010c 	add.w	r1, r4, #12
 8005ff8:	e7e8      	b.n	8005fcc <USBD_StdDevReq+0x1fc>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8005ffa:	884b      	ldrh	r3, [r1, #2]
 8005ffc:	2b01      	cmp	r3, #1
 8005ffe:	f47f af0a 	bne.w	8005e16 <USBD_StdDevReq+0x46>
    pdev->dev_remote_wakeup = 1U;
 8006002:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
 8006006:	e730      	b.n	8005e6a <USBD_StdDevReq+0x9a>
  switch (pdev->dev_state)
 8006008:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 800600c:	3b01      	subs	r3, #1
 800600e:	2b02      	cmp	r3, #2
 8006010:	d886      	bhi.n	8005f20 <USBD_StdDevReq+0x150>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8006012:	884b      	ldrh	r3, [r1, #2]
 8006014:	2b01      	cmp	r3, #1
 8006016:	f47f aefe 	bne.w	8005e16 <USBD_StdDevReq+0x46>
      pdev->dev_remote_wakeup = 0U;
 800601a:	2300      	movs	r3, #0
 800601c:	e7f1      	b.n	8006002 <USBD_StdDevReq+0x232>
 800601e:	bf00      	nop
 8006020:	2000029c 	.word	0x2000029c

08006024 <USBD_StdItfReq>:
{
 8006024:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006026:	780b      	ldrb	r3, [r1, #0]
 8006028:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800602c:	2b20      	cmp	r3, #32
{
 800602e:	4604      	mov	r4, r0
 8006030:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006032:	d002      	beq.n	800603a <USBD_StdItfReq+0x16>
 8006034:	2b40      	cmp	r3, #64	; 0x40
 8006036:	d000      	beq.n	800603a <USBD_StdItfReq+0x16>
 8006038:	b9b3      	cbnz	r3, 8006068 <USBD_StdItfReq+0x44>
    switch (pdev->dev_state)
 800603a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 800603e:	3b01      	subs	r3, #1
 8006040:	2b02      	cmp	r3, #2
 8006042:	d810      	bhi.n	8006066 <USBD_StdItfReq+0x42>
      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8006044:	792b      	ldrb	r3, [r5, #4]
 8006046:	2b01      	cmp	r3, #1
 8006048:	d80d      	bhi.n	8006066 <USBD_StdItfReq+0x42>
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup (pdev, req);
 800604a:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 800604e:	4629      	mov	r1, r5
 8006050:	689b      	ldr	r3, [r3, #8]
 8006052:	4620      	mov	r0, r4
 8006054:	4798      	blx	r3
        if ((req->wLength == 0U) && (ret == USBD_OK))
 8006056:	88eb      	ldrh	r3, [r5, #6]
 8006058:	b91b      	cbnz	r3, 8006062 <USBD_StdItfReq+0x3e>
 800605a:	b910      	cbnz	r0, 8006062 <USBD_StdItfReq+0x3e>
          USBD_CtlSendStatus(pdev);
 800605c:	4620      	mov	r0, r4
 800605e:	f000 f8f5 	bl	800624c <USBD_CtlSendStatus>
}
 8006062:	2000      	movs	r0, #0
 8006064:	bd38      	pop	{r3, r4, r5, pc}
      USBD_CtlError(pdev, req);
 8006066:	4620      	mov	r0, r4
    USBD_CtlError(pdev, req);
 8006068:	f7ff fea7 	bl	8005dba <USBD_CtlError.constprop.1>
    break;
 800606c:	e7f9      	b.n	8006062 <USBD_StdItfReq+0x3e>

0800606e <USBD_StdEPReq>:
{
 800606e:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006070:	780a      	ldrb	r2, [r1, #0]
 8006072:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8006076:	2a20      	cmp	r2, #32
{
 8006078:	4604      	mov	r4, r0
 800607a:	460b      	mov	r3, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800607c:	d013      	beq.n	80060a6 <USBD_StdEPReq+0x38>
 800607e:	2a40      	cmp	r2, #64	; 0x40
 8006080:	d011      	beq.n	80060a6 <USBD_StdEPReq+0x38>
 8006082:	b96a      	cbnz	r2, 80060a0 <USBD_StdEPReq+0x32>
    switch (req->bRequest)
 8006084:	785d      	ldrb	r5, [r3, #1]
  ep_addr  = LOBYTE(req->wIndex);
 8006086:	888a      	ldrh	r2, [r1, #4]
    switch (req->bRequest)
 8006088:	2d01      	cmp	r5, #1
  ep_addr  = LOBYTE(req->wIndex);
 800608a:	b2d1      	uxtb	r1, r2
    switch (req->bRequest)
 800608c:	d01f      	beq.n	80060ce <USBD_StdEPReq+0x60>
 800608e:	d335      	bcc.n	80060fc <USBD_StdEPReq+0x8e>
 8006090:	2d03      	cmp	r5, #3
 8006092:	d105      	bne.n	80060a0 <USBD_StdEPReq+0x32>
      switch (pdev->dev_state)
 8006094:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8006098:	2a02      	cmp	r2, #2
 800609a:	d026      	beq.n	80060ea <USBD_StdEPReq+0x7c>
 800609c:	2a03      	cmp	r2, #3
 800609e:	d00a      	beq.n	80060b6 <USBD_StdEPReq+0x48>
    USBD_CtlError(pdev, req);
 80060a0:	f7ff fe8b 	bl	8005dba <USBD_CtlError.constprop.1>
    break;
 80060a4:	e005      	b.n	80060b2 <USBD_StdEPReq+0x44>
    pdev->pClass->Setup (pdev, req);
 80060a6:	f8d4 228c 	ldr.w	r2, [r4, #652]	; 0x28c
 80060aa:	4619      	mov	r1, r3
 80060ac:	6892      	ldr	r2, [r2, #8]
 80060ae:	4620      	mov	r0, r4
 80060b0:	4790      	blx	r2
}
 80060b2:	2000      	movs	r0, #0
 80060b4:	bd38      	pop	{r3, r4, r5, pc}
        if (req->wValue == USB_FEATURE_EP_HALT)
 80060b6:	885a      	ldrh	r2, [r3, #2]
 80060b8:	b92a      	cbnz	r2, 80060c6 <USBD_StdEPReq+0x58>
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 80060ba:	064a      	lsls	r2, r1, #25
 80060bc:	d003      	beq.n	80060c6 <USBD_StdEPReq+0x58>
 80060be:	88db      	ldrh	r3, [r3, #6]
 80060c0:	b90b      	cbnz	r3, 80060c6 <USBD_StdEPReq+0x58>
            USBD_LL_StallEP(pdev, ep_addr);
 80060c2:	f00b fffd 	bl	80120c0 <USBD_LL_StallEP>
        USBD_CtlSendStatus(pdev);
 80060c6:	4620      	mov	r0, r4
 80060c8:	f000 f8c0 	bl	800624c <USBD_CtlSendStatus>
        break;
 80060cc:	e7f1      	b.n	80060b2 <USBD_StdEPReq+0x44>
      switch (pdev->dev_state)
 80060ce:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 80060d2:	2a02      	cmp	r2, #2
 80060d4:	d009      	beq.n	80060ea <USBD_StdEPReq+0x7c>
 80060d6:	2a03      	cmp	r2, #3
 80060d8:	d1e2      	bne.n	80060a0 <USBD_StdEPReq+0x32>
        if (req->wValue == USB_FEATURE_EP_HALT)
 80060da:	885b      	ldrh	r3, [r3, #2]
 80060dc:	2b00      	cmp	r3, #0
 80060de:	d1e8      	bne.n	80060b2 <USBD_StdEPReq+0x44>
          if ((ep_addr & 0x7FU) != 0x00U)
 80060e0:	064d      	lsls	r5, r1, #25
 80060e2:	d0f0      	beq.n	80060c6 <USBD_StdEPReq+0x58>
            USBD_LL_ClearStallEP(pdev, ep_addr);
 80060e4:	f00b fffa 	bl	80120dc <USBD_LL_ClearStallEP>
 80060e8:	e7ed      	b.n	80060c6 <USBD_StdEPReq+0x58>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80060ea:	064b      	lsls	r3, r1, #25
 80060ec:	d017      	beq.n	800611e <USBD_StdEPReq+0xb0>
          USBD_LL_StallEP(pdev, ep_addr);
 80060ee:	f00b ffe7 	bl	80120c0 <USBD_LL_StallEP>
          USBD_LL_StallEP(pdev, 0x80U);
 80060f2:	2180      	movs	r1, #128	; 0x80
 80060f4:	4620      	mov	r0, r4
 80060f6:	f00b ffe3 	bl	80120c0 <USBD_LL_StallEP>
 80060fa:	e7da      	b.n	80060b2 <USBD_StdEPReq+0x44>
      switch (pdev->dev_state)
 80060fc:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8006100:	2b02      	cmp	r3, #2
 8006102:	d00e      	beq.n	8006122 <USBD_StdEPReq+0xb4>
 8006104:	2b03      	cmp	r3, #3
 8006106:	d1cb      	bne.n	80060a0 <USBD_StdEPReq+0x32>
        if((ep_addr & 0x80U) == 0x80U)
 8006108:	f012 0f80 	tst.w	r2, #128	; 0x80
 800610c:	f04f 0314 	mov.w	r3, #20
 8006110:	f001 020f 	and.w	r2, r1, #15
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8006114:	fb03 0202 	mla	r2, r3, r2, r0
        if((ep_addr & 0x80U) == 0x80U)
 8006118:	d012      	beq.n	8006140 <USBD_StdEPReq+0xd2>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800611a:	6992      	ldr	r2, [r2, #24]
 800611c:	b9da      	cbnz	r2, 8006156 <USBD_StdEPReq+0xe8>
          USBD_CtlError(pdev, req);
 800611e:	4620      	mov	r0, r4
 8006120:	e7be      	b.n	80060a0 <USBD_StdEPReq+0x32>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006122:	0649      	lsls	r1, r1, #25
 8006124:	d1fb      	bne.n	800611e <USBD_StdEPReq+0xb0>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8006126:	0613      	lsls	r3, r2, #24
 8006128:	bf4c      	ite	mi
 800612a:	f100 0114 	addmi.w	r1, r0, #20
 800612e:	f500 71a0 	addpl.w	r1, r0, #320	; 0x140
          pep->status = 0x0000U;
 8006132:	2300      	movs	r3, #0
 8006134:	600b      	str	r3, [r1, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8006136:	2202      	movs	r2, #2
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8006138:	4620      	mov	r0, r4
 800613a:	f000 f85b 	bl	80061f4 <USBD_CtlSendData>
          break;
 800613e:	e7b8      	b.n	80060b2 <USBD_StdEPReq+0x44>
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8006140:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
 8006144:	2a00      	cmp	r2, #0
 8006146:	d0ea      	beq.n	800611e <USBD_StdEPReq+0xb0>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8006148:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 800614c:	fb03 0505 	mla	r5, r3, r5, r0
 8006150:	f505 75a0 	add.w	r5, r5, #320	; 0x140
 8006154:	e004      	b.n	8006160 <USBD_StdEPReq+0xf2>
 8006156:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 800615a:	fb05 3503 	mla	r5, r5, r3, r3
 800615e:	4405      	add	r5, r0
          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8006160:	f011 037f 	ands.w	r3, r1, #127	; 0x7f
 8006164:	d103      	bne.n	800616e <USBD_StdEPReq+0x100>
            pep->status = 0x0001U;
 8006166:	602b      	str	r3, [r5, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8006168:	2202      	movs	r2, #2
 800616a:	4629      	mov	r1, r5
 800616c:	e7e4      	b.n	8006138 <USBD_StdEPReq+0xca>
          else if(USBD_LL_IsStallEP(pdev, ep_addr))
 800616e:	4620      	mov	r0, r4
 8006170:	f00b ffc2 	bl	80120f8 <USBD_LL_IsStallEP>
 8006174:	b108      	cbz	r0, 800617a <USBD_StdEPReq+0x10c>
            pep->status = 0x0001U;
 8006176:	2301      	movs	r3, #1
 8006178:	e7f5      	b.n	8006166 <USBD_StdEPReq+0xf8>
            pep->status = 0x0000U;
 800617a:	6028      	str	r0, [r5, #0]
 800617c:	e7f4      	b.n	8006168 <USBD_StdEPReq+0xfa>

0800617e <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 800617e:	780b      	ldrb	r3, [r1, #0]
 8006180:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8006182:	784b      	ldrb	r3, [r1, #1]
 8006184:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8006186:	78ca      	ldrb	r2, [r1, #3]
 8006188:	788b      	ldrb	r3, [r1, #2]
 800618a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800618e:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8006190:	794a      	ldrb	r2, [r1, #5]
 8006192:	790b      	ldrb	r3, [r1, #4]
 8006194:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8006198:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 800619a:	79ca      	ldrb	r2, [r1, #7]
 800619c:	798b      	ldrb	r3, [r1, #6]
 800619e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80061a2:	80c3      	strh	r3, [r0, #6]
 80061a4:	4770      	bx	lr

080061a6 <USBD_CtlError>:
{
 80061a6:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80U);
 80061a8:	2180      	movs	r1, #128	; 0x80
{
 80061aa:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80U);
 80061ac:	f00b ff88 	bl	80120c0 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 80061b0:	4620      	mov	r0, r4
 80061b2:	2100      	movs	r1, #0
}
 80061b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0U);
 80061b8:	f00b bf82 	b.w	80120c0 <USBD_LL_StallEP>

080061bc <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80061bc:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0U;

  if (desc != NULL)
 80061be:	b188      	cbz	r0, 80061e4 <USBD_GetString+0x28>
 80061c0:	4605      	mov	r5, r0
 80061c2:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0U;

    while (*buf != '\0')
 80061c4:	f815 4b01 	ldrb.w	r4, [r5], #1
 80061c8:	b2db      	uxtb	r3, r3
 80061ca:	2c00      	cmp	r4, #0
 80061cc:	d1f9      	bne.n	80061c2 <USBD_GetString+0x6>
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 80061ce:	3301      	adds	r3, #1
 80061d0:	005b      	lsls	r3, r3, #1
 80061d2:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 80061d4:	700b      	strb	r3, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 80061d6:	2303      	movs	r3, #3
 80061d8:	704b      	strb	r3, [r1, #1]
 80061da:	3801      	subs	r0, #1
 80061dc:	2302      	movs	r3, #2
    while (*desc != '\0')
 80061de:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 80061e2:	b905      	cbnz	r5, 80061e6 <USBD_GetString+0x2a>
 80061e4:	bd30      	pop	{r4, r5, pc}
      unicode[idx++] = *desc++;
 80061e6:	1c5a      	adds	r2, r3, #1
 80061e8:	b2d2      	uxtb	r2, r2
 80061ea:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0U;
 80061ec:	3302      	adds	r3, #2
 80061ee:	b2db      	uxtb	r3, r3
 80061f0:	548c      	strb	r4, [r1, r2]
 80061f2:	e7f4      	b.n	80061de <USBD_GetString+0x22>

080061f4 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                     uint16_t len)
{
 80061f4:	b510      	push	{r4, lr}
 80061f6:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80061f8:	2202      	movs	r2, #2
 80061fa:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  pdev->ep_in[0].total_length = len;
 80061fe:	61c3      	str	r3, [r0, #28]
  pdev->ep_in[0].rem_length   = len;

 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8006200:	460a      	mov	r2, r1
  pdev->ep_in[0].rem_length   = len;
 8006202:	6203      	str	r3, [r0, #32]
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8006204:	2100      	movs	r1, #0
 8006206:	f00b ff99 	bl	801213c <USBD_LL_Transmit>

  return USBD_OK;
}
 800620a:	2000      	movs	r0, #0
 800620c:	bd10      	pop	{r4, pc}

0800620e <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData (USBD_HandleTypeDef *pdev,
                                             uint8_t *pbuf, uint16_t len)
{
 800620e:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8006210:	4613      	mov	r3, r2
 8006212:	460a      	mov	r2, r1
 8006214:	2100      	movs	r1, #0
 8006216:	f00b ff91 	bl	801213c <USBD_LL_Transmit>

  return USBD_OK;
}
 800621a:	2000      	movs	r0, #0
 800621c:	bd08      	pop	{r3, pc}

0800621e <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                      uint16_t len)
{
 800621e:	b510      	push	{r4, lr}
 8006220:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8006222:	2203      	movs	r2, #3
 8006224:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  pdev->ep_out[0].total_length = len;
 8006228:	f8c0 3148 	str.w	r3, [r0, #328]	; 0x148
  pdev->ep_out[0].rem_length   = len;

  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 800622c:	460a      	mov	r2, r1
  pdev->ep_out[0].rem_length   = len;
 800622e:	f8c0 314c 	str.w	r3, [r0, #332]	; 0x14c
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8006232:	2100      	movs	r1, #0
 8006234:	f00b ff90 	bl	8012158 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006238:	2000      	movs	r0, #0
 800623a:	bd10      	pop	{r4, pc}

0800623c <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                       uint16_t len)
{
 800623c:	b508      	push	{r3, lr}
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800623e:	4613      	mov	r3, r2
 8006240:	460a      	mov	r2, r1
 8006242:	2100      	movs	r1, #0
 8006244:	f00b ff88 	bl	8012158 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006248:	2000      	movs	r0, #0
 800624a:	bd08      	pop	{r3, pc}

0800624c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus (USBD_HandleTypeDef *pdev)
{
 800624c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800624e:	2304      	movs	r3, #4
 8006250:	f8c0 326c 	str.w	r3, [r0, #620]	; 0x26c

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8006254:	2300      	movs	r3, #0
 8006256:	461a      	mov	r2, r3
 8006258:	4619      	mov	r1, r3
 800625a:	f00b ff6f 	bl	801213c <USBD_LL_Transmit>

  return USBD_OK;
}
 800625e:	2000      	movs	r0, #0
 8006260:	bd08      	pop	{r3, pc}

08006262 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus (USBD_HandleTypeDef *pdev)
{
 8006262:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8006264:	2305      	movs	r3, #5
 8006266:	f8c0 326c 	str.w	r3, [r0, #620]	; 0x26c

 /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 800626a:	2300      	movs	r3, #0
 800626c:	461a      	mov	r2, r3
 800626e:	4619      	mov	r1, r3
 8006270:	f00b ff72 	bl	8012158 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006274:	2000      	movs	r0, #0
 8006276:	bd08      	pop	{r3, pc}

08006278 <flash_data_read_buff>:
#include "CRC_check.h"

uint64_t flash_data_read_buff(uint32_t flash_addr_buff) 
{ 
	return ( *(__IO uint64_t*) flash_addr_buff);
}
 8006278:	e9d0 0100 	ldrd	r0, r1, [r0]
 800627c:	4770      	bx	lr
	...

08006280 <Calibration_Load_Pack>:
	uint8_t buff_array[8] = {0};
	uint64_t buff = 0;
	uint32_t buff_float = 0;
	
void Calibration_Load_Pack(uint32_t Address, uint16_t size, float data[])
{
 8006280:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint16_t idx = 0;
	
	for (uint16_t i = 0; i < (4*size); i+=8){
		addr = Address + i;
 8006284:	f8df a07c 	ldr.w	sl, [pc, #124]	; 8006304 <Calibration_Load_Pack+0x84>
		buff = flash_data_read_buff(Address+i);
 8006288:	f8df b070 	ldr.w	fp, [pc, #112]	; 80062fc <Calibration_Load_Pack+0x7c>
		memcpy(buff_array, &buff, sizeof(uint64_t));
 800628c:	4c1a      	ldr	r4, [pc, #104]	; (80062f8 <Calibration_Load_Pack+0x78>)
{
 800628e:	4681      	mov	r9, r0
 8006290:	4617      	mov	r7, r2
	for (uint16_t i = 0; i < (4*size); i+=8){
 8006292:	ea4f 0881 	mov.w	r8, r1, lsl #2
	uint16_t idx = 0;
 8006296:	2500      	movs	r5, #0
 8006298:	00ae      	lsls	r6, r5, #2
 800629a:	b2b0      	uxth	r0, r6
	for (uint16_t i = 0; i < (4*size); i+=8){
 800629c:	4540      	cmp	r0, r8
 800629e:	db01      	blt.n	80062a4 <Calibration_Load_Pack+0x24>
		memcpy(&data[idx]	, &buff_float, sizeof(uint32_t));
		buff_float	= (uint32_t)buff_array[4]<<24 | (uint32_t)buff_array[5] << 16 | (uint32_t)buff_array[6] << 8 | (uint32_t)buff_array[7];
		memcpy(&data[idx+1]	, &buff_float, sizeof(uint32_t));
		idx+=2;
	}
}
 80062a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		addr = Address + i;
 80062a4:	4448      	add	r0, r9
 80062a6:	f8ca 0000 	str.w	r0, [sl]
		buff = flash_data_read_buff(Address+i);
 80062aa:	f7ff ffe5 	bl	8006278 <flash_data_read_buff>
 80062ae:	17c1      	asrs	r1, r0, #31
 80062b0:	e9cb 0100 	strd	r0, r1, [fp]
		memcpy(buff_array, &buff, sizeof(uint64_t));
 80062b4:	4b11      	ldr	r3, [pc, #68]	; (80062fc <Calibration_Load_Pack+0x7c>)
 80062b6:	cb03      	ldmia	r3!, {r0, r1}
 80062b8:	6020      	str	r0, [r4, #0]
		buff_float	= (uint32_t)buff_array[0]<<24 | (uint32_t)buff_array[1] << 16 | (uint32_t)buff_array[2] << 8 | (uint32_t)buff_array[3];
 80062ba:	7863      	ldrb	r3, [r4, #1]
 80062bc:	7822      	ldrb	r2, [r4, #0]
		memcpy(buff_array, &buff, sizeof(uint64_t));
 80062be:	6061      	str	r1, [r4, #4]
		buff_float	= (uint32_t)buff_array[0]<<24 | (uint32_t)buff_array[1] << 16 | (uint32_t)buff_array[2] << 8 | (uint32_t)buff_array[3];
 80062c0:	041b      	lsls	r3, r3, #16
 80062c2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80062c6:	78e2      	ldrb	r2, [r4, #3]
 80062c8:	4313      	orrs	r3, r2
 80062ca:	78a2      	ldrb	r2, [r4, #2]
 80062cc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		memcpy(&data[idx]	, &buff_float, sizeof(uint32_t));
 80062d0:	f847 3025 	str.w	r3, [r7, r5, lsl #2]
		buff_float	= (uint32_t)buff_array[4]<<24 | (uint32_t)buff_array[5] << 16 | (uint32_t)buff_array[6] << 8 | (uint32_t)buff_array[7];
 80062d4:	7963      	ldrb	r3, [r4, #5]
 80062d6:	7922      	ldrb	r2, [r4, #4]
 80062d8:	041b      	lsls	r3, r3, #16
 80062da:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80062de:	79e2      	ldrb	r2, [r4, #7]
 80062e0:	4313      	orrs	r3, r2
 80062e2:	79a2      	ldrb	r2, [r4, #6]
		memcpy(&data[idx+1]	, &buff_float, sizeof(uint32_t));
 80062e4:	443e      	add	r6, r7
		buff_float	= (uint32_t)buff_array[4]<<24 | (uint32_t)buff_array[5] << 16 | (uint32_t)buff_array[6] << 8 | (uint32_t)buff_array[7];
 80062e6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80062ea:	4a05      	ldr	r2, [pc, #20]	; (8006300 <Calibration_Load_Pack+0x80>)
		idx+=2;
 80062ec:	3502      	adds	r5, #2
		buff_float	= (uint32_t)buff_array[4]<<24 | (uint32_t)buff_array[5] << 16 | (uint32_t)buff_array[6] << 8 | (uint32_t)buff_array[7];
 80062ee:	6013      	str	r3, [r2, #0]
		idx+=2;
 80062f0:	b2ad      	uxth	r5, r5
		memcpy(&data[idx+1]	, &buff_float, sizeof(uint32_t));
 80062f2:	6073      	str	r3, [r6, #4]
 80062f4:	e7d0      	b.n	8006298 <Calibration_Load_Pack+0x18>
 80062f6:	bf00      	nop
 80062f8:	200002a8 	.word	0x200002a8
 80062fc:	200002a0 	.word	0x200002a0
 8006300:	200002b0 	.word	0x200002b0
 8006304:	20084b88 	.word	0x20084b88

08006308 <GUI_OptionMenuRu>:
uint8_t screen_count = 0, screen_count_old = 0, state_Measure_Elements = 0;



void GUI_OptionMenuRu()
{	
 8006308:	b513      	push	{r0, r1, r4, lr}
	GUI_TextRu_Language(10, 86);
 800630a:	2156      	movs	r1, #86	; 0x56
 800630c:	200a      	movs	r0, #10
 800630e:	f009 f955 	bl	800f5bc <GUI_TextRu_Language>
	GUI_TextRu_Russian(118, 86);
 8006312:	2156      	movs	r1, #86	; 0x56
 8006314:	2076      	movs	r0, #118	; 0x76
 8006316:	f009 f983 	bl	800f620 <GUI_TextRu_Russian>
	GUI_Flag_Ru(218, 86);
 800631a:	2156      	movs	r1, #86	; 0x56
 800631c:	20da      	movs	r0, #218	; 0xda
 800631e:	f005 fce2 	bl	800bce6 <GUI_Flag_Ru>
	TFT_DrawLine(10, 120, 262, 120, TFT_White);
 8006322:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8006326:	2378      	movs	r3, #120	; 0x78
 8006328:	4619      	mov	r1, r3
 800632a:	f44f 7283 	mov.w	r2, #262	; 0x106
 800632e:	9400      	str	r4, [sp, #0]
 8006330:	200a      	movs	r0, #10
 8006332:	f00a faa5 	bl	8010880 <TFT_DrawLine>
	GUI_TextRu_Info(10, 145);
 8006336:	2191      	movs	r1, #145	; 0x91
 8006338:	200a      	movs	r0, #10
 800633a:	f009 f9b9 	bl	800f6b0 <GUI_TextRu_Info>
	TFT_DrawLine(10, 183, 262, 183, TFT_White);
 800633e:	23b7      	movs	r3, #183	; 0xb7
 8006340:	4619      	mov	r1, r3
 8006342:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006346:	9400      	str	r4, [sp, #0]
 8006348:	200a      	movs	r0, #10
 800634a:	f00a fa99 	bl	8010880 <TFT_DrawLine>
	
	GUI_TextRu_Mode(10, 209);
 800634e:	21d1      	movs	r1, #209	; 0xd1
 8006350:	200a      	movs	r0, #10
 8006352:	f009 fa4f 	bl	800f7f4 <GUI_TextRu_Mode>
	GUI_Switch_ButtonActive(182, 202, Mode_EL);
 8006356:	4b21      	ldr	r3, [pc, #132]	; (80063dc <GUI_OptionMenuRu+0xd4>)
 8006358:	21ca      	movs	r1, #202	; 0xca
 800635a:	781a      	ldrb	r2, [r3, #0]
 800635c:	20b6      	movs	r0, #182	; 0xb6
 800635e:	f005 fc89 	bl	800bc74 <GUI_Switch_ButtonActive>
	TFT_SetTextColor(TFT_White);
 8006362:	4620      	mov	r0, r4
 8006364:	f00a fcf2 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 8006368:	2063      	movs	r0, #99	; 0x63
 800636a:	f00a fcf5 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800636e:	481c      	ldr	r0, [pc, #112]	; (80063e0 <GUI_OptionMenuRu+0xd8>)
 8006370:	f00a fce6 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(225, 210, 'E' );
 8006374:	2245      	movs	r2, #69	; 0x45
 8006376:	21d2      	movs	r1, #210	; 0xd2
 8006378:	20e1      	movs	r0, #225	; 0xe1
 800637a:	f00a fd57 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(155, 210, 'L');
 800637e:	224c      	movs	r2, #76	; 0x4c
 8006380:	21d2      	movs	r1, #210	; 0xd2
 8006382:	209b      	movs	r0, #155	; 0x9b
 8006384:	f00a fd52 	bl	8010e2c <TFT_DrawChar>
	
	TFT_DrawLine(10, 248, 262, 248, TFT_White);
 8006388:	23f8      	movs	r3, #248	; 0xf8
 800638a:	4619      	mov	r1, r3
 800638c:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006390:	9400      	str	r4, [sp, #0]
 8006392:	200a      	movs	r0, #10
 8006394:	f00a fa74 	bl	8010880 <TFT_DrawLine>
	
	GUI_Text_Bluetooth(10, 275);
 8006398:	f240 1113 	movw	r1, #275	; 0x113
 800639c:	200a      	movs	r0, #10
 800639e:	f007 fe6f 	bl	800e080 <GUI_Text_Bluetooth>
	GUI_Switch_Button(182, 268, Bluetooth);
 80063a2:	4b10      	ldr	r3, [pc, #64]	; (80063e4 <GUI_OptionMenuRu+0xdc>)
 80063a4:	f44f 7186 	mov.w	r1, #268	; 0x10c
 80063a8:	781a      	ldrb	r2, [r3, #0]
 80063aa:	20b6      	movs	r0, #182	; 0xb6
 80063ac:	f005 fc08 	bl	800bbc0 <GUI_Switch_Button>
	GUI_Text_On(222, 275);
 80063b0:	f240 1113 	movw	r1, #275	; 0x113
 80063b4:	20de      	movs	r0, #222	; 0xde
 80063b6:	f008 f941 	bl	800e63c <GUI_Text_On>
	GUI_Text_Off(140, 275);
 80063ba:	f240 1113 	movw	r1, #275	; 0x113
 80063be:	208c      	movs	r0, #140	; 0x8c
 80063c0:	f008 f960 	bl	800e684 <GUI_Text_Off>
	TFT_DrawLine(10, 313, 262, 313, TFT_White);
 80063c4:	f240 1339 	movw	r3, #313	; 0x139
 80063c8:	9400      	str	r4, [sp, #0]
 80063ca:	f44f 7283 	mov.w	r2, #262	; 0x106
 80063ce:	4619      	mov	r1, r3
 80063d0:	200a      	movs	r0, #10
 80063d2:	f00a fa55 	bl	8010880 <TFT_DrawLine>
}
 80063d6:	b002      	add	sp, #8
 80063d8:	bd10      	pop	{r4, pc}
 80063da:	bf00      	nop
 80063dc:	2000019c 	.word	0x2000019c
 80063e0:	200000f8 	.word	0x200000f8
 80063e4:	20084b92 	.word	0x20084b92

080063e8 <GUI_OptionMenuEn>:
void GUI_OptionMenuEn()
{
 80063e8:	b513      	push	{r0, r1, r4, lr}
	GUI_TextEn_Language(10, 88);
 80063ea:	2158      	movs	r1, #88	; 0x58
 80063ec:	200a      	movs	r0, #10
 80063ee:	f008 f9e9 	bl	800e7c4 <GUI_TextEn_Language>
	GUI_TextEn_English(127, 88);
 80063f2:	2158      	movs	r1, #88	; 0x58
 80063f4:	207f      	movs	r0, #127	; 0x7f
 80063f6:	f008 fa33 	bl	800e860 <GUI_TextEn_English>
	GUI_Flag_En(218, 86);
 80063fa:	2156      	movs	r1, #86	; 0x56
 80063fc:	20da      	movs	r0, #218	; 0xda
 80063fe:	f005 fc9c 	bl	800bd3a <GUI_Flag_En>
	TFT_DrawLine(10, 120, 262, 120, TFT_White);
 8006402:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8006406:	2378      	movs	r3, #120	; 0x78
 8006408:	4619      	mov	r1, r3
 800640a:	f44f 7283 	mov.w	r2, #262	; 0x106
 800640e:	9400      	str	r4, [sp, #0]
 8006410:	200a      	movs	r0, #10
 8006412:	f00a fa35 	bl	8010880 <TFT_DrawLine>
	GUI_TextEn_Info(10, 147);
 8006416:	2193      	movs	r1, #147	; 0x93
 8006418:	200a      	movs	r0, #10
 800641a:	f008 fa69 	bl	800e8f0 <GUI_TextEn_Info>
	TFT_DrawLine(10, 183, 262, 183, TFT_White);
 800641e:	23b7      	movs	r3, #183	; 0xb7
 8006420:	4619      	mov	r1, r3
 8006422:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006426:	9400      	str	r4, [sp, #0]
 8006428:	200a      	movs	r0, #10
 800642a:	f00a fa29 	bl	8010880 <TFT_DrawLine>
	
	GUI_TextEn_Mode(10, 211);
 800642e:	21d3      	movs	r1, #211	; 0xd3
 8006430:	200a      	movs	r0, #10
 8006432:	f008 fbf3 	bl	800ec1c <GUI_TextEn_Mode>
	GUI_Switch_ButtonActive(182, 202, Mode_EL);
 8006436:	4b21      	ldr	r3, [pc, #132]	; (80064bc <GUI_OptionMenuEn+0xd4>)
 8006438:	21ca      	movs	r1, #202	; 0xca
 800643a:	781a      	ldrb	r2, [r3, #0]
 800643c:	20b6      	movs	r0, #182	; 0xb6
 800643e:	f005 fc19 	bl	800bc74 <GUI_Switch_ButtonActive>
	TFT_SetTextColor(TFT_White);
 8006442:	4620      	mov	r0, r4
 8006444:	f00a fc82 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 8006448:	2063      	movs	r0, #99	; 0x63
 800644a:	f00a fc85 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800644e:	481c      	ldr	r0, [pc, #112]	; (80064c0 <GUI_OptionMenuEn+0xd8>)
 8006450:	f00a fc76 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(225, 210, 'E' );
 8006454:	2245      	movs	r2, #69	; 0x45
 8006456:	21d2      	movs	r1, #210	; 0xd2
 8006458:	20e1      	movs	r0, #225	; 0xe1
 800645a:	f00a fce7 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(155, 210, 'L');
 800645e:	224c      	movs	r2, #76	; 0x4c
 8006460:	21d2      	movs	r1, #210	; 0xd2
 8006462:	209b      	movs	r0, #155	; 0x9b
 8006464:	f00a fce2 	bl	8010e2c <TFT_DrawChar>
	
	TFT_DrawLine(10, 248, 262, 248, TFT_White);
 8006468:	23f8      	movs	r3, #248	; 0xf8
 800646a:	4619      	mov	r1, r3
 800646c:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006470:	9400      	str	r4, [sp, #0]
 8006472:	200a      	movs	r0, #10
 8006474:	f00a fa04 	bl	8010880 <TFT_DrawLine>
	
	GUI_Text_Bluetooth(10, 275);
 8006478:	f240 1113 	movw	r1, #275	; 0x113
 800647c:	200a      	movs	r0, #10
 800647e:	f007 fdff 	bl	800e080 <GUI_Text_Bluetooth>
	GUI_Switch_Button(182, 268, Bluetooth);
 8006482:	4b10      	ldr	r3, [pc, #64]	; (80064c4 <GUI_OptionMenuEn+0xdc>)
 8006484:	f44f 7186 	mov.w	r1, #268	; 0x10c
 8006488:	781a      	ldrb	r2, [r3, #0]
 800648a:	20b6      	movs	r0, #182	; 0xb6
 800648c:	f005 fb98 	bl	800bbc0 <GUI_Switch_Button>
	GUI_Text_On(222, 275);
 8006490:	f240 1113 	movw	r1, #275	; 0x113
 8006494:	20de      	movs	r0, #222	; 0xde
 8006496:	f008 f8d1 	bl	800e63c <GUI_Text_On>
	GUI_Text_Off(140, 275);
 800649a:	f240 1113 	movw	r1, #275	; 0x113
 800649e:	208c      	movs	r0, #140	; 0x8c
 80064a0:	f008 f8f0 	bl	800e684 <GUI_Text_Off>
	TFT_DrawLine(10, 313, 262, 313, TFT_White);
 80064a4:	f240 1339 	movw	r3, #313	; 0x139
 80064a8:	9400      	str	r4, [sp, #0]
 80064aa:	f44f 7283 	mov.w	r2, #262	; 0x106
 80064ae:	4619      	mov	r1, r3
 80064b0:	200a      	movs	r0, #10
 80064b2:	f00a f9e5 	bl	8010880 <TFT_DrawLine>
}
 80064b6:	b002      	add	sp, #8
 80064b8:	bd10      	pop	{r4, pc}
 80064ba:	bf00      	nop
 80064bc:	2000019c 	.word	0x2000019c
 80064c0:	200000f8 	.word	0x200000f8
 80064c4:	20084b92 	.word	0x20084b92

080064c8 <GUI_Title_Screen>:
void GUI_Title_Screen()
{
 80064c8:	b508      	push	{r3, lr}
//	TFT_FillScreen(TFT_Black_Bkgr);

	TFT_FillScreen_DMA(TFT_Black_Bkgr);
 80064ca:	2063      	movs	r0, #99	; 0x63
 80064cc:	f00a f836 	bl	801053c <TFT_FillScreen_DMA>
	GUI_TitleString_Name(50, 330);
 80064d0:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 80064d4:	2032      	movs	r0, #50	; 0x32
 80064d6:	f008 ffc5 	bl	800f464 <GUI_TitleString_Name>
	GUI_TitleString_Version(180, 420);
 80064da:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
 80064de:	20b4      	movs	r0, #180	; 0xb4
 80064e0:	f009 f834 	bl	800f54c <GUI_TitleString_Version>
	
	Bluetooth = 0x00;
 80064e4:	4a0b      	ldr	r2, [pc, #44]	; (8006514 <GUI_Title_Screen+0x4c>)
	Mode_EL = 0x00;
	Color_Field |= Color_CIE_xy;
 80064e6:	490c      	ldr	r1, [pc, #48]	; (8006518 <GUI_Title_Screen+0x50>)
	Bluetooth = 0x00;
 80064e8:	2300      	movs	r3, #0
 80064ea:	7013      	strb	r3, [r2, #0]
	Mode_EL = 0x00;
 80064ec:	4a0b      	ldr	r2, [pc, #44]	; (800651c <GUI_Title_Screen+0x54>)
 80064ee:	7013      	strb	r3, [r2, #0]
	Color_Field |= Color_CIE_xy;
 80064f0:	780a      	ldrb	r2, [r1, #0]
 80064f2:	f042 0201 	orr.w	r2, r2, #1
 80064f6:	700a      	strb	r2, [r1, #0]
	Measure_Field = 0;
 80064f8:	4a09      	ldr	r2, [pc, #36]	; (8006520 <GUI_Title_Screen+0x58>)
 80064fa:	8013      	strh	r3, [r2, #0]
	Source_Type |= Source_D55;
 80064fc:	4a09      	ldr	r2, [pc, #36]	; (8006524 <GUI_Title_Screen+0x5c>)
 80064fe:	7813      	ldrb	r3, [r2, #0]
 8006500:	f043 0310 	orr.w	r3, r3, #16
 8006504:	7013      	strb	r3, [r2, #0]
	Measure_Color_xy |= CIE_xy_1931_1964;
 8006506:	4a08      	ldr	r2, [pc, #32]	; (8006528 <GUI_Title_Screen+0x60>)
 8006508:	7813      	ldrb	r3, [r2, #0]
 800650a:	f043 0301 	orr.w	r3, r3, #1
 800650e:	7013      	strb	r3, [r2, #0]
 8006510:	bd08      	pop	{r3, pc}
 8006512:	bf00      	nop
 8006514:	20084b92 	.word	0x20084b92
 8006518:	200002b7 	.word	0x200002b7
 800651c:	2000019c 	.word	0x2000019c
 8006520:	200002be 	.word	0x200002be
 8006524:	20084b91 	.word	0x20084b91
 8006528:	200002bc 	.word	0x200002bc

0800652c <Measure_Elements_Draw>:
	}
		Prev_Inf_Screen = Measure_Screen;
}

void Measure_Elements_Draw(uint8_t Measure_Number)
{
 800652c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint16_t Y = 50, limit = 410;

	for (uint8_t state_i = Measure_Number; state_i < 15; state_i++)
	{
		screen_count_old = screen_count;
 8006530:	4dad      	ldr	r5, [pc, #692]	; (80067e8 <Measure_Elements_Draw+0x2bc>)
 8006532:	4fae      	ldr	r7, [pc, #696]	; (80067ec <Measure_Elements_Draw+0x2c0>)
{
 8006534:	4606      	mov	r6, r0
	uint16_t Y = 50, limit = 410;
 8006536:	2432      	movs	r4, #50	; 0x32
	for (uint8_t state_i = Measure_Number; state_i < 15; state_i++)
 8006538:	2e0e      	cmp	r6, #14
 800653a:	f200 809e 	bhi.w	800667a <Measure_Elements_Draw+0x14e>
		screen_count_old = screen_count;
 800653e:	782b      	ldrb	r3, [r5, #0]
 8006540:	703b      	strb	r3, [r7, #0]

		switch(state_i){
 8006542:	2e0d      	cmp	r6, #13
 8006544:	f200 8091 	bhi.w	800666a <Measure_Elements_Draw+0x13e>
 8006548:	e8df f016 	tbh	[pc, r6, lsl #1]
 800654c:	0037000e 	.word	0x0037000e
 8006550:	00690059 	.word	0x00690059
 8006554:	00ba009a 	.word	0x00ba009a
 8006558:	00ed00ce 	.word	0x00ed00ce
 800655c:	011100ff 	.word	0x011100ff
 8006560:	013a0127 	.word	0x013a0127
 8006564:	01910176 	.word	0x01910176
					case 0: if(Measure_Field&Illuminance){
 8006568:	4aa1      	ldr	r2, [pc, #644]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 800656a:	8812      	ldrh	r2, [r2, #0]
 800656c:	07d1      	lsls	r1, r2, #31
 800656e:	d57c      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
					if(Y+35 <= limit){
 8006570:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 8006574:	f280 818b 	bge.w	800688e <Measure_Elements_Draw+0x362>
						Y+=35;
					Mode_EL ?	 GUI_Text_E_Measure(20, Y, E_day, 0):GUI_Text_L_Measure(20, Y, E_day, 0);
 8006578:	4b9e      	ldr	r3, [pc, #632]	; (80067f4 <Measure_Elements_Draw+0x2c8>)
 800657a:	781a      	ldrb	r2, [r3, #0]
 800657c:	4b9e      	ldr	r3, [pc, #632]	; (80067f8 <Measure_Elements_Draw+0x2cc>)
						Y+=35;
 800657e:	f104 0123 	add.w	r1, r4, #35	; 0x23
 8006582:	b289      	uxth	r1, r1
					Mode_EL ?	 GUI_Text_E_Measure(20, Y, E_day, 0):GUI_Text_L_Measure(20, Y, E_day, 0);
 8006584:	b19a      	cbz	r2, 80065ae <Measure_Elements_Draw+0x82>
 8006586:	2200      	movs	r2, #0
 8006588:	ed93 0a00 	vldr	s0, [r3]
 800658c:	2014      	movs	r0, #20
 800658e:	f005 fcf5 	bl	800bf7c <GUI_Text_E_Measure>
									Y+=10;
							}else {screen_count++;}} break;
				case 12: if(Measure_Field&EbEr){
					if(Y+70 <= limit){
						Mode_EL ?	 GUI_Text_EbEr_Measure(10, Y, ELb_Measure, ELr_Measure):GUI_Text_LbLr_Measure(20, Y, ELb_Measure, ELr_Measure);
									Y+=70;
 8006592:	f104 0346 	add.w	r3, r4, #70	; 0x46
 8006596:	b29b      	uxth	r3, r3
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 8006598:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800659c:	9200      	str	r2, [sp, #0]
 800659e:	4619      	mov	r1, r3
 80065a0:	f44f 7283 	mov.w	r2, #262	; 0x106
 80065a4:	200a      	movs	r0, #10
 80065a6:	f00a f96b 	bl	8010880 <TFT_DrawLine>
									Y+=10;
 80065aa:	3450      	adds	r4, #80	; 0x50
 80065ac:	e05c      	b.n	8006668 <Measure_Elements_Draw+0x13c>
					Mode_EL ?	 GUI_Text_E_Measure(20, Y, E_day, 0):GUI_Text_L_Measure(20, Y, E_day, 0);
 80065ae:	ed93 0a00 	vldr	s0, [r3]
 80065b2:	2014      	movs	r0, #20
 80065b4:	f005 fe70 	bl	800c298 <GUI_Text_L_Measure>
 80065b8:	e7eb      	b.n	8006592 <Measure_Elements_Draw+0x66>
				case 1: if(Measure_Field&Irradiance){
 80065ba:	4a8d      	ldr	r2, [pc, #564]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 80065bc:	8812      	ldrh	r2, [r2, #0]
 80065be:	0792      	lsls	r2, r2, #30
 80065c0:	d553      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
					if(Y+35 <= limit){
 80065c2:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 80065c6:	f280 8162 	bge.w	800688e <Measure_Elements_Draw+0x362>
					Mode_EL ?	GUI_Text_E_Measure(20, Y, E_day_Wt, 1):GUI_Text_L_Measure(20, Y, E_day_Wt, 1);
 80065ca:	4b8a      	ldr	r3, [pc, #552]	; (80067f4 <Measure_Elements_Draw+0x2c8>)
 80065cc:	781a      	ldrb	r2, [r3, #0]
 80065ce:	4b8b      	ldr	r3, [pc, #556]	; (80067fc <Measure_Elements_Draw+0x2d0>)
 80065d0:	b16a      	cbz	r2, 80065ee <Measure_Elements_Draw+0xc2>
 80065d2:	2201      	movs	r2, #1
 80065d4:	ed93 0a00 	vldr	s0, [r3]
 80065d8:	4621      	mov	r1, r4
 80065da:	2014      	movs	r0, #20
 80065dc:	f005 fcce 	bl	800bf7c <GUI_Text_E_Measure>
							}else {screen_count++;}} break;
				case 13: if(Measure_Field&SP_measure){
					if(Y+35 <= limit){
						GUI_Text_S_P_Measure(20, Y, SP_Measure);
									Y+=35;
 80065e0:	f104 0323 	add.w	r3, r4, #35	; 0x23
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 80065e4:	f64f 72ff 	movw	r2, #65535	; 0xffff
									Y+=35;
 80065e8:	b29b      	uxth	r3, r3
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 80065ea:	9200      	str	r2, [sp, #0]
 80065ec:	e060      	b.n	80066b0 <Measure_Elements_Draw+0x184>
					Mode_EL ?	GUI_Text_E_Measure(20, Y, E_day_Wt, 1):GUI_Text_L_Measure(20, Y, E_day_Wt, 1);
 80065ee:	2201      	movs	r2, #1
 80065f0:	ed93 0a00 	vldr	s0, [r3]
 80065f4:	4621      	mov	r1, r4
 80065f6:	2014      	movs	r0, #20
 80065f8:	f005 fe4e 	bl	800c298 <GUI_Text_L_Measure>
 80065fc:	e7f0      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
				case 2: if(Measure_Field&PPFD){
 80065fe:	4a7c      	ldr	r2, [pc, #496]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 8006600:	8812      	ldrh	r2, [r2, #0]
 8006602:	0750      	lsls	r0, r2, #29
 8006604:	d531      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
						if(Y+35 <= limit){
 8006606:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 800660a:	f280 8140 	bge.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_PPF_Measure(20, Y, PPFD_PPL_Measure);
 800660e:	4b7c      	ldr	r3, [pc, #496]	; (8006800 <Measure_Elements_Draw+0x2d4>)
 8006610:	4621      	mov	r1, r4
 8006612:	ed93 0a00 	vldr	s0, [r3]
 8006616:	2014      	movs	r0, #20
 8006618:	f005 ff8e 	bl	800c538 <GUI_Text_PPF_Measure>
 800661c:	e7e0      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
				case 3: if(Measure_Field&PPFD_BGR){
 800661e:	4a74      	ldr	r2, [pc, #464]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 8006620:	8812      	ldrh	r2, [r2, #0]
 8006622:	0711      	lsls	r1, r2, #28
 8006624:	d521      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
						if(Y+95 <= limit){
 8006626:	f5b4 7f9e 	cmp.w	r4, #316	; 0x13c
 800662a:	f280 8130 	bge.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_PPFRGB_Measure(20, Y, PPFD_PPL_Red_Measure, PPFD_PPL_Green_Measure, PPFD_PPL_Blue_Measure, PPFD_PPL_Far_Red_Measure);
 800662e:	4b75      	ldr	r3, [pc, #468]	; (8006804 <Measure_Elements_Draw+0x2d8>)
 8006630:	edd3 1a00 	vldr	s3, [r3]
 8006634:	4b74      	ldr	r3, [pc, #464]	; (8006808 <Measure_Elements_Draw+0x2dc>)
 8006636:	ed93 1a00 	vldr	s2, [r3]
 800663a:	4b74      	ldr	r3, [pc, #464]	; (800680c <Measure_Elements_Draw+0x2e0>)
 800663c:	edd3 0a00 	vldr	s1, [r3]
 8006640:	4b73      	ldr	r3, [pc, #460]	; (8006810 <Measure_Elements_Draw+0x2e4>)
 8006642:	4621      	mov	r1, r4
 8006644:	ed93 0a00 	vldr	s0, [r3]
 8006648:	2014      	movs	r0, #20
 800664a:	f006 f843 	bl	800c6d4 <GUI_Text_PPFRGB_Measure>
									Y+=95;
 800664e:	f104 035f 	add.w	r3, r4, #95	; 0x5f
 8006652:	b29b      	uxth	r3, r3
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 8006654:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006658:	9200      	str	r2, [sp, #0]
 800665a:	4619      	mov	r1, r3
 800665c:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006660:	200a      	movs	r0, #10
 8006662:	f00a f90d 	bl	8010880 <TFT_DrawLine>
									Y+=10;
 8006666:	3469      	adds	r4, #105	; 0x69
									Y+=10;
 8006668:	b2a4      	uxth	r4, r4
							}else {screen_count++;}} break;
			default: break;
		}

		if (screen_count != screen_count_old)
 800666a:	782b      	ldrb	r3, [r5, #0]
 800666c:	783a      	ldrb	r2, [r7, #0]
 800666e:	429a      	cmp	r2, r3
 8006670:	f000 8110 	beq.w	8006894 <Measure_Elements_Draw+0x368>
			{
				state_Measure_Elements = state_i;
 8006674:	4a67      	ldr	r2, [pc, #412]	; (8006814 <Measure_Elements_Draw+0x2e8>)
				screen_count_old = screen_count;
 8006676:	703b      	strb	r3, [r7, #0]
				state_Measure_Elements = state_i;
 8006678:	7016      	strb	r6, [r2, #0]
				break;
			}

	}

}
 800667a:	b002      	add	sp, #8
 800667c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				case 4: if(Measure_Field&CCT){
 8006680:	4a5b      	ldr	r2, [pc, #364]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 8006682:	8812      	ldrh	r2, [r2, #0]
 8006684:	05d2      	lsls	r2, r2, #23
 8006686:	d5f0      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
						if(Y+35 <= limit){
 8006688:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 800668c:	f280 80ff 	bge.w	800688e <Measure_Elements_Draw+0x362>
							GUI_Text_CCT_Measure(20, Y,  Tc_Measure == 0xFFFF ? 0 : Tc_Measure); //
 8006690:	4b61      	ldr	r3, [pc, #388]	; (8006818 <Measure_Elements_Draw+0x2ec>)
 8006692:	881a      	ldrh	r2, [r3, #0]
 8006694:	f64f 78ff 	movw	r8, #65535	; 0xffff
 8006698:	4542      	cmp	r2, r8
 800669a:	bf08      	it	eq
 800669c:	2200      	moveq	r2, #0
 800669e:	4621      	mov	r1, r4
 80066a0:	2014      	movs	r0, #20
 80066a2:	f006 fc89 	bl	800cfb8 <GUI_Text_CCT_Measure>
									Y+=35;
 80066a6:	f104 0323 	add.w	r3, r4, #35	; 0x23
 80066aa:	b29b      	uxth	r3, r3
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 80066ac:	f8cd 8000 	str.w	r8, [sp]
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 80066b0:	f44f 7283 	mov.w	r2, #262	; 0x106
 80066b4:	4619      	mov	r1, r3
 80066b6:	200a      	movs	r0, #10
 80066b8:	f00a f8e2 	bl	8010880 <TFT_DrawLine>
									Y+=10;
 80066bc:	342d      	adds	r4, #45	; 0x2d
 80066be:	e7d3      	b.n	8006668 <Measure_Elements_Draw+0x13c>
				case 5: if(Measure_Field&delta_E){
 80066c0:	4a4b      	ldr	r2, [pc, #300]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 80066c2:	8812      	ldrh	r2, [r2, #0]
 80066c4:	0510      	lsls	r0, r2, #20
 80066c6:	d5d0      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
						if(Y+35 <= limit){
 80066c8:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 80066cc:	f280 80df 	bge.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_deltaE_Measure(20, Y, delta_Eab_Measure);
 80066d0:	4b52      	ldr	r3, [pc, #328]	; (800681c <Measure_Elements_Draw+0x2f0>)
 80066d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80066d6:	ee00 3a10 	vmov	s0, r3
 80066da:	4621      	mov	r1, r4
 80066dc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80066e0:	2014      	movs	r0, #20
 80066e2:	f006 fe4d 	bl	800d380 <GUI_Text_deltaE_Measure>
 80066e6:	e77b      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
				case 6: if(Measure_Field&CIE_XYZ){
 80066e8:	4a41      	ldr	r2, [pc, #260]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 80066ea:	8812      	ldrh	r2, [r2, #0]
 80066ec:	06d1      	lsls	r1, r2, #27
 80066ee:	d5bc      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
						if(Y+105 <= limit){
 80066f0:	f5b4 7f99 	cmp.w	r4, #306	; 0x132
 80066f4:	f280 80cb 	bge.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_XYZ_Measure(20, Y, colorimetry_XYZ[0], colorimetry_XYZ[1], colorimetry_XYZ[2]);
 80066f8:	4949      	ldr	r1, [pc, #292]	; (8006820 <Measure_Elements_Draw+0x2f4>)
 80066fa:	884b      	ldrh	r3, [r1, #2]
 80066fc:	880a      	ldrh	r2, [r1, #0]
 80066fe:	8889      	ldrh	r1, [r1, #4]
 8006700:	9100      	str	r1, [sp, #0]
 8006702:	2014      	movs	r0, #20
 8006704:	4621      	mov	r1, r4
 8006706:	f006 fa51 	bl	800cbac <GUI_Text_XYZ_Measure>
									Y+=105;
 800670a:	f104 0369 	add.w	r3, r4, #105	; 0x69
 800670e:	b29b      	uxth	r3, r3
									TFT_DrawLine(10, Y, 262, Y, TFT_White);
 8006710:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006714:	9200      	str	r2, [sp, #0]
 8006716:	4619      	mov	r1, r3
 8006718:	f44f 7283 	mov.w	r2, #262	; 0x106
 800671c:	200a      	movs	r0, #10
 800671e:	f00a f8af 	bl	8010880 <TFT_DrawLine>
									Y+=10;
 8006722:	3473      	adds	r4, #115	; 0x73
 8006724:	e7a0      	b.n	8006668 <Measure_Elements_Draw+0x13c>
				case 7: if(Measure_Field&CIE_xy){
 8006726:	4a32      	ldr	r2, [pc, #200]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 8006728:	8812      	ldrh	r2, [r2, #0]
 800672a:	0692      	lsls	r2, r2, #26
 800672c:	d59d      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
					if(Y+70 <= limit){
 800672e:	f5b4 7faa 	cmp.w	r4, #340	; 0x154
 8006732:	f300 80ac 	bgt.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_xy_Measure(20, Y, colorimetry_xy[0], colorimetry_xy[1]);
 8006736:	4b3b      	ldr	r3, [pc, #236]	; (8006824 <Measure_Elements_Draw+0x2f8>)
 8006738:	4621      	mov	r1, r4
 800673a:	edd3 0a01 	vldr	s1, [r3, #4]
 800673e:	ed93 0a00 	vldr	s0, [r3]
 8006742:	2014      	movs	r0, #20
 8006744:	f006 fb4c 	bl	800cde0 <GUI_Text_xy_Measure>
 8006748:	e723      	b.n	8006592 <Measure_Elements_Draw+0x66>
				case 8: if(Measure_Field&CIE_Luv){
 800674a:	4a29      	ldr	r2, [pc, #164]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 800674c:	8812      	ldrh	r2, [r2, #0]
 800674e:	0650      	lsls	r0, r2, #25
 8006750:	d58b      	bpl.n	800666a <Measure_Elements_Draw+0x13e>
					if(Y+70 <= limit){
 8006752:	f5b4 7faa 	cmp.w	r4, #340	; 0x154
 8006756:	f300 809a 	bgt.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_uv_Measure(20, Y, colorimetry_uv[0], colorimetry_uv[1]);
 800675a:	4b33      	ldr	r3, [pc, #204]	; (8006828 <Measure_Elements_Draw+0x2fc>)
 800675c:	4621      	mov	r1, r4
 800675e:	edd3 0a01 	vldr	s1, [r3, #4]
 8006762:	ed93 0a00 	vldr	s0, [r3]
 8006766:	2014      	movs	r0, #20
 8006768:	f006 fbaa 	bl	800cec0 <GUI_Text_uv_Measure>
 800676c:	e711      	b.n	8006592 <Measure_Elements_Draw+0x66>
				case 9: if(Measure_Field&CIE_Lab){
 800676e:	4a20      	ldr	r2, [pc, #128]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 8006770:	8812      	ldrh	r2, [r2, #0]
 8006772:	0611      	lsls	r1, r2, #24
 8006774:	f57f af79 	bpl.w	800666a <Measure_Elements_Draw+0x13e>
					if(Y+105 <= limit){
 8006778:	f5b4 7f99 	cmp.w	r4, #306	; 0x132
 800677c:	f280 8087 	bge.w	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_LAB_Measure(20, Y, colorimetry_LAB[0],colorimetry_LAB[1], colorimetry_LAB[2]);
 8006780:	492a      	ldr	r1, [pc, #168]	; (800682c <Measure_Elements_Draw+0x300>)
 8006782:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
 8006786:	f9b1 2000 	ldrsh.w	r2, [r1]
 800678a:	f9b1 1004 	ldrsh.w	r1, [r1, #4]
 800678e:	9100      	str	r1, [sp, #0]
 8006790:	2014      	movs	r0, #20
 8006792:	4621      	mov	r1, r4
 8006794:	f007 f8be 	bl	800d914 <GUI_Text_LAB_Measure>
 8006798:	e7b7      	b.n	800670a <Measure_Elements_Draw+0x1de>
				case 10: if(Measure_Field&lambda_d){
 800679a:	4a15      	ldr	r2, [pc, #84]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 800679c:	8812      	ldrh	r2, [r2, #0]
 800679e:	0592      	lsls	r2, r2, #22
 80067a0:	f57f af63 	bpl.w	800666a <Measure_Elements_Draw+0x13e>
					if(Y+35 <= limit){
 80067a4:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 80067a8:	da71      	bge.n	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_lambdaD_Measure(20, Y, lambda_d_Measure);
 80067aa:	4b21      	ldr	r3, [pc, #132]	; (8006830 <Measure_Elements_Draw+0x304>)
 80067ac:	881b      	ldrh	r3, [r3, #0]
 80067ae:	ee00 3a10 	vmov	s0, r3
 80067b2:	4621      	mov	r1, r4
 80067b4:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 80067b8:	2014      	movs	r0, #20
 80067ba:	f006 fcb1 	bl	800d120 <GUI_Text_lambdaD_Measure>
 80067be:	e70f      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
				case 11: if(Measure_Field&lambda_c){
 80067c0:	4a0b      	ldr	r2, [pc, #44]	; (80067f0 <Measure_Elements_Draw+0x2c4>)
 80067c2:	8812      	ldrh	r2, [r2, #0]
 80067c4:	0550      	lsls	r0, r2, #21
 80067c6:	f57f af50 	bpl.w	800666a <Measure_Elements_Draw+0x13e>
					if(Y+35 <= limit){
 80067ca:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 80067ce:	da5e      	bge.n	800688e <Measure_Elements_Draw+0x362>
									GUI_Text_lambdaC_Measure(20, Y, lambda_c_Measure);
 80067d0:	4b18      	ldr	r3, [pc, #96]	; (8006834 <Measure_Elements_Draw+0x308>)
 80067d2:	881b      	ldrh	r3, [r3, #0]
 80067d4:	ee00 3a10 	vmov	s0, r3
 80067d8:	4621      	mov	r1, r4
 80067da:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 80067de:	2014      	movs	r0, #20
 80067e0:	f006 fd36 	bl	800d250 <GUI_Text_lambdaC_Measure>
 80067e4:	e6fc      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
 80067e6:	bf00      	nop
 80067e8:	200002f8 	.word	0x200002f8
 80067ec:	200002f9 	.word	0x200002f9
 80067f0:	200002be 	.word	0x200002be
 80067f4:	2000019c 	.word	0x2000019c
 80067f8:	20085dbc 	.word	0x20085dbc
 80067fc:	2008598c 	.word	0x2008598c
 8006800:	20085994 	.word	0x20085994
 8006804:	20085990 	.word	0x20085990
 8006808:	20085a30 	.word	0x20085a30
 800680c:	20085ca4 	.word	0x20085ca4
 8006810:	20085c48 	.word	0x20085c48
 8006814:	200002fc 	.word	0x200002fc
 8006818:	20084b18 	.word	0x20084b18
 800681c:	20084b8e 	.word	0x20084b8e
 8006820:	20084b2a 	.word	0x20084b2a
 8006824:	20084b38 	.word	0x20084b38
 8006828:	20084b30 	.word	0x20084b30
 800682c:	20084b24 	.word	0x20084b24
 8006830:	20085ca0 	.word	0x20085ca0
 8006834:	20085bc8 	.word	0x20085bc8
				case 12: if(Measure_Field&EbEr){
 8006838:	4a18      	ldr	r2, [pc, #96]	; (800689c <Measure_Elements_Draw+0x370>)
 800683a:	8812      	ldrh	r2, [r2, #0]
 800683c:	04d1      	lsls	r1, r2, #19
 800683e:	f57f af14 	bpl.w	800666a <Measure_Elements_Draw+0x13e>
					if(Y+70 <= limit){
 8006842:	f5b4 7faa 	cmp.w	r4, #340	; 0x154
 8006846:	dc22      	bgt.n	800688e <Measure_Elements_Draw+0x362>
						Mode_EL ?	 GUI_Text_EbEr_Measure(10, Y, ELb_Measure, ELr_Measure):GUI_Text_LbLr_Measure(20, Y, ELb_Measure, ELr_Measure);
 8006848:	4b15      	ldr	r3, [pc, #84]	; (80068a0 <Measure_Elements_Draw+0x374>)
 800684a:	4a16      	ldr	r2, [pc, #88]	; (80068a4 <Measure_Elements_Draw+0x378>)
 800684c:	7819      	ldrb	r1, [r3, #0]
 800684e:	4b16      	ldr	r3, [pc, #88]	; (80068a8 <Measure_Elements_Draw+0x37c>)
 8006850:	edd2 0a00 	vldr	s1, [r2]
 8006854:	ed93 0a00 	vldr	s0, [r3]
 8006858:	b121      	cbz	r1, 8006864 <Measure_Elements_Draw+0x338>
 800685a:	4621      	mov	r1, r4
 800685c:	200a      	movs	r0, #10
 800685e:	f006 fe27 	bl	800d4b0 <GUI_Text_EbEr_Measure>
 8006862:	e696      	b.n	8006592 <Measure_Elements_Draw+0x66>
 8006864:	4621      	mov	r1, r4
 8006866:	2014      	movs	r0, #20
 8006868:	f006 fefa 	bl	800d660 <GUI_Text_LbLr_Measure>
 800686c:	e691      	b.n	8006592 <Measure_Elements_Draw+0x66>
				case 13: if(Measure_Field&SP_measure){
 800686e:	4a0b      	ldr	r2, [pc, #44]	; (800689c <Measure_Elements_Draw+0x370>)
 8006870:	8812      	ldrh	r2, [r2, #0]
 8006872:	0492      	lsls	r2, r2, #18
 8006874:	f57f aef9 	bpl.w	800666a <Measure_Elements_Draw+0x13e>
					if(Y+35 <= limit){
 8006878:	f5b4 7fbc 	cmp.w	r4, #376	; 0x178
 800687c:	da07      	bge.n	800688e <Measure_Elements_Draw+0x362>
						GUI_Text_S_P_Measure(20, Y, SP_Measure);
 800687e:	4b0b      	ldr	r3, [pc, #44]	; (80068ac <Measure_Elements_Draw+0x380>)
 8006880:	4621      	mov	r1, r4
 8006882:	ed93 0a00 	vldr	s0, [r3]
 8006886:	2014      	movs	r0, #20
 8006888:	f006 ffc4 	bl	800d814 <GUI_Text_S_P_Measure>
 800688c:	e6a8      	b.n	80065e0 <Measure_Elements_Draw+0xb4>
							}else {screen_count++;}} break;
 800688e:	3301      	adds	r3, #1
 8006890:	702b      	strb	r3, [r5, #0]
 8006892:	e6ea      	b.n	800666a <Measure_Elements_Draw+0x13e>
	for (uint8_t state_i = Measure_Number; state_i < 15; state_i++)
 8006894:	3601      	adds	r6, #1
 8006896:	b2f6      	uxtb	r6, r6
 8006898:	e64e      	b.n	8006538 <Measure_Elements_Draw+0xc>
 800689a:	bf00      	nop
 800689c:	200002be 	.word	0x200002be
 80068a0:	2000019c 	.word	0x2000019c
 80068a4:	20085db8 	.word	0x20085db8
 80068a8:	20085db4 	.word	0x20085db4
 80068ac:	200002d0 	.word	0x200002d0

080068b0 <GUI_Information_Screen>:
	TFT_FillScreen_DMA(TFT_Red);

}

void GUI_Information_Screen()
{
 80068b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 80068b2:	4b1e      	ldr	r3, [pc, #120]	; (800692c <GUI_Information_Screen+0x7c>)
 80068b4:	4a1e      	ldr	r2, [pc, #120]	; (8006930 <GUI_Information_Screen+0x80>)
 80068b6:	781b      	ldrb	r3, [r3, #0]
 80068b8:	7812      	ldrb	r2, [r2, #0]
 80068ba:	429a      	cmp	r2, r3
 80068bc:	d034      	beq.n	8006928 <GUI_Information_Screen+0x78>
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 80068be:	2063      	movs	r0, #99	; 0x63
 80068c0:	f009 fe3c 	bl	801053c <TFT_FillScreen_DMA>
		if(Language_status == En){
 80068c4:	4b1b      	ldr	r3, [pc, #108]	; (8006934 <GUI_Information_Screen+0x84>)
 80068c6:	491c      	ldr	r1, [pc, #112]	; (8006938 <GUI_Information_Screen+0x88>)
 80068c8:	781b      	ldrb	r3, [r3, #0]
 80068ca:	4a1c      	ldr	r2, [pc, #112]	; (800693c <GUI_Information_Screen+0x8c>)
			GUI_TextEn_Info_Callibration(0, 0, (uint8_t)(Calibration_date&0x00FF), (uint8_t)(Calibration_month&0x00FF), Calibration_year);
 80068cc:	8809      	ldrh	r1, [r1, #0]
 80068ce:	7812      	ldrb	r2, [r2, #0]
 80068d0:	4d1b      	ldr	r5, [pc, #108]	; (8006940 <GUI_Information_Screen+0x90>)
 80068d2:	4c1c      	ldr	r4, [pc, #112]	; (8006944 <GUI_Information_Screen+0x94>)
		if(Language_status == En){
 80068d4:	2b01      	cmp	r3, #1
 80068d6:	4b1c      	ldr	r3, [pc, #112]	; (8006948 <GUI_Information_Screen+0x98>)
			GUI_TextEn_Info_Callibration(0, 0, (uint8_t)(Calibration_date&0x00FF), (uint8_t)(Calibration_month&0x00FF), Calibration_year);
 80068d8:	781b      	ldrb	r3, [r3, #0]
 80068da:	9100      	str	r1, [sp, #0]
 80068dc:	f04f 0100 	mov.w	r1, #0
 80068e0:	4608      	mov	r0, r1
		if(Language_status == En){
 80068e2:	d110      	bne.n	8006906 <GUI_Information_Screen+0x56>
			GUI_TextEn_Info_Callibration(0, 0, (uint8_t)(Calibration_date&0x00FF), (uint8_t)(Calibration_month&0x00FF), Calibration_year);
 80068e4:	f008 fc52 	bl	800f18c <GUI_TextEn_Info_Callibration>
			GUI_TextEn_Info_Serial(0,0, Serial_part_device, Serial_number_device);
 80068e8:	2100      	movs	r1, #0
 80068ea:	4608      	mov	r0, r1
 80068ec:	882b      	ldrh	r3, [r5, #0]
 80068ee:	8822      	ldrh	r2, [r4, #0]
 80068f0:	f008 fcce 	bl	800f290 <GUI_TextEn_Info_Serial>
			GUI_TextEn_Info_Ver(0, 0, VERSION);
 80068f4:	2100      	movs	r1, #0
 80068f6:	ed9f 0a15 	vldr	s0, [pc, #84]	; 800694c <GUI_Information_Screen+0x9c>
 80068fa:	4608      	mov	r0, r1
			GUI_TextRu_Info_Callibration(0, 0,(uint8_t)(Calibration_date&0x00FF), (uint8_t)(Calibration_month&0x00FF), Calibration_year);
			GUI_TextRu_Info_Serial(0,0, Serial_part_device, Serial_number_device);
			GUI_TextRu_Info_Ver(0, 0, VERSION);
		}
	}
}
 80068fc:	b003      	add	sp, #12
 80068fe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			GUI_TextEn_Info_Ver(0, 0, VERSION);
 8006902:	f008 bd3b 	b.w	800f37c <GUI_TextEn_Info_Ver>
			GUI_TextRu_Info_Callibration(0, 0,(uint8_t)(Calibration_date&0x00FF), (uint8_t)(Calibration_month&0x00FF), Calibration_year);
 8006906:	f009 f935 	bl	800fb74 <GUI_TextRu_Info_Callibration>
			GUI_TextRu_Info_Serial(0,0, Serial_part_device, Serial_number_device);
 800690a:	2100      	movs	r1, #0
 800690c:	4608      	mov	r0, r1
 800690e:	882b      	ldrh	r3, [r5, #0]
 8006910:	8822      	ldrh	r2, [r4, #0]
 8006912:	f009 f9ed 	bl	800fcf0 <GUI_TextRu_Info_Serial>
			GUI_TextRu_Info_Ver(0, 0, VERSION);
 8006916:	2100      	movs	r1, #0
 8006918:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 800694c <GUI_Information_Screen+0x9c>
 800691c:	4608      	mov	r0, r1
}
 800691e:	b003      	add	sp, #12
 8006920:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			GUI_TextRu_Info_Ver(0, 0, VERSION);
 8006924:	f009 ba5e 	b.w	800fde4 <GUI_TextRu_Info_Ver>
}
 8006928:	b003      	add	sp, #12
 800692a:	bd30      	pop	{r4, r5, pc}
 800692c:	20000176 	.word	0x20000176
 8006930:	200002b9 	.word	0x200002b9
 8006934:	200002bb 	.word	0x200002bb
 8006938:	20000174 	.word	0x20000174
 800693c:	20000170 	.word	0x20000170
 8006940:	200002d4 	.word	0x200002d4
 8006944:	200002d6 	.word	0x200002d6
 8006948:	20000172 	.word	0x20000172
 800694c:	3f99999a 	.word	0x3f99999a

08006950 <GUI_SD_Write_Screen>:

void GUI_SD_Write_Screen()
{
 8006950:	b538      	push	{r3, r4, r5, lr}

	if(preGUI_screen_state != GUI_screen_state){
 8006952:	4b20      	ldr	r3, [pc, #128]	; (80069d4 <GUI_SD_Write_Screen+0x84>)
 8006954:	4d20      	ldr	r5, [pc, #128]	; (80069d8 <GUI_SD_Write_Screen+0x88>)
 8006956:	781a      	ldrb	r2, [r3, #0]
 8006958:	7829      	ldrb	r1, [r5, #0]
 800695a:	4291      	cmp	r1, r2
 800695c:	d014      	beq.n	8006988 <GUI_SD_Write_Screen+0x38>
		pause = 1;
 800695e:	4b1f      	ldr	r3, [pc, #124]	; (80069dc <GUI_SD_Write_Screen+0x8c>)
 8006960:	2201      	movs	r2, #1
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006962:	2063      	movs	r0, #99	; 0x63
		pause = 1;
 8006964:	701a      	strb	r2, [r3, #0]
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006966:	f009 fde9 	bl	801053c <TFT_FillScreen_DMA>
		if(Language_status == En){
 800696a:	4b1d      	ldr	r3, [pc, #116]	; (80069e0 <GUI_SD_Write_Screen+0x90>)
 800696c:	781b      	ldrb	r3, [r3, #0]
 800696e:	2b01      	cmp	r3, #1
 8006970:	d12a      	bne.n	80069c8 <GUI_SD_Write_Screen+0x78>
			TFT_SetBackColor(TFT_Black_Bkgr);
 8006972:	2063      	movs	r0, #99	; 0x63
 8006974:	f00a f9f0 	bl	8010d58 <TFT_SetBackColor>
			TFT_SetFont(&Font16EN_arch_big);
 8006978:	481a      	ldr	r0, [pc, #104]	; (80069e4 <GUI_SD_Write_Screen+0x94>)
 800697a:	f00a f9e1 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(100, 200, 'W');
 800697e:	2257      	movs	r2, #87	; 0x57
 8006980:	21c8      	movs	r1, #200	; 0xc8
 8006982:	2064      	movs	r0, #100	; 0x64
 8006984:	f00a fa52 	bl	8010e2c <TFT_DrawChar>
//			SD_Witer(sdfile_cnt, Language_status, Memory_Data_satus, Mode_EL, CRICQS_done);

		}
	}

	GUI_Bar_Measure(85, 280, SDWr_Status_bar);
 8006988:	4c17      	ldr	r4, [pc, #92]	; (80069e8 <GUI_SD_Write_Screen+0x98>)
 800698a:	e9d4 0100 	ldrd	r0, r1, [r4]
 800698e:	f7fa f901 	bl	8000b94 <__aeabi_d2f>
 8006992:	f44f 718c 	mov.w	r1, #280	; 0x118
 8006996:	ee00 0a10 	vmov	s0, r0
 800699a:	2055      	movs	r0, #85	; 0x55
 800699c:	f005 fabe 	bl	800bf1c <GUI_Bar_Measure>

	if(SDWr_Status_bar == 1){sdfile_cnt++; write_FileNum = 1; pause = 1; GUI_screen_state = Prev_Inf_Screen;}
 80069a0:	2200      	movs	r2, #0
 80069a2:	4b12      	ldr	r3, [pc, #72]	; (80069ec <GUI_SD_Write_Screen+0x9c>)
 80069a4:	e9d4 0100 	ldrd	r0, r1, [r4]
 80069a8:	f7fa f89a 	bl	8000ae0 <__aeabi_dcmpeq>
 80069ac:	b158      	cbz	r0, 80069c6 <GUI_SD_Write_Screen+0x76>
 80069ae:	4a10      	ldr	r2, [pc, #64]	; (80069f0 <GUI_SD_Write_Screen+0xa0>)
 80069b0:	8813      	ldrh	r3, [r2, #0]
 80069b2:	3301      	adds	r3, #1
 80069b4:	8013      	strh	r3, [r2, #0]
 80069b6:	4a0f      	ldr	r2, [pc, #60]	; (80069f4 <GUI_SD_Write_Screen+0xa4>)
 80069b8:	2301      	movs	r3, #1
 80069ba:	7013      	strb	r3, [r2, #0]
 80069bc:	4a07      	ldr	r2, [pc, #28]	; (80069dc <GUI_SD_Write_Screen+0x8c>)
 80069be:	7013      	strb	r3, [r2, #0]
 80069c0:	4b0d      	ldr	r3, [pc, #52]	; (80069f8 <GUI_SD_Write_Screen+0xa8>)
 80069c2:	781b      	ldrb	r3, [r3, #0]
 80069c4:	702b      	strb	r3, [r5, #0]
 80069c6:	bd38      	pop	{r3, r4, r5, pc}
			GUI_TextRu_WriteSD(80, 120);
 80069c8:	2178      	movs	r1, #120	; 0x78
 80069ca:	2050      	movs	r0, #80	; 0x50
 80069cc:	f009 f950 	bl	800fc70 <GUI_TextRu_WriteSD>
 80069d0:	e7da      	b.n	8006988 <GUI_SD_Write_Screen+0x38>
 80069d2:	bf00      	nop
 80069d4:	20000176 	.word	0x20000176
 80069d8:	200002b9 	.word	0x200002b9
 80069dc:	200002e9 	.word	0x200002e9
 80069e0:	200002bb 	.word	0x200002bb
 80069e4:	200000f8 	.word	0x200000f8
 80069e8:	200002c8 	.word	0x200002c8
 80069ec:	3ff00000 	.word	0x3ff00000
 80069f0:	200002fa 	.word	0x200002fa
 80069f4:	20084b51 	.word	0x20084b51
 80069f8:	20084b8d 	.word	0x20084b8d

080069fc <GUI_Up_Panel>:
}


void GUI_Up_Panel()
{
	GUI_Battery_Level(0, 0, percentage_charge);
 80069fc:	4b0f      	ldr	r3, [pc, #60]	; (8006a3c <GUI_Up_Panel+0x40>)
{
 80069fe:	b507      	push	{r0, r1, r2, lr}
	GUI_Battery_Level(0, 0, percentage_charge);
 8006a00:	2100      	movs	r1, #0
 8006a02:	ed93 0b00 	vldr	d0, [r3]
 8006a06:	4608      	mov	r0, r1
 8006a08:	f007 f8d2 	bl	800dbb0 <GUI_Battery_Level>
	if (Bluetooth == ON){
 8006a0c:	4b0c      	ldr	r3, [pc, #48]	; (8006a40 <GUI_Up_Panel+0x44>)
 8006a0e:	781b      	ldrb	r3, [r3, #0]
 8006a10:	2b01      	cmp	r3, #1
 8006a12:	d106      	bne.n	8006a22 <GUI_Up_Panel+0x26>
		GUI_Bluetooth_Logo(240, 5);
 8006a14:	2105      	movs	r1, #5
 8006a16:	20f0      	movs	r0, #240	; 0xf0
	} else
	{
		TFT_FillRectangle(239, 4, 260, 35, TFT_Black_Bkgr);
	}
}
 8006a18:	b003      	add	sp, #12
 8006a1a:	f85d eb04 	ldr.w	lr, [sp], #4
		GUI_Bluetooth_Logo(240, 5);
 8006a1e:	f004 bc0b 	b.w	800b238 <GUI_Bluetooth_Logo>
		TFT_FillRectangle(239, 4, 260, 35, TFT_Black_Bkgr);
 8006a22:	2363      	movs	r3, #99	; 0x63
 8006a24:	9300      	str	r3, [sp, #0]
 8006a26:	f44f 7282 	mov.w	r2, #260	; 0x104
 8006a2a:	2323      	movs	r3, #35	; 0x23
 8006a2c:	2104      	movs	r1, #4
 8006a2e:	20ef      	movs	r0, #239	; 0xef
 8006a30:	f009 ff83 	bl	801093a <TFT_FillRectangle>
}
 8006a34:	b003      	add	sp, #12
 8006a36:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a3a:	bf00      	nop
 8006a3c:	200002f0 	.word	0x200002f0
 8006a40:	20084b92 	.word	0x20084b92

08006a44 <GUI_Down_Panel>:

void GUI_Down_Panel()
{
 8006a44:	b508      	push	{r3, lr}
	GUI_Button_Settings(1, 426);
 8006a46:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006a4a:	2001      	movs	r0, #1
 8006a4c:	f004 fc46 	bl	800b2dc <GUI_Button_Settings>
	GUI_Button_SD_Card(55, 426, !SD_Detect);
 8006a50:	4b1b      	ldr	r3, [pc, #108]	; (8006ac0 <GUI_Down_Panel+0x7c>)
 8006a52:	781a      	ldrb	r2, [r3, #0]
 8006a54:	fab2 f282 	clz	r2, r2
 8006a58:	0952      	lsrs	r2, r2, #5
 8006a5a:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006a5e:	2037      	movs	r0, #55	; 0x37
 8006a60:	f004 fdf6 	bl	800b650 <GUI_Button_SD_Card>
	GUI_Button_Measure_Start_Pause(109, 426);
 8006a64:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006a68:	206d      	movs	r0, #109	; 0x6d
 8006a6a:	f004 febd 	bl	800b7e8 <GUI_Button_Measure_Start_Pause>

	if(GUI_screen_state >= DataSet1_Screen)
 8006a6e:	4b15      	ldr	r3, [pc, #84]	; (8006ac4 <GUI_Down_Panel+0x80>)
 8006a70:	781b      	ldrb	r3, [r3, #0]
 8006a72:	2b06      	cmp	r3, #6
 8006a74:	d90b      	bls.n	8006a8e <GUI_Down_Panel+0x4a>
	{
		GUI_Button_Down(163, 426);
 8006a76:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006a7a:	20a3      	movs	r0, #163	; 0xa3
 8006a7c:	f004 fc6c 	bl	800b358 <GUI_Button_Down>
		GUI_Button_TFT_On_Off(217, 426);
 8006a80:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006a84:	20d9      	movs	r0, #217	; 0xd9
	else
	{
		GUI_Button_TFT_Rotate(163, 426);
		GUI_Button_Right(217, 426);
	}
}
 8006a86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		GUI_Button_TFT_On_Off(217, 426);
 8006a8a:	f004 bd3e 	b.w	800b50a <GUI_Button_TFT_On_Off>
	}else if(GUI_screen_state <= Measure3_Screen)
 8006a8e:	2b03      	cmp	r3, #3
 8006a90:	d810      	bhi.n	8006ab4 <GUI_Down_Panel+0x70>
		GUI_Button_Down_Active(163, 426, (screen_count > 0));
 8006a92:	4b0d      	ldr	r3, [pc, #52]	; (8006ac8 <GUI_Down_Panel+0x84>)
 8006a94:	781a      	ldrb	r2, [r3, #0]
 8006a96:	3200      	adds	r2, #0
 8006a98:	bf18      	it	ne
 8006a9a:	2201      	movne	r2, #1
 8006a9c:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006aa0:	20a3      	movs	r0, #163	; 0xa3
 8006aa2:	f004 fc9e 	bl	800b3e2 <GUI_Button_Down_Active>
		GUI_Button_Right(217, 426);
 8006aa6:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006aaa:	20d9      	movs	r0, #217	; 0xd9
}
 8006aac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		GUI_Button_Right(217, 426);
 8006ab0:	f004 bce1 	b.w	800b476 <GUI_Button_Right>
		GUI_Button_TFT_Rotate(163, 426);
 8006ab4:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8006ab8:	20a3      	movs	r0, #163	; 0xa3
 8006aba:	f004 fd54 	bl	800b566 <GUI_Button_TFT_Rotate>
 8006abe:	e7f2      	b.n	8006aa6 <GUI_Down_Panel+0x62>
 8006ac0:	20085d70 	.word	0x20085d70
 8006ac4:	200002b9 	.word	0x200002b9
 8006ac8:	200002f8 	.word	0x200002f8

08006acc <GUI_Measure_Screen>:
void GUI_Measure_Screen(){
 8006acc:	b508      	push	{r3, lr}
	if(preGUI_screen_state != GUI_screen_state){
 8006ace:	4a0d      	ldr	r2, [pc, #52]	; (8006b04 <GUI_Measure_Screen+0x38>)
 8006ad0:	4b0d      	ldr	r3, [pc, #52]	; (8006b08 <GUI_Measure_Screen+0x3c>)
 8006ad2:	7812      	ldrb	r2, [r2, #0]
 8006ad4:	781b      	ldrb	r3, [r3, #0]
 8006ad6:	429a      	cmp	r2, r3
 8006ad8:	d00f      	beq.n	8006afa <GUI_Measure_Screen+0x2e>
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006ada:	2063      	movs	r0, #99	; 0x63
 8006adc:	f009 fd2e 	bl	801053c <TFT_FillScreen_DMA>
		screen_count = 0;
 8006ae0:	4b0a      	ldr	r3, [pc, #40]	; (8006b0c <GUI_Measure_Screen+0x40>)
 8006ae2:	2000      	movs	r0, #0
 8006ae4:	7018      	strb	r0, [r3, #0]
		Measure_Elements_Draw(0);
 8006ae6:	f7ff fd21 	bl	800652c <Measure_Elements_Draw>
		GUI_Up_Panel();
 8006aea:	f7ff ff87 	bl	80069fc <GUI_Up_Panel>
		GUI_Down_Panel();
 8006aee:	f7ff ffa9 	bl	8006a44 <GUI_Down_Panel>
		Prev_Inf_Screen = Measure_Screen;
 8006af2:	4b07      	ldr	r3, [pc, #28]	; (8006b10 <GUI_Measure_Screen+0x44>)
 8006af4:	2201      	movs	r2, #1
 8006af6:	701a      	strb	r2, [r3, #0]
 8006af8:	bd08      	pop	{r3, pc}
			Measure_Elements_Draw(0);
 8006afa:	2000      	movs	r0, #0
 8006afc:	f7ff fd16 	bl	800652c <Measure_Elements_Draw>
 8006b00:	e7f7      	b.n	8006af2 <GUI_Measure_Screen+0x26>
 8006b02:	bf00      	nop
 8006b04:	200002b9 	.word	0x200002b9
 8006b08:	20000176 	.word	0x20000176
 8006b0c:	200002f8 	.word	0x200002f8
 8006b10:	20084b8d 	.word	0x20084b8d

08006b14 <GUI_Measure2_Screen>:
	old_meas_type_E = 2; old_meas_type_L = 2;
 8006b14:	4a10      	ldr	r2, [pc, #64]	; (8006b58 <GUI_Measure2_Screen+0x44>)
{
 8006b16:	b510      	push	{r4, lr}
	old_meas_type_E = 2; old_meas_type_L = 2;
 8006b18:	2302      	movs	r3, #2
 8006b1a:	7013      	strb	r3, [r2, #0]
 8006b1c:	4a0f      	ldr	r2, [pc, #60]	; (8006b5c <GUI_Measure2_Screen+0x48>)
 8006b1e:	4c10      	ldr	r4, [pc, #64]	; (8006b60 <GUI_Measure2_Screen+0x4c>)
 8006b20:	7013      	strb	r3, [r2, #0]
	if(preGUI_screen_state != Measure2_Screen){
 8006b22:	4b10      	ldr	r3, [pc, #64]	; (8006b64 <GUI_Measure2_Screen+0x50>)
 8006b24:	781b      	ldrb	r3, [r3, #0]
 8006b26:	2b02      	cmp	r3, #2
 8006b28:	d012      	beq.n	8006b50 <GUI_Measure2_Screen+0x3c>
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006b2a:	2063      	movs	r0, #99	; 0x63
 8006b2c:	f009 fd06 	bl	801053c <TFT_FillScreen_DMA>
		current_state_Measure_Draw = state_Measure_Elements;
 8006b30:	4b0d      	ldr	r3, [pc, #52]	; (8006b68 <GUI_Measure2_Screen+0x54>)
 8006b32:	7818      	ldrb	r0, [r3, #0]
		screen_count = 1;
 8006b34:	4b0d      	ldr	r3, [pc, #52]	; (8006b6c <GUI_Measure2_Screen+0x58>)
		current_state_Measure_Draw = state_Measure_Elements;
 8006b36:	7020      	strb	r0, [r4, #0]
		screen_count = 1;
 8006b38:	2201      	movs	r2, #1
 8006b3a:	701a      	strb	r2, [r3, #0]
		Measure_Elements_Draw(current_state_Measure_Draw);
 8006b3c:	f7ff fcf6 	bl	800652c <Measure_Elements_Draw>
		GUI_Up_Panel();
 8006b40:	f7ff ff5c 	bl	80069fc <GUI_Up_Panel>
		GUI_Down_Panel();
 8006b44:	f7ff ff7e 	bl	8006a44 <GUI_Down_Panel>
	Prev_Inf_Screen = Measure_Screen;
 8006b48:	4b09      	ldr	r3, [pc, #36]	; (8006b70 <GUI_Measure2_Screen+0x5c>)
 8006b4a:	2201      	movs	r2, #1
 8006b4c:	701a      	strb	r2, [r3, #0]
 8006b4e:	bd10      	pop	{r4, pc}
			Measure_Elements_Draw(current_state_Measure_Draw);
 8006b50:	7820      	ldrb	r0, [r4, #0]
 8006b52:	f7ff fceb 	bl	800652c <Measure_Elements_Draw>
 8006b56:	e7f7      	b.n	8006b48 <GUI_Measure2_Screen+0x34>
 8006b58:	2000017a 	.word	0x2000017a
 8006b5c:	2000017b 	.word	0x2000017b
 8006b60:	200002e8 	.word	0x200002e8
 8006b64:	20000176 	.word	0x20000176
 8006b68:	200002fc 	.word	0x200002fc
 8006b6c:	200002f8 	.word	0x200002f8
 8006b70:	20084b8d 	.word	0x20084b8d

08006b74 <GUI_Measure3_Screen>:
{
 8006b74:	b538      	push	{r3, r4, r5, lr}
	old_meas_type_E = 2; old_meas_type_L = 2;
 8006b76:	4b10      	ldr	r3, [pc, #64]	; (8006bb8 <GUI_Measure3_Screen+0x44>)
 8006b78:	4d10      	ldr	r5, [pc, #64]	; (8006bbc <GUI_Measure3_Screen+0x48>)
 8006b7a:	2402      	movs	r4, #2
 8006b7c:	701c      	strb	r4, [r3, #0]
 8006b7e:	4b10      	ldr	r3, [pc, #64]	; (8006bc0 <GUI_Measure3_Screen+0x4c>)
 8006b80:	701c      	strb	r4, [r3, #0]
	if(preGUI_screen_state != Measure3_Screen){
 8006b82:	4b10      	ldr	r3, [pc, #64]	; (8006bc4 <GUI_Measure3_Screen+0x50>)
 8006b84:	781b      	ldrb	r3, [r3, #0]
 8006b86:	2b03      	cmp	r3, #3
 8006b88:	d011      	beq.n	8006bae <GUI_Measure3_Screen+0x3a>
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006b8a:	2063      	movs	r0, #99	; 0x63
 8006b8c:	f009 fcd6 	bl	801053c <TFT_FillScreen_DMA>
		current_state_Measure_Draw= state_Measure_Elements;
 8006b90:	4b0d      	ldr	r3, [pc, #52]	; (8006bc8 <GUI_Measure3_Screen+0x54>)
 8006b92:	7818      	ldrb	r0, [r3, #0]
		screen_count = 2;
 8006b94:	4b0d      	ldr	r3, [pc, #52]	; (8006bcc <GUI_Measure3_Screen+0x58>)
		current_state_Measure_Draw= state_Measure_Elements;
 8006b96:	7028      	strb	r0, [r5, #0]
		screen_count = 2;
 8006b98:	701c      	strb	r4, [r3, #0]
		Measure_Elements_Draw(current_state_Measure_Draw);
 8006b9a:	f7ff fcc7 	bl	800652c <Measure_Elements_Draw>
		GUI_Up_Panel();
 8006b9e:	f7ff ff2d 	bl	80069fc <GUI_Up_Panel>
		GUI_Down_Panel();
 8006ba2:	f7ff ff4f 	bl	8006a44 <GUI_Down_Panel>
	Prev_Inf_Screen = Measure_Screen;
 8006ba6:	4b0a      	ldr	r3, [pc, #40]	; (8006bd0 <GUI_Measure3_Screen+0x5c>)
 8006ba8:	2201      	movs	r2, #1
 8006baa:	701a      	strb	r2, [r3, #0]
 8006bac:	bd38      	pop	{r3, r4, r5, pc}
			Measure_Elements_Draw(current_state_Measure_Draw);
 8006bae:	7828      	ldrb	r0, [r5, #0]
 8006bb0:	f7ff fcbc 	bl	800652c <Measure_Elements_Draw>
 8006bb4:	e7f7      	b.n	8006ba6 <GUI_Measure3_Screen+0x32>
 8006bb6:	bf00      	nop
 8006bb8:	2000017a 	.word	0x2000017a
 8006bbc:	200002e8 	.word	0x200002e8
 8006bc0:	2000017b 	.word	0x2000017b
 8006bc4:	20000176 	.word	0x20000176
 8006bc8:	200002fc 	.word	0x200002fc
 8006bcc:	200002f8 	.word	0x200002f8
 8006bd0:	20084b8d 	.word	0x20084b8d

08006bd4 <GUI_Panels>:

void GUI_Panels()
{
 8006bd4:	b507      	push	{r0, r1, r2, lr}
	if((GUI_screen_state == Measure_Screen && (preGUI_screen_state !=Measure2_Screen
 8006bd6:	4b19      	ldr	r3, [pc, #100]	; (8006c3c <GUI_Panels+0x68>)
 8006bd8:	781a      	ldrb	r2, [r3, #0]
 8006bda:	2a01      	cmp	r2, #1
 8006bdc:	d11c      	bne.n	8006c18 <GUI_Panels+0x44>
 8006bde:	4b18      	ldr	r3, [pc, #96]	; (8006c40 <GUI_Panels+0x6c>)
 8006be0:	7819      	ldrb	r1, [r3, #0]
 8006be2:	2902      	cmp	r1, #2
 8006be4:	d120      	bne.n	8006c28 <GUI_Panels+0x54>
			|| preGUI_screen_state !=Measure3_Screen)) || (GUI_screen_state == Graph_Screen)
 8006be6:	781b      	ldrb	r3, [r3, #0]
 8006be8:	2b03      	cmp	r3, #3
 8006bea:	d11d      	bne.n	8006c28 <GUI_Panels+0x54>
			|| (GUI_screen_state >= DataSet1_Screen && preGUI_screen_state < DataSet1_Screen)
			|| (preGUI_screen_state >= DataSet1_Screen && GUI_screen_state < DataSet1_Screen)
 8006bec:	4b14      	ldr	r3, [pc, #80]	; (8006c40 <GUI_Panels+0x6c>)
 8006bee:	7819      	ldrb	r1, [r3, #0]
 8006bf0:	2906      	cmp	r1, #6
 8006bf2:	d901      	bls.n	8006bf8 <GUI_Panels+0x24>
 8006bf4:	2a06      	cmp	r2, #6
 8006bf6:	d917      	bls.n	8006c28 <GUI_Panels+0x54>
			|| (preGUI_screen_state == Information_Screen))
 8006bf8:	781b      	ldrb	r3, [r3, #0]
 8006bfa:	2b11      	cmp	r3, #17
 8006bfc:	d014      	beq.n	8006c28 <GUI_Panels+0x54>
		GUI_Up_Panel();
		GUI_Down_Panel();
	}
	else
	{
		TFT_FillRectangle(0, 40, 271, 425, TFT_Black_Bkgr);
 8006bfe:	2363      	movs	r3, #99	; 0x63
 8006c00:	9300      	str	r3, [sp, #0]
 8006c02:	f240 120f 	movw	r2, #271	; 0x10f
 8006c06:	f240 13a9 	movw	r3, #425	; 0x1a9
 8006c0a:	2128      	movs	r1, #40	; 0x28
 8006c0c:	2000      	movs	r0, #0
 8006c0e:	f009 fe94 	bl	801093a <TFT_FillRectangle>
	}
}
 8006c12:	b003      	add	sp, #12
 8006c14:	f85d fb04 	ldr.w	pc, [sp], #4
			|| preGUI_screen_state !=Measure3_Screen)) || (GUI_screen_state == Graph_Screen)
 8006c18:	2a04      	cmp	r2, #4
 8006c1a:	d005      	beq.n	8006c28 <GUI_Panels+0x54>
			|| (GUI_screen_state >= DataSet1_Screen && preGUI_screen_state < DataSet1_Screen)
 8006c1c:	2a06      	cmp	r2, #6
 8006c1e:	d9e5      	bls.n	8006bec <GUI_Panels+0x18>
 8006c20:	4b07      	ldr	r3, [pc, #28]	; (8006c40 <GUI_Panels+0x6c>)
 8006c22:	781b      	ldrb	r3, [r3, #0]
 8006c24:	2b06      	cmp	r3, #6
 8006c26:	d8e1      	bhi.n	8006bec <GUI_Panels+0x18>
		TFT_FillScreen_DMA(TFT_Black_Bkgr);
 8006c28:	2063      	movs	r0, #99	; 0x63
 8006c2a:	f009 fc87 	bl	801053c <TFT_FillScreen_DMA>
		GUI_Up_Panel();
 8006c2e:	f7ff fee5 	bl	80069fc <GUI_Up_Panel>
}
 8006c32:	b003      	add	sp, #12
 8006c34:	f85d eb04 	ldr.w	lr, [sp], #4
		GUI_Down_Panel();
 8006c38:	f7ff bf04 	b.w	8006a44 <GUI_Down_Panel>
 8006c3c:	200002b9 	.word	0x200002b9
 8006c40:	20000176 	.word	0x20000176

08006c44 <GUI_DataSet1_Screen>:
{
 8006c44:	b537      	push	{r0, r1, r2, r4, r5, lr}
	old_meas_type_E = 2; old_meas_type_L = 2;
 8006c46:	4a29      	ldr	r2, [pc, #164]	; (8006cec <GUI_DataSet1_Screen+0xa8>)
 8006c48:	4c29      	ldr	r4, [pc, #164]	; (8006cf0 <GUI_DataSet1_Screen+0xac>)
 8006c4a:	4d2a      	ldr	r5, [pc, #168]	; (8006cf4 <GUI_DataSet1_Screen+0xb0>)
 8006c4c:	2302      	movs	r3, #2
 8006c4e:	7013      	strb	r3, [r2, #0]
 8006c50:	4a29      	ldr	r2, [pc, #164]	; (8006cf8 <GUI_DataSet1_Screen+0xb4>)
 8006c52:	7013      	strb	r3, [r2, #0]
	if(preGUI_screen_state != GUI_screen_state || Mode_EL_Old != Mode_EL || Language_status_prev != Language_status){
 8006c54:	4b29      	ldr	r3, [pc, #164]	; (8006cfc <GUI_DataSet1_Screen+0xb8>)
 8006c56:	4a2a      	ldr	r2, [pc, #168]	; (8006d00 <GUI_DataSet1_Screen+0xbc>)
 8006c58:	781b      	ldrb	r3, [r3, #0]
 8006c5a:	7812      	ldrb	r2, [r2, #0]
 8006c5c:	429a      	cmp	r2, r3
 8006c5e:	4a29      	ldr	r2, [pc, #164]	; (8006d04 <GUI_DataSet1_Screen+0xc0>)
 8006c60:	4b29      	ldr	r3, [pc, #164]	; (8006d08 <GUI_DataSet1_Screen+0xc4>)
 8006c62:	d107      	bne.n	8006c74 <GUI_DataSet1_Screen+0x30>
 8006c64:	7810      	ldrb	r0, [r2, #0]
 8006c66:	7821      	ldrb	r1, [r4, #0]
 8006c68:	4288      	cmp	r0, r1
 8006c6a:	d103      	bne.n	8006c74 <GUI_DataSet1_Screen+0x30>
 8006c6c:	7818      	ldrb	r0, [r3, #0]
 8006c6e:	7829      	ldrb	r1, [r5, #0]
 8006c70:	4288      	cmp	r0, r1
 8006c72:	d027      	beq.n	8006cc4 <GUI_DataSet1_Screen+0x80>
		Mode_EL_Old = Mode_EL;
 8006c74:	7821      	ldrb	r1, [r4, #0]
 8006c76:	7011      	strb	r1, [r2, #0]
		Language_status_prev = Language_status;
 8006c78:	782a      	ldrb	r2, [r5, #0]
 8006c7a:	701a      	strb	r2, [r3, #0]
		GUI_Panels();
 8006c7c:	f7ff ffaa 	bl	8006bd4 <GUI_Panels>
		Prev_Inf_Screen2 = DataSet1_Screen;
 8006c80:	4b22      	ldr	r3, [pc, #136]	; (8006d0c <GUI_DataSet1_Screen+0xc8>)
 8006c82:	2207      	movs	r2, #7
 8006c84:	701a      	strb	r2, [r3, #0]
		if(Language_status == Ru){
 8006c86:	782b      	ldrb	r3, [r5, #0]
 8006c88:	bb0b      	cbnz	r3, 8006cce <GUI_DataSet1_Screen+0x8a>
			GUI_OptionMenuRu();
 8006c8a:	f7ff fb3d 	bl	8006308 <GUI_OptionMenuRu>
			Mode_EL ? GUI_TextRu_Illuminance(10, 337):GUI_TextRu_Luminance(10, 337);
 8006c8e:	7823      	ldrb	r3, [r4, #0]
 8006c90:	f240 1151 	movw	r1, #337	; 0x151
 8006c94:	200a      	movs	r0, #10
 8006c96:	b1bb      	cbz	r3, 8006cc8 <GUI_DataSet1_Screen+0x84>
 8006c98:	f008 fde6 	bl	800f868 <GUI_TextRu_Illuminance>
		GUI_CheckBox(200, 327, Measure_Field&Illuminance);
 8006c9c:	4b1c      	ldr	r3, [pc, #112]	; (8006d10 <GUI_DataSet1_Screen+0xcc>)
 8006c9e:	881a      	ldrh	r2, [r3, #0]
 8006ca0:	f240 1147 	movw	r1, #327	; 0x147
 8006ca4:	f002 0201 	and.w	r2, r2, #1
 8006ca8:	20c8      	movs	r0, #200	; 0xc8
 8006caa:	f004 ff19 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 377, 262, 377, TFT_White);
 8006cae:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006cb2:	9300      	str	r3, [sp, #0]
 8006cb4:	f240 1379 	movw	r3, #377	; 0x179
 8006cb8:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006cbc:	4619      	mov	r1, r3
 8006cbe:	200a      	movs	r0, #10
 8006cc0:	f009 fdde 	bl	8010880 <TFT_DrawLine>
}
 8006cc4:	b003      	add	sp, #12
 8006cc6:	bd30      	pop	{r4, r5, pc}
			Mode_EL ? GUI_TextRu_Illuminance(10, 337):GUI_TextRu_Luminance(10, 337);
 8006cc8:	f009 fb0e 	bl	80102e8 <GUI_TextRu_Luminance>
 8006ccc:	e7e6      	b.n	8006c9c <GUI_DataSet1_Screen+0x58>
		else if (Language_status == En) {
 8006cce:	2b01      	cmp	r3, #1
 8006cd0:	d1e4      	bne.n	8006c9c <GUI_DataSet1_Screen+0x58>
			GUI_OptionMenuEn();
 8006cd2:	f7ff fb89 	bl	80063e8 <GUI_OptionMenuEn>
			Mode_EL ? GUI_TextEn_Illuminance(10, 339):GUI_TextEn_Luminance(10, 339);
 8006cd6:	7823      	ldrb	r3, [r4, #0]
 8006cd8:	f240 1153 	movw	r1, #339	; 0x153
 8006cdc:	200a      	movs	r0, #10
 8006cde:	b113      	cbz	r3, 8006ce6 <GUI_DataSet1_Screen+0xa2>
 8006ce0:	f007 ff38 	bl	800eb54 <GUI_TextEn_Illuminance>
 8006ce4:	e7da      	b.n	8006c9c <GUI_DataSet1_Screen+0x58>
 8006ce6:	f007 fedf 	bl	800eaa8 <GUI_TextEn_Luminance>
 8006cea:	e7d7      	b.n	8006c9c <GUI_DataSet1_Screen+0x58>
 8006cec:	2000017a 	.word	0x2000017a
 8006cf0:	2000019c 	.word	0x2000019c
 8006cf4:	200002bb 	.word	0x200002bb
 8006cf8:	2000017b 	.word	0x2000017b
 8006cfc:	20000176 	.word	0x20000176
 8006d00:	200002b9 	.word	0x200002b9
 8006d04:	20084b93 	.word	0x20084b93
 8006d08:	20084b8c 	.word	0x20084b8c
 8006d0c:	20085120 	.word	0x20085120
 8006d10:	200002be 	.word	0x200002be

08006d14 <GUI_DataSet2_Screen>:
{
 8006d14:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 8006d16:	4b5b      	ldr	r3, [pc, #364]	; (8006e84 <GUI_DataSet2_Screen+0x170>)
 8006d18:	4a5b      	ldr	r2, [pc, #364]	; (8006e88 <GUI_DataSet2_Screen+0x174>)
 8006d1a:	781b      	ldrb	r3, [r3, #0]
 8006d1c:	7812      	ldrb	r2, [r2, #0]
 8006d1e:	429a      	cmp	r2, r3
 8006d20:	d069      	beq.n	8006df6 <GUI_DataSet2_Screen+0xe2>
			GUI_Panels();
 8006d22:	f7ff ff57 	bl	8006bd4 <GUI_Panels>
			if(Language_status == Ru){
 8006d26:	4b59      	ldr	r3, [pc, #356]	; (8006e8c <GUI_DataSet2_Screen+0x178>)
 8006d28:	781b      	ldrb	r3, [r3, #0]
 8006d2a:	2b00      	cmp	r3, #0
 8006d2c:	d168      	bne.n	8006e00 <GUI_DataSet2_Screen+0xec>
				Mode_EL ? 	GUI_TextRu_Irradiance(18, 82):GUI_TextRu_Radiance(18, 82);
 8006d2e:	4b58      	ldr	r3, [pc, #352]	; (8006e90 <GUI_DataSet2_Screen+0x17c>)
 8006d30:	781b      	ldrb	r3, [r3, #0]
 8006d32:	2152      	movs	r1, #82	; 0x52
 8006d34:	2012      	movs	r0, #18
 8006d36:	2b00      	cmp	r3, #0
 8006d38:	d05f      	beq.n	8006dfa <GUI_DataSet2_Screen+0xe6>
 8006d3a:	f009 fa6b 	bl	8010214 <GUI_TextRu_Irradiance>
				GUI_CheckBox(200, 70, Measure_Field&Irradiance);
 8006d3e:	4c55      	ldr	r4, [pc, #340]	; (8006e94 <GUI_DataSet2_Screen+0x180>)
 8006d40:	8822      	ldrh	r2, [r4, #0]
 8006d42:	2146      	movs	r1, #70	; 0x46
 8006d44:	f002 0202 	and.w	r2, r2, #2
 8006d48:	20c8      	movs	r0, #200	; 0xc8
 8006d4a:	f004 fec9 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 120, 262, 120, TFT_White);
 8006d4e:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8006d52:	2378      	movs	r3, #120	; 0x78
 8006d54:	4619      	mov	r1, r3
 8006d56:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006d5a:	200a      	movs	r0, #10
 8006d5c:	9500      	str	r5, [sp, #0]
 8006d5e:	f009 fd8f 	bl	8010880 <TFT_DrawLine>
				GUI_TextRu_PPF(10, 145);
 8006d62:	2191      	movs	r1, #145	; 0x91
 8006d64:	200a      	movs	r0, #10
 8006d66:	f008 fde9 	bl	800f93c <GUI_TextRu_PPF>
				GUI_CheckBox(200, 133, Measure_Field&PPFD);
 8006d6a:	8822      	ldrh	r2, [r4, #0]
 8006d6c:	2185      	movs	r1, #133	; 0x85
 8006d6e:	f002 0204 	and.w	r2, r2, #4
 8006d72:	20c8      	movs	r0, #200	; 0xc8
 8006d74:	f004 feb4 	bl	800bae0 <GUI_CheckBox>
				GUI_TextRu_PPF_RGB(10, 209);
 8006d78:	21d1      	movs	r1, #209	; 0xd1
 8006d7a:	200a      	movs	r0, #10
 8006d7c:	f008 fe02 	bl	800f984 <GUI_TextRu_PPF_RGB>
				GUI_CheckBox(200, 198, Measure_Field&PPFD_BGR);
 8006d80:	8822      	ldrh	r2, [r4, #0]
 8006d82:	21c6      	movs	r1, #198	; 0xc6
 8006d84:	f002 0208 	and.w	r2, r2, #8
 8006d88:	20c8      	movs	r0, #200	; 0xc8
 8006d8a:	f004 fea9 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 248, 262, 248, TFT_White);
 8006d8e:	23f8      	movs	r3, #248	; 0xf8
 8006d90:	4619      	mov	r1, r3
 8006d92:	200a      	movs	r0, #10
 8006d94:	9500      	str	r5, [sp, #0]
 8006d96:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006d9a:	f009 fd71 	bl	8010880 <TFT_DrawLine>
				GUI_TextRu_CCT(20, 275);
 8006d9e:	f240 1113 	movw	r1, #275	; 0x113
 8006da2:	2014      	movs	r0, #20
 8006da4:	f009 f86a 	bl	800fe7c <GUI_TextRu_CCT>
				GUI_CheckBox(200, 263, Measure_Field&CCT);
 8006da8:	8822      	ldrh	r2, [r4, #0]
 8006daa:	f240 1107 	movw	r1, #263	; 0x107
 8006dae:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8006db2:	20c8      	movs	r0, #200	; 0xc8
 8006db4:	f004 fe94 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 313, 262, 313, TFT_White);
 8006db8:	f240 1339 	movw	r3, #313	; 0x139
 8006dbc:	4619      	mov	r1, r3
 8006dbe:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006dc2:	200a      	movs	r0, #10
 8006dc4:	9500      	str	r5, [sp, #0]
 8006dc6:	f009 fd5b 	bl	8010880 <TFT_DrawLine>
				GUI_Text_deltaE(20, 337);
 8006dca:	f240 1151 	movw	r1, #337	; 0x151
 8006dce:	2014      	movs	r0, #20
 8006dd0:	f007 fbb0 	bl	800e534 <GUI_Text_deltaE>
				GUI_CheckBox(200, 327, Measure_Field&delta_E);
 8006dd4:	8822      	ldrh	r2, [r4, #0]
 8006dd6:	f240 1147 	movw	r1, #327	; 0x147
 8006dda:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8006dde:	20c8      	movs	r0, #200	; 0xc8
 8006de0:	f004 fe7e 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 377, 262, 377, TFT_White);
 8006de4:	f240 1379 	movw	r3, #377	; 0x179
 8006de8:	9500      	str	r5, [sp, #0]
 8006dea:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006dee:	4619      	mov	r1, r3
 8006df0:	200a      	movs	r0, #10
 8006df2:	f009 fd45 	bl	8010880 <TFT_DrawLine>
}
 8006df6:	b003      	add	sp, #12
 8006df8:	bd30      	pop	{r4, r5, pc}
				Mode_EL ? 	GUI_TextRu_Irradiance(18, 82):GUI_TextRu_Radiance(18, 82);
 8006dfa:	f009 fabd 	bl	8010378 <GUI_TextRu_Radiance>
 8006dfe:	e79e      	b.n	8006d3e <GUI_DataSet2_Screen+0x2a>
			else if(Language_status == En){
 8006e00:	2b01      	cmp	r3, #1
 8006e02:	d1f8      	bne.n	8006df6 <GUI_DataSet2_Screen+0xe2>
				Mode_EL ? 	GUI_TextEn_Irradiance(18, 84) : GUI_TextEn_Radiance(18, 84);
 8006e04:	4b22      	ldr	r3, [pc, #136]	; (8006e90 <GUI_DataSet2_Screen+0x17c>)
 8006e06:	781b      	ldrb	r3, [r3, #0]
 8006e08:	2154      	movs	r1, #84	; 0x54
 8006e0a:	2012      	movs	r0, #18
 8006e0c:	b3bb      	cbz	r3, 8006e7e <GUI_DataSet2_Screen+0x16a>
 8006e0e:	f007 fdef 	bl	800e9f0 <GUI_TextEn_Irradiance>
				GUI_CheckBox(200, 70, Measure_Field&Irradiance);
 8006e12:	4c20      	ldr	r4, [pc, #128]	; (8006e94 <GUI_DataSet2_Screen+0x180>)
 8006e14:	8822      	ldrh	r2, [r4, #0]
 8006e16:	2146      	movs	r1, #70	; 0x46
 8006e18:	f002 0202 	and.w	r2, r2, #2
 8006e1c:	20c8      	movs	r0, #200	; 0xc8
 8006e1e:	f004 fe5f 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 120, 262, 120, TFT_White);
 8006e22:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8006e26:	2378      	movs	r3, #120	; 0x78
 8006e28:	4619      	mov	r1, r3
 8006e2a:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006e2e:	9500      	str	r5, [sp, #0]
 8006e30:	200a      	movs	r0, #10
 8006e32:	f009 fd25 	bl	8010880 <TFT_DrawLine>
				GUI_TextEn_PPFD(10, 147);
 8006e36:	2193      	movs	r1, #147	; 0x93
 8006e38:	200a      	movs	r0, #10
 8006e3a:	f007 ff21 	bl	800ec80 <GUI_TextEn_PPFD>
				GUI_CheckBox(200, 133, Measure_Field&PPFD);
 8006e3e:	8822      	ldrh	r2, [r4, #0]
 8006e40:	2185      	movs	r1, #133	; 0x85
 8006e42:	f002 0204 	and.w	r2, r2, #4
 8006e46:	20c8      	movs	r0, #200	; 0xc8
 8006e48:	f004 fe4a 	bl	800bae0 <GUI_CheckBox>
				GUI_TextEn_B_G_R_FR(10, 211);
 8006e4c:	21d3      	movs	r1, #211	; 0xd3
 8006e4e:	200a      	movs	r0, #10
 8006e50:	f007 ffac 	bl	800edac <GUI_TextEn_B_G_R_FR>
				GUI_CheckBox(200, 198, Measure_Field&PPFD_BGR);
 8006e54:	8822      	ldrh	r2, [r4, #0]
 8006e56:	21c6      	movs	r1, #198	; 0xc6
 8006e58:	f002 0208 	and.w	r2, r2, #8
 8006e5c:	20c8      	movs	r0, #200	; 0xc8
 8006e5e:	f004 fe3f 	bl	800bae0 <GUI_CheckBox>
				TFT_DrawLine(10, 248, 262, 248, TFT_White);
 8006e62:	23f8      	movs	r3, #248	; 0xf8
 8006e64:	4619      	mov	r1, r3
 8006e66:	9500      	str	r5, [sp, #0]
 8006e68:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006e6c:	200a      	movs	r0, #10
 8006e6e:	f009 fd07 	bl	8010880 <TFT_DrawLine>
				GUI_TextEn_CCT(20, 277);
 8006e72:	f240 1115 	movw	r1, #277	; 0x115
 8006e76:	2014      	movs	r0, #20
 8006e78:	f007 ffe0 	bl	800ee3c <GUI_TextEn_CCT>
 8006e7c:	e794      	b.n	8006da8 <GUI_DataSet2_Screen+0x94>
				Mode_EL ? 	GUI_TextEn_Irradiance(18, 84) : GUI_TextEn_Radiance(18, 84);
 8006e7e:	f007 fd69 	bl	800e954 <GUI_TextEn_Radiance>
 8006e82:	e7c6      	b.n	8006e12 <GUI_DataSet2_Screen+0xfe>
 8006e84:	20000176 	.word	0x20000176
 8006e88:	200002b9 	.word	0x200002b9
 8006e8c:	200002bb 	.word	0x200002bb
 8006e90:	2000019c 	.word	0x2000019c
 8006e94:	200002be 	.word	0x200002be

08006e98 <GUI_DataSet3_Screen>:
{
 8006e98:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if(preGUI_screen_state != GUI_screen_state){
 8006e9a:	4b35      	ldr	r3, [pc, #212]	; (8006f70 <GUI_DataSet3_Screen+0xd8>)
 8006e9c:	4a35      	ldr	r2, [pc, #212]	; (8006f74 <GUI_DataSet3_Screen+0xdc>)
 8006e9e:	781b      	ldrb	r3, [r3, #0]
 8006ea0:	7812      	ldrb	r2, [r2, #0]
 8006ea2:	429a      	cmp	r2, r3
 8006ea4:	d061      	beq.n	8006f6a <GUI_DataSet3_Screen+0xd2>
		GUI_CheckBox(200, 70, Measure_Field&CIE_XYZ);
 8006ea6:	4c34      	ldr	r4, [pc, #208]	; (8006f78 <GUI_DataSet3_Screen+0xe0>)
		GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, Measure_Field&CIE_xy);
 8006ea8:	4e34      	ldr	r6, [pc, #208]	; (8006f7c <GUI_DataSet3_Screen+0xe4>)
		GUI_Panels();
 8006eaa:	f7ff fe93 	bl	8006bd4 <GUI_Panels>
		GUI_Text_CIE_XYZ(20, 82);
 8006eae:	2152      	movs	r1, #82	; 0x52
 8006eb0:	2014      	movs	r0, #20
 8006eb2:	f006 ff4f 	bl	800dd54 <GUI_Text_CIE_XYZ>
		GUI_CheckBox(200, 70, Measure_Field&CIE_XYZ);
 8006eb6:	8822      	ldrh	r2, [r4, #0]
 8006eb8:	2146      	movs	r1, #70	; 0x46
 8006eba:	f002 0210 	and.w	r2, r2, #16
 8006ebe:	20c8      	movs	r0, #200	; 0xc8
 8006ec0:	f004 fe0e 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 120, 262, 120, TFT_White);
 8006ec4:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8006ec8:	2378      	movs	r3, #120	; 0x78
 8006eca:	4619      	mov	r1, r3
 8006ecc:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006ed0:	200a      	movs	r0, #10
 8006ed2:	9500      	str	r5, [sp, #0]
 8006ed4:	f009 fcd4 	bl	8010880 <TFT_DrawLine>
		GUI_Text_CIE_xy(20, 145);
 8006ed8:	2191      	movs	r1, #145	; 0x91
 8006eda:	2014      	movs	r0, #20
 8006edc:	f007 f9e6 	bl	800e2ac <GUI_Text_CIE_xy>
		GUI_CheckBox(200, 133, Measure_Field&CIE_xy);
 8006ee0:	8822      	ldrh	r2, [r4, #0]
 8006ee2:	2185      	movs	r1, #133	; 0x85
 8006ee4:	f002 0220 	and.w	r2, r2, #32
 8006ee8:	20c8      	movs	r0, #200	; 0xc8
 8006eea:	f004 fdf9 	bl	800bae0 <GUI_CheckBox>
		GUI_Text_CIE_xy_1931(35, 209);
 8006eee:	21d1      	movs	r1, #209	; 0xd1
 8006ef0:	2023      	movs	r0, #35	; 0x23
 8006ef2:	f006 ff69 	bl	800ddc8 <GUI_Text_CIE_xy_1931>
		GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, Measure_Field&CIE_xy);
 8006ef6:	8823      	ldrh	r3, [r4, #0]
 8006ef8:	7832      	ldrb	r2, [r6, #0]
 8006efa:	f003 0320 	and.w	r3, r3, #32
 8006efe:	f002 0201 	and.w	r2, r2, #1
 8006f02:	21c6      	movs	r1, #198	; 0xc6
 8006f04:	20c8      	movs	r0, #200	; 0xc8
 8006f06:	f004 fe2c 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_CIE_xy_1964(35, 275);
 8006f0a:	f240 1113 	movw	r1, #275	; 0x113
 8006f0e:	2023      	movs	r0, #35	; 0x23
 8006f10:	f006 ffba 	bl	800de88 <GUI_Text_CIE_xy_1964>
		GUI_RadioBox(200, 263, !(Measure_Color_xy&CIE_xy_1931_1964), Measure_Field&CIE_xy);
 8006f14:	7832      	ldrb	r2, [r6, #0]
 8006f16:	8823      	ldrh	r3, [r4, #0]
 8006f18:	43d2      	mvns	r2, r2
 8006f1a:	f003 0320 	and.w	r3, r3, #32
 8006f1e:	f002 0201 	and.w	r2, r2, #1
 8006f22:	f240 1107 	movw	r1, #263	; 0x107
 8006f26:	20c8      	movs	r0, #200	; 0xc8
 8006f28:	f004 fe1b 	bl	800bb62 <GUI_RadioBox>
		TFT_DrawLine(10, 313, 262, 313, TFT_White);
 8006f2c:	f240 1339 	movw	r3, #313	; 0x139
 8006f30:	4619      	mov	r1, r3
 8006f32:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006f36:	200a      	movs	r0, #10
 8006f38:	9500      	str	r5, [sp, #0]
 8006f3a:	f009 fca1 	bl	8010880 <TFT_DrawLine>
		GUI_Text_CIE_Luv(20, 337);
 8006f3e:	f240 1151 	movw	r1, #337	; 0x151
 8006f42:	2014      	movs	r0, #20
 8006f44:	f007 f800 	bl	800df48 <GUI_Text_CIE_Luv>
		GUI_CheckBox(200, 327, Measure_Field&CIE_Luv);
 8006f48:	8822      	ldrh	r2, [r4, #0]
 8006f4a:	f240 1147 	movw	r1, #327	; 0x147
 8006f4e:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8006f52:	20c8      	movs	r0, #200	; 0xc8
 8006f54:	f004 fdc4 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 377, 262, 377, TFT_White);
 8006f58:	f240 1379 	movw	r3, #377	; 0x179
 8006f5c:	9500      	str	r5, [sp, #0]
 8006f5e:	f44f 7283 	mov.w	r2, #262	; 0x106
 8006f62:	4619      	mov	r1, r3
 8006f64:	200a      	movs	r0, #10
 8006f66:	f009 fc8b 	bl	8010880 <TFT_DrawLine>
}
 8006f6a:	b002      	add	sp, #8
 8006f6c:	bd70      	pop	{r4, r5, r6, pc}
 8006f6e:	bf00      	nop
 8006f70:	20000176 	.word	0x20000176
 8006f74:	200002b9 	.word	0x200002b9
 8006f78:	200002be 	.word	0x200002be
 8006f7c:	200002bc 	.word	0x200002bc

08006f80 <GUI_DataSet4_Screen>:
{
 8006f80:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 8006f82:	4b4b      	ldr	r3, [pc, #300]	; (80070b0 <GUI_DataSet4_Screen+0x130>)
 8006f84:	4a4b      	ldr	r2, [pc, #300]	; (80070b4 <GUI_DataSet4_Screen+0x134>)
 8006f86:	781b      	ldrb	r3, [r3, #0]
 8006f88:	7812      	ldrb	r2, [r2, #0]
 8006f8a:	429a      	cmp	r2, r3
 8006f8c:	f000 808b 	beq.w	80070a6 <GUI_DataSet4_Screen+0x126>
		GUI_CheckBox(200, 65, Measure_Field&CIE_Lab);
 8006f90:	4c49      	ldr	r4, [pc, #292]	; (80070b8 <GUI_DataSet4_Screen+0x138>)
		GUI_RadioBox(200, 108, Source_Type&Source_A, Measure_Field&CIE_Lab);
 8006f92:	4d4a      	ldr	r5, [pc, #296]	; (80070bc <GUI_DataSet4_Screen+0x13c>)
		GUI_Panels();
 8006f94:	f7ff fe1e 	bl	8006bd4 <GUI_Panels>
		GUI_Text_CIE_Lab(20, 80);
 8006f98:	2150      	movs	r1, #80	; 0x50
 8006f9a:	2014      	movs	r0, #20
 8006f9c:	f007 f822 	bl	800dfe4 <GUI_Text_CIE_Lab>
		GUI_CheckBox(200, 65, Measure_Field&CIE_Lab);
 8006fa0:	8822      	ldrh	r2, [r4, #0]
 8006fa2:	2141      	movs	r1, #65	; 0x41
 8006fa4:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8006fa8:	20c8      	movs	r0, #200	; 0xc8
 8006faa:	f004 fd99 	bl	800bae0 <GUI_CheckBox>
		GUI_Text_A(40, 115);
 8006fae:	2173      	movs	r1, #115	; 0x73
 8006fb0:	2028      	movs	r0, #40	; 0x28
 8006fb2:	f007 f8bf 	bl	800e134 <GUI_Text_A>
		GUI_RadioBox(200, 108, Source_Type&Source_A, Measure_Field&CIE_Lab);
 8006fb6:	8823      	ldrh	r3, [r4, #0]
 8006fb8:	782a      	ldrb	r2, [r5, #0]
 8006fba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006fbe:	f002 0201 	and.w	r2, r2, #1
 8006fc2:	216c      	movs	r1, #108	; 0x6c
 8006fc4:	20c8      	movs	r0, #200	; 0xc8
 8006fc6:	f004 fdcc 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_D65(40, 150);
 8006fca:	2196      	movs	r1, #150	; 0x96
 8006fcc:	2028      	movs	r0, #40	; 0x28
 8006fce:	f007 f8c7 	bl	800e160 <GUI_Text_D65>
		GUI_RadioBox(200, 143, Source_Type&Source_D65, Measure_Field&CIE_Lab);
 8006fd2:	8823      	ldrh	r3, [r4, #0]
 8006fd4:	782a      	ldrb	r2, [r5, #0]
 8006fd6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006fda:	f002 0202 	and.w	r2, r2, #2
 8006fde:	218f      	movs	r1, #143	; 0x8f
 8006fe0:	20c8      	movs	r0, #200	; 0xc8
 8006fe2:	f004 fdbe 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_C(40, 185);
 8006fe6:	21b9      	movs	r1, #185	; 0xb9
 8006fe8:	2028      	movs	r0, #40	; 0x28
 8006fea:	f007 f8dd 	bl	800e1a8 <GUI_Text_C>
		GUI_RadioBox(200, 178, Source_Type&Source_C, Measure_Field&CIE_Lab);
 8006fee:	8823      	ldrh	r3, [r4, #0]
 8006ff0:	782a      	ldrb	r2, [r5, #0]
 8006ff2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006ff6:	f002 0204 	and.w	r2, r2, #4
 8006ffa:	21b2      	movs	r1, #178	; 0xb2
 8006ffc:	20c8      	movs	r0, #200	; 0xc8
 8006ffe:	f004 fdb0 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_D50(40, 220);
 8007002:	21dc      	movs	r1, #220	; 0xdc
 8007004:	2028      	movs	r0, #40	; 0x28
 8007006:	f007 f8e5 	bl	800e1d4 <GUI_Text_D50>
		GUI_RadioBox(200, 213, Source_Type&Source_D50, Measure_Field&CIE_Lab);
 800700a:	8823      	ldrh	r3, [r4, #0]
 800700c:	782a      	ldrb	r2, [r5, #0]
 800700e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8007012:	f002 0208 	and.w	r2, r2, #8
 8007016:	21d5      	movs	r1, #213	; 0xd5
 8007018:	20c8      	movs	r0, #200	; 0xc8
 800701a:	f004 fda2 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_D55(40, 255);
 800701e:	21ff      	movs	r1, #255	; 0xff
 8007020:	2028      	movs	r0, #40	; 0x28
 8007022:	f007 f8fb 	bl	800e21c <GUI_Text_D55>
		GUI_RadioBox(200, 248, Source_Type&Source_D55, Measure_Field&CIE_Lab);
 8007026:	8823      	ldrh	r3, [r4, #0]
 8007028:	782a      	ldrb	r2, [r5, #0]
 800702a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800702e:	f002 0210 	and.w	r2, r2, #16
 8007032:	21f8      	movs	r1, #248	; 0xf8
 8007034:	20c8      	movs	r0, #200	; 0xc8
 8007036:	f004 fd94 	bl	800bb62 <GUI_RadioBox>
		GUI_Text_D75(40, 290);
 800703a:	f44f 7191 	mov.w	r1, #290	; 0x122
 800703e:	2028      	movs	r0, #40	; 0x28
 8007040:	f007 f910 	bl	800e264 <GUI_Text_D75>
		GUI_RadioBox(200, 283, Source_Type&Source_D75, Measure_Field&CIE_Lab);
 8007044:	8823      	ldrh	r3, [r4, #0]
 8007046:	782a      	ldrb	r2, [r5, #0]
 8007048:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800704c:	f002 0220 	and.w	r2, r2, #32
 8007050:	f240 111b 	movw	r1, #283	; 0x11b
 8007054:	20c8      	movs	r0, #200	; 0xc8
 8007056:	f004 fd84 	bl	800bb62 <GUI_RadioBox>
		TFT_DrawLine(10, 330, 262, 330, TFT_White);
 800705a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800705e:	9300      	str	r3, [sp, #0]
 8007060:	f44f 73a5 	mov.w	r3, #330	; 0x14a
 8007064:	4619      	mov	r1, r3
 8007066:	200a      	movs	r0, #10
 8007068:	f44f 7283 	mov.w	r2, #262	; 0x106
 800706c:	f009 fc08 	bl	8010880 <TFT_DrawLine>
		Mode_EL ? GUI_Text_EbEr(20, 360) : GUI_Text_LbLr(20, 360);
 8007070:	4b13      	ldr	r3, [pc, #76]	; (80070c0 <GUI_DataSet4_Screen+0x140>)
 8007072:	781b      	ldrb	r3, [r3, #0]
 8007074:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8007078:	2014      	movs	r0, #20
 800707a:	b1b3      	cbz	r3, 80070aa <GUI_DataSet4_Screen+0x12a>
 800707c:	f007 fb2e 	bl	800e6dc <GUI_Text_EbEr>
		GUI_CheckBox(200, 345, Measure_Field&EbEr);
 8007080:	8822      	ldrh	r2, [r4, #0]
 8007082:	f240 1159 	movw	r1, #345	; 0x159
 8007086:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 800708a:	20c8      	movs	r0, #200	; 0xc8
 800708c:	f004 fd28 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 390, 262, 390, TFT_White);
 8007090:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8007094:	9300      	str	r3, [sp, #0]
 8007096:	f44f 73c3 	mov.w	r3, #390	; 0x186
 800709a:	f44f 7283 	mov.w	r2, #262	; 0x106
 800709e:	4619      	mov	r1, r3
 80070a0:	200a      	movs	r0, #10
 80070a2:	f009 fbed 	bl	8010880 <TFT_DrawLine>
}
 80070a6:	b003      	add	sp, #12
 80070a8:	bd30      	pop	{r4, r5, pc}
		Mode_EL ? GUI_Text_EbEr(20, 360) : GUI_Text_LbLr(20, 360);
 80070aa:	f007 fb51 	bl	800e750 <GUI_Text_LbLr>
 80070ae:	e7e7      	b.n	8007080 <GUI_DataSet4_Screen+0x100>
 80070b0:	20000176 	.word	0x20000176
 80070b4:	200002b9 	.word	0x200002b9
 80070b8:	200002be 	.word	0x200002be
 80070bc:	20084b91 	.word	0x20084b91
 80070c0:	2000019c 	.word	0x2000019c

080070c4 <GUI_DataSet5_Screen>:
{
 80070c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 80070c6:	4b23      	ldr	r3, [pc, #140]	; (8007154 <GUI_DataSet5_Screen+0x90>)
 80070c8:	4a23      	ldr	r2, [pc, #140]	; (8007158 <GUI_DataSet5_Screen+0x94>)
 80070ca:	781b      	ldrb	r3, [r3, #0]
 80070cc:	7812      	ldrb	r2, [r2, #0]
 80070ce:	429a      	cmp	r2, r3
 80070d0:	d03d      	beq.n	800714e <GUI_DataSet5_Screen+0x8a>
		GUI_CheckBox(200, 70, Measure_Field&lambda_d);
 80070d2:	4d22      	ldr	r5, [pc, #136]	; (800715c <GUI_DataSet5_Screen+0x98>)
		GUI_Panels();
 80070d4:	f7ff fd7e 	bl	8006bd4 <GUI_Panels>
		GUI_Text_lambda_d(35, 86);
 80070d8:	2156      	movs	r1, #86	; 0x56
 80070da:	2023      	movs	r0, #35	; 0x23
 80070dc:	f007 f98c 	bl	800e3f8 <GUI_Text_lambda_d>
		GUI_CheckBox(200, 70, Measure_Field&lambda_d);
 80070e0:	882a      	ldrh	r2, [r5, #0]
 80070e2:	2146      	movs	r1, #70	; 0x46
 80070e4:	f402 7200 	and.w	r2, r2, #512	; 0x200
 80070e8:	20c8      	movs	r0, #200	; 0xc8
 80070ea:	f004 fcf9 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 120, 262, 120, TFT_White);
 80070ee:	f64f 74ff 	movw	r4, #65535	; 0xffff
 80070f2:	2378      	movs	r3, #120	; 0x78
 80070f4:	4619      	mov	r1, r3
 80070f6:	f44f 7283 	mov.w	r2, #262	; 0x106
 80070fa:	200a      	movs	r0, #10
 80070fc:	9400      	str	r4, [sp, #0]
 80070fe:	f009 fbbf 	bl	8010880 <TFT_DrawLine>
		GUI_Text_lambda_c(35, 145);
 8007102:	2191      	movs	r1, #145	; 0x91
 8007104:	2023      	movs	r0, #35	; 0x23
 8007106:	f007 f99b 	bl	800e440 <GUI_Text_lambda_c>
		GUI_CheckBox(200, 133, Measure_Field&lambda_c);
 800710a:	882a      	ldrh	r2, [r5, #0]
 800710c:	2185      	movs	r1, #133	; 0x85
 800710e:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8007112:	20c8      	movs	r0, #200	; 0xc8
 8007114:	f004 fce4 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 183, 262, 183, TFT_White);
 8007118:	23b7      	movs	r3, #183	; 0xb7
 800711a:	4619      	mov	r1, r3
 800711c:	f44f 7283 	mov.w	r2, #262	; 0x106
 8007120:	200a      	movs	r0, #10
 8007122:	9400      	str	r4, [sp, #0]
 8007124:	f009 fbac 	bl	8010880 <TFT_DrawLine>
		GUI_Text_SP(35, 209);
 8007128:	21d1      	movs	r1, #209	; 0xd1
 800712a:	2023      	movs	r0, #35	; 0x23
 800712c:	f007 f940 	bl	800e3b0 <GUI_Text_SP>
		GUI_CheckBox(200, 198, Measure_Field&SP_measure);
 8007130:	882a      	ldrh	r2, [r5, #0]
 8007132:	21c6      	movs	r1, #198	; 0xc6
 8007134:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8007138:	20c8      	movs	r0, #200	; 0xc8
 800713a:	f004 fcd1 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 248, 262, 248, TFT_White);
 800713e:	23f8      	movs	r3, #248	; 0xf8
 8007140:	9400      	str	r4, [sp, #0]
 8007142:	f44f 7283 	mov.w	r2, #262	; 0x106
 8007146:	4619      	mov	r1, r3
 8007148:	200a      	movs	r0, #10
 800714a:	f009 fb99 	bl	8010880 <TFT_DrawLine>
}
 800714e:	b003      	add	sp, #12
 8007150:	bd30      	pop	{r4, r5, pc}
 8007152:	bf00      	nop
 8007154:	20000176 	.word	0x20000176
 8007158:	200002b9 	.word	0x200002b9
 800715c:	200002be 	.word	0x200002be

08007160 <GUI_GraphSet1_Screen>:
{
 8007160:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state || Language_status_prev != Language_status){
 8007162:	4b1d      	ldr	r3, [pc, #116]	; (80071d8 <GUI_GraphSet1_Screen+0x78>)
 8007164:	4a1d      	ldr	r2, [pc, #116]	; (80071dc <GUI_GraphSet1_Screen+0x7c>)
 8007166:	781b      	ldrb	r3, [r3, #0]
 8007168:	7812      	ldrb	r2, [r2, #0]
 800716a:	4c1d      	ldr	r4, [pc, #116]	; (80071e0 <GUI_GraphSet1_Screen+0x80>)
 800716c:	4d1d      	ldr	r5, [pc, #116]	; (80071e4 <GUI_GraphSet1_Screen+0x84>)
 800716e:	429a      	cmp	r2, r3
 8007170:	d103      	bne.n	800717a <GUI_GraphSet1_Screen+0x1a>
 8007172:	7822      	ldrb	r2, [r4, #0]
 8007174:	782b      	ldrb	r3, [r5, #0]
 8007176:	429a      	cmp	r2, r3
 8007178:	d022      	beq.n	80071c0 <GUI_GraphSet1_Screen+0x60>
		GUI_Panels();
 800717a:	f7ff fd2b 	bl	8006bd4 <GUI_Panels>
		Language_status_prev = Language_status;
 800717e:	782b      	ldrb	r3, [r5, #0]
		Prev_Inf_Screen2 = GraphSet1_Screen;
 8007180:	4a19      	ldr	r2, [pc, #100]	; (80071e8 <GUI_GraphSet1_Screen+0x88>)
		Language_status_prev = Language_status;
 8007182:	7023      	strb	r3, [r4, #0]
		Prev_Inf_Screen2 = GraphSet1_Screen;
 8007184:	210c      	movs	r1, #12
 8007186:	7011      	strb	r1, [r2, #0]
		if(Language_status == Ru){
 8007188:	b9e3      	cbnz	r3, 80071c4 <GUI_GraphSet1_Screen+0x64>
			GUI_OptionMenuRu();
 800718a:	f7ff f8bd 	bl	8006308 <GUI_OptionMenuRu>
			GUI_TextRu_PPF_bands(10, 337);
 800718e:	f240 1151 	movw	r1, #337	; 0x151
 8007192:	200a      	movs	r0, #10
 8007194:	f008 fc84 	bl	800faa0 <GUI_TextRu_PPF_bands>
			GUI_CheckBox(200, 327, Graph_Field&PPF_Bands);
 8007198:	4b14      	ldr	r3, [pc, #80]	; (80071ec <GUI_GraphSet1_Screen+0x8c>)
 800719a:	781a      	ldrb	r2, [r3, #0]
 800719c:	f240 1147 	movw	r1, #327	; 0x147
 80071a0:	f002 0201 	and.w	r2, r2, #1
 80071a4:	20c8      	movs	r0, #200	; 0xc8
 80071a6:	f004 fc9b 	bl	800bae0 <GUI_CheckBox>
			TFT_DrawLine(10, 377, 262, 377, TFT_White);
 80071aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80071ae:	9300      	str	r3, [sp, #0]
 80071b0:	f240 1379 	movw	r3, #377	; 0x179
 80071b4:	f44f 7283 	mov.w	r2, #262	; 0x106
 80071b8:	4619      	mov	r1, r3
 80071ba:	200a      	movs	r0, #10
 80071bc:	f009 fb60 	bl	8010880 <TFT_DrawLine>
}
 80071c0:	b003      	add	sp, #12
 80071c2:	bd30      	pop	{r4, r5, pc}
		else if(Language_status == En){
 80071c4:	2b01      	cmp	r3, #1
 80071c6:	d1e7      	bne.n	8007198 <GUI_GraphSet1_Screen+0x38>
			GUI_OptionMenuEn();
 80071c8:	f7ff f90e 	bl	80063e8 <GUI_OptionMenuEn>
			GUI_TextEn_PARwavebands(10, 339);
 80071cc:	f240 1153 	movw	r1, #339	; 0x153
 80071d0:	200a      	movs	r0, #10
 80071d2:	f007 fd81 	bl	800ecd8 <GUI_TextEn_PARwavebands>
 80071d6:	e7df      	b.n	8007198 <GUI_GraphSet1_Screen+0x38>
 80071d8:	20000176 	.word	0x20000176
 80071dc:	200002b9 	.word	0x200002b9
 80071e0:	20084b8c 	.word	0x20084b8c
 80071e4:	200002bb 	.word	0x200002bb
 80071e8:	20085120 	.word	0x20085120
 80071ec:	200002ba 	.word	0x200002ba

080071f0 <GUI_GraphSet2_Screen>:
{
 80071f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 80071f2:	4b19      	ldr	r3, [pc, #100]	; (8007258 <GUI_GraphSet2_Screen+0x68>)
 80071f4:	4a19      	ldr	r2, [pc, #100]	; (800725c <GUI_GraphSet2_Screen+0x6c>)
 80071f6:	781b      	ldrb	r3, [r3, #0]
 80071f8:	7812      	ldrb	r2, [r2, #0]
 80071fa:	429a      	cmp	r2, r3
 80071fc:	d02a      	beq.n	8007254 <GUI_GraphSet2_Screen+0x64>
		GUI_CheckBox(200, 70, Graph_Field&EbEr_graph);
 80071fe:	4d18      	ldr	r5, [pc, #96]	; (8007260 <GUI_GraphSet2_Screen+0x70>)
		GUI_Panels();
 8007200:	f7ff fce8 	bl	8006bd4 <GUI_Panels>
		GUI_Text_EbEr(18, 82);
 8007204:	2152      	movs	r1, #82	; 0x52
 8007206:	2012      	movs	r0, #18
 8007208:	f007 fa68 	bl	800e6dc <GUI_Text_EbEr>
		GUI_CheckBox(200, 70, Graph_Field&EbEr_graph);
 800720c:	782a      	ldrb	r2, [r5, #0]
 800720e:	2146      	movs	r1, #70	; 0x46
 8007210:	f002 0202 	and.w	r2, r2, #2
 8007214:	20c8      	movs	r0, #200	; 0xc8
 8007216:	f004 fc63 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 122, 262, 122, TFT_White);
 800721a:	f64f 74ff 	movw	r4, #65535	; 0xffff
 800721e:	237a      	movs	r3, #122	; 0x7a
 8007220:	4619      	mov	r1, r3
 8007222:	f44f 7283 	mov.w	r2, #262	; 0x106
 8007226:	200a      	movs	r0, #10
 8007228:	9400      	str	r4, [sp, #0]
 800722a:	f009 fb29 	bl	8010880 <TFT_DrawLine>
		GUI_Text_V_lambda(10, 145);
 800722e:	2191      	movs	r1, #145	; 0x91
 8007230:	200a      	movs	r0, #10
 8007232:	f007 f929 	bl	800e488 <GUI_Text_V_lambda>
		GUI_CheckBox(200, 133, Graph_Field&V_lambda);
 8007236:	782a      	ldrb	r2, [r5, #0]
 8007238:	2185      	movs	r1, #133	; 0x85
 800723a:	f002 0204 	and.w	r2, r2, #4
 800723e:	20c8      	movs	r0, #200	; 0xc8
 8007240:	f004 fc4e 	bl	800bae0 <GUI_CheckBox>
		TFT_DrawLine(10, 185, 262, 185, TFT_White);
 8007244:	23b9      	movs	r3, #185	; 0xb9
 8007246:	9400      	str	r4, [sp, #0]
 8007248:	f44f 7283 	mov.w	r2, #262	; 0x106
 800724c:	4619      	mov	r1, r3
 800724e:	200a      	movs	r0, #10
 8007250:	f009 fb16 	bl	8010880 <TFT_DrawLine>
}
 8007254:	b003      	add	sp, #12
 8007256:	bd30      	pop	{r4, r5, pc}
 8007258:	20000176 	.word	0x20000176
 800725c:	200002b9 	.word	0x200002b9
 8007260:	200002ba 	.word	0x200002ba

08007264 <GUI_ColorSet1_Screen>:
{
 8007264:	b513      	push	{r0, r1, r4, lr}
	if(preGUI_screen_state != GUI_screen_state || Language_status_prev != Language_status){
 8007266:	4b1b      	ldr	r3, [pc, #108]	; (80072d4 <GUI_ColorSet1_Screen+0x70>)
 8007268:	4a1b      	ldr	r2, [pc, #108]	; (80072d8 <GUI_ColorSet1_Screen+0x74>)
 800726a:	781b      	ldrb	r3, [r3, #0]
 800726c:	7812      	ldrb	r2, [r2, #0]
 800726e:	4c1b      	ldr	r4, [pc, #108]	; (80072dc <GUI_ColorSet1_Screen+0x78>)
 8007270:	429a      	cmp	r2, r3
 8007272:	4b1b      	ldr	r3, [pc, #108]	; (80072e0 <GUI_ColorSet1_Screen+0x7c>)
 8007274:	d103      	bne.n	800727e <GUI_ColorSet1_Screen+0x1a>
 8007276:	7819      	ldrb	r1, [r3, #0]
 8007278:	7822      	ldrb	r2, [r4, #0]
 800727a:	4291      	cmp	r1, r2
 800727c:	d023      	beq.n	80072c6 <GUI_ColorSet1_Screen+0x62>
		Language_status_prev = Language_status;
 800727e:	7822      	ldrb	r2, [r4, #0]
 8007280:	701a      	strb	r2, [r3, #0]
		GUI_Panels();
 8007282:	f7ff fca7 	bl	8006bd4 <GUI_Panels>
		Prev_Inf_Screen2 = ColorSet1_Screen;
 8007286:	4b17      	ldr	r3, [pc, #92]	; (80072e4 <GUI_ColorSet1_Screen+0x80>)
 8007288:	220e      	movs	r2, #14
 800728a:	701a      	strb	r2, [r3, #0]
		if(Language_status == Ru){
 800728c:	7823      	ldrb	r3, [r4, #0]
 800728e:	b9e3      	cbnz	r3, 80072ca <GUI_ColorSet1_Screen+0x66>
			GUI_OptionMenuRu();
 8007290:	f7ff f83a 	bl	8006308 <GUI_OptionMenuRu>
			GUI_Text_CIE_xy(10, 337);
 8007294:	f240 1151 	movw	r1, #337	; 0x151
 8007298:	200a      	movs	r0, #10
 800729a:	f007 f807 	bl	800e2ac <GUI_Text_CIE_xy>
			GUI_RadioBox(200, 327, Color_Field&Color_CIE_xy, 0x01);
 800729e:	4b12      	ldr	r3, [pc, #72]	; (80072e8 <GUI_ColorSet1_Screen+0x84>)
 80072a0:	781a      	ldrb	r2, [r3, #0]
 80072a2:	2301      	movs	r3, #1
 80072a4:	401a      	ands	r2, r3
 80072a6:	f240 1147 	movw	r1, #327	; 0x147
 80072aa:	20c8      	movs	r0, #200	; 0xc8
 80072ac:	f004 fc59 	bl	800bb62 <GUI_RadioBox>
			TFT_DrawLine(10, 377, 262, 377, TFT_White);
 80072b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80072b4:	9300      	str	r3, [sp, #0]
 80072b6:	f240 1379 	movw	r3, #377	; 0x179
 80072ba:	f44f 7283 	mov.w	r2, #262	; 0x106
 80072be:	4619      	mov	r1, r3
 80072c0:	200a      	movs	r0, #10
 80072c2:	f009 fadd 	bl	8010880 <TFT_DrawLine>
}
 80072c6:	b002      	add	sp, #8
 80072c8:	bd10      	pop	{r4, pc}
		else if(Language_status == En){
 80072ca:	2b01      	cmp	r3, #1
 80072cc:	d1e2      	bne.n	8007294 <GUI_ColorSet1_Screen+0x30>
			GUI_OptionMenuEn();
 80072ce:	f7ff f88b 	bl	80063e8 <GUI_OptionMenuEn>
 80072d2:	e7df      	b.n	8007294 <GUI_ColorSet1_Screen+0x30>
 80072d4:	20000176 	.word	0x20000176
 80072d8:	200002b9 	.word	0x200002b9
 80072dc:	200002bb 	.word	0x200002bb
 80072e0:	20084b8c 	.word	0x20084b8c
 80072e4:	20085120 	.word	0x20085120
 80072e8:	200002b7 	.word	0x200002b7

080072ec <GUI_ColorSet2_Screen>:
{
 80072ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(preGUI_screen_state != GUI_screen_state){
 80072ee:	4b1a      	ldr	r3, [pc, #104]	; (8007358 <GUI_ColorSet2_Screen+0x6c>)
 80072f0:	4a1a      	ldr	r2, [pc, #104]	; (800735c <GUI_ColorSet2_Screen+0x70>)
 80072f2:	781b      	ldrb	r3, [r3, #0]
 80072f4:	7812      	ldrb	r2, [r2, #0]
 80072f6:	429a      	cmp	r2, r3
 80072f8:	d02c      	beq.n	8007354 <GUI_ColorSet2_Screen+0x68>
		GUI_RadioBox(200, 70, Color_Field&Color_CIE_Luv, 0x01);
 80072fa:	4d19      	ldr	r5, [pc, #100]	; (8007360 <GUI_ColorSet2_Screen+0x74>)
		GUI_Panels();
 80072fc:	f7ff fc6a 	bl	8006bd4 <GUI_Panels>
		GUI_Text_CIE_Luv(20, 82);
 8007300:	2152      	movs	r1, #82	; 0x52
 8007302:	2014      	movs	r0, #20
 8007304:	f006 fe20 	bl	800df48 <GUI_Text_CIE_Luv>
		GUI_RadioBox(200, 70, Color_Field&Color_CIE_Luv, 0x01);
 8007308:	782a      	ldrb	r2, [r5, #0]
 800730a:	2301      	movs	r3, #1
 800730c:	f002 0204 	and.w	r2, r2, #4
 8007310:	2146      	movs	r1, #70	; 0x46
 8007312:	20c8      	movs	r0, #200	; 0xc8
 8007314:	f004 fc25 	bl	800bb62 <GUI_RadioBox>
		TFT_DrawLine(10, 122, 262, 122, TFT_White);
 8007318:	f64f 74ff 	movw	r4, #65535	; 0xffff
 800731c:	237a      	movs	r3, #122	; 0x7a
 800731e:	4619      	mov	r1, r3
 8007320:	f44f 7283 	mov.w	r2, #262	; 0x106
 8007324:	200a      	movs	r0, #10
 8007326:	9400      	str	r4, [sp, #0]
 8007328:	f009 faaa 	bl	8010880 <TFT_DrawLine>
		GUI_Text_CIE_Lab(20, 145);
 800732c:	2191      	movs	r1, #145	; 0x91
 800732e:	2014      	movs	r0, #20
 8007330:	f006 fe58 	bl	800dfe4 <GUI_Text_CIE_Lab>
		GUI_RadioBox(200, 133, Color_Field&Color_CIE_Lab, 0x01);
 8007334:	782a      	ldrb	r2, [r5, #0]
 8007336:	2301      	movs	r3, #1
 8007338:	f002 0202 	and.w	r2, r2, #2
 800733c:	2185      	movs	r1, #133	; 0x85
 800733e:	20c8      	movs	r0, #200	; 0xc8
 8007340:	f004 fc0f 	bl	800bb62 <GUI_RadioBox>
		TFT_DrawLine(10, 185, 262, 185, TFT_White);
 8007344:	23b9      	movs	r3, #185	; 0xb9
 8007346:	9400      	str	r4, [sp, #0]
 8007348:	f44f 7283 	mov.w	r2, #262	; 0x106
 800734c:	4619      	mov	r1, r3
 800734e:	200a      	movs	r0, #10
 8007350:	f009 fa96 	bl	8010880 <TFT_DrawLine>
}
 8007354:	b003      	add	sp, #12
 8007356:	bd30      	pop	{r4, r5, pc}
 8007358:	20000176 	.word	0x20000176
 800735c:	200002b9 	.word	0x200002b9
 8007360:	200002b7 	.word	0x200002b7

08007364 <GUI_ColorRendSet_Screen>:
{
 8007364:	b537      	push	{r0, r1, r2, r4, r5, lr}
	old_meas_type_E = 2; old_meas_type_L = 2;
 8007366:	4a29      	ldr	r2, [pc, #164]	; (800740c <GUI_ColorRendSet_Screen+0xa8>)
 8007368:	4d29      	ldr	r5, [pc, #164]	; (8007410 <GUI_ColorRendSet_Screen+0xac>)
 800736a:	4c2a      	ldr	r4, [pc, #168]	; (8007414 <GUI_ColorRendSet_Screen+0xb0>)
 800736c:	2302      	movs	r3, #2
 800736e:	7013      	strb	r3, [r2, #0]
 8007370:	4a29      	ldr	r2, [pc, #164]	; (8007418 <GUI_ColorRendSet_Screen+0xb4>)
 8007372:	7013      	strb	r3, [r2, #0]
	if(preGUI_screen_state != GUI_screen_state || Language_status_prev != Language_status){
 8007374:	4b29      	ldr	r3, [pc, #164]	; (800741c <GUI_ColorRendSet_Screen+0xb8>)
 8007376:	4a2a      	ldr	r2, [pc, #168]	; (8007420 <GUI_ColorRendSet_Screen+0xbc>)
 8007378:	781b      	ldrb	r3, [r3, #0]
 800737a:	7812      	ldrb	r2, [r2, #0]
 800737c:	429a      	cmp	r2, r3
 800737e:	d103      	bne.n	8007388 <GUI_ColorRendSet_Screen+0x24>
 8007380:	782a      	ldrb	r2, [r5, #0]
 8007382:	7823      	ldrb	r3, [r4, #0]
 8007384:	429a      	cmp	r2, r3
 8007386:	d03e      	beq.n	8007406 <GUI_ColorRendSet_Screen+0xa2>
		GUI_Panels();
 8007388:	f7ff fc24 	bl	8006bd4 <GUI_Panels>
		Language_status_prev = Language_status;
 800738c:	7823      	ldrb	r3, [r4, #0]
		Prev_Inf_Screen2 = ColorRendSet_Screen;
 800738e:	4a25      	ldr	r2, [pc, #148]	; (8007424 <GUI_ColorRendSet_Screen+0xc0>)
		Language_status_prev = Language_status;
 8007390:	702b      	strb	r3, [r5, #0]
		Prev_Inf_Screen2 = ColorRendSet_Screen;
 8007392:	2110      	movs	r1, #16
 8007394:	7011      	strb	r1, [r2, #0]
		if(Language_status == Ru){
 8007396:	b90b      	cbnz	r3, 800739c <GUI_ColorRendSet_Screen+0x38>
			GUI_OptionMenuRu();
 8007398:	f7fe ffb6 	bl	8006308 <GUI_OptionMenuRu>
		if(Language_status == En){
 800739c:	7823      	ldrb	r3, [r4, #0]
 800739e:	2b01      	cmp	r3, #1
 80073a0:	d101      	bne.n	80073a6 <GUI_ColorRendSet_Screen+0x42>
			GUI_OptionMenuEn();
 80073a2:	f7ff f821 	bl	80063e8 <GUI_OptionMenuEn>
			GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 80073a6:	4d20      	ldr	r5, [pc, #128]	; (8007428 <GUI_ColorRendSet_Screen+0xc4>)
			GUI_Text_CRI(30, 325);
 80073a8:	f240 1145 	movw	r1, #325	; 0x145
 80073ac:	201e      	movs	r0, #30
 80073ae:	f006 ffb7 	bl	800e320 <GUI_Text_CRI>
			GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 80073b2:	782a      	ldrb	r2, [r5, #0]
 80073b4:	2301      	movs	r3, #1
 80073b6:	401a      	ands	r2, r3
 80073b8:	f44f 719f 	mov.w	r1, #318	; 0x13e
 80073bc:	20b9      	movs	r0, #185	; 0xb9
 80073be:	f004 fbd0 	bl	800bb62 <GUI_RadioBox>
			TFT_DrawLine(10, 355, 262, 355, TFT_White);
 80073c2:	f64f 74ff 	movw	r4, #65535	; 0xffff
 80073c6:	f240 1363 	movw	r3, #355	; 0x163
 80073ca:	4619      	mov	r1, r3
 80073cc:	f44f 7283 	mov.w	r2, #262	; 0x106
 80073d0:	200a      	movs	r0, #10
 80073d2:	9400      	str	r4, [sp, #0]
 80073d4:	f009 fa54 	bl	8010880 <TFT_DrawLine>
			GUI_Text_CQS(30, 369);
 80073d8:	f240 1171 	movw	r1, #369	; 0x171
 80073dc:	201e      	movs	r0, #30
 80073de:	f006 ffc3 	bl	800e368 <GUI_Text_CQS>
			GUI_RadioBox(185, 362, !(Color_rend_Field&CRI_CQS), 0x01);
 80073e2:	782a      	ldrb	r2, [r5, #0]
 80073e4:	2301      	movs	r3, #1
 80073e6:	43d2      	mvns	r2, r2
 80073e8:	401a      	ands	r2, r3
 80073ea:	f44f 71b5 	mov.w	r1, #362	; 0x16a
 80073ee:	20b9      	movs	r0, #185	; 0xb9
 80073f0:	f004 fbb7 	bl	800bb62 <GUI_RadioBox>
			TFT_DrawLine(10, 401, 262, 401, TFT_White);
 80073f4:	f240 1391 	movw	r3, #401	; 0x191
 80073f8:	9400      	str	r4, [sp, #0]
 80073fa:	f44f 7283 	mov.w	r2, #262	; 0x106
 80073fe:	4619      	mov	r1, r3
 8007400:	200a      	movs	r0, #10
 8007402:	f009 fa3d 	bl	8010880 <TFT_DrawLine>
}
 8007406:	b003      	add	sp, #12
 8007408:	bd30      	pop	{r4, r5, pc}
 800740a:	bf00      	nop
 800740c:	2000017a 	.word	0x2000017a
 8007410:	20084b8c 	.word	0x20084b8c
 8007414:	200002bb 	.word	0x200002bb
 8007418:	2000017b 	.word	0x2000017b
 800741c:	20000176 	.word	0x20000176
 8007420:	200002b9 	.word	0x200002b9
 8007424:	20085120 	.word	0x20085120
 8007428:	200002b8 	.word	0x200002b8
 800742c:	00000000 	.word	0x00000000

08007430 <GUI_Graph_Screen>:
void GUI_Graph_Screen(){
 8007430:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007434:	ed2d 8b02 	vpush	{d8}
	if((preGUI_screen_state != GUI_screen_state || Rotation_Screen_Spectral_Old != Rotation_Screen_Spectral)&& !pause){
 8007438:	4b6f      	ldr	r3, [pc, #444]	; (80075f8 <GUI_Graph_Screen+0x1c8>)
 800743a:	4a70      	ldr	r2, [pc, #448]	; (80075fc <GUI_Graph_Screen+0x1cc>)
 800743c:	781b      	ldrb	r3, [r3, #0]
 800743e:	7812      	ldrb	r2, [r2, #0]
 8007440:	429a      	cmp	r2, r3
 8007442:	d10c      	bne.n	800745e <GUI_Graph_Screen+0x2e>
 8007444:	4b6e      	ldr	r3, [pc, #440]	; (8007600 <GUI_Graph_Screen+0x1d0>)
 8007446:	781a      	ldrb	r2, [r3, #0]
 8007448:	4b6e      	ldr	r3, [pc, #440]	; (8007604 <GUI_Graph_Screen+0x1d4>)
 800744a:	781b      	ldrb	r3, [r3, #0]
 800744c:	429a      	cmp	r2, r3
 800744e:	d106      	bne.n	800745e <GUI_Graph_Screen+0x2e>
	Prev_Inf_Screen = Graph_Screen;
 8007450:	4b6d      	ldr	r3, [pc, #436]	; (8007608 <GUI_Graph_Screen+0x1d8>)
 8007452:	2204      	movs	r2, #4
 8007454:	701a      	strb	r2, [r3, #0]
}
 8007456:	ecbd 8b02 	vpop	{d8}
 800745a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if((preGUI_screen_state != GUI_screen_state || Rotation_Screen_Spectral_Old != Rotation_Screen_Spectral)&& !pause){
 800745e:	4b6b      	ldr	r3, [pc, #428]	; (800760c <GUI_Graph_Screen+0x1dc>)
 8007460:	781d      	ldrb	r5, [r3, #0]
 8007462:	2d00      	cmp	r5, #0
 8007464:	d1f4      	bne.n	8007450 <GUI_Graph_Screen+0x20>
		GUI_Panels();
 8007466:	f7ff fbb5 	bl	8006bd4 <GUI_Panels>
		Rotation_Screen_Spectral_Old = Rotation_Screen_Spectral;
 800746a:	4b66      	ldr	r3, [pc, #408]	; (8007604 <GUI_Graph_Screen+0x1d4>)
 800746c:	781c      	ldrb	r4, [r3, #0]
 800746e:	4b64      	ldr	r3, [pc, #400]	; (8007600 <GUI_Graph_Screen+0x1d0>)
 8007470:	701c      	strb	r4, [r3, #0]
		if(Graph_Field&PPF_Bands)
 8007472:	4b67      	ldr	r3, [pc, #412]	; (8007610 <GUI_Graph_Screen+0x1e0>)
 8007474:	7818      	ldrb	r0, [r3, #0]
		if(Graph_Field&V_lambda)
 8007476:	0742      	lsls	r2, r0, #29
 8007478:	d437      	bmi.n	80074ea <GUI_Graph_Screen+0xba>
			if(Graph_Field&EbEr_graph)
 800747a:	0783      	lsls	r3, r0, #30
 800747c:	d5e8      	bpl.n	8007450 <GUI_Graph_Screen+0x20>
 800747e:	4f65      	ldr	r7, [pc, #404]	; (8007614 <GUI_Graph_Screen+0x1e4>)
 8007480:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 8007630 <GUI_Graph_Screen+0x200>
 8007484:	4d64      	ldr	r5, [pc, #400]	; (8007618 <GUI_Graph_Screen+0x1e8>)
 8007486:	4e65      	ldr	r6, [pc, #404]	; (800761c <GUI_Graph_Screen+0x1ec>)
				if(Rotation_Screen_Spectral == 0)
 8007488:	2c00      	cmp	r4, #0
 800748a:	d177      	bne.n	800757c <GUI_Graph_Screen+0x14c>
							buf_pix = (Hazard_Blue[i])*307;
 800748c:	ed9f 8a64 	vldr	s16, [pc, #400]	; 8007620 <GUI_Graph_Screen+0x1f0>
							buf_pix = (Hazard_Retina[i])/10.*307;
 8007490:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8007634 <GUI_Graph_Screen+0x204>
 8007494:	f04f 0800 	mov.w	r8, #0
 8007498:	0122      	lsls	r2, r4, #4
							buf_pix = (Hazard_Blue[i])*307;
 800749a:	eb0a 0302 	add.w	r3, sl, r2
 800749e:	edd3 7a00 	vldr	s15, [r3]
 80074a2:	ee67 7a88 	vmul.f32	s15, s15, s16
							buf_pix = (Hazard_Retina[i])/10.*307;
 80074a6:	4432      	add	r2, r6
							graph_spectral_Blue[jj] = (uint16_t)buf_pix;
 80074a8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
							buf_pix = (Hazard_Retina[i])/10.*307;
 80074ac:	6810      	ldr	r0, [r2, #0]
							graph_spectral_Blue[jj] = (uint16_t)buf_pix;
 80074ae:	ee17 3a90 	vmov	r3, s15
 80074b2:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]
							buf_pix = (Hazard_Retina[i])/10.*307;
 80074b6:	f7f9 f857 	bl	8000568 <__aeabi_f2d>
 80074ba:	4642      	mov	r2, r8
 80074bc:	464b      	mov	r3, r9
 80074be:	f7f9 f9d1 	bl	8000864 <__aeabi_ddiv>
 80074c2:	a349      	add	r3, pc, #292	; (adr r3, 80075e8 <GUI_Graph_Screen+0x1b8>)
 80074c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80074c8:	f7f9 f8a2 	bl	8000610 <__aeabi_dmul>
 80074cc:	f7f9 fb62 	bl	8000b94 <__aeabi_d2f>
							graph_spectral_Retina[jj] = (uint16_t)buf_pix;
 80074d0:	ee07 0a90 	vmov	s15, r0
 80074d4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80074d8:	ee17 0a90 	vmov	r0, s15
 80074dc:	f825 0014 	strh.w	r0, [r5, r4, lsl #1]
 80074e0:	3401      	adds	r4, #1
					for(uint16_t i = 0; i < 1024; i+=4)
 80074e2:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 80074e6:	d1d7      	bne.n	8007498 <GUI_Graph_Screen+0x68>
 80074e8:	e7b2      	b.n	8007450 <GUI_Graph_Screen+0x20>
 80074ea:	f8df e14c 	ldr.w	lr, [pc, #332]	; 8007638 <GUI_Graph_Screen+0x208>
 80074ee:	f8df c14c 	ldr.w	ip, [pc, #332]	; 800763c <GUI_Graph_Screen+0x20c>
 80074f2:	4e4c      	ldr	r6, [pc, #304]	; (8007624 <GUI_Graph_Screen+0x1f4>)
 80074f4:	4f4c      	ldr	r7, [pc, #304]	; (8007628 <GUI_Graph_Screen+0x1f8>)
			if(Rotation_Screen_Spectral == 0)
 80074f6:	b9fc      	cbnz	r4, 8007538 <GUI_Graph_Screen+0x108>
						buf_pix = (Spectral_day[i])*307;
 80074f8:	ed9f 7a49 	vldr	s14, [pc, #292]	; 8007620 <GUI_Graph_Screen+0x1f0>
 80074fc:	4623      	mov	r3, r4
 80074fe:	0119      	lsls	r1, r3, #4
 8007500:	eb0c 0201 	add.w	r2, ip, r1
 8007504:	edd2 7a00 	vldr	s15, [r2]
 8007508:	ee67 7a87 	vmul.f32	s15, s15, s14
						buf_pix = (Spectral_night[i])*307;
 800750c:	4439      	add	r1, r7
						graph_spectral_day[jj] = (uint16_t)buf_pix;
 800750e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8007512:	ee17 2a90 	vmov	r2, s15
						buf_pix = (Spectral_night[i])*307;
 8007516:	edd1 7a00 	vldr	s15, [r1]
						graph_spectral_day[jj] = (uint16_t)buf_pix;
 800751a:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
						buf_pix = (Spectral_night[i])*307;
 800751e:	ee67 7a87 	vmul.f32	s15, s15, s14
						graph_spectral_night[jj] = (uint16_t)buf_pix;
 8007522:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8007526:	ee17 2a90 	vmov	r2, s15
 800752a:	f826 2013 	strh.w	r2, [r6, r3, lsl #1]
 800752e:	3301      	adds	r3, #1
				for(uint16_t i = 0; i < 1024; i+=4)
 8007530:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007534:	d1e3      	bne.n	80074fe <GUI_Graph_Screen+0xce>
 8007536:	e7a0      	b.n	800747a <GUI_Graph_Screen+0x4a>
								buf_pix = (Spectral_day[i])*209;
 8007538:	ed9f 7a3c 	vldr	s14, [pc, #240]	; 800762c <GUI_Graph_Screen+0x1fc>
 800753c:	462b      	mov	r3, r5
 800753e:	250c      	movs	r5, #12
 8007540:	fb05 f103 	mul.w	r1, r5, r3
 8007544:	eb0c 0201 	add.w	r2, ip, r1
 8007548:	edd2 7a00 	vldr	s15, [r2]
 800754c:	ee67 7a87 	vmul.f32	s15, s15, s14
								buf_pix = (Spectral_night[i])*209;
 8007550:	4439      	add	r1, r7
								graph_spectral_day[ii] = (uint16_t)buf_pix;
 8007552:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8007556:	ee17 2a90 	vmov	r2, s15
								buf_pix = (Spectral_night[i])*209;
 800755a:	edd1 7a00 	vldr	s15, [r1]
								graph_spectral_day[ii] = (uint16_t)buf_pix;
 800755e:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
								buf_pix = (Spectral_night[i])*209;
 8007562:	ee67 7a87 	vmul.f32	s15, s15, s14
								graph_spectral_night[ii] = (uint16_t)buf_pix;
 8007566:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800756a:	ee17 2a90 	vmov	r2, s15
 800756e:	f826 2013 	strh.w	r2, [r6, r3, lsl #1]
 8007572:	3301      	adds	r3, #1
						for(uint16_t i = 0; i < 1024; i+=3)
 8007574:	f5b3 7fab 	cmp.w	r3, #342	; 0x156
 8007578:	d1e2      	bne.n	8007540 <GUI_Graph_Screen+0x110>
 800757a:	e77e      	b.n	800747a <GUI_Graph_Screen+0x4a>
								buf_pix = (Hazard_Blue[i])*209;
 800757c:	ed9f 8a2b 	vldr	s16, [pc, #172]	; 800762c <GUI_Graph_Screen+0x1fc>
								buf_pix = (Hazard_Retina[i])/10.*209;
 8007580:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 8007634 <GUI_Graph_Screen+0x204>
 8007584:	2400      	movs	r4, #0
 8007586:	f04f 0b0c 	mov.w	fp, #12
 800758a:	f04f 0800 	mov.w	r8, #0
 800758e:	fb0b f204 	mul.w	r2, fp, r4
								buf_pix = (Hazard_Blue[i])*209;
 8007592:	eb0a 0302 	add.w	r3, sl, r2
 8007596:	edd3 7a00 	vldr	s15, [r3]
 800759a:	ee67 7a88 	vmul.f32	s15, s15, s16
								buf_pix = (Hazard_Retina[i])/10.*209;
 800759e:	4432      	add	r2, r6
								graph_spectral_Blue[ii] = (uint16_t)buf_pix;
 80075a0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
								buf_pix = (Hazard_Retina[i])/10.*209;
 80075a4:	6810      	ldr	r0, [r2, #0]
								graph_spectral_Blue[ii] = (uint16_t)buf_pix;
 80075a6:	ee17 3a90 	vmov	r3, s15
 80075aa:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]
								buf_pix = (Hazard_Retina[i])/10.*209;
 80075ae:	f7f8 ffdb 	bl	8000568 <__aeabi_f2d>
 80075b2:	4642      	mov	r2, r8
 80075b4:	464b      	mov	r3, r9
 80075b6:	f7f9 f955 	bl	8000864 <__aeabi_ddiv>
 80075ba:	a30d      	add	r3, pc, #52	; (adr r3, 80075f0 <GUI_Graph_Screen+0x1c0>)
 80075bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80075c0:	f7f9 f826 	bl	8000610 <__aeabi_dmul>
 80075c4:	f7f9 fae6 	bl	8000b94 <__aeabi_d2f>
								graph_spectral_Retina[ii] = (uint16_t)buf_pix;
 80075c8:	ee07 0a90 	vmov	s15, r0
 80075cc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80075d0:	ee17 0a90 	vmov	r0, s15
 80075d4:	f825 0014 	strh.w	r0, [r5, r4, lsl #1]
 80075d8:	3401      	adds	r4, #1
						for(uint16_t i = 0; i < 1024; i+=3)
 80075da:	f5b4 7fab 	cmp.w	r4, #342	; 0x156
 80075de:	d1d6      	bne.n	800758e <GUI_Graph_Screen+0x15e>
 80075e0:	e736      	b.n	8007450 <GUI_Graph_Screen+0x20>
 80075e2:	bf00      	nop
 80075e4:	f3af 8000 	nop.w
 80075e8:	00000000 	.word	0x00000000
 80075ec:	40733000 	.word	0x40733000
 80075f0:	00000000 	.word	0x00000000
 80075f4:	406a2000 	.word	0x406a2000
 80075f8:	20000176 	.word	0x20000176
 80075fc:	200002b9 	.word	0x200002b9
 8007600:	20085121 	.word	0x20085121
 8007604:	200002c1 	.word	0x200002c1
 8007608:	20084b8d 	.word	0x20084b8d
 800760c:	200002e9 	.word	0x200002e9
 8007610:	200002ba 	.word	0x200002ba
 8007614:	20085122 	.word	0x20085122
 8007618:	20084b94 	.word	0x20084b94
 800761c:	20001314 	.word	0x20001314
 8007620:	43998000 	.word	0x43998000
 8007624:	200853e8 	.word	0x200853e8
 8007628:	20083b18 	.word	0x20083b18
 800762c:	43510000 	.word	0x43510000
 8007630:	20000314 	.word	0x20000314
 8007634:	40240000 	.word	0x40240000
 8007638:	20084e5a 	.word	0x20084e5a
 800763c:	20082b18 	.word	0x20082b18

08007640 <GUI_Color_Screen>:
void GUI_Color_Screen(){
 8007640:	b570      	push	{r4, r5, r6, lr}
 8007642:	ed2d 8b02 	vpush	{d8}
	if((preGUI_screen_state == Graph_Screen) ||  (preGUI_screen_state == ColorSet1_Screen)||(preGUI_screen_state == ColorSet2_Screen) || (preGUI_screen_state == SD_Write_Screen)){
 8007646:	4d6c      	ldr	r5, [pc, #432]	; (80077f8 <GUI_Color_Screen+0x1b8>)
 8007648:	782b      	ldrb	r3, [r5, #0]
 800764a:	2b04      	cmp	r3, #4
void GUI_Color_Screen(){
 800764c:	b084      	sub	sp, #16
	if((preGUI_screen_state == Graph_Screen) ||  (preGUI_screen_state == ColorSet1_Screen)||(preGUI_screen_state == ColorSet2_Screen) || (preGUI_screen_state == SD_Write_Screen)){
 800764e:	d008      	beq.n	8007662 <GUI_Color_Screen+0x22>
 8007650:	782b      	ldrb	r3, [r5, #0]
 8007652:	2b0e      	cmp	r3, #14
 8007654:	d005      	beq.n	8007662 <GUI_Color_Screen+0x22>
 8007656:	782b      	ldrb	r3, [r5, #0]
 8007658:	2b0f      	cmp	r3, #15
 800765a:	d002      	beq.n	8007662 <GUI_Color_Screen+0x22>
 800765c:	782b      	ldrb	r3, [r5, #0]
 800765e:	2b12      	cmp	r3, #18
 8007660:	d101      	bne.n	8007666 <GUI_Color_Screen+0x26>
		GUI_Panels();
 8007662:	f7ff fab7 	bl	8006bd4 <GUI_Panels>
	Prev_Inf_Screen = Color_Screen;
 8007666:	4b65      	ldr	r3, [pc, #404]	; (80077fc <GUI_Color_Screen+0x1bc>)
	preGUI_screen_state = Color_Screen;
 8007668:	2405      	movs	r4, #5
	Prev_Inf_Screen = Color_Screen;
 800766a:	701c      	strb	r4, [r3, #0]
	if(Color_Field&Color_CIE_xy) {GUI_Text_xy_Measure(40, 50, colorimetry_xy[0], colorimetry_xy[1]); TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*colorimetry_xy[0], 150+350*colorimetry_xy[1], 5, TFT_Cyan); } else
 800766c:	4b64      	ldr	r3, [pc, #400]	; (8007800 <GUI_Color_Screen+0x1c0>)
	preGUI_screen_state = Color_Screen;
 800766e:	702c      	strb	r4, [r5, #0]
	if(Color_Field&Color_CIE_xy) {GUI_Text_xy_Measure(40, 50, colorimetry_xy[0], colorimetry_xy[1]); TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*colorimetry_xy[0], 150+350*colorimetry_xy[1], 5, TFT_Cyan); } else
 8007670:	781b      	ldrb	r3, [r3, #0]
 8007672:	07d9      	lsls	r1, r3, #31
 8007674:	d538      	bpl.n	80076e8 <GUI_Color_Screen+0xa8>
 8007676:	4d63      	ldr	r5, [pc, #396]	; (8007804 <GUI_Color_Screen+0x1c4>)
 8007678:	2132      	movs	r1, #50	; 0x32
 800767a:	edd5 0a01 	vldr	s1, [r5, #4]
 800767e:	ed95 0a00 	vldr	s0, [r5]
 8007682:	2028      	movs	r0, #40	; 0x28
 8007684:	f005 fbac 	bl	800cde0 <GUI_Text_xy_Measure>
 8007688:	2363      	movs	r3, #99	; 0x63
 800768a:	9300      	str	r3, [sp, #0]
 800768c:	f44f 7282 	mov.w	r2, #260	; 0x104
 8007690:	f44f 73cd 	mov.w	r3, #410	; 0x19a
 8007694:	2196      	movs	r1, #150	; 0x96
 8007696:	4620      	mov	r0, r4
 8007698:	f009 f94f 	bl	801093a <TFT_FillRectangle>
 800769c:	edd5 6a01 	vldr	s13, [r5, #4]
 80076a0:	ed9f 7a59 	vldr	s14, [pc, #356]	; 8007808 <GUI_Color_Screen+0x1c8>
 80076a4:	eddf 7a59 	vldr	s15, [pc, #356]	; 800780c <GUI_Color_Screen+0x1cc>
 80076a8:	eee6 7a87 	vfma.f32	s15, s13, s14
 80076ac:	f240 73ff 	movw	r3, #2047	; 0x7ff
 80076b0:	edd5 6a00 	vldr	s13, [r5]
 80076b4:	ed9f 7a56 	vldr	s14, [pc, #344]	; 8007810 <GUI_Color_Screen+0x1d0>
 80076b8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80076bc:	edcd 7a02 	vstr	s15, [sp, #8]
 80076c0:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80076c4:	eee6 7a87 	vfma.f32	s15, s13, s14
 80076c8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80076cc:	edcd 7a03 	vstr	s15, [sp, #12]
	if(Color_Field&Color_CIE_Luv) {GUI_Text_uv_Measure(40, 50, colorimetry_uv[0], colorimetry_uv[1]);TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*colorimetry_uv[0], 150+350*colorimetry_uv[1], 5, TFT_Magenta);} else
 80076d0:	f9bd 1008 	ldrsh.w	r1, [sp, #8]
 80076d4:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
 80076d8:	4622      	mov	r2, r4
}
 80076da:	b004      	add	sp, #16
 80076dc:	ecbd 8b02 	vpop	{d8}
 80076e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if(Color_Field&Color_CIE_Lab) {GUI_Text_LAB_Measure(40, 50, colorimetry_LAB[0], colorimetry_LAB[1], colorimetry_LAB[2]);TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*(float)abs(colorimetry_LAB[1])/100.0, 200+200*(float)abs(colorimetry_LAB[2])/100.0, 5, TFT_Orange);}
 80076e4:	f009 b965 	b.w	80109b2 <TFT_DrawFilledCircle>
	if(Color_Field&Color_CIE_Luv) {GUI_Text_uv_Measure(40, 50, colorimetry_uv[0], colorimetry_uv[1]);TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*colorimetry_uv[0], 150+350*colorimetry_uv[1], 5, TFT_Magenta);} else
 80076e8:	075a      	lsls	r2, r3, #29
 80076ea:	d52d      	bpl.n	8007748 <GUI_Color_Screen+0x108>
 80076ec:	4d49      	ldr	r5, [pc, #292]	; (8007814 <GUI_Color_Screen+0x1d4>)
 80076ee:	2132      	movs	r1, #50	; 0x32
 80076f0:	edd5 0a01 	vldr	s1, [r5, #4]
 80076f4:	ed95 0a00 	vldr	s0, [r5]
 80076f8:	2028      	movs	r0, #40	; 0x28
 80076fa:	f005 fbe1 	bl	800cec0 <GUI_Text_uv_Measure>
 80076fe:	2363      	movs	r3, #99	; 0x63
 8007700:	9300      	str	r3, [sp, #0]
 8007702:	f44f 7282 	mov.w	r2, #260	; 0x104
 8007706:	f44f 73cd 	mov.w	r3, #410	; 0x19a
 800770a:	2196      	movs	r1, #150	; 0x96
 800770c:	4620      	mov	r0, r4
 800770e:	f009 f914 	bl	801093a <TFT_FillRectangle>
 8007712:	edd5 6a01 	vldr	s13, [r5, #4]
 8007716:	ed9f 7a3c 	vldr	s14, [pc, #240]	; 8007808 <GUI_Color_Screen+0x1c8>
 800771a:	eddf 7a3c 	vldr	s15, [pc, #240]	; 800780c <GUI_Color_Screen+0x1cc>
 800771e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8007722:	f64f 031f 	movw	r3, #63519	; 0xf81f
 8007726:	edd5 6a00 	vldr	s13, [r5]
 800772a:	ed9f 7a39 	vldr	s14, [pc, #228]	; 8007810 <GUI_Color_Screen+0x1d0>
 800772e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007732:	edcd 7a02 	vstr	s15, [sp, #8]
 8007736:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800773a:	eee6 7a87 	vfma.f32	s15, s13, s14
 800773e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007742:	edcd 7a03 	vstr	s15, [sp, #12]
 8007746:	e7c3      	b.n	80076d0 <GUI_Color_Screen+0x90>
	if(Color_Field&Color_CIE_Lab) {GUI_Text_LAB_Measure(40, 50, colorimetry_LAB[0], colorimetry_LAB[1], colorimetry_LAB[2]);TFT_FillRectangle(5, 150, 260, 410, TFT_Black_Bkgr); TFT_DrawFilledCircle(10+200*(float)abs(colorimetry_LAB[1])/100.0, 200+200*(float)abs(colorimetry_LAB[2])/100.0, 5, TFT_Orange);}
 8007748:	079b      	lsls	r3, r3, #30
 800774a:	d550      	bpl.n	80077ee <GUI_Color_Screen+0x1ae>
 800774c:	4d32      	ldr	r5, [pc, #200]	; (8007818 <GUI_Color_Screen+0x1d8>)
 800774e:	ed9f 8a30 	vldr	s16, [pc, #192]	; 8007810 <GUI_Color_Screen+0x1d0>
 8007752:	f9b5 1004 	ldrsh.w	r1, [r5, #4]
 8007756:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
 800775a:	f9b5 2000 	ldrsh.w	r2, [r5]
 800775e:	9100      	str	r1, [sp, #0]
 8007760:	2028      	movs	r0, #40	; 0x28
 8007762:	2132      	movs	r1, #50	; 0x32
 8007764:	f006 f8d6 	bl	800d914 <GUI_Text_LAB_Measure>
 8007768:	2363      	movs	r3, #99	; 0x63
 800776a:	f44f 7282 	mov.w	r2, #260	; 0x104
 800776e:	9300      	str	r3, [sp, #0]
 8007770:	2196      	movs	r1, #150	; 0x96
 8007772:	f44f 73cd 	mov.w	r3, #410	; 0x19a
 8007776:	4620      	mov	r0, r4
 8007778:	f009 f8df 	bl	801093a <TFT_FillRectangle>
 800777c:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
 8007780:	2b00      	cmp	r3, #0
 8007782:	bfb8      	it	lt
 8007784:	425b      	neglt	r3, r3
 8007786:	ee07 3a90 	vmov	s15, r3
 800778a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800778e:	ee67 7a88 	vmul.f32	s15, s15, s16
 8007792:	ee17 0a90 	vmov	r0, s15
 8007796:	f7f8 fee7 	bl	8000568 <__aeabi_f2d>
 800779a:	2200      	movs	r2, #0
 800779c:	4b1f      	ldr	r3, [pc, #124]	; (800781c <GUI_Color_Screen+0x1dc>)
 800779e:	f7f9 f861 	bl	8000864 <__aeabi_ddiv>
 80077a2:	2200      	movs	r2, #0
 80077a4:	4b1e      	ldr	r3, [pc, #120]	; (8007820 <GUI_Color_Screen+0x1e0>)
 80077a6:	f7f8 fd81 	bl	80002ac <__adddf3>
 80077aa:	f7f9 f9cb 	bl	8000b44 <__aeabi_d2iz>
 80077ae:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
 80077b2:	2b00      	cmp	r3, #0
 80077b4:	bfb8      	it	lt
 80077b6:	425b      	neglt	r3, r3
 80077b8:	ee07 3a90 	vmov	s15, r3
 80077bc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80077c0:	b206      	sxth	r6, r0
 80077c2:	ee67 7a88 	vmul.f32	s15, s15, s16
 80077c6:	ee17 0a90 	vmov	r0, s15
 80077ca:	f7f8 fecd 	bl	8000568 <__aeabi_f2d>
 80077ce:	2200      	movs	r2, #0
 80077d0:	4b12      	ldr	r3, [pc, #72]	; (800781c <GUI_Color_Screen+0x1dc>)
 80077d2:	f7f9 f847 	bl	8000864 <__aeabi_ddiv>
 80077d6:	2200      	movs	r2, #0
 80077d8:	4b12      	ldr	r3, [pc, #72]	; (8007824 <GUI_Color_Screen+0x1e4>)
 80077da:	f7f8 fd67 	bl	80002ac <__adddf3>
 80077de:	f7f9 f9b1 	bl	8000b44 <__aeabi_d2iz>
 80077e2:	f64f 5320 	movw	r3, #64800	; 0xfd20
 80077e6:	4622      	mov	r2, r4
 80077e8:	4631      	mov	r1, r6
 80077ea:	b200      	sxth	r0, r0
 80077ec:	e775      	b.n	80076da <GUI_Color_Screen+0x9a>
}
 80077ee:	b004      	add	sp, #16
 80077f0:	ecbd 8b02 	vpop	{d8}
 80077f4:	bd70      	pop	{r4, r5, r6, pc}
 80077f6:	bf00      	nop
 80077f8:	20000176 	.word	0x20000176
 80077fc:	20084b8d 	.word	0x20084b8d
 8007800:	200002b7 	.word	0x200002b7
 8007804:	20084b38 	.word	0x20084b38
 8007808:	43af0000 	.word	0x43af0000
 800780c:	43160000 	.word	0x43160000
 8007810:	43480000 	.word	0x43480000
 8007814:	20084b30 	.word	0x20084b30
 8007818:	20084b24 	.word	0x20084b24
 800781c:	40590000 	.word	0x40590000
 8007820:	40690000 	.word	0x40690000
 8007824:	40240000 	.word	0x40240000

08007828 <GUI_ColorRend_Screen>:
	old_meas_type_E = 2; old_meas_type_L = 2;
 8007828:	4a18      	ldr	r2, [pc, #96]	; (800788c <GUI_ColorRend_Screen+0x64>)
void GUI_ColorRend_Screen(){
 800782a:	b538      	push	{r3, r4, r5, lr}
	old_meas_type_E = 2; old_meas_type_L = 2;
 800782c:	2302      	movs	r3, #2
 800782e:	7013      	strb	r3, [r2, #0]
 8007830:	4a17      	ldr	r2, [pc, #92]	; (8007890 <GUI_ColorRend_Screen+0x68>)
 8007832:	4c18      	ldr	r4, [pc, #96]	; (8007894 <GUI_ColorRend_Screen+0x6c>)
 8007834:	7013      	strb	r3, [r2, #0]
	if(preGUI_screen_state != GUI_screen_state || Rotation_Screen_Rend_Old != Rotation_Screen_Rend){
 8007836:	4b18      	ldr	r3, [pc, #96]	; (8007898 <GUI_ColorRend_Screen+0x70>)
 8007838:	4a18      	ldr	r2, [pc, #96]	; (800789c <GUI_ColorRend_Screen+0x74>)
 800783a:	781b      	ldrb	r3, [r3, #0]
 800783c:	7812      	ldrb	r2, [r2, #0]
 800783e:	4d18      	ldr	r5, [pc, #96]	; (80078a0 <GUI_ColorRend_Screen+0x78>)
 8007840:	429a      	cmp	r2, r3
 8007842:	d103      	bne.n	800784c <GUI_ColorRend_Screen+0x24>
 8007844:	7822      	ldrb	r2, [r4, #0]
 8007846:	782b      	ldrb	r3, [r5, #0]
 8007848:	429a      	cmp	r2, r3
 800784a:	d014      	beq.n	8007876 <GUI_ColorRend_Screen+0x4e>
		GUI_Panels();
 800784c:	f7ff f9c2 	bl	8006bd4 <GUI_Panels>
	Rotation_Screen_Rend_Old = Rotation_Screen_Rend;
 8007850:	782b      	ldrb	r3, [r5, #0]
 8007852:	7023      	strb	r3, [r4, #0]
		GUI_Bar_Measure(85, 13, Color_rend_Field? bar_CRI : bar_CQS);
 8007854:	4b13      	ldr	r3, [pc, #76]	; (80078a4 <GUI_ColorRend_Screen+0x7c>)
 8007856:	781b      	ldrb	r3, [r3, #0]
 8007858:	b1ab      	cbz	r3, 8007886 <GUI_ColorRend_Screen+0x5e>
 800785a:	4b13      	ldr	r3, [pc, #76]	; (80078a8 <GUI_ColorRend_Screen+0x80>)
 800785c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007860:	f7f9 f998 	bl	8000b94 <__aeabi_d2f>
 8007864:	210d      	movs	r1, #13
 8007866:	ee00 0a10 	vmov	s0, r0
 800786a:	2055      	movs	r0, #85	; 0x55
 800786c:	f004 fb56 	bl	800bf1c <GUI_Bar_Measure>
	Prev_Inf_Screen = Color_Rendition_Screen;
 8007870:	4b0e      	ldr	r3, [pc, #56]	; (80078ac <GUI_ColorRend_Screen+0x84>)
 8007872:	2206      	movs	r2, #6
 8007874:	701a      	strb	r2, [r3, #0]
	if(Calc_ColorRend != Calc_ColorRend_old){
 8007876:	4b0e      	ldr	r3, [pc, #56]	; (80078b0 <GUI_ColorRend_Screen+0x88>)
 8007878:	781a      	ldrb	r2, [r3, #0]
 800787a:	4b0e      	ldr	r3, [pc, #56]	; (80078b4 <GUI_ColorRend_Screen+0x8c>)
 800787c:	7819      	ldrb	r1, [r3, #0]
 800787e:	4291      	cmp	r1, r2
		Calc_ColorRend_old = Calc_ColorRend;
 8007880:	bf18      	it	ne
 8007882:	701a      	strbne	r2, [r3, #0]
 8007884:	bd38      	pop	{r3, r4, r5, pc}
		GUI_Bar_Measure(85, 13, Color_rend_Field? bar_CRI : bar_CQS);
 8007886:	4b0c      	ldr	r3, [pc, #48]	; (80078b8 <GUI_ColorRend_Screen+0x90>)
 8007888:	e7e8      	b.n	800785c <GUI_ColorRend_Screen+0x34>
 800788a:	bf00      	nop
 800788c:	2000017a 	.word	0x2000017a
 8007890:	2000017b 	.word	0x2000017b
 8007894:	20084b90 	.word	0x20084b90
 8007898:	20000176 	.word	0x20000176
 800789c:	200002b9 	.word	0x200002b9
 80078a0:	200002c0 	.word	0x200002c0
 80078a4:	200002b8 	.word	0x200002b8
 80078a8:	200002e0 	.word	0x200002e0
 80078ac:	20084b8d 	.word	0x20084b8d
 80078b0:	200002b5 	.word	0x200002b5
 80078b4:	200002b6 	.word	0x200002b6
 80078b8:	200002d8 	.word	0x200002d8

080078bc <GUI_Display_Refresh>:
	}
}


void GUI_Display_Refresh()
{
 80078bc:	b508      	push	{r3, lr}

	switch(GUI_screen_state){
 80078be:	4b2d      	ldr	r3, [pc, #180]	; (8007974 <GUI_Display_Refresh+0xb8>)
 80078c0:	781b      	ldrb	r3, [r3, #0]
 80078c2:	3b01      	subs	r3, #1
 80078c4:	2b11      	cmp	r3, #17
 80078c6:	d80f      	bhi.n	80078e8 <GUI_Display_Refresh+0x2c>
 80078c8:	e8df f003 	tbb	[pc, r3]
 80078cc:	17130f09 	.word	0x17130f09
 80078d0:	27231f1b 	.word	0x27231f1b
 80078d4:	37332f2b 	.word	0x37332f2b
 80078d8:	47433f3b 	.word	0x47433f3b
 80078dc:	4f4b      	.short	0x4f4b
		case Measure_Screen: GUI_Measure_Screen(); preGUI_screen_state = Measure_Screen; break;
 80078de:	f7ff f8f5 	bl	8006acc <GUI_Measure_Screen>
 80078e2:	2201      	movs	r2, #1
		case ColorSet1_Screen: GUI_ColorSet1_Screen(); preGUI_screen_state = ColorSet1_Screen; break;
		case ColorSet2_Screen: GUI_ColorSet2_Screen(); preGUI_screen_state = ColorSet2_Screen; break;
		case ColorRendSet_Screen:GUI_ColorRendSet_Screen();preGUI_screen_state = ColorRendSet_Screen; break;

		case Information_Screen : GUI_Information_Screen();preGUI_screen_state = Information_Screen; break;
		case SD_Write_Screen : GUI_SD_Write_Screen();preGUI_screen_state = SD_Write_Screen; break;
 80078e4:	4b24      	ldr	r3, [pc, #144]	; (8007978 <GUI_Display_Refresh+0xbc>)
 80078e6:	701a      	strb	r2, [r3, #0]
 80078e8:	bd08      	pop	{r3, pc}
		case Measure2_Screen: GUI_Measure2_Screen(); preGUI_screen_state = Measure2_Screen; break;
 80078ea:	f7ff f913 	bl	8006b14 <GUI_Measure2_Screen>
 80078ee:	2202      	movs	r2, #2
 80078f0:	e7f8      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case Measure3_Screen: GUI_Measure3_Screen(); preGUI_screen_state = Measure3_Screen; break;
 80078f2:	f7ff f93f 	bl	8006b74 <GUI_Measure3_Screen>
 80078f6:	2203      	movs	r2, #3
 80078f8:	e7f4      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case Graph_Screen: GUI_Graph_Screen(); preGUI_screen_state = Graph_Screen; break;
 80078fa:	f7ff fd99 	bl	8007430 <GUI_Graph_Screen>
 80078fe:	2204      	movs	r2, #4
 8007900:	e7f0      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case Color_Screen: GUI_Color_Screen(); preGUI_screen_state = Color_Screen; break;
 8007902:	f7ff fe9d 	bl	8007640 <GUI_Color_Screen>
 8007906:	2205      	movs	r2, #5
 8007908:	e7ec      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case Color_Rendition_Screen: GUI_ColorRend_Screen(); preGUI_screen_state = Color_Rendition_Screen; break;
 800790a:	f7ff ff8d 	bl	8007828 <GUI_ColorRend_Screen>
 800790e:	2206      	movs	r2, #6
 8007910:	e7e8      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case DataSet1_Screen: GUI_DataSet1_Screen();  preGUI_screen_state = DataSet1_Screen; break;
 8007912:	f7ff f997 	bl	8006c44 <GUI_DataSet1_Screen>
 8007916:	2207      	movs	r2, #7
 8007918:	e7e4      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case DataSet2_Screen: GUI_DataSet2_Screen();  preGUI_screen_state = DataSet2_Screen; break;
 800791a:	f7ff f9fb 	bl	8006d14 <GUI_DataSet2_Screen>
 800791e:	2208      	movs	r2, #8
 8007920:	e7e0      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case DataSet3_Screen: GUI_DataSet3_Screen();  preGUI_screen_state = DataSet3_Screen; break;
 8007922:	f7ff fab9 	bl	8006e98 <GUI_DataSet3_Screen>
 8007926:	2209      	movs	r2, #9
 8007928:	e7dc      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case DataSet4_Screen: GUI_DataSet4_Screen();  preGUI_screen_state = DataSet4_Screen; break;
 800792a:	f7ff fb29 	bl	8006f80 <GUI_DataSet4_Screen>
 800792e:	220a      	movs	r2, #10
 8007930:	e7d8      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case DataSet5_Screen: GUI_DataSet5_Screen();  preGUI_screen_state = DataSet5_Screen; break;
 8007932:	f7ff fbc7 	bl	80070c4 <GUI_DataSet5_Screen>
 8007936:	220b      	movs	r2, #11
 8007938:	e7d4      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case GraphSet1_Screen: GUI_GraphSet1_Screen(); preGUI_screen_state = GraphSet1_Screen; break;
 800793a:	f7ff fc11 	bl	8007160 <GUI_GraphSet1_Screen>
 800793e:	220c      	movs	r2, #12
 8007940:	e7d0      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case GraphSet2_Screen: GUI_GraphSet2_Screen(); preGUI_screen_state = GraphSet2_Screen; break;
 8007942:	f7ff fc55 	bl	80071f0 <GUI_GraphSet2_Screen>
 8007946:	220d      	movs	r2, #13
 8007948:	e7cc      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case ColorSet1_Screen: GUI_ColorSet1_Screen(); preGUI_screen_state = ColorSet1_Screen; break;
 800794a:	f7ff fc8b 	bl	8007264 <GUI_ColorSet1_Screen>
 800794e:	220e      	movs	r2, #14
 8007950:	e7c8      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case ColorSet2_Screen: GUI_ColorSet2_Screen(); preGUI_screen_state = ColorSet2_Screen; break;
 8007952:	f7ff fccb 	bl	80072ec <GUI_ColorSet2_Screen>
 8007956:	220f      	movs	r2, #15
 8007958:	e7c4      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case ColorRendSet_Screen:GUI_ColorRendSet_Screen();preGUI_screen_state = ColorRendSet_Screen; break;
 800795a:	f7ff fd03 	bl	8007364 <GUI_ColorRendSet_Screen>
 800795e:	2210      	movs	r2, #16
 8007960:	e7c0      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case Information_Screen : GUI_Information_Screen();preGUI_screen_state = Information_Screen; break;
 8007962:	f7fe ffa5 	bl	80068b0 <GUI_Information_Screen>
 8007966:	2211      	movs	r2, #17
 8007968:	e7bc      	b.n	80078e4 <GUI_Display_Refresh+0x28>
		case SD_Write_Screen : GUI_SD_Write_Screen();preGUI_screen_state = SD_Write_Screen; break;
 800796a:	f7fe fff1 	bl	8006950 <GUI_SD_Write_Screen>
 800796e:	2212      	movs	r2, #18
 8007970:	e7b8      	b.n	80078e4 <GUI_Display_Refresh+0x28>
 8007972:	bf00      	nop
 8007974:	200002b9 	.word	0x200002b9
 8007978:	20000176 	.word	0x20000176
 800797c:	00000000 	.word	0x00000000

08007980 <GUI_Touch_Processing>:
		default: break;
	}
}

void GUI_Touch_Processing()
{
 8007980:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007984:	b087      	sub	sp, #28
	uint16_t Touch_x = 0, Touch_y = 0;
 8007986:	aa06      	add	r2, sp, #24
 8007988:	2300      	movs	r3, #0
	TS_Get_XY1(TS_I2C_ADDRESS, &Touch_x, &Touch_y);
	switch(GUI_screen_state){
 800798a:	4c89      	ldr	r4, [pc, #548]	; (8007bb0 <GUI_Touch_Processing+0x230>)
	uint16_t Touch_x = 0, Touch_y = 0;
 800798c:	f822 3d02 	strh.w	r3, [r2, #-2]!
	TS_Get_XY1(TS_I2C_ADDRESS, &Touch_x, &Touch_y);
 8007990:	a905      	add	r1, sp, #20
 8007992:	2070      	movs	r0, #112	; 0x70
	uint16_t Touch_x = 0, Touch_y = 0;
 8007994:	f8ad 3014 	strh.w	r3, [sp, #20]
	TS_Get_XY1(TS_I2C_ADDRESS, &Touch_x, &Touch_y);
 8007998:	f008 fda0 	bl	80104dc <TS_Get_XY1>
	switch(GUI_screen_state){
 800799c:	7823      	ldrb	r3, [r4, #0]
 800799e:	3b01      	subs	r3, #1
 80079a0:	2b11      	cmp	r3, #17
 80079a2:	f203 8423 	bhi.w	800b1ec <GUI_Touch_Processing+0x386c>
 80079a6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80079aa:	0012      	.short	0x0012
 80079ac:	01d8010f 	.word	0x01d8010f
 80079b0:	039302c9 	.word	0x039302c9
 80079b4:	05250446 	.word	0x05250446
 80079b8:	099c07ae 	.word	0x099c07ae
 80079bc:	0fa80bbc 	.word	0x0fa80bbc
 80079c0:	13681123 	.word	0x13681123
 80079c4:	16da14c0 	.word	0x16da14c0
 80079c8:	1b1e1867 	.word	0x1b1e1867
 80079cc:	1b9f      	.short	0x1b9f

		case Measure_Screen:
			preGUI_screen_state = GUI_screen_state;
 80079ce:	4b79      	ldr	r3, [pc, #484]	; (8007bb4 <GUI_Touch_Processing+0x234>)

			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 80079d0:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 80079d4:	2501      	movs	r5, #1
 80079d6:	701d      	strb	r5, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 80079d8:	f7f8 fdb4 	bl	8000544 <__aeabi_i2d>
 80079dc:	4606      	mov	r6, r0
 80079de:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 80079e2:	460f      	mov	r7, r1
 80079e4:	f7f8 fdae 	bl	8000544 <__aeabi_i2d>
 80079e8:	a363      	add	r3, pc, #396	; (adr r3, 8007b78 <GUI_Touch_Processing+0x1f8>)
 80079ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80079ee:	4680      	mov	r8, r0
 80079f0:	4689      	mov	r9, r1
 80079f2:	f7f9 f893 	bl	8000b1c <__aeabi_dcmpge>
 80079f6:	b900      	cbnz	r0, 80079fa <GUI_Touch_Processing+0x7a>
 80079f8:	4605      	mov	r5, r0
 80079fa:	2200      	movs	r2, #0
 80079fc:	4b6e      	ldr	r3, [pc, #440]	; (8007bb8 <GUI_Touch_Processing+0x238>)
 80079fe:	4640      	mov	r0, r8
 8007a00:	4649      	mov	r1, r9
 8007a02:	b2ed      	uxtb	r5, r5
 8007a04:	f04f 0a01 	mov.w	sl, #1
 8007a08:	f7f9 f87e 	bl	8000b08 <__aeabi_dcmple>
 8007a0c:	b900      	cbnz	r0, 8007a10 <GUI_Touch_Processing+0x90>
 8007a0e:	4682      	mov	sl, r0
 8007a10:	a35b      	add	r3, pc, #364	; (adr r3, 8007b80 <GUI_Touch_Processing+0x200>)
 8007a12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007a16:	4630      	mov	r0, r6
 8007a18:	4639      	mov	r1, r7
 8007a1a:	fa5f f88a 	uxtb.w	r8, sl
 8007a1e:	f04f 0901 	mov.w	r9, #1
 8007a22:	f7f9 f87b 	bl	8000b1c <__aeabi_dcmpge>
 8007a26:	b900      	cbnz	r0, 8007a2a <GUI_Touch_Processing+0xaa>
 8007a28:	4681      	mov	r9, r0
 8007a2a:	a357      	add	r3, pc, #348	; (adr r3, 8007b88 <GUI_Touch_Processing+0x208>)
 8007a2c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007a30:	4630      	mov	r0, r6
 8007a32:	4639      	mov	r1, r7
 8007a34:	f04f 0a01 	mov.w	sl, #1
 8007a38:	f7f9 f866 	bl	8000b08 <__aeabi_dcmple>
 8007a3c:	b900      	cbnz	r0, 8007a40 <GUI_Touch_Processing+0xc0>
 8007a3e:	4682      	mov	sl, r0
 8007a40:	ea09 090a 	and.w	r9, r9, sl
 8007a44:	ea15 0f09 	tst.w	r5, r9
 8007a48:	d004      	beq.n	8007a54 <GUI_Touch_Processing+0xd4>
 8007a4a:	f1b8 0f00 	cmp.w	r8, #0
 8007a4e:	d001      	beq.n	8007a54 <GUI_Touch_Processing+0xd4>
				{
					GUI_screen_state = DataSet1_Screen;
 8007a50:	2307      	movs	r3, #7
 8007a52:	7023      	strb	r3, [r4, #0]
				}
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //down
 8007a54:	a34e      	add	r3, pc, #312	; (adr r3, 8007b90 <GUI_Touch_Processing+0x210>)
 8007a56:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007a5a:	4630      	mov	r0, r6
 8007a5c:	4639      	mov	r1, r7
 8007a5e:	ea05 0508 	and.w	r5, r5, r8
 8007a62:	f04f 0801 	mov.w	r8, #1
 8007a66:	f7f9 f859 	bl	8000b1c <__aeabi_dcmpge>
 8007a6a:	b900      	cbnz	r0, 8007a6e <GUI_Touch_Processing+0xee>
 8007a6c:	4680      	mov	r8, r0
 8007a6e:	a34a      	add	r3, pc, #296	; (adr r3, 8007b98 <GUI_Touch_Processing+0x218>)
 8007a70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007a74:	4630      	mov	r0, r6
 8007a76:	4639      	mov	r1, r7
 8007a78:	f04f 0901 	mov.w	r9, #1
 8007a7c:	f7f9 f844 	bl	8000b08 <__aeabi_dcmple>
 8007a80:	b900      	cbnz	r0, 8007a84 <GUI_Touch_Processing+0x104>
 8007a82:	4681      	mov	r9, r0
 8007a84:	ea08 0809 	and.w	r8, r8, r9
 8007a88:	f018 0f01 	tst.w	r8, #1
 8007a8c:	d00a      	beq.n	8007aa4 <GUI_Touch_Processing+0x124>
 8007a8e:	b14d      	cbz	r5, 8007aa4 <GUI_Touch_Processing+0x124>
				{
					GUI_screen_state = (screen_count > 0) ? Measure2_Screen : Measure_Screen;
 8007a90:	4b4a      	ldr	r3, [pc, #296]	; (8007bbc <GUI_Touch_Processing+0x23c>)
 8007a92:	781b      	ldrb	r3, [r3, #0]
 8007a94:	2b00      	cmp	r3, #0
 8007a96:	bf0c      	ite	eq
 8007a98:	2301      	moveq	r3, #1
 8007a9a:	2302      	movne	r3, #2
 8007a9c:	7023      	strb	r3, [r4, #0]
				}
			break;

		default: preGUI_screen_state = Measure_Screen;
			}
}
 8007a9e:	b007      	add	sp, #28
 8007aa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 8007aa4:	a33c      	add	r3, pc, #240	; (adr r3, 8007b98 <GUI_Touch_Processing+0x218>)
 8007aa6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007aaa:	4630      	mov	r0, r6
 8007aac:	4639      	mov	r1, r7
 8007aae:	f04f 0801 	mov.w	r8, #1
 8007ab2:	f7f9 f833 	bl	8000b1c <__aeabi_dcmpge>
 8007ab6:	b900      	cbnz	r0, 8007aba <GUI_Touch_Processing+0x13a>
 8007ab8:	4680      	mov	r8, r0
 8007aba:	a339      	add	r3, pc, #228	; (adr r3, 8007ba0 <GUI_Touch_Processing+0x220>)
 8007abc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007ac0:	4630      	mov	r0, r6
 8007ac2:	4639      	mov	r1, r7
 8007ac4:	f04f 0901 	mov.w	r9, #1
 8007ac8:	f7f9 f81e 	bl	8000b08 <__aeabi_dcmple>
 8007acc:	b900      	cbnz	r0, 8007ad0 <GUI_Touch_Processing+0x150>
 8007ace:	4681      	mov	r9, r0
 8007ad0:	ea08 0809 	and.w	r8, r8, r9
 8007ad4:	f018 0f01 	tst.w	r8, #1
 8007ad8:	d003      	beq.n	8007ae2 <GUI_Touch_Processing+0x162>
 8007ada:	b115      	cbz	r5, 8007ae2 <GUI_Touch_Processing+0x162>
					GUI_screen_state =  Graph_Screen;
 8007adc:	2304      	movs	r3, #4
 8007ade:	7023      	strb	r3, [r4, #0]
 8007ae0:	e7dd      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8007ae2:	a329      	add	r3, pc, #164	; (adr r3, 8007b88 <GUI_Touch_Processing+0x208>)
 8007ae4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007ae8:	4630      	mov	r0, r6
 8007aea:	4639      	mov	r1, r7
 8007aec:	f04f 0401 	mov.w	r4, #1
 8007af0:	f7f9 f814 	bl	8000b1c <__aeabi_dcmpge>
 8007af4:	b900      	cbnz	r0, 8007af8 <GUI_Touch_Processing+0x178>
 8007af6:	4604      	mov	r4, r0
 8007af8:	a32b      	add	r3, pc, #172	; (adr r3, 8007ba8 <GUI_Touch_Processing+0x228>)
 8007afa:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007afe:	4630      	mov	r0, r6
 8007b00:	4639      	mov	r1, r7
 8007b02:	f04f 0801 	mov.w	r8, #1
 8007b06:	f7f8 ffff 	bl	8000b08 <__aeabi_dcmple>
 8007b0a:	b900      	cbnz	r0, 8007b0e <GUI_Touch_Processing+0x18e>
 8007b0c:	4680      	mov	r8, r0
 8007b0e:	ea04 0408 	and.w	r4, r4, r8
 8007b12:	07e4      	lsls	r4, r4, #31
 8007b14:	d504      	bpl.n	8007b20 <GUI_Touch_Processing+0x1a0>
 8007b16:	b11d      	cbz	r5, 8007b20 <GUI_Touch_Processing+0x1a0>
					 GUI_screen_state = SD_Write_Screen;
 8007b18:	4b25      	ldr	r3, [pc, #148]	; (8007bb0 <GUI_Touch_Processing+0x230>)
 8007b1a:	2212      	movs	r2, #18
 8007b1c:	701a      	strb	r2, [r3, #0]
 8007b1e:	e7be      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 8007b20:	a321      	add	r3, pc, #132	; (adr r3, 8007ba8 <GUI_Touch_Processing+0x228>)
 8007b22:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007b26:	4630      	mov	r0, r6
 8007b28:	4639      	mov	r1, r7
 8007b2a:	f04f 0401 	mov.w	r4, #1
 8007b2e:	f7f8 fff5 	bl	8000b1c <__aeabi_dcmpge>
 8007b32:	b900      	cbnz	r0, 8007b36 <GUI_Touch_Processing+0x1b6>
 8007b34:	4604      	mov	r4, r0
 8007b36:	a316      	add	r3, pc, #88	; (adr r3, 8007b90 <GUI_Touch_Processing+0x210>)
 8007b38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007b3c:	4630      	mov	r0, r6
 8007b3e:	4639      	mov	r1, r7
 8007b40:	f04f 0801 	mov.w	r8, #1
 8007b44:	f7f8 ffe0 	bl	8000b08 <__aeabi_dcmple>
 8007b48:	b900      	cbnz	r0, 8007b4c <GUI_Touch_Processing+0x1cc>
 8007b4a:	4680      	mov	r8, r0
 8007b4c:	ea04 0408 	and.w	r4, r4, r8
 8007b50:	07e0      	lsls	r0, r4, #31
 8007b52:	d5a4      	bpl.n	8007a9e <GUI_Touch_Processing+0x11e>
 8007b54:	2d00      	cmp	r5, #0
 8007b56:	d0a2      	beq.n	8007a9e <GUI_Touch_Processing+0x11e>
						pause = !pause;
 8007b58:	4a19      	ldr	r2, [pc, #100]	; (8007bc0 <GUI_Touch_Processing+0x240>)
						GUI_Bar_Measure(85, 13, 0.0);
 8007b5a:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 8007bc4 <GUI_Touch_Processing+0x244>
						pause = !pause;
 8007b5e:	7813      	ldrb	r3, [r2, #0]
 8007b60:	fab3 f383 	clz	r3, r3
 8007b64:	095b      	lsrs	r3, r3, #5
						GUI_Bar_Measure(85, 13, 0.0);
 8007b66:	210d      	movs	r1, #13
 8007b68:	2055      	movs	r0, #85	; 0x55
						pause = !pause;
 8007b6a:	7013      	strb	r3, [r2, #0]
						GUI_Bar_Measure(85, 13, 0.0);
 8007b6c:	f004 f9d6 	bl	800bf1c <GUI_Bar_Measure>
 8007b70:	e795      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
 8007b72:	bf00      	nop
 8007b74:	f3af 8000 	nop.w
 8007b78:	99999999 	.word	0x99999999
 8007b7c:	4091a399 	.word	0x4091a399
 8007b80:	33333333 	.word	0x33333333
 8007b84:	40053333 	.word	0x40053333
 8007b88:	00000000 	.word	0x00000000
 8007b8c:	40623800 	.word	0x40623800
 8007b90:	33333333 	.word	0x33333333
 8007b94:	407aff33 	.word	0x407aff33
 8007b98:	66666666 	.word	0x66666666
 8007b9c:	4081f866 	.word	0x4081f866
 8007ba0:	33333333 	.word	0x33333333
 8007ba4:	40867133 	.word	0x40867133
 8007ba8:	99999999 	.word	0x99999999
 8007bac:	40720d99 	.word	0x40720d99
 8007bb0:	200002b9 	.word	0x200002b9
 8007bb4:	20000176 	.word	0x20000176
 8007bb8:	4093e000 	.word	0x4093e000
 8007bbc:	200002f8 	.word	0x200002f8
 8007bc0:	200002e9 	.word	0x200002e9
 8007bc4:	00000000 	.word	0x00000000
			preGUI_screen_state = GUI_screen_state;
 8007bc8:	4ba5      	ldr	r3, [pc, #660]	; (8007e60 <GUI_Touch_Processing+0x4e0>)
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007bca:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 8007bce:	2202      	movs	r2, #2
 8007bd0:	701a      	strb	r2, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007bd2:	f7f8 fcb7 	bl	8000544 <__aeabi_i2d>
 8007bd6:	4606      	mov	r6, r0
 8007bd8:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8007bdc:	460f      	mov	r7, r1
 8007bde:	f7f8 fcb1 	bl	8000544 <__aeabi_i2d>
 8007be2:	a391      	add	r3, pc, #580	; (adr r3, 8007e28 <GUI_Touch_Processing+0x4a8>)
 8007be4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007be8:	4680      	mov	r8, r0
 8007bea:	4689      	mov	r9, r1
 8007bec:	f04f 0a01 	mov.w	sl, #1
 8007bf0:	f7f8 ff94 	bl	8000b1c <__aeabi_dcmpge>
 8007bf4:	b900      	cbnz	r0, 8007bf8 <GUI_Touch_Processing+0x278>
 8007bf6:	4682      	mov	sl, r0
 8007bf8:	2200      	movs	r2, #0
 8007bfa:	4b9a      	ldr	r3, [pc, #616]	; (8007e64 <GUI_Touch_Processing+0x4e4>)
 8007bfc:	4640      	mov	r0, r8
 8007bfe:	4649      	mov	r1, r9
 8007c00:	fa5f fa8a 	uxtb.w	sl, sl
 8007c04:	f04f 0501 	mov.w	r5, #1
 8007c08:	f7f8 ff7e 	bl	8000b08 <__aeabi_dcmple>
 8007c0c:	b900      	cbnz	r0, 8007c10 <GUI_Touch_Processing+0x290>
 8007c0e:	4605      	mov	r5, r0
 8007c10:	a387      	add	r3, pc, #540	; (adr r3, 8007e30 <GUI_Touch_Processing+0x4b0>)
 8007c12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c16:	4630      	mov	r0, r6
 8007c18:	4639      	mov	r1, r7
 8007c1a:	b2ed      	uxtb	r5, r5
 8007c1c:	f04f 0801 	mov.w	r8, #1
 8007c20:	f7f8 ff7c 	bl	8000b1c <__aeabi_dcmpge>
 8007c24:	b900      	cbnz	r0, 8007c28 <GUI_Touch_Processing+0x2a8>
 8007c26:	4680      	mov	r8, r0
 8007c28:	a383      	add	r3, pc, #524	; (adr r3, 8007e38 <GUI_Touch_Processing+0x4b8>)
 8007c2a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c2e:	4630      	mov	r0, r6
 8007c30:	4639      	mov	r1, r7
 8007c32:	f04f 0901 	mov.w	r9, #1
 8007c36:	f7f8 ff67 	bl	8000b08 <__aeabi_dcmple>
 8007c3a:	b900      	cbnz	r0, 8007c3e <GUI_Touch_Processing+0x2be>
 8007c3c:	4681      	mov	r9, r0
 8007c3e:	ea08 0809 	and.w	r8, r8, r9
 8007c42:	ea1a 0f08 	tst.w	sl, r8
 8007c46:	d002      	beq.n	8007c4e <GUI_Touch_Processing+0x2ce>
 8007c48:	b10d      	cbz	r5, 8007c4e <GUI_Touch_Processing+0x2ce>
					GUI_screen_state = DataSet1_Screen;
 8007c4a:	2307      	movs	r3, #7
 8007c4c:	7023      	strb	r3, [r4, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007c4e:	a37c      	add	r3, pc, #496	; (adr r3, 8007e40 <GUI_Touch_Processing+0x4c0>)
 8007c50:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c54:	4630      	mov	r0, r6
 8007c56:	4639      	mov	r1, r7
 8007c58:	ea0a 0505 	and.w	r5, sl, r5
 8007c5c:	f04f 0801 	mov.w	r8, #1
 8007c60:	f7f8 ff5c 	bl	8000b1c <__aeabi_dcmpge>
 8007c64:	b900      	cbnz	r0, 8007c68 <GUI_Touch_Processing+0x2e8>
 8007c66:	4680      	mov	r8, r0
 8007c68:	a377      	add	r3, pc, #476	; (adr r3, 8007e48 <GUI_Touch_Processing+0x4c8>)
 8007c6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c6e:	4630      	mov	r0, r6
 8007c70:	4639      	mov	r1, r7
 8007c72:	f04f 0901 	mov.w	r9, #1
 8007c76:	f7f8 ff47 	bl	8000b08 <__aeabi_dcmple>
 8007c7a:	b900      	cbnz	r0, 8007c7e <GUI_Touch_Processing+0x2fe>
 8007c7c:	4681      	mov	r9, r0
 8007c7e:	ea08 0809 	and.w	r8, r8, r9
 8007c82:	f018 0f01 	tst.w	r8, #1
 8007c86:	d008      	beq.n	8007c9a <GUI_Touch_Processing+0x31a>
 8007c88:	b13d      	cbz	r5, 8007c9a <GUI_Touch_Processing+0x31a>
					GUI_screen_state = (screen_count > 1) ? Measure3_Screen : Measure_Screen;
 8007c8a:	4b77      	ldr	r3, [pc, #476]	; (8007e68 <GUI_Touch_Processing+0x4e8>)
 8007c8c:	781b      	ldrb	r3, [r3, #0]
 8007c8e:	2b02      	cmp	r3, #2
 8007c90:	bf34      	ite	cc
 8007c92:	2301      	movcc	r3, #1
 8007c94:	2303      	movcs	r3, #3
 8007c96:	7023      	strb	r3, [r4, #0]
 8007c98:	e701      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 8007c9a:	a36b      	add	r3, pc, #428	; (adr r3, 8007e48 <GUI_Touch_Processing+0x4c8>)
 8007c9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007ca0:	4630      	mov	r0, r6
 8007ca2:	4639      	mov	r1, r7
 8007ca4:	f04f 0801 	mov.w	r8, #1
 8007ca8:	f7f8 ff38 	bl	8000b1c <__aeabi_dcmpge>
 8007cac:	b900      	cbnz	r0, 8007cb0 <GUI_Touch_Processing+0x330>
 8007cae:	4680      	mov	r8, r0
 8007cb0:	a367      	add	r3, pc, #412	; (adr r3, 8007e50 <GUI_Touch_Processing+0x4d0>)
 8007cb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cb6:	4630      	mov	r0, r6
 8007cb8:	4639      	mov	r1, r7
 8007cba:	f04f 0901 	mov.w	r9, #1
 8007cbe:	f7f8 ff23 	bl	8000b08 <__aeabi_dcmple>
 8007cc2:	b900      	cbnz	r0, 8007cc6 <GUI_Touch_Processing+0x346>
 8007cc4:	4681      	mov	r9, r0
 8007cc6:	ea08 0809 	and.w	r8, r8, r9
 8007cca:	f018 0f01 	tst.w	r8, #1
 8007cce:	d002      	beq.n	8007cd6 <GUI_Touch_Processing+0x356>
 8007cd0:	2d00      	cmp	r5, #0
 8007cd2:	f47f af03 	bne.w	8007adc <GUI_Touch_Processing+0x15c>
			if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8007cd6:	a358      	add	r3, pc, #352	; (adr r3, 8007e38 <GUI_Touch_Processing+0x4b8>)
 8007cd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cdc:	4630      	mov	r0, r6
 8007cde:	4639      	mov	r1, r7
 8007ce0:	f04f 0401 	mov.w	r4, #1
 8007ce4:	f7f8 ff1a 	bl	8000b1c <__aeabi_dcmpge>
 8007ce8:	b900      	cbnz	r0, 8007cec <GUI_Touch_Processing+0x36c>
 8007cea:	4604      	mov	r4, r0
 8007cec:	a35a      	add	r3, pc, #360	; (adr r3, 8007e58 <GUI_Touch_Processing+0x4d8>)
 8007cee:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cf2:	4630      	mov	r0, r6
 8007cf4:	4639      	mov	r1, r7
 8007cf6:	f04f 0801 	mov.w	r8, #1
 8007cfa:	f7f8 ff05 	bl	8000b08 <__aeabi_dcmple>
 8007cfe:	b900      	cbnz	r0, 8007d02 <GUI_Touch_Processing+0x382>
 8007d00:	4680      	mov	r8, r0
 8007d02:	ea04 0408 	and.w	r4, r4, r8
 8007d06:	07e1      	lsls	r1, r4, #31
 8007d08:	d502      	bpl.n	8007d10 <GUI_Touch_Processing+0x390>
 8007d0a:	2d00      	cmp	r5, #0
 8007d0c:	f47f af04 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 8007d10:	a351      	add	r3, pc, #324	; (adr r3, 8007e58 <GUI_Touch_Processing+0x4d8>)
 8007d12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d16:	4630      	mov	r0, r6
 8007d18:	4639      	mov	r1, r7
 8007d1a:	f04f 0401 	mov.w	r4, #1
 8007d1e:	f7f8 fefd 	bl	8000b1c <__aeabi_dcmpge>
 8007d22:	b900      	cbnz	r0, 8007d26 <GUI_Touch_Processing+0x3a6>
 8007d24:	4604      	mov	r4, r0
 8007d26:	a346      	add	r3, pc, #280	; (adr r3, 8007e40 <GUI_Touch_Processing+0x4c0>)
 8007d28:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d2c:	4630      	mov	r0, r6
 8007d2e:	4639      	mov	r1, r7
 8007d30:	f04f 0801 	mov.w	r8, #1
 8007d34:	f7f8 fee8 	bl	8000b08 <__aeabi_dcmple>
 8007d38:	b900      	cbnz	r0, 8007d3c <GUI_Touch_Processing+0x3bc>
 8007d3a:	4680      	mov	r8, r0
 8007d3c:	ea04 0408 	and.w	r4, r4, r8
 8007d40:	07e2      	lsls	r2, r4, #31
 8007d42:	f57f aeac 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 8007d46:	2d00      	cmp	r5, #0
 8007d48:	f43f aea9 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
						pause = !pause;
 8007d4c:	4a47      	ldr	r2, [pc, #284]	; (8007e6c <GUI_Touch_Processing+0x4ec>)
 8007d4e:	7813      	ldrb	r3, [r2, #0]
 8007d50:	fab3 f383 	clz	r3, r3
 8007d54:	095b      	lsrs	r3, r3, #5
 8007d56:	7013      	strb	r3, [r2, #0]
 8007d58:	e6a1      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			preGUI_screen_state = GUI_screen_state;
 8007d5a:	4b41      	ldr	r3, [pc, #260]	; (8007e60 <GUI_Touch_Processing+0x4e0>)
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007d5c:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 8007d60:	2203      	movs	r2, #3
 8007d62:	701a      	strb	r2, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007d64:	f7f8 fbee 	bl	8000544 <__aeabi_i2d>
 8007d68:	4606      	mov	r6, r0
 8007d6a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8007d6e:	460f      	mov	r7, r1
 8007d70:	f7f8 fbe8 	bl	8000544 <__aeabi_i2d>
 8007d74:	a32c      	add	r3, pc, #176	; (adr r3, 8007e28 <GUI_Touch_Processing+0x4a8>)
 8007d76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d7a:	4680      	mov	r8, r0
 8007d7c:	4689      	mov	r9, r1
 8007d7e:	f04f 0a01 	mov.w	sl, #1
 8007d82:	f7f8 fecb 	bl	8000b1c <__aeabi_dcmpge>
 8007d86:	b900      	cbnz	r0, 8007d8a <GUI_Touch_Processing+0x40a>
 8007d88:	4682      	mov	sl, r0
 8007d8a:	2200      	movs	r2, #0
 8007d8c:	4b35      	ldr	r3, [pc, #212]	; (8007e64 <GUI_Touch_Processing+0x4e4>)
 8007d8e:	4640      	mov	r0, r8
 8007d90:	4649      	mov	r1, r9
 8007d92:	fa5f fa8a 	uxtb.w	sl, sl
 8007d96:	f04f 0501 	mov.w	r5, #1
 8007d9a:	f7f8 feb5 	bl	8000b08 <__aeabi_dcmple>
 8007d9e:	b900      	cbnz	r0, 8007da2 <GUI_Touch_Processing+0x422>
 8007da0:	4605      	mov	r5, r0
 8007da2:	a323      	add	r3, pc, #140	; (adr r3, 8007e30 <GUI_Touch_Processing+0x4b0>)
 8007da4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007da8:	4630      	mov	r0, r6
 8007daa:	4639      	mov	r1, r7
 8007dac:	b2ed      	uxtb	r5, r5
 8007dae:	f04f 0801 	mov.w	r8, #1
 8007db2:	f7f8 feb3 	bl	8000b1c <__aeabi_dcmpge>
 8007db6:	b900      	cbnz	r0, 8007dba <GUI_Touch_Processing+0x43a>
 8007db8:	4680      	mov	r8, r0
 8007dba:	a31f      	add	r3, pc, #124	; (adr r3, 8007e38 <GUI_Touch_Processing+0x4b8>)
 8007dbc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007dc0:	4630      	mov	r0, r6
 8007dc2:	4639      	mov	r1, r7
 8007dc4:	f04f 0901 	mov.w	r9, #1
 8007dc8:	f7f8 fe9e 	bl	8000b08 <__aeabi_dcmple>
 8007dcc:	b900      	cbnz	r0, 8007dd0 <GUI_Touch_Processing+0x450>
 8007dce:	4681      	mov	r9, r0
 8007dd0:	ea08 0809 	and.w	r8, r8, r9
 8007dd4:	ea1a 0f08 	tst.w	sl, r8
 8007dd8:	d002      	beq.n	8007de0 <GUI_Touch_Processing+0x460>
 8007dda:	b10d      	cbz	r5, 8007de0 <GUI_Touch_Processing+0x460>
					GUI_screen_state = DataSet1_Screen;
 8007ddc:	2307      	movs	r3, #7
 8007dde:	7023      	strb	r3, [r4, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Down
 8007de0:	a317      	add	r3, pc, #92	; (adr r3, 8007e40 <GUI_Touch_Processing+0x4c0>)
 8007de2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007de6:	4630      	mov	r0, r6
 8007de8:	4639      	mov	r1, r7
 8007dea:	ea0a 0505 	and.w	r5, sl, r5
 8007dee:	f04f 0801 	mov.w	r8, #1
 8007df2:	f7f8 fe93 	bl	8000b1c <__aeabi_dcmpge>
 8007df6:	b900      	cbnz	r0, 8007dfa <GUI_Touch_Processing+0x47a>
 8007df8:	4680      	mov	r8, r0
 8007dfa:	a313      	add	r3, pc, #76	; (adr r3, 8007e48 <GUI_Touch_Processing+0x4c8>)
 8007dfc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007e00:	4630      	mov	r0, r6
 8007e02:	4639      	mov	r1, r7
 8007e04:	f04f 0901 	mov.w	r9, #1
 8007e08:	f7f8 fe7e 	bl	8000b08 <__aeabi_dcmple>
 8007e0c:	b900      	cbnz	r0, 8007e10 <GUI_Touch_Processing+0x490>
 8007e0e:	4681      	mov	r9, r0
 8007e10:	ea08 0809 	and.w	r8, r8, r9
 8007e14:	f018 0f01 	tst.w	r8, #1
 8007e18:	d02a      	beq.n	8007e70 <GUI_Touch_Processing+0x4f0>
 8007e1a:	b34d      	cbz	r5, 8007e70 <GUI_Touch_Processing+0x4f0>
					GUI_screen_state = Measure_Screen;
 8007e1c:	2301      	movs	r3, #1
 8007e1e:	7023      	strb	r3, [r4, #0]
 8007e20:	e63d      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
 8007e22:	bf00      	nop
 8007e24:	f3af 8000 	nop.w
 8007e28:	99999999 	.word	0x99999999
 8007e2c:	4091a399 	.word	0x4091a399
 8007e30:	33333333 	.word	0x33333333
 8007e34:	40053333 	.word	0x40053333
 8007e38:	00000000 	.word	0x00000000
 8007e3c:	40623800 	.word	0x40623800
 8007e40:	33333333 	.word	0x33333333
 8007e44:	407aff33 	.word	0x407aff33
 8007e48:	66666666 	.word	0x66666666
 8007e4c:	4081f866 	.word	0x4081f866
 8007e50:	33333333 	.word	0x33333333
 8007e54:	40867133 	.word	0x40867133
 8007e58:	99999999 	.word	0x99999999
 8007e5c:	40720d99 	.word	0x40720d99
 8007e60:	20000176 	.word	0x20000176
 8007e64:	4093e000 	.word	0x4093e000
 8007e68:	200002f8 	.word	0x200002f8
 8007e6c:	200002e9 	.word	0x200002e9
			if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 8007e70:	a3d3      	add	r3, pc, #844	; (adr r3, 80081c0 <GUI_Touch_Processing+0x840>)
 8007e72:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007e76:	4630      	mov	r0, r6
 8007e78:	4639      	mov	r1, r7
 8007e7a:	f04f 0801 	mov.w	r8, #1
 8007e7e:	f7f8 fe4d 	bl	8000b1c <__aeabi_dcmpge>
 8007e82:	b900      	cbnz	r0, 8007e86 <GUI_Touch_Processing+0x506>
 8007e84:	4680      	mov	r8, r0
 8007e86:	a3d0      	add	r3, pc, #832	; (adr r3, 80081c8 <GUI_Touch_Processing+0x848>)
 8007e88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007e8c:	4630      	mov	r0, r6
 8007e8e:	4639      	mov	r1, r7
 8007e90:	f04f 0901 	mov.w	r9, #1
 8007e94:	f7f8 fe38 	bl	8000b08 <__aeabi_dcmple>
 8007e98:	b900      	cbnz	r0, 8007e9c <GUI_Touch_Processing+0x51c>
 8007e9a:	4681      	mov	r9, r0
 8007e9c:	ea08 0809 	and.w	r8, r8, r9
 8007ea0:	f018 0f01 	tst.w	r8, #1
 8007ea4:	d002      	beq.n	8007eac <GUI_Touch_Processing+0x52c>
 8007ea6:	2d00      	cmp	r5, #0
 8007ea8:	f47f ae18 	bne.w	8007adc <GUI_Touch_Processing+0x15c>
			if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8007eac:	a3c0      	add	r3, pc, #768	; (adr r3, 80081b0 <GUI_Touch_Processing+0x830>)
 8007eae:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007eb2:	4630      	mov	r0, r6
 8007eb4:	4639      	mov	r1, r7
 8007eb6:	f04f 0401 	mov.w	r4, #1
 8007eba:	f7f8 fe2f 	bl	8000b1c <__aeabi_dcmpge>
 8007ebe:	b900      	cbnz	r0, 8007ec2 <GUI_Touch_Processing+0x542>
 8007ec0:	4604      	mov	r4, r0
 8007ec2:	a3c3      	add	r3, pc, #780	; (adr r3, 80081d0 <GUI_Touch_Processing+0x850>)
 8007ec4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007ec8:	4630      	mov	r0, r6
 8007eca:	4639      	mov	r1, r7
 8007ecc:	f04f 0801 	mov.w	r8, #1
 8007ed0:	f7f8 fe1a 	bl	8000b08 <__aeabi_dcmple>
 8007ed4:	b900      	cbnz	r0, 8007ed8 <GUI_Touch_Processing+0x558>
 8007ed6:	4680      	mov	r8, r0
 8007ed8:	ea04 0408 	and.w	r4, r4, r8
 8007edc:	07e3      	lsls	r3, r4, #31
 8007ede:	d502      	bpl.n	8007ee6 <GUI_Touch_Processing+0x566>
 8007ee0:	2d00      	cmp	r5, #0
 8007ee2:	f47f ae19 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 8007ee6:	a3ba      	add	r3, pc, #744	; (adr r3, 80081d0 <GUI_Touch_Processing+0x850>)
 8007ee8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007eec:	4630      	mov	r0, r6
 8007eee:	4639      	mov	r1, r7
 8007ef0:	f04f 0401 	mov.w	r4, #1
 8007ef4:	f7f8 fe12 	bl	8000b1c <__aeabi_dcmpge>
 8007ef8:	b900      	cbnz	r0, 8007efc <GUI_Touch_Processing+0x57c>
 8007efa:	4604      	mov	r4, r0
 8007efc:	a3ae      	add	r3, pc, #696	; (adr r3, 80081b8 <GUI_Touch_Processing+0x838>)
 8007efe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007f02:	4630      	mov	r0, r6
 8007f04:	4639      	mov	r1, r7
 8007f06:	f04f 0801 	mov.w	r8, #1
 8007f0a:	f7f8 fdfd 	bl	8000b08 <__aeabi_dcmple>
 8007f0e:	b900      	cbnz	r0, 8007f12 <GUI_Touch_Processing+0x592>
 8007f10:	4680      	mov	r8, r0
 8007f12:	ea04 0408 	and.w	r4, r4, r8
 8007f16:	07e4      	lsls	r4, r4, #31
 8007f18:	f57f adc1 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 8007f1c:	2d00      	cmp	r5, #0
 8007f1e:	f43f adbe 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
						pause = !pause;
 8007f22:	4aad      	ldr	r2, [pc, #692]	; (80081d8 <GUI_Touch_Processing+0x858>)
						GUI_Bar_Measure(85, 13, 0.0);
 8007f24:	ed9f 0aad 	vldr	s0, [pc, #692]	; 80081dc <GUI_Touch_Processing+0x85c>
						pause = !pause;
 8007f28:	7813      	ldrb	r3, [r2, #0]
 8007f2a:	fab3 f383 	clz	r3, r3
 8007f2e:	095b      	lsrs	r3, r3, #5
						GUI_Bar_Measure(85, 13, 0.0);
 8007f30:	210d      	movs	r1, #13
 8007f32:	2055      	movs	r0, #85	; 0x55
						pause = !pause;
 8007f34:	7013      	strb	r3, [r2, #0]
						GUI_Bar_Measure(85, 13, 0.0);
 8007f36:	f003 fff1 	bl	800bf1c <GUI_Bar_Measure>
 8007f3a:	e5b0      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			preGUI_screen_state = GUI_screen_state;
 8007f3c:	4ba8      	ldr	r3, [pc, #672]	; (80081e0 <GUI_Touch_Processing+0x860>)
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007f3e:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 8007f42:	2204      	movs	r2, #4
 8007f44:	701a      	strb	r2, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8007f46:	f7f8 fafd 	bl	8000544 <__aeabi_i2d>
 8007f4a:	4606      	mov	r6, r0
 8007f4c:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8007f50:	460f      	mov	r7, r1
 8007f52:	f7f8 faf7 	bl	8000544 <__aeabi_i2d>
 8007f56:	a392      	add	r3, pc, #584	; (adr r3, 80081a0 <GUI_Touch_Processing+0x820>)
 8007f58:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007f5c:	4680      	mov	r8, r0
 8007f5e:	4689      	mov	r9, r1
 8007f60:	f04f 0a01 	mov.w	sl, #1
 8007f64:	f7f8 fdda 	bl	8000b1c <__aeabi_dcmpge>
 8007f68:	b900      	cbnz	r0, 8007f6c <GUI_Touch_Processing+0x5ec>
 8007f6a:	4682      	mov	sl, r0
 8007f6c:	2200      	movs	r2, #0
 8007f6e:	4b9d      	ldr	r3, [pc, #628]	; (80081e4 <GUI_Touch_Processing+0x864>)
 8007f70:	4640      	mov	r0, r8
 8007f72:	4649      	mov	r1, r9
 8007f74:	fa5f fa8a 	uxtb.w	sl, sl
 8007f78:	f04f 0501 	mov.w	r5, #1
 8007f7c:	f7f8 fdc4 	bl	8000b08 <__aeabi_dcmple>
 8007f80:	b900      	cbnz	r0, 8007f84 <GUI_Touch_Processing+0x604>
 8007f82:	4605      	mov	r5, r0
 8007f84:	a388      	add	r3, pc, #544	; (adr r3, 80081a8 <GUI_Touch_Processing+0x828>)
 8007f86:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007f8a:	4630      	mov	r0, r6
 8007f8c:	4639      	mov	r1, r7
 8007f8e:	b2ed      	uxtb	r5, r5
 8007f90:	f04f 0801 	mov.w	r8, #1
 8007f94:	f7f8 fdc2 	bl	8000b1c <__aeabi_dcmpge>
 8007f98:	b900      	cbnz	r0, 8007f9c <GUI_Touch_Processing+0x61c>
 8007f9a:	4680      	mov	r8, r0
 8007f9c:	a384      	add	r3, pc, #528	; (adr r3, 80081b0 <GUI_Touch_Processing+0x830>)
 8007f9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007fa2:	4630      	mov	r0, r6
 8007fa4:	4639      	mov	r1, r7
 8007fa6:	f04f 0901 	mov.w	r9, #1
 8007faa:	f7f8 fdad 	bl	8000b08 <__aeabi_dcmple>
 8007fae:	b900      	cbnz	r0, 8007fb2 <GUI_Touch_Processing+0x632>
 8007fb0:	4681      	mov	r9, r0
 8007fb2:	ea08 0809 	and.w	r8, r8, r9
 8007fb6:	ea1a 0f08 	tst.w	sl, r8
 8007fba:	d002      	beq.n	8007fc2 <GUI_Touch_Processing+0x642>
 8007fbc:	b10d      	cbz	r5, 8007fc2 <GUI_Touch_Processing+0x642>
					GUI_screen_state = GraphSet1_Screen;
 8007fbe:	230c      	movs	r3, #12
 8007fc0:	7023      	strb	r3, [r4, #0]
			if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Rotation_Screen
 8007fc2:	a37d      	add	r3, pc, #500	; (adr r3, 80081b8 <GUI_Touch_Processing+0x838>)
 8007fc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007fc8:	4630      	mov	r0, r6
 8007fca:	4639      	mov	r1, r7
 8007fcc:	ea0a 0505 	and.w	r5, sl, r5
 8007fd0:	f04f 0801 	mov.w	r8, #1
 8007fd4:	f7f8 fda2 	bl	8000b1c <__aeabi_dcmpge>
 8007fd8:	b900      	cbnz	r0, 8007fdc <GUI_Touch_Processing+0x65c>
 8007fda:	4680      	mov	r8, r0
 8007fdc:	a378      	add	r3, pc, #480	; (adr r3, 80081c0 <GUI_Touch_Processing+0x840>)
 8007fde:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007fe2:	4630      	mov	r0, r6
 8007fe4:	4639      	mov	r1, r7
 8007fe6:	f04f 0901 	mov.w	r9, #1
 8007fea:	f7f8 fd8d 	bl	8000b08 <__aeabi_dcmple>
 8007fee:	b900      	cbnz	r0, 8007ff2 <GUI_Touch_Processing+0x672>
 8007ff0:	4681      	mov	r9, r0
 8007ff2:	ea08 0809 	and.w	r8, r8, r9
 8007ff6:	f018 0f01 	tst.w	r8, #1
 8007ffa:	d008      	beq.n	800800e <GUI_Touch_Processing+0x68e>
 8007ffc:	b13d      	cbz	r5, 800800e <GUI_Touch_Processing+0x68e>
					if(Rotation_Screen_Spectral < 0x02) {Rotation_Screen_Spectral++;} else{Rotation_Screen_Spectral= 0x00;}
 8007ffe:	4a7a      	ldr	r2, [pc, #488]	; (80081e8 <GUI_Touch_Processing+0x868>)
 8008000:	7813      	ldrb	r3, [r2, #0]
 8008002:	2b01      	cmp	r3, #1
 8008004:	bf94      	ite	ls
 8008006:	3301      	addls	r3, #1
 8008008:	2300      	movhi	r3, #0
 800800a:	7013      	strb	r3, [r2, #0]
 800800c:	e547      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 800800e:	a36c      	add	r3, pc, #432	; (adr r3, 80081c0 <GUI_Touch_Processing+0x840>)
 8008010:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008014:	4630      	mov	r0, r6
 8008016:	4639      	mov	r1, r7
 8008018:	f04f 0801 	mov.w	r8, #1
 800801c:	f7f8 fd7e 	bl	8000b1c <__aeabi_dcmpge>
 8008020:	b900      	cbnz	r0, 8008024 <GUI_Touch_Processing+0x6a4>
 8008022:	4680      	mov	r8, r0
 8008024:	a368      	add	r3, pc, #416	; (adr r3, 80081c8 <GUI_Touch_Processing+0x848>)
 8008026:	e9d3 2300 	ldrd	r2, r3, [r3]
 800802a:	4630      	mov	r0, r6
 800802c:	4639      	mov	r1, r7
 800802e:	f04f 0901 	mov.w	r9, #1
 8008032:	f7f8 fd69 	bl	8000b08 <__aeabi_dcmple>
 8008036:	b900      	cbnz	r0, 800803a <GUI_Touch_Processing+0x6ba>
 8008038:	4681      	mov	r9, r0
 800803a:	ea08 0809 	and.w	r8, r8, r9
 800803e:	f018 0f01 	tst.w	r8, #1
 8008042:	d003      	beq.n	800804c <GUI_Touch_Processing+0x6cc>
 8008044:	b115      	cbz	r5, 800804c <GUI_Touch_Processing+0x6cc>
					GUI_screen_state = Color_Screen;
 8008046:	2305      	movs	r3, #5
 8008048:	7023      	strb	r3, [r4, #0]
 800804a:	e528      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 800804c:	a358      	add	r3, pc, #352	; (adr r3, 80081b0 <GUI_Touch_Processing+0x830>)
 800804e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008052:	4630      	mov	r0, r6
 8008054:	4639      	mov	r1, r7
 8008056:	f04f 0401 	mov.w	r4, #1
 800805a:	f7f8 fd5f 	bl	8000b1c <__aeabi_dcmpge>
 800805e:	b900      	cbnz	r0, 8008062 <GUI_Touch_Processing+0x6e2>
 8008060:	4604      	mov	r4, r0
 8008062:	a35b      	add	r3, pc, #364	; (adr r3, 80081d0 <GUI_Touch_Processing+0x850>)
 8008064:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008068:	4630      	mov	r0, r6
 800806a:	4639      	mov	r1, r7
 800806c:	f04f 0801 	mov.w	r8, #1
 8008070:	f7f8 fd4a 	bl	8000b08 <__aeabi_dcmple>
 8008074:	b900      	cbnz	r0, 8008078 <GUI_Touch_Processing+0x6f8>
 8008076:	4680      	mov	r8, r0
 8008078:	ea04 0408 	and.w	r4, r4, r8
 800807c:	07e0      	lsls	r0, r4, #31
 800807e:	d502      	bpl.n	8008086 <GUI_Touch_Processing+0x706>
 8008080:	2d00      	cmp	r5, #0
 8008082:	f47f ad49 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 8008086:	a352      	add	r3, pc, #328	; (adr r3, 80081d0 <GUI_Touch_Processing+0x850>)
 8008088:	e9d3 2300 	ldrd	r2, r3, [r3]
 800808c:	4630      	mov	r0, r6
 800808e:	4639      	mov	r1, r7
 8008090:	f04f 0401 	mov.w	r4, #1
 8008094:	f7f8 fd42 	bl	8000b1c <__aeabi_dcmpge>
 8008098:	b900      	cbnz	r0, 800809c <GUI_Touch_Processing+0x71c>
 800809a:	4604      	mov	r4, r0
 800809c:	a346      	add	r3, pc, #280	; (adr r3, 80081b8 <GUI_Touch_Processing+0x838>)
 800809e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80080a2:	4630      	mov	r0, r6
 80080a4:	4639      	mov	r1, r7
 80080a6:	f04f 0801 	mov.w	r8, #1
 80080aa:	f7f8 fd2d 	bl	8000b08 <__aeabi_dcmple>
 80080ae:	b900      	cbnz	r0, 80080b2 <GUI_Touch_Processing+0x732>
 80080b0:	4680      	mov	r8, r0
 80080b2:	ea04 0408 	and.w	r4, r4, r8
 80080b6:	07e1      	lsls	r1, r4, #31
 80080b8:	f57f acf1 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 80080bc:	2d00      	cmp	r5, #0
 80080be:	f43f acee 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
					pause = !pause;
 80080c2:	4a45      	ldr	r2, [pc, #276]	; (80081d8 <GUI_Touch_Processing+0x858>)
 80080c4:	7813      	ldrb	r3, [r2, #0]
 80080c6:	fab3 f383 	clz	r3, r3
 80080ca:	095b      	lsrs	r3, r3, #5
 80080cc:	7013      	strb	r3, [r2, #0]
 80080ce:	e4e6      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			preGUI_screen_state = GUI_screen_state;
 80080d0:	4b43      	ldr	r3, [pc, #268]	; (80081e0 <GUI_Touch_Processing+0x860>)
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 80080d2:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 80080d6:	2205      	movs	r2, #5
 80080d8:	701a      	strb	r2, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 80080da:	f7f8 fa33 	bl	8000544 <__aeabi_i2d>
 80080de:	4606      	mov	r6, r0
 80080e0:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 80080e4:	460f      	mov	r7, r1
 80080e6:	f7f8 fa2d 	bl	8000544 <__aeabi_i2d>
 80080ea:	a32d      	add	r3, pc, #180	; (adr r3, 80081a0 <GUI_Touch_Processing+0x820>)
 80080ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80080f0:	4680      	mov	r8, r0
 80080f2:	4689      	mov	r9, r1
 80080f4:	f04f 0a01 	mov.w	sl, #1
 80080f8:	f7f8 fd10 	bl	8000b1c <__aeabi_dcmpge>
 80080fc:	b900      	cbnz	r0, 8008100 <GUI_Touch_Processing+0x780>
 80080fe:	4682      	mov	sl, r0
 8008100:	2200      	movs	r2, #0
 8008102:	4b38      	ldr	r3, [pc, #224]	; (80081e4 <GUI_Touch_Processing+0x864>)
 8008104:	4640      	mov	r0, r8
 8008106:	4649      	mov	r1, r9
 8008108:	fa5f fa8a 	uxtb.w	sl, sl
 800810c:	f04f 0501 	mov.w	r5, #1
 8008110:	f7f8 fcfa 	bl	8000b08 <__aeabi_dcmple>
 8008114:	b900      	cbnz	r0, 8008118 <GUI_Touch_Processing+0x798>
 8008116:	4605      	mov	r5, r0
 8008118:	a323      	add	r3, pc, #140	; (adr r3, 80081a8 <GUI_Touch_Processing+0x828>)
 800811a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800811e:	4630      	mov	r0, r6
 8008120:	4639      	mov	r1, r7
 8008122:	b2ed      	uxtb	r5, r5
 8008124:	f04f 0801 	mov.w	r8, #1
 8008128:	f7f8 fcf8 	bl	8000b1c <__aeabi_dcmpge>
 800812c:	b900      	cbnz	r0, 8008130 <GUI_Touch_Processing+0x7b0>
 800812e:	4680      	mov	r8, r0
 8008130:	a31f      	add	r3, pc, #124	; (adr r3, 80081b0 <GUI_Touch_Processing+0x830>)
 8008132:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008136:	4630      	mov	r0, r6
 8008138:	4639      	mov	r1, r7
 800813a:	f04f 0901 	mov.w	r9, #1
 800813e:	f7f8 fce3 	bl	8000b08 <__aeabi_dcmple>
 8008142:	b900      	cbnz	r0, 8008146 <GUI_Touch_Processing+0x7c6>
 8008144:	4681      	mov	r9, r0
 8008146:	ea08 0809 	and.w	r8, r8, r9
 800814a:	ea1a 0f08 	tst.w	sl, r8
 800814e:	d003      	beq.n	8008158 <GUI_Touch_Processing+0x7d8>
 8008150:	b115      	cbz	r5, 8008158 <GUI_Touch_Processing+0x7d8>
					GUI_screen_state = ColorSet1_Screen;
 8008152:	230e      	movs	r3, #14
 8008154:	7023      	strb	r3, [r4, #0]
 8008156:	e4a2      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 8008158:	a319      	add	r3, pc, #100	; (adr r3, 80081c0 <GUI_Touch_Processing+0x840>)
 800815a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800815e:	4630      	mov	r0, r6
 8008160:	4639      	mov	r1, r7
 8008162:	ea0a 0505 	and.w	r5, sl, r5
 8008166:	f04f 0801 	mov.w	r8, #1
 800816a:	f7f8 fcd7 	bl	8000b1c <__aeabi_dcmpge>
 800816e:	b900      	cbnz	r0, 8008172 <GUI_Touch_Processing+0x7f2>
 8008170:	4680      	mov	r8, r0
 8008172:	a315      	add	r3, pc, #84	; (adr r3, 80081c8 <GUI_Touch_Processing+0x848>)
 8008174:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008178:	4630      	mov	r0, r6
 800817a:	4639      	mov	r1, r7
 800817c:	f04f 0901 	mov.w	r9, #1
 8008180:	f7f8 fcc2 	bl	8000b08 <__aeabi_dcmple>
 8008184:	b900      	cbnz	r0, 8008188 <GUI_Touch_Processing+0x808>
 8008186:	4681      	mov	r9, r0
 8008188:	ea08 0809 	and.w	r8, r8, r9
 800818c:	f018 0f01 	tst.w	r8, #1
 8008190:	d02c      	beq.n	80081ec <GUI_Touch_Processing+0x86c>
 8008192:	b35d      	cbz	r5, 80081ec <GUI_Touch_Processing+0x86c>
					GUI_screen_state = Color_Rendition_Screen;
 8008194:	2306      	movs	r3, #6
 8008196:	7023      	strb	r3, [r4, #0]
 8008198:	e481      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
 800819a:	bf00      	nop
 800819c:	f3af 8000 	nop.w
 80081a0:	99999999 	.word	0x99999999
 80081a4:	4091a399 	.word	0x4091a399
 80081a8:	33333333 	.word	0x33333333
 80081ac:	40053333 	.word	0x40053333
 80081b0:	00000000 	.word	0x00000000
 80081b4:	40623800 	.word	0x40623800
 80081b8:	33333333 	.word	0x33333333
 80081bc:	407aff33 	.word	0x407aff33
 80081c0:	66666666 	.word	0x66666666
 80081c4:	4081f866 	.word	0x4081f866
 80081c8:	33333333 	.word	0x33333333
 80081cc:	40867133 	.word	0x40867133
 80081d0:	99999999 	.word	0x99999999
 80081d4:	40720d99 	.word	0x40720d99
 80081d8:	200002e9 	.word	0x200002e9
 80081dc:	00000000 	.word	0x00000000
 80081e0:	20000176 	.word	0x20000176
 80081e4:	4093e000 	.word	0x4093e000
 80081e8:	200002c1 	.word	0x200002c1
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 80081ec:	a3b2      	add	r3, pc, #712	; (adr r3, 80084b8 <GUI_Touch_Processing+0xb38>)
 80081ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80081f2:	4630      	mov	r0, r6
 80081f4:	4639      	mov	r1, r7
 80081f6:	f04f 0401 	mov.w	r4, #1
 80081fa:	f7f8 fc8f 	bl	8000b1c <__aeabi_dcmpge>
 80081fe:	b900      	cbnz	r0, 8008202 <GUI_Touch_Processing+0x882>
 8008200:	4604      	mov	r4, r0
 8008202:	a3ab      	add	r3, pc, #684	; (adr r3, 80084b0 <GUI_Touch_Processing+0xb30>)
 8008204:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008208:	4630      	mov	r0, r6
 800820a:	4639      	mov	r1, r7
 800820c:	f04f 0801 	mov.w	r8, #1
 8008210:	f7f8 fc7a 	bl	8000b08 <__aeabi_dcmple>
 8008214:	b900      	cbnz	r0, 8008218 <GUI_Touch_Processing+0x898>
 8008216:	4680      	mov	r8, r0
 8008218:	ea04 0408 	and.w	r4, r4, r8
 800821c:	07e2      	lsls	r2, r4, #31
 800821e:	f142 8411 	bpl.w	800aa44 <GUI_Touch_Processing+0x30c4>
 8008222:	2d00      	cmp	r5, #0
 8008224:	f002 840e 	beq.w	800aa44 <GUI_Touch_Processing+0x30c4>
					pause = !pause;
 8008228:	4aa5      	ldr	r2, [pc, #660]	; (80084c0 <GUI_Touch_Processing+0xb40>)
 800822a:	7813      	ldrb	r3, [r2, #0]
 800822c:	fab3 f383 	clz	r3, r3
 8008230:	095b      	lsrs	r3, r3, #5
 8008232:	7013      	strb	r3, [r2, #0]
 8008234:	e433      	b.n	8007a9e <GUI_Touch_Processing+0x11e>
			preGUI_screen_state = GUI_screen_state;
 8008236:	4ba3      	ldr	r3, [pc, #652]	; (80084c4 <GUI_Touch_Processing+0xb44>)
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8008238:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 800823c:	2206      	movs	r2, #6
 800823e:	701a      	strb	r2, [r3, #0]
			if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Settings
 8008240:	f7f8 f980 	bl	8000544 <__aeabi_i2d>
 8008244:	4606      	mov	r6, r0
 8008246:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800824a:	460f      	mov	r7, r1
 800824c:	f7f8 f97a 	bl	8000544 <__aeabi_i2d>
 8008250:	a38d      	add	r3, pc, #564	; (adr r3, 8008488 <GUI_Touch_Processing+0xb08>)
 8008252:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008256:	4680      	mov	r8, r0
 8008258:	4689      	mov	r9, r1
 800825a:	f04f 0a01 	mov.w	sl, #1
 800825e:	f7f8 fc5d 	bl	8000b1c <__aeabi_dcmpge>
 8008262:	b900      	cbnz	r0, 8008266 <GUI_Touch_Processing+0x8e6>
 8008264:	4682      	mov	sl, r0
 8008266:	2200      	movs	r2, #0
 8008268:	4b97      	ldr	r3, [pc, #604]	; (80084c8 <GUI_Touch_Processing+0xb48>)
 800826a:	4640      	mov	r0, r8
 800826c:	4649      	mov	r1, r9
 800826e:	fa5f fa8a 	uxtb.w	sl, sl
 8008272:	f04f 0501 	mov.w	r5, #1
 8008276:	f7f8 fc47 	bl	8000b08 <__aeabi_dcmple>
 800827a:	b900      	cbnz	r0, 800827e <GUI_Touch_Processing+0x8fe>
 800827c:	4605      	mov	r5, r0
 800827e:	a384      	add	r3, pc, #528	; (adr r3, 8008490 <GUI_Touch_Processing+0xb10>)
 8008280:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008284:	4630      	mov	r0, r6
 8008286:	4639      	mov	r1, r7
 8008288:	b2ed      	uxtb	r5, r5
 800828a:	f04f 0801 	mov.w	r8, #1
 800828e:	f7f8 fc45 	bl	8000b1c <__aeabi_dcmpge>
 8008292:	b900      	cbnz	r0, 8008296 <GUI_Touch_Processing+0x916>
 8008294:	4680      	mov	r8, r0
 8008296:	a380      	add	r3, pc, #512	; (adr r3, 8008498 <GUI_Touch_Processing+0xb18>)
 8008298:	e9d3 2300 	ldrd	r2, r3, [r3]
 800829c:	4630      	mov	r0, r6
 800829e:	4639      	mov	r1, r7
 80082a0:	f04f 0901 	mov.w	r9, #1
 80082a4:	f7f8 fc30 	bl	8000b08 <__aeabi_dcmple>
 80082a8:	b900      	cbnz	r0, 80082ac <GUI_Touch_Processing+0x92c>
 80082aa:	4681      	mov	r9, r0
 80082ac:	ea08 0809 	and.w	r8, r8, r9
 80082b0:	ea1a 0f08 	tst.w	sl, r8
 80082b4:	d004      	beq.n	80082c0 <GUI_Touch_Processing+0x940>
 80082b6:	b11d      	cbz	r5, 80082c0 <GUI_Touch_Processing+0x940>
					GUI_screen_state = ColorRendSet_Screen;
 80082b8:	2310      	movs	r3, #16
 80082ba:	7023      	strb	r3, [r4, #0]
 80082bc:	f7ff bbef 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 80082c0:	a377      	add	r3, pc, #476	; (adr r3, 80084a0 <GUI_Touch_Processing+0xb20>)
 80082c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80082c6:	4630      	mov	r0, r6
 80082c8:	4639      	mov	r1, r7
 80082ca:	ea0a 0505 	and.w	r5, sl, r5
 80082ce:	f04f 0801 	mov.w	r8, #1
 80082d2:	f7f8 fc23 	bl	8000b1c <__aeabi_dcmpge>
 80082d6:	b900      	cbnz	r0, 80082da <GUI_Touch_Processing+0x95a>
 80082d8:	4680      	mov	r8, r0
 80082da:	a373      	add	r3, pc, #460	; (adr r3, 80084a8 <GUI_Touch_Processing+0xb28>)
 80082dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80082e0:	4630      	mov	r0, r6
 80082e2:	4639      	mov	r1, r7
 80082e4:	f04f 0901 	mov.w	r9, #1
 80082e8:	f7f8 fc0e 	bl	8000b08 <__aeabi_dcmple>
 80082ec:	b900      	cbnz	r0, 80082f0 <GUI_Touch_Processing+0x970>
 80082ee:	4681      	mov	r9, r0
 80082f0:	ea08 0809 	and.w	r8, r8, r9
 80082f4:	f018 0f01 	tst.w	r8, #1
 80082f8:	d002      	beq.n	8008300 <GUI_Touch_Processing+0x980>
 80082fa:	2d00      	cmp	r5, #0
 80082fc:	f47f ad8e 	bne.w	8007e1c <GUI_Touch_Processing+0x49c>
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Rotation_Screen
 8008300:	a36b      	add	r3, pc, #428	; (adr r3, 80084b0 <GUI_Touch_Processing+0xb30>)
 8008302:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008306:	4630      	mov	r0, r6
 8008308:	4639      	mov	r1, r7
 800830a:	f04f 0801 	mov.w	r8, #1
 800830e:	f7f8 fc05 	bl	8000b1c <__aeabi_dcmpge>
 8008312:	b900      	cbnz	r0, 8008316 <GUI_Touch_Processing+0x996>
 8008314:	4680      	mov	r8, r0
 8008316:	a362      	add	r3, pc, #392	; (adr r3, 80084a0 <GUI_Touch_Processing+0xb20>)
 8008318:	e9d3 2300 	ldrd	r2, r3, [r3]
 800831c:	4630      	mov	r0, r6
 800831e:	4639      	mov	r1, r7
 8008320:	f04f 0901 	mov.w	r9, #1
 8008324:	f7f8 fbf0 	bl	8000b08 <__aeabi_dcmple>
 8008328:	b900      	cbnz	r0, 800832c <GUI_Touch_Processing+0x9ac>
 800832a:	4681      	mov	r9, r0
 800832c:	ea08 0809 	and.w	r8, r8, r9
 8008330:	f018 0f01 	tst.w	r8, #1
 8008334:	d009      	beq.n	800834a <GUI_Touch_Processing+0x9ca>
 8008336:	b145      	cbz	r5, 800834a <GUI_Touch_Processing+0x9ca>
					if(Rotation_Screen_Rend < 0x02) {Rotation_Screen_Rend++;} else{Rotation_Screen_Rend = 0x00;}
 8008338:	4a64      	ldr	r2, [pc, #400]	; (80084cc <GUI_Touch_Processing+0xb4c>)
 800833a:	7813      	ldrb	r3, [r2, #0]
 800833c:	2b01      	cmp	r3, #1
 800833e:	bf94      	ite	ls
 8008340:	3301      	addls	r3, #1
 8008342:	2300      	movhi	r3, #0
 8008344:	7013      	strb	r3, [r2, #0]
 8008346:	f7ff bbaa 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Measure
 800834a:	a35b      	add	r3, pc, #364	; (adr r3, 80084b8 <GUI_Touch_Processing+0xb38>)
 800834c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008350:	4630      	mov	r0, r6
 8008352:	4639      	mov	r1, r7
 8008354:	f04f 0801 	mov.w	r8, #1
 8008358:	f7f8 fbe0 	bl	8000b1c <__aeabi_dcmpge>
 800835c:	b900      	cbnz	r0, 8008360 <GUI_Touch_Processing+0x9e0>
 800835e:	4680      	mov	r8, r0
 8008360:	a353      	add	r3, pc, #332	; (adr r3, 80084b0 <GUI_Touch_Processing+0xb30>)
 8008362:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008366:	4630      	mov	r0, r6
 8008368:	4639      	mov	r1, r7
 800836a:	f04f 0901 	mov.w	r9, #1
 800836e:	f7f8 fbcb 	bl	8000b08 <__aeabi_dcmple>
 8008372:	b900      	cbnz	r0, 8008376 <GUI_Touch_Processing+0x9f6>
 8008374:	4681      	mov	r9, r0
 8008376:	ea08 0809 	and.w	r8, r8, r9
 800837a:	f018 0f01 	tst.w	r8, #1
 800837e:	d013      	beq.n	80083a8 <GUI_Touch_Processing+0xa28>
 8008380:	b195      	cbz	r5, 80083a8 <GUI_Touch_Processing+0xa28>
					if (Color_rend_Field){
 8008382:	4b53      	ldr	r3, [pc, #332]	; (80084d0 <GUI_Touch_Processing+0xb50>)
 8008384:	4a53      	ldr	r2, [pc, #332]	; (80084d4 <GUI_Touch_Processing+0xb54>)
 8008386:	781b      	ldrb	r3, [r3, #0]
 8008388:	2101      	movs	r1, #1
						CRICQS_done = 0x01;
 800838a:	7011      	strb	r1, [r2, #0]
					if (Color_rend_Field){
 800838c:	b14b      	cbz	r3, 80083a2 <GUI_Touch_Processing+0xa22>
					Calc_ColorRend = !Calc_ColorRend;
 800838e:	4a52      	ldr	r2, [pc, #328]	; (80084d8 <GUI_Touch_Processing+0xb58>)
 8008390:	7813      	ldrb	r3, [r2, #0]
 8008392:	fab3 f383 	clz	r3, r3
 8008396:	095b      	lsrs	r3, r3, #5
 8008398:	7013      	strb	r3, [r2, #0]
					GUI_Display_Refresh();
 800839a:	f7ff fa8f 	bl	80078bc <GUI_Display_Refresh>
 800839e:	f7ff bb7e 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						pause = 0;
 80083a2:	4a47      	ldr	r2, [pc, #284]	; (80084c0 <GUI_Touch_Processing+0xb40>)
 80083a4:	7013      	strb	r3, [r2, #0]
 80083a6:	e7f2      	b.n	800838e <GUI_Touch_Processing+0xa0e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 80083a8:	a33b      	add	r3, pc, #236	; (adr r3, 8008498 <GUI_Touch_Processing+0xb18>)
 80083aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083ae:	4630      	mov	r0, r6
 80083b0:	4639      	mov	r1, r7
 80083b2:	f04f 0801 	mov.w	r8, #1
 80083b6:	f7f8 fbb1 	bl	8000b1c <__aeabi_dcmpge>
 80083ba:	b900      	cbnz	r0, 80083be <GUI_Touch_Processing+0xa3e>
 80083bc:	4680      	mov	r8, r0
 80083be:	a33e      	add	r3, pc, #248	; (adr r3, 80084b8 <GUI_Touch_Processing+0xb38>)
 80083c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083c4:	4630      	mov	r0, r6
 80083c6:	4639      	mov	r1, r7
 80083c8:	f04f 0901 	mov.w	r9, #1
 80083cc:	f7f8 fb9c 	bl	8000b08 <__aeabi_dcmple>
 80083d0:	b900      	cbnz	r0, 80083d4 <GUI_Touch_Processing+0xa54>
 80083d2:	4681      	mov	r9, r0
 80083d4:	ea08 0809 	and.w	r8, r8, r9
 80083d8:	f018 0f01 	tst.w	r8, #1
 80083dc:	f43f ab5f 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
 80083e0:	2d00      	cmp	r5, #0
 80083e2:	f43f ab5c 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_screen_state = SD_Write_Screen;
 80083e6:	2312      	movs	r3, #18
 80083e8:	7023      	strb	r3, [r4, #0]
						pause = 0;
 80083ea:	4b35      	ldr	r3, [pc, #212]	; (80084c0 <GUI_Touch_Processing+0xb40>)
 80083ec:	2200      	movs	r2, #0
 80083ee:	701a      	strb	r2, [r3, #0]
 80083f0:	f7ff bb55 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
			preGUI_screen_state = GUI_screen_state;
 80083f4:	4b33      	ldr	r3, [pc, #204]	; (80084c4 <GUI_Touch_Processing+0xb44>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Down
 80083f6:	f8bd 0014 	ldrh.w	r0, [sp, #20]
			preGUI_screen_state = GUI_screen_state;
 80083fa:	2207      	movs	r2, #7
 80083fc:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Down
 80083fe:	f7f8 f8a1 	bl	8000544 <__aeabi_i2d>
 8008402:	4606      	mov	r6, r0
 8008404:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8008408:	460f      	mov	r7, r1
 800840a:	f7f8 f89b 	bl	8000544 <__aeabi_i2d>
 800840e:	a31e      	add	r3, pc, #120	; (adr r3, 8008488 <GUI_Touch_Processing+0xb08>)
 8008410:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008414:	e9cd 0100 	strd	r0, r1, [sp]
 8008418:	f04f 0a01 	mov.w	sl, #1
 800841c:	f7f8 fb7e 	bl	8000b1c <__aeabi_dcmpge>
 8008420:	b900      	cbnz	r0, 8008424 <GUI_Touch_Processing+0xaa4>
 8008422:	4682      	mov	sl, r0
 8008424:	2200      	movs	r2, #0
 8008426:	4b28      	ldr	r3, [pc, #160]	; (80084c8 <GUI_Touch_Processing+0xb48>)
 8008428:	e9dd 0100 	ldrd	r0, r1, [sp]
 800842c:	fa5f fa8a 	uxtb.w	sl, sl
 8008430:	f04f 0b01 	mov.w	fp, #1
 8008434:	f7f8 fb68 	bl	8000b08 <__aeabi_dcmple>
 8008438:	b900      	cbnz	r0, 800843c <GUI_Touch_Processing+0xabc>
 800843a:	4683      	mov	fp, r0
 800843c:	a31c      	add	r3, pc, #112	; (adr r3, 80084b0 <GUI_Touch_Processing+0xb30>)
 800843e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008442:	4630      	mov	r0, r6
 8008444:	4639      	mov	r1, r7
 8008446:	fa5f fb8b 	uxtb.w	fp, fp
 800844a:	f04f 0501 	mov.w	r5, #1
 800844e:	f7f8 fb65 	bl	8000b1c <__aeabi_dcmpge>
 8008452:	b900      	cbnz	r0, 8008456 <GUI_Touch_Processing+0xad6>
 8008454:	4605      	mov	r5, r0
 8008456:	a312      	add	r3, pc, #72	; (adr r3, 80084a0 <GUI_Touch_Processing+0xb20>)
 8008458:	e9d3 2300 	ldrd	r2, r3, [r3]
 800845c:	4630      	mov	r0, r6
 800845e:	4639      	mov	r1, r7
 8008460:	f04f 0801 	mov.w	r8, #1
 8008464:	f7f8 fb50 	bl	8000b08 <__aeabi_dcmple>
 8008468:	b900      	cbnz	r0, 800846c <GUI_Touch_Processing+0xaec>
 800846a:	4680      	mov	r8, r0
 800846c:	ea05 0508 	and.w	r5, r5, r8
 8008470:	ea1a 0f05 	tst.w	sl, r5
 8008474:	d032      	beq.n	80084dc <GUI_Touch_Processing+0xb5c>
 8008476:	f1bb 0f00 	cmp.w	fp, #0
 800847a:	d02f      	beq.n	80084dc <GUI_Touch_Processing+0xb5c>
					GUI_screen_state = DataSet2_Screen;
 800847c:	2308      	movs	r3, #8
 800847e:	7023      	strb	r3, [r4, #0]
 8008480:	f7ff bb0d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8008484:	f3af 8000 	nop.w
 8008488:	99999999 	.word	0x99999999
 800848c:	4091a399 	.word	0x4091a399
 8008490:	33333333 	.word	0x33333333
 8008494:	40053333 	.word	0x40053333
 8008498:	00000000 	.word	0x00000000
 800849c:	40623800 	.word	0x40623800
 80084a0:	66666666 	.word	0x66666666
 80084a4:	4081f866 	.word	0x4081f866
 80084a8:	33333333 	.word	0x33333333
 80084ac:	40867133 	.word	0x40867133
 80084b0:	33333333 	.word	0x33333333
 80084b4:	407aff33 	.word	0x407aff33
 80084b8:	99999999 	.word	0x99999999
 80084bc:	40720d99 	.word	0x40720d99
 80084c0:	200002e9 	.word	0x200002e9
 80084c4:	20000176 	.word	0x20000176
 80084c8:	4093e000 	.word	0x4093e000
 80084cc:	200002c0 	.word	0x200002c0
 80084d0:	200002b8 	.word	0x200002b8
 80084d4:	200002b4 	.word	0x200002b4
 80084d8:	200002b5 	.word	0x200002b5
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=202*TS_Callib & Touch_y <=(202+54)*TS_Callib) //Mode_EL
 80084dc:	a3da      	add	r3, pc, #872	; (adr r3, 8008848 <GUI_Touch_Processing+0xec8>)
 80084de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80084e2:	4630      	mov	r0, r6
 80084e4:	4639      	mov	r1, r7
 80084e6:	f04f 0501 	mov.w	r5, #1
 80084ea:	f7f8 fb17 	bl	8000b1c <__aeabi_dcmpge>
 80084ee:	b900      	cbnz	r0, 80084f2 <GUI_Touch_Processing+0xb72>
 80084f0:	4605      	mov	r5, r0
 80084f2:	a3d7      	add	r3, pc, #860	; (adr r3, 8008850 <GUI_Touch_Processing+0xed0>)
 80084f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80084f8:	4630      	mov	r0, r6
 80084fa:	4639      	mov	r1, r7
 80084fc:	f04f 0801 	mov.w	r8, #1
 8008500:	f7f8 fb02 	bl	8000b08 <__aeabi_dcmple>
 8008504:	b900      	cbnz	r0, 8008508 <GUI_Touch_Processing+0xb88>
 8008506:	4680      	mov	r8, r0
 8008508:	ea05 0508 	and.w	r5, r5, r8
 800850c:	a3d2      	add	r3, pc, #840	; (adr r3, 8008858 <GUI_Touch_Processing+0xed8>)
 800850e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008512:	e9dd 0100 	ldrd	r0, r1, [sp]
 8008516:	b2ed      	uxtb	r5, r5
 8008518:	f04f 0801 	mov.w	r8, #1
 800851c:	f7f8 fafe 	bl	8000b1c <__aeabi_dcmpge>
 8008520:	b900      	cbnz	r0, 8008524 <GUI_Touch_Processing+0xba4>
 8008522:	4680      	mov	r8, r0
 8008524:	a3ce      	add	r3, pc, #824	; (adr r3, 8008860 <GUI_Touch_Processing+0xee0>)
 8008526:	e9d3 2300 	ldrd	r2, r3, [r3]
 800852a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800852e:	f04f 0901 	mov.w	r9, #1
 8008532:	f7f8 fae9 	bl	8000b08 <__aeabi_dcmple>
 8008536:	b900      	cbnz	r0, 800853a <GUI_Touch_Processing+0xbba>
 8008538:	4681      	mov	r9, r0
 800853a:	ea08 0809 	and.w	r8, r8, r9
 800853e:	f018 0f01 	tst.w	r8, #1
 8008542:	d026      	beq.n	8008592 <GUI_Touch_Processing+0xc12>
 8008544:	b32d      	cbz	r5, 8008592 <GUI_Touch_Processing+0xc12>
					Mode_EL = !Mode_EL;
 8008546:	4cb2      	ldr	r4, [pc, #712]	; (8008810 <GUI_Touch_Processing+0xe90>)
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 8008548:	4bb2      	ldr	r3, [pc, #712]	; (8008814 <GUI_Touch_Processing+0xe94>)
					Mode_EL = !Mode_EL;
 800854a:	7822      	ldrb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800854c:	48b2      	ldr	r0, [pc, #712]	; (8008818 <GUI_Touch_Processing+0xe98>)
					Mode_EL = !Mode_EL;
 800854e:	2a00      	cmp	r2, #0
 8008550:	bf0c      	ite	eq
 8008552:	2201      	moveq	r2, #1
 8008554:	2200      	movne	r2, #0
 8008556:	7022      	strb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 8008558:	bf18      	it	ne
 800855a:	4618      	movne	r0, r3
 800855c:	4aaf      	ldr	r2, [pc, #700]	; (800881c <GUI_Touch_Processing+0xe9c>)
 800855e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008562:	f7fd fe8d 	bl	8006280 <Calibration_Load_Pack>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 8008566:	7822      	ldrb	r2, [r4, #0]
 8008568:	4bad      	ldr	r3, [pc, #692]	; (8008820 <GUI_Touch_Processing+0xea0>)
 800856a:	b982      	cbnz	r2, 800858e <GUI_Touch_Processing+0xc0e>
 800856c:	4aad      	ldr	r2, [pc, #692]	; (8008824 <GUI_Touch_Processing+0xea4>)
 800856e:	edd2 0a00 	vldr	s1, [r2]
 8008572:	ed93 0a00 	vldr	s0, [r3]
 8008576:	f007 ff73 	bl	8010460 <Rabs_calc_Factor2_Settings_change>
 800857a:	4bab      	ldr	r3, [pc, #684]	; (8008828 <GUI_Touch_Processing+0xea8>)
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 800857c:	7822      	ldrb	r2, [r4, #0]
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800857e:	ed83 0a00 	vstr	s0, [r3]
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 8008582:	21ca      	movs	r1, #202	; 0xca
 8008584:	20b6      	movs	r0, #182	; 0xb6
 8008586:	f003 fb75 	bl	800bc74 <GUI_Switch_ButtonActive>
 800858a:	f7ff ba88 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800858e:	4aa7      	ldr	r2, [pc, #668]	; (800882c <GUI_Touch_Processing+0xeac>)
 8008590:	e7ed      	b.n	800856e <GUI_Touch_Processing+0xbee>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=268*TS_Callib & Touch_y <=(268+54)*TS_Callib) //Bluetooth
 8008592:	a387      	add	r3, pc, #540	; (adr r3, 80087b0 <GUI_Touch_Processing+0xe30>)
 8008594:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008598:	e9dd 0100 	ldrd	r0, r1, [sp]
 800859c:	f04f 0801 	mov.w	r8, #1
 80085a0:	f7f8 fabc 	bl	8000b1c <__aeabi_dcmpge>
 80085a4:	b900      	cbnz	r0, 80085a8 <GUI_Touch_Processing+0xc28>
 80085a6:	4680      	mov	r8, r0
 80085a8:	a383      	add	r3, pc, #524	; (adr r3, 80087b8 <GUI_Touch_Processing+0xe38>)
 80085aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80085ae:	e9dd 0100 	ldrd	r0, r1, [sp]
 80085b2:	f04f 0901 	mov.w	r9, #1
 80085b6:	f7f8 faa7 	bl	8000b08 <__aeabi_dcmple>
 80085ba:	b900      	cbnz	r0, 80085be <GUI_Touch_Processing+0xc3e>
 80085bc:	4681      	mov	r9, r0
 80085be:	ea08 0809 	and.w	r8, r8, r9
 80085c2:	f018 0f01 	tst.w	r8, #1
 80085c6:	d00f      	beq.n	80085e8 <GUI_Touch_Processing+0xc68>
 80085c8:	b175      	cbz	r5, 80085e8 <GUI_Touch_Processing+0xc68>
					Bluetooth = !Bluetooth;
 80085ca:	4b99      	ldr	r3, [pc, #612]	; (8008830 <GUI_Touch_Processing+0xeb0>)
 80085cc:	781a      	ldrb	r2, [r3, #0]
 80085ce:	fab2 f282 	clz	r2, r2
 80085d2:	0952      	lsrs	r2, r2, #5
					GUI_Switch_Button(182, 268, Bluetooth);
 80085d4:	f44f 7186 	mov.w	r1, #268	; 0x10c
 80085d8:	20b6      	movs	r0, #182	; 0xb6
					Bluetooth = !Bluetooth;
 80085da:	701a      	strb	r2, [r3, #0]
					GUI_Switch_Button(182, 268, Bluetooth);
 80085dc:	f003 faf0 	bl	800bbc0 <GUI_Switch_Button>
					GUI_Up_Panel();
 80085e0:	f7fe fa0c 	bl	80069fc <GUI_Up_Panel>
 80085e4:	f7ff ba5b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=124*TS_Callib & Touch_y <=(174)*TS_Callib) // Information
 80085e8:	a375      	add	r3, pc, #468	; (adr r3, 80087c0 <GUI_Touch_Processing+0xe40>)
 80085ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80085ee:	4630      	mov	r0, r6
 80085f0:	4639      	mov	r1, r7
 80085f2:	f04f 0501 	mov.w	r5, #1
 80085f6:	f7f8 fa91 	bl	8000b1c <__aeabi_dcmpge>
 80085fa:	b900      	cbnz	r0, 80085fe <GUI_Touch_Processing+0xc7e>
 80085fc:	4605      	mov	r5, r0
 80085fe:	a372      	add	r3, pc, #456	; (adr r3, 80087c8 <GUI_Touch_Processing+0xe48>)
 8008600:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008604:	4630      	mov	r0, r6
 8008606:	4639      	mov	r1, r7
 8008608:	f04f 0801 	mov.w	r8, #1
 800860c:	f7f8 fa7c 	bl	8000b08 <__aeabi_dcmple>
 8008610:	b900      	cbnz	r0, 8008614 <GUI_Touch_Processing+0xc94>
 8008612:	4680      	mov	r8, r0
 8008614:	ea05 0508 	and.w	r5, r5, r8
 8008618:	a36d      	add	r3, pc, #436	; (adr r3, 80087d0 <GUI_Touch_Processing+0xe50>)
 800861a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800861e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8008622:	b2ed      	uxtb	r5, r5
 8008624:	f04f 0801 	mov.w	r8, #1
 8008628:	f7f8 fa78 	bl	8000b1c <__aeabi_dcmpge>
 800862c:	b900      	cbnz	r0, 8008630 <GUI_Touch_Processing+0xcb0>
 800862e:	4680      	mov	r8, r0
 8008630:	a369      	add	r3, pc, #420	; (adr r3, 80087d8 <GUI_Touch_Processing+0xe58>)
 8008632:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008636:	e9dd 0100 	ldrd	r0, r1, [sp]
 800863a:	f04f 0901 	mov.w	r9, #1
 800863e:	f7f8 fa63 	bl	8000b08 <__aeabi_dcmple>
 8008642:	b900      	cbnz	r0, 8008646 <GUI_Touch_Processing+0xcc6>
 8008644:	4681      	mov	r9, r0
 8008646:	ea08 0809 	and.w	r8, r8, r9
 800864a:	f018 0f01 	tst.w	r8, #1
 800864e:	d004      	beq.n	800865a <GUI_Touch_Processing+0xcda>
 8008650:	b11d      	cbz	r5, 800865a <GUI_Touch_Processing+0xcda>
					GUI_screen_state = Information_Screen;
 8008652:	2311      	movs	r3, #17
 8008654:	7023      	strb	r3, [r4, #0]
 8008656:	f7ff ba22 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=327*TS_Callib & Touch_y <=(327+54)*TS_Callib) //Illuminance
 800865a:	2200      	movs	r2, #0
 800865c:	4b75      	ldr	r3, [pc, #468]	; (8008834 <GUI_Touch_Processing+0xeb4>)
 800865e:	4630      	mov	r0, r6
 8008660:	4639      	mov	r1, r7
 8008662:	f04f 0901 	mov.w	r9, #1
 8008666:	f7f8 fa59 	bl	8000b1c <__aeabi_dcmpge>
 800866a:	b900      	cbnz	r0, 800866e <GUI_Touch_Processing+0xcee>
 800866c:	4681      	mov	r9, r0
 800866e:	a35c      	add	r3, pc, #368	; (adr r3, 80087e0 <GUI_Touch_Processing+0xe60>)
 8008670:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008674:	4630      	mov	r0, r6
 8008676:	4639      	mov	r1, r7
 8008678:	f04f 0801 	mov.w	r8, #1
 800867c:	f7f8 fa44 	bl	8000b08 <__aeabi_dcmple>
 8008680:	b900      	cbnz	r0, 8008684 <GUI_Touch_Processing+0xd04>
 8008682:	4680      	mov	r8, r0
 8008684:	a358      	add	r3, pc, #352	; (adr r3, 80087e8 <GUI_Touch_Processing+0xe68>)
 8008686:	e9d3 2300 	ldrd	r2, r3, [r3]
 800868a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800868e:	ea09 0808 	and.w	r8, r9, r8
 8008692:	f04f 0901 	mov.w	r9, #1
 8008696:	f7f8 fa41 	bl	8000b1c <__aeabi_dcmpge>
 800869a:	b900      	cbnz	r0, 800869e <GUI_Touch_Processing+0xd1e>
 800869c:	4681      	mov	r9, r0
 800869e:	ea08 0809 	and.w	r8, r8, r9
 80086a2:	f018 0f01 	tst.w	r8, #1
 80086a6:	d01b      	beq.n	80086e0 <GUI_Touch_Processing+0xd60>
 80086a8:	a351      	add	r3, pc, #324	; (adr r3, 80087f0 <GUI_Touch_Processing+0xe70>)
 80086aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086ae:	e9dd 0100 	ldrd	r0, r1, [sp]
 80086b2:	f04f 0801 	mov.w	r8, #1
 80086b6:	f7f8 fa27 	bl	8000b08 <__aeabi_dcmple>
 80086ba:	b900      	cbnz	r0, 80086be <GUI_Touch_Processing+0xd3e>
 80086bc:	4680      	mov	r8, r0
 80086be:	f018 0fff 	tst.w	r8, #255	; 0xff
 80086c2:	d00d      	beq.n	80086e0 <GUI_Touch_Processing+0xd60>
					Measure_Field ^= Illuminance;
 80086c4:	4b5c      	ldr	r3, [pc, #368]	; (8008838 <GUI_Touch_Processing+0xeb8>)
 80086c6:	881a      	ldrh	r2, [r3, #0]
 80086c8:	f082 0201 	eor.w	r2, r2, #1
 80086cc:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 327, Measure_Field&Illuminance);
 80086ce:	f240 1147 	movw	r1, #327	; 0x147
 80086d2:	f002 0201 	and.w	r2, r2, #1
 80086d6:	20c8      	movs	r0, #200	; 0xc8
 80086d8:	f003 fa02 	bl	800bae0 <GUI_CheckBox>
 80086dc:	f7ff b9df 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 80086e0:	a345      	add	r3, pc, #276	; (adr r3, 80087f8 <GUI_Touch_Processing+0xe78>)
 80086e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086e6:	4630      	mov	r0, r6
 80086e8:	4639      	mov	r1, r7
 80086ea:	ea0a 0b0b 	and.w	fp, sl, fp
 80086ee:	f04f 0901 	mov.w	r9, #1
 80086f2:	f7f8 fa13 	bl	8000b1c <__aeabi_dcmpge>
 80086f6:	b900      	cbnz	r0, 80086fa <GUI_Touch_Processing+0xd7a>
 80086f8:	4681      	mov	r9, r0
 80086fa:	a341      	add	r3, pc, #260	; (adr r3, 8008800 <GUI_Touch_Processing+0xe80>)
 80086fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008700:	4630      	mov	r0, r6
 8008702:	4639      	mov	r1, r7
 8008704:	f04f 0a01 	mov.w	sl, #1
 8008708:	f7f8 f9fe 	bl	8000b08 <__aeabi_dcmple>
 800870c:	b900      	cbnz	r0, 8008710 <GUI_Touch_Processing+0xd90>
 800870e:	4682      	mov	sl, r0
 8008710:	ea09 090a 	and.w	r9, r9, sl
 8008714:	f019 0f01 	tst.w	r9, #1
 8008718:	d01f      	beq.n	800875a <GUI_Touch_Processing+0xdda>
 800871a:	f1bb 0f00 	cmp.w	fp, #0
 800871e:	d01c      	beq.n	800875a <GUI_Touch_Processing+0xdda>
					GUI_screen_state = Prev_Inf_Screen;
 8008720:	4b46      	ldr	r3, [pc, #280]	; (800883c <GUI_Touch_Processing+0xebc>)
 8008722:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 8008724:	1e5a      	subs	r2, r3, #1
 8008726:	2a05      	cmp	r2, #5
 8008728:	d804      	bhi.n	8008734 <GUI_Touch_Processing+0xdb4>
 800872a:	e8df f002 	tbb	[pc, r2]
 800872e:	0306      	.short	0x0306
 8008730:	0e120a03 	.word	0x0e120a03
					GUI_screen_state = Prev_Inf_Screen;
 8008734:	7023      	strb	r3, [r4, #0]
 8008736:	f7ff b9b2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 800873a:	2301      	movs	r3, #1
 800873c:	7023      	strb	r3, [r4, #0]
 800873e:	f7ff b9ae 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 8008742:	2304      	movs	r3, #4
 8008744:	7023      	strb	r3, [r4, #0]
 8008746:	f7ff b9aa 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 800874a:	2306      	movs	r3, #6
 800874c:	7023      	strb	r3, [r4, #0]
 800874e:	f7ff b9a6 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 8008752:	2305      	movs	r3, #5
 8008754:	7023      	strb	r3, [r4, #0]
 8008756:	f7ff b9a2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=80*TS_Callib & Touch_y <=(120)*TS_Callib) // Language change
 800875a:	2200      	movs	r2, #0
 800875c:	4b38      	ldr	r3, [pc, #224]	; (8008840 <GUI_Touch_Processing+0xec0>)
 800875e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8008762:	f04f 0401 	mov.w	r4, #1
 8008766:	f7f8 f9d9 	bl	8000b1c <__aeabi_dcmpge>
 800876a:	b900      	cbnz	r0, 800876e <GUI_Touch_Processing+0xdee>
 800876c:	4604      	mov	r4, r0
 800876e:	a326      	add	r3, pc, #152	; (adr r3, 8008808 <GUI_Touch_Processing+0xe88>)
 8008770:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008774:	e9dd 0100 	ldrd	r0, r1, [sp]
 8008778:	f04f 0901 	mov.w	r9, #1
 800877c:	f7f8 f9c4 	bl	8000b08 <__aeabi_dcmple>
 8008780:	b900      	cbnz	r0, 8008784 <GUI_Touch_Processing+0xe04>
 8008782:	4681      	mov	r9, r0
 8008784:	ea04 0409 	and.w	r4, r4, r9
 8008788:	07e3      	lsls	r3, r4, #31
 800878a:	d56d      	bpl.n	8008868 <GUI_Touch_Processing+0xee8>
 800878c:	2d00      	cmp	r5, #0
 800878e:	d06b      	beq.n	8008868 <GUI_Touch_Processing+0xee8>
					if (Language_status == Ru) Language_status=En;
 8008790:	4b2c      	ldr	r3, [pc, #176]	; (8008844 <GUI_Touch_Processing+0xec4>)
 8008792:	781a      	ldrb	r2, [r3, #0]
 8008794:	b91a      	cbnz	r2, 800879e <GUI_Touch_Processing+0xe1e>
 8008796:	2201      	movs	r2, #1
 8008798:	701a      	strb	r2, [r3, #0]
 800879a:	f7ff b980 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					else if (Language_status == En) Language_status=Ru;
 800879e:	2a01      	cmp	r2, #1
 80087a0:	f47f a97d 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
 80087a4:	2200      	movs	r2, #0
 80087a6:	701a      	strb	r2, [r3, #0]
 80087a8:	f7ff b979 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 80087ac:	f3af 8000 	nop.w
 80087b0:	99999999 	.word	0x99999999
 80087b4:	40863199 	.word	0x40863199
 80087b8:	66666666 	.word	0x66666666
 80087bc:	408aaa66 	.word	0x408aaa66
 80087c0:	33333333 	.word	0x33333333
 80087c4:	40353333 	.word	0x40353333
 80087c8:	00000000 	.word	0x00000000
 80087cc:	4084b400 	.word	0x4084b400
 80087d0:	99999999 	.word	0x99999999
 80087d4:	40748999 	.word	0x40748999
 80087d8:	99999999 	.word	0x99999999
 80087dc:	407cd199 	.word	0x407cd199
 80087e0:	cccccccd 	.word	0xcccccccd
 80087e4:	408508cc 	.word	0x408508cc
 80087e8:	66666666 	.word	0x66666666
 80087ec:	408b1466 	.word	0x408b1466
 80087f0:	33333333 	.word	0x33333333
 80087f4:	408f8d33 	.word	0x408f8d33
 80087f8:	33333333 	.word	0x33333333
 80087fc:	40053333 	.word	0x40053333
 8008800:	00000000 	.word	0x00000000
 8008804:	40623800 	.word	0x40623800
 8008808:	00000000 	.word	0x00000000
 800880c:	4073e000 	.word	0x4073e000
 8008810:	2000019c 	.word	0x2000019c
 8008814:	08101838 	.word	0x08101838
 8008818:	08100838 	.word	0x08100838
 800881c:	20081b18 	.word	0x20081b18
 8008820:	2000030c 	.word	0x2000030c
 8008824:	20000308 	.word	0x20000308
 8008828:	20000310 	.word	0x20000310
 800882c:	20000304 	.word	0x20000304
 8008830:	20084b92 	.word	0x20084b92
 8008834:	40809000 	.word	0x40809000
 8008838:	200002be 	.word	0x200002be
 800883c:	20084b8d 	.word	0x20084b8d
 8008840:	406a8000 	.word	0x406a8000
 8008844:	200002bb 	.word	0x200002bb
 8008848:	cccccccd 	.word	0xcccccccd
 800884c:	407e24cc 	.word	0x407e24cc
 8008850:	33333333 	.word	0x33333333
 8008854:	40838b33 	.word	0x40838b33
 8008858:	66666666 	.word	0x66666666
 800885c:	4080ba66 	.word	0x4080ba66
 8008860:	33333333 	.word	0x33333333
 8008864:	40853333 	.word	0x40853333
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 8008868:	a3b1      	add	r3, pc, #708	; (adr r3, 8008b30 <GUI_Touch_Processing+0x11b0>)
 800886a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800886e:	4630      	mov	r0, r6
 8008870:	4639      	mov	r1, r7
 8008872:	f04f 0401 	mov.w	r4, #1
 8008876:	f7f8 f951 	bl	8000b1c <__aeabi_dcmpge>
 800887a:	b900      	cbnz	r0, 800887e <GUI_Touch_Processing+0xefe>
 800887c:	4604      	mov	r4, r0
 800887e:	a3c7      	add	r3, pc, #796	; (adr r3, 8008b9c <GUI_Touch_Processing+0x121c>)
 8008880:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008884:	4630      	mov	r0, r6
 8008886:	4639      	mov	r1, r7
 8008888:	f04f 0501 	mov.w	r5, #1
 800888c:	f7f8 f93c 	bl	8000b08 <__aeabi_dcmple>
 8008890:	b900      	cbnz	r0, 8008894 <GUI_Touch_Processing+0xf14>
 8008892:	4605      	mov	r5, r0
 8008894:	402c      	ands	r4, r5
 8008896:	07e4      	lsls	r4, r4, #31
 8008898:	d515      	bpl.n	80088c6 <GUI_Touch_Processing+0xf46>
 800889a:	f1bb 0f00 	cmp.w	fp, #0
 800889e:	d012      	beq.n	80088c6 <GUI_Touch_Processing+0xf46>
					TFT_ON_OFF = 0x00;
 80088a0:	4bb7      	ldr	r3, [pc, #732]	; (8008b80 <GUI_Touch_Processing+0x1200>)
 80088a2:	2400      	movs	r4, #0
					HAL_NVIC_DisableIRQ(TIM4_IRQn);	//TFT_booster SHDN off
 80088a4:	201e      	movs	r0, #30
					TFT_ON_OFF = 0x00;
 80088a6:	701c      	strb	r4, [r3, #0]
					HAL_NVIC_DisableIRQ(TIM4_IRQn);	//TFT_booster SHDN off
 80088a8:	f7f9 f87c 	bl	80019a4 <HAL_NVIC_DisableIRQ>
					HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_RESET); //TFT_booster SHDN off
 80088ac:	4622      	mov	r2, r4
 80088ae:	2120      	movs	r1, #32
 80088b0:	48b4      	ldr	r0, [pc, #720]	; (8008b84 <GUI_Touch_Processing+0x1204>)
 80088b2:	f7f9 fbd1 	bl	8002058 <HAL_GPIO_WritePin>
					HAL_GPIO_WritePin(GPIOF, GPIO_PIN_11, GPIO_PIN_RESET); //LTDC_En off
 80088b6:	4622      	mov	r2, r4
 80088b8:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80088bc:	48b2      	ldr	r0, [pc, #712]	; (8008b88 <GUI_Touch_Processing+0x1208>)
 80088be:	f7f9 fbcb 	bl	8002058 <HAL_GPIO_WritePin>
 80088c2:	f7ff b8ec 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 80088c6:	a392      	add	r3, pc, #584	; (adr r3, 8008b10 <GUI_Touch_Processing+0x1190>)
 80088c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80088cc:	4630      	mov	r0, r6
 80088ce:	4639      	mov	r1, r7
 80088d0:	f04f 0401 	mov.w	r4, #1
 80088d4:	f7f8 f922 	bl	8000b1c <__aeabi_dcmpge>
 80088d8:	b900      	cbnz	r0, 80088dc <GUI_Touch_Processing+0xf5c>
 80088da:	4604      	mov	r4, r0
 80088dc:	a38e      	add	r3, pc, #568	; (adr r3, 8008b18 <GUI_Touch_Processing+0x1198>)
 80088de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80088e2:	4630      	mov	r0, r6
 80088e4:	4639      	mov	r1, r7
 80088e6:	f04f 0501 	mov.w	r5, #1
 80088ea:	f7f8 f90d 	bl	8000b08 <__aeabi_dcmple>
 80088ee:	b900      	cbnz	r0, 80088f2 <GUI_Touch_Processing+0xf72>
 80088f0:	4605      	mov	r5, r0
 80088f2:	402c      	ands	r4, r5
 80088f4:	07e0      	lsls	r0, r4, #31
 80088f6:	f57f a8d2 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 80088fa:	f1bb 0f00 	cmp.w	fp, #0
 80088fe:	f47f a90b 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
 8008902:	f7ff b8cc 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				preGUI_screen_state = GUI_screen_state;
 8008906:	4ba1      	ldr	r3, [pc, #644]	; (8008b8c <GUI_Touch_Processing+0x120c>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)////down
 8008908:	f8bd 0014 	ldrh.w	r0, [sp, #20]
				preGUI_screen_state = GUI_screen_state;
 800890c:	2208      	movs	r2, #8
 800890e:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)////down
 8008910:	f7f7 fe18 	bl	8000544 <__aeabi_i2d>
 8008914:	4680      	mov	r8, r0
 8008916:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800891a:	4689      	mov	r9, r1
 800891c:	f7f7 fe12 	bl	8000544 <__aeabi_i2d>
 8008920:	a37f      	add	r3, pc, #508	; (adr r3, 8008b20 <GUI_Touch_Processing+0x11a0>)
 8008922:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008926:	4606      	mov	r6, r0
 8008928:	460f      	mov	r7, r1
 800892a:	f04f 0501 	mov.w	r5, #1
 800892e:	f7f8 f8f5 	bl	8000b1c <__aeabi_dcmpge>
 8008932:	b900      	cbnz	r0, 8008936 <GUI_Touch_Processing+0xfb6>
 8008934:	4605      	mov	r5, r0
 8008936:	b2eb      	uxtb	r3, r5
 8008938:	9300      	str	r3, [sp, #0]
 800893a:	2200      	movs	r2, #0
 800893c:	4b94      	ldr	r3, [pc, #592]	; (8008b90 <GUI_Touch_Processing+0x1210>)
 800893e:	4630      	mov	r0, r6
 8008940:	4639      	mov	r1, r7
 8008942:	f04f 0501 	mov.w	r5, #1
 8008946:	f7f8 f8df 	bl	8000b08 <__aeabi_dcmple>
 800894a:	b900      	cbnz	r0, 800894e <GUI_Touch_Processing+0xfce>
 800894c:	4605      	mov	r5, r0
 800894e:	b2eb      	uxtb	r3, r5
 8008950:	9302      	str	r3, [sp, #8]
 8008952:	4640      	mov	r0, r8
 8008954:	a374      	add	r3, pc, #464	; (adr r3, 8008b28 <GUI_Touch_Processing+0x11a8>)
 8008956:	e9d3 2300 	ldrd	r2, r3, [r3]
 800895a:	4649      	mov	r1, r9
 800895c:	f04f 0501 	mov.w	r5, #1
 8008960:	f7f8 f8dc 	bl	8000b1c <__aeabi_dcmpge>
 8008964:	b900      	cbnz	r0, 8008968 <GUI_Touch_Processing+0xfe8>
 8008966:	4605      	mov	r5, r0
 8008968:	a371      	add	r3, pc, #452	; (adr r3, 8008b30 <GUI_Touch_Processing+0x11b0>)
 800896a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800896e:	4640      	mov	r0, r8
 8008970:	4649      	mov	r1, r9
 8008972:	f04f 0a01 	mov.w	sl, #1
 8008976:	f7f8 f8c7 	bl	8000b08 <__aeabi_dcmple>
 800897a:	b900      	cbnz	r0, 800897e <GUI_Touch_Processing+0xffe>
 800897c:	4682      	mov	sl, r0
 800897e:	9b00      	ldr	r3, [sp, #0]
 8008980:	ea05 050a 	and.w	r5, r5, sl
 8008984:	422b      	tst	r3, r5
 8008986:	d005      	beq.n	8008994 <GUI_Touch_Processing+0x1014>
 8008988:	9b02      	ldr	r3, [sp, #8]
 800898a:	b11b      	cbz	r3, 8008994 <GUI_Touch_Processing+0x1014>
					GUI_screen_state = DataSet3_Screen;
 800898c:	2309      	movs	r3, #9
 800898e:	7023      	strb	r3, [r4, #0]
 8008990:	f7ff b885 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=70*TS_Callib & Touch_y <=(70+54)*TS_Callib) //Irradiance
 8008994:	2200      	movs	r2, #0
 8008996:	4b7f      	ldr	r3, [pc, #508]	; (8008b94 <GUI_Touch_Processing+0x1214>)
 8008998:	4640      	mov	r0, r8
 800899a:	4649      	mov	r1, r9
 800899c:	f04f 0501 	mov.w	r5, #1
 80089a0:	f7f8 f8bc 	bl	8000b1c <__aeabi_dcmpge>
 80089a4:	b900      	cbnz	r0, 80089a8 <GUI_Touch_Processing+0x1028>
 80089a6:	4605      	mov	r5, r0
 80089a8:	a363      	add	r3, pc, #396	; (adr r3, 8008b38 <GUI_Touch_Processing+0x11b8>)
 80089aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80089ae:	4640      	mov	r0, r8
 80089b0:	4649      	mov	r1, r9
 80089b2:	f04f 0a01 	mov.w	sl, #1
 80089b6:	f7f8 f8a7 	bl	8000b08 <__aeabi_dcmple>
 80089ba:	b900      	cbnz	r0, 80089be <GUI_Touch_Processing+0x103e>
 80089bc:	4682      	mov	sl, r0
 80089be:	ea05 050a 	and.w	r5, r5, sl
 80089c2:	a35f      	add	r3, pc, #380	; (adr r3, 8008b40 <GUI_Touch_Processing+0x11c0>)
 80089c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80089c8:	4630      	mov	r0, r6
 80089ca:	4639      	mov	r1, r7
 80089cc:	b2ed      	uxtb	r5, r5
 80089ce:	f04f 0a01 	mov.w	sl, #1
 80089d2:	f7f8 f8a3 	bl	8000b1c <__aeabi_dcmpge>
 80089d6:	b900      	cbnz	r0, 80089da <GUI_Touch_Processing+0x105a>
 80089d8:	4682      	mov	sl, r0
 80089da:	a35b      	add	r3, pc, #364	; (adr r3, 8008b48 <GUI_Touch_Processing+0x11c8>)
 80089dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80089e0:	4630      	mov	r0, r6
 80089e2:	4639      	mov	r1, r7
 80089e4:	f04f 0b01 	mov.w	fp, #1
 80089e8:	f7f8 f88e 	bl	8000b08 <__aeabi_dcmple>
 80089ec:	b900      	cbnz	r0, 80089f0 <GUI_Touch_Processing+0x1070>
 80089ee:	4683      	mov	fp, r0
 80089f0:	ea0a 0a0b 	and.w	sl, sl, fp
 80089f4:	f01a 0f01 	tst.w	sl, #1
 80089f8:	d00d      	beq.n	8008a16 <GUI_Touch_Processing+0x1096>
 80089fa:	b165      	cbz	r5, 8008a16 <GUI_Touch_Processing+0x1096>
					Measure_Field ^= Irradiance;
 80089fc:	4b66      	ldr	r3, [pc, #408]	; (8008b98 <GUI_Touch_Processing+0x1218>)
 80089fe:	881a      	ldrh	r2, [r3, #0]
 8008a00:	f082 0202 	eor.w	r2, r2, #2
 8008a04:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 70, Measure_Field&Irradiance);
 8008a06:	2146      	movs	r1, #70	; 0x46
 8008a08:	f002 0202 	and.w	r2, r2, #2
 8008a0c:	20c8      	movs	r0, #200	; 0xc8
 8008a0e:	f003 f867 	bl	800bae0 <GUI_CheckBox>
 8008a12:	f7ff b844 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=133*TS_Callib & Touch_y <=(133+54)*TS_Callib) //PPFD
 8008a16:	a34e      	add	r3, pc, #312	; (adr r3, 8008b50 <GUI_Touch_Processing+0x11d0>)
 8008a18:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008a1c:	4630      	mov	r0, r6
 8008a1e:	4639      	mov	r1, r7
 8008a20:	f04f 0a01 	mov.w	sl, #1
 8008a24:	f7f8 f87a 	bl	8000b1c <__aeabi_dcmpge>
 8008a28:	b900      	cbnz	r0, 8008a2c <GUI_Touch_Processing+0x10ac>
 8008a2a:	4682      	mov	sl, r0
 8008a2c:	a34a      	add	r3, pc, #296	; (adr r3, 8008b58 <GUI_Touch_Processing+0x11d8>)
 8008a2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008a32:	4630      	mov	r0, r6
 8008a34:	4639      	mov	r1, r7
 8008a36:	f04f 0b01 	mov.w	fp, #1
 8008a3a:	f7f8 f865 	bl	8000b08 <__aeabi_dcmple>
 8008a3e:	b900      	cbnz	r0, 8008a42 <GUI_Touch_Processing+0x10c2>
 8008a40:	4683      	mov	fp, r0
 8008a42:	ea0a 0a0b 	and.w	sl, sl, fp
 8008a46:	f01a 0f01 	tst.w	sl, #1
 8008a4a:	d00d      	beq.n	8008a68 <GUI_Touch_Processing+0x10e8>
 8008a4c:	b165      	cbz	r5, 8008a68 <GUI_Touch_Processing+0x10e8>
					Measure_Field ^= PPFD;
 8008a4e:	4b52      	ldr	r3, [pc, #328]	; (8008b98 <GUI_Touch_Processing+0x1218>)
 8008a50:	881a      	ldrh	r2, [r3, #0]
 8008a52:	f082 0204 	eor.w	r2, r2, #4
 8008a56:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 133, Measure_Field&PPFD);
 8008a58:	2185      	movs	r1, #133	; 0x85
 8008a5a:	f002 0204 	and.w	r2, r2, #4
 8008a5e:	20c8      	movs	r0, #200	; 0xc8
 8008a60:	f003 f83e 	bl	800bae0 <GUI_CheckBox>
 8008a64:	f7ff b81b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=198*TS_Callib & Touch_y <=(198+54)*TS_Callib) //PPFD_BGR
 8008a68:	a33d      	add	r3, pc, #244	; (adr r3, 8008b60 <GUI_Touch_Processing+0x11e0>)
 8008a6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008a6e:	4630      	mov	r0, r6
 8008a70:	4639      	mov	r1, r7
 8008a72:	f04f 0a01 	mov.w	sl, #1
 8008a76:	f7f8 f851 	bl	8000b1c <__aeabi_dcmpge>
 8008a7a:	b900      	cbnz	r0, 8008a7e <GUI_Touch_Processing+0x10fe>
 8008a7c:	4682      	mov	sl, r0
 8008a7e:	a33a      	add	r3, pc, #232	; (adr r3, 8008b68 <GUI_Touch_Processing+0x11e8>)
 8008a80:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008a84:	4630      	mov	r0, r6
 8008a86:	4639      	mov	r1, r7
 8008a88:	f04f 0b01 	mov.w	fp, #1
 8008a8c:	f7f8 f83c 	bl	8000b08 <__aeabi_dcmple>
 8008a90:	b900      	cbnz	r0, 8008a94 <GUI_Touch_Processing+0x1114>
 8008a92:	4683      	mov	fp, r0
 8008a94:	ea0a 0a0b 	and.w	sl, sl, fp
 8008a98:	f01a 0f01 	tst.w	sl, #1
 8008a9c:	d00d      	beq.n	8008aba <GUI_Touch_Processing+0x113a>
 8008a9e:	b165      	cbz	r5, 8008aba <GUI_Touch_Processing+0x113a>
					Measure_Field ^= PPFD_BGR;
 8008aa0:	4b3d      	ldr	r3, [pc, #244]	; (8008b98 <GUI_Touch_Processing+0x1218>)
 8008aa2:	881a      	ldrh	r2, [r3, #0]
 8008aa4:	f082 0208 	eor.w	r2, r2, #8
 8008aa8:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 198, Measure_Field&PPFD_BGR);
 8008aaa:	21c6      	movs	r1, #198	; 0xc6
 8008aac:	f002 0208 	and.w	r2, r2, #8
 8008ab0:	20c8      	movs	r0, #200	; 0xc8
 8008ab2:	f003 f815 	bl	800bae0 <GUI_CheckBox>
 8008ab6:	f7fe bff2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=263*TS_Callib & Touch_y <=(263+54)*TS_Callib) //CCT
 8008aba:	a32d      	add	r3, pc, #180	; (adr r3, 8008b70 <GUI_Touch_Processing+0x11f0>)
 8008abc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008ac0:	4630      	mov	r0, r6
 8008ac2:	4639      	mov	r1, r7
 8008ac4:	f04f 0a01 	mov.w	sl, #1
 8008ac8:	f7f8 f828 	bl	8000b1c <__aeabi_dcmpge>
 8008acc:	b900      	cbnz	r0, 8008ad0 <GUI_Touch_Processing+0x1150>
 8008ace:	4682      	mov	sl, r0
 8008ad0:	a329      	add	r3, pc, #164	; (adr r3, 8008b78 <GUI_Touch_Processing+0x11f8>)
 8008ad2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008ad6:	4630      	mov	r0, r6
 8008ad8:	4639      	mov	r1, r7
 8008ada:	f04f 0b01 	mov.w	fp, #1
 8008ade:	f7f8 f813 	bl	8000b08 <__aeabi_dcmple>
 8008ae2:	b900      	cbnz	r0, 8008ae6 <GUI_Touch_Processing+0x1166>
 8008ae4:	4683      	mov	fp, r0
 8008ae6:	ea0a 0a0b 	and.w	sl, sl, fp
 8008aea:	f01a 0f01 	tst.w	sl, #1
 8008aee:	d059      	beq.n	8008ba4 <GUI_Touch_Processing+0x1224>
 8008af0:	2d00      	cmp	r5, #0
 8008af2:	d057      	beq.n	8008ba4 <GUI_Touch_Processing+0x1224>
					Measure_Field ^= CCT;
 8008af4:	4b28      	ldr	r3, [pc, #160]	; (8008b98 <GUI_Touch_Processing+0x1218>)
 8008af6:	881a      	ldrh	r2, [r3, #0]
 8008af8:	f482 7280 	eor.w	r2, r2, #256	; 0x100
 8008afc:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 263, Measure_Field&CCT);
 8008afe:	f240 1107 	movw	r1, #263	; 0x107
 8008b02:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8008b06:	20c8      	movs	r0, #200	; 0xc8
 8008b08:	f002 ffea 	bl	800bae0 <GUI_CheckBox>
 8008b0c:	f7fe bfc7 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8008b10:	00000000 	.word	0x00000000
 8008b14:	40623800 	.word	0x40623800
 8008b18:	99999999 	.word	0x99999999
 8008b1c:	40720d99 	.word	0x40720d99
 8008b20:	99999999 	.word	0x99999999
 8008b24:	4091a399 	.word	0x4091a399
 8008b28:	33333333 	.word	0x33333333
 8008b2c:	407aff33 	.word	0x407aff33
 8008b30:	66666666 	.word	0x66666666
 8008b34:	4081f866 	.word	0x4081f866
 8008b38:	cccccccd 	.word	0xcccccccd
 8008b3c:	408508cc 	.word	0x408508cc
 8008b40:	00000000 	.word	0x00000000
 8008b44:	40673000 	.word	0x40673000
 8008b48:	99999999 	.word	0x99999999
 8008b4c:	40748999 	.word	0x40748999
 8008b50:	33333333 	.word	0x33333333
 8008b54:	40760733 	.word	0x40760733
 8008b58:	cccccccd 	.word	0xcccccccd
 8008b5c:	407ef8cc 	.word	0x407ef8cc
 8008b60:	99999999 	.word	0x99999999
 8008b64:	40806599 	.word	0x40806599
 8008b68:	66666666 	.word	0x66666666
 8008b6c:	4084de66 	.word	0x4084de66
 8008b70:	99999999 	.word	0x99999999
 8008b74:	4085c799 	.word	0x4085c799
 8008b78:	66666666 	.word	0x66666666
 8008b7c:	408a4066 	.word	0x408a4066
 8008b80:	2000019d 	.word	0x2000019d
 8008b84:	48000c00 	.word	0x48000c00
 8008b88:	48001400 	.word	0x48001400
 8008b8c:	20000176 	.word	0x20000176
 8008b90:	4093e000 	.word	0x4093e000
 8008b94:	40809000 	.word	0x40809000
 8008b98:	200002be 	.word	0x200002be
 8008b9c:	33333333 	.word	0x33333333
 8008ba0:	40867133 	.word	0x40867133
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=327*TS_Callib & Touch_y <=(327+54)*TS_Callib) //delta_E
 8008ba4:	a3d2      	add	r3, pc, #840	; (adr r3, 8008ef0 <GUI_Touch_Processing+0x1570>)
 8008ba6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008baa:	4630      	mov	r0, r6
 8008bac:	4639      	mov	r1, r7
 8008bae:	f04f 0a01 	mov.w	sl, #1
 8008bb2:	f7f7 ffb3 	bl	8000b1c <__aeabi_dcmpge>
 8008bb6:	b900      	cbnz	r0, 8008bba <GUI_Touch_Processing+0x123a>
 8008bb8:	4682      	mov	sl, r0
 8008bba:	a3cf      	add	r3, pc, #828	; (adr r3, 8008ef8 <GUI_Touch_Processing+0x1578>)
 8008bbc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008bc0:	4630      	mov	r0, r6
 8008bc2:	4639      	mov	r1, r7
 8008bc4:	f04f 0b01 	mov.w	fp, #1
 8008bc8:	f7f7 ff9e 	bl	8000b08 <__aeabi_dcmple>
 8008bcc:	b900      	cbnz	r0, 8008bd0 <GUI_Touch_Processing+0x1250>
 8008bce:	4683      	mov	fp, r0
 8008bd0:	ea0a 0a0b 	and.w	sl, sl, fp
 8008bd4:	f01a 0f01 	tst.w	sl, #1
 8008bd8:	d00e      	beq.n	8008bf8 <GUI_Touch_Processing+0x1278>
 8008bda:	b16d      	cbz	r5, 8008bf8 <GUI_Touch_Processing+0x1278>
					Measure_Field ^= delta_E;
 8008bdc:	4bbe      	ldr	r3, [pc, #760]	; (8008ed8 <GUI_Touch_Processing+0x1558>)
 8008bde:	881a      	ldrh	r2, [r3, #0]
 8008be0:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8008be4:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 327, Measure_Field&delta_E);
 8008be6:	f240 1147 	movw	r1, #327	; 0x147
 8008bea:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8008bee:	20c8      	movs	r0, #200	; 0xc8
 8008bf0:	f002 ff76 	bl	800bae0 <GUI_CheckBox>
 8008bf4:	f7fe bf53 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8008bf8:	9b02      	ldr	r3, [sp, #8]
 8008bfa:	9d00      	ldr	r5, [sp, #0]
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 8008bfc:	4640      	mov	r0, r8
 8008bfe:	401d      	ands	r5, r3
 8008c00:	4649      	mov	r1, r9
 8008c02:	a39d      	add	r3, pc, #628	; (adr r3, 8008e78 <GUI_Touch_Processing+0x14f8>)
 8008c04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008c08:	f04f 0601 	mov.w	r6, #1
 8008c0c:	f7f7 ff86 	bl	8000b1c <__aeabi_dcmpge>
 8008c10:	b900      	cbnz	r0, 8008c14 <GUI_Touch_Processing+0x1294>
 8008c12:	4606      	mov	r6, r0
 8008c14:	a39a      	add	r3, pc, #616	; (adr r3, 8008e80 <GUI_Touch_Processing+0x1500>)
 8008c16:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008c1a:	4640      	mov	r0, r8
 8008c1c:	4649      	mov	r1, r9
 8008c1e:	f04f 0701 	mov.w	r7, #1
 8008c22:	f7f7 ff71 	bl	8000b08 <__aeabi_dcmple>
 8008c26:	b900      	cbnz	r0, 8008c2a <GUI_Touch_Processing+0x12aa>
 8008c28:	4607      	mov	r7, r0
 8008c2a:	403e      	ands	r6, r7
 8008c2c:	07f1      	lsls	r1, r6, #31
 8008c2e:	d51d      	bpl.n	8008c6c <GUI_Touch_Processing+0x12ec>
 8008c30:	b1e5      	cbz	r5, 8008c6c <GUI_Touch_Processing+0x12ec>
					GUI_screen_state = Prev_Inf_Screen;
 8008c32:	4baa      	ldr	r3, [pc, #680]	; (8008edc <GUI_Touch_Processing+0x155c>)
 8008c34:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 8008c36:	1e5a      	subs	r2, r3, #1
 8008c38:	2a05      	cmp	r2, #5
 8008c3a:	d804      	bhi.n	8008c46 <GUI_Touch_Processing+0x12c6>
 8008c3c:	e8df f002 	tbb	[pc, r2]
 8008c40:	0a030306 	.word	0x0a030306
 8008c44:	0e12      	.short	0x0e12
					GUI_screen_state = Prev_Inf_Screen;
 8008c46:	7023      	strb	r3, [r4, #0]
 8008c48:	f7fe bf29 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 8008c4c:	2301      	movs	r3, #1
 8008c4e:	7023      	strb	r3, [r4, #0]
 8008c50:	f7fe bf25 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 8008c54:	2304      	movs	r3, #4
 8008c56:	7023      	strb	r3, [r4, #0]
 8008c58:	f7fe bf21 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 8008c5c:	2306      	movs	r3, #6
 8008c5e:	7023      	strb	r3, [r4, #0]
 8008c60:	f7fe bf1d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 8008c64:	2305      	movs	r3, #5
 8008c66:	7023      	strb	r3, [r4, #0]
 8008c68:	f7fe bf19 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 8008c6c:	a386      	add	r3, pc, #536	; (adr r3, 8008e88 <GUI_Touch_Processing+0x1508>)
 8008c6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008c72:	4640      	mov	r0, r8
 8008c74:	4649      	mov	r1, r9
 8008c76:	f04f 0401 	mov.w	r4, #1
 8008c7a:	f7f7 ff4f 	bl	8000b1c <__aeabi_dcmpge>
 8008c7e:	b900      	cbnz	r0, 8008c82 <GUI_Touch_Processing+0x1302>
 8008c80:	4604      	mov	r4, r0
 8008c82:	a383      	add	r3, pc, #524	; (adr r3, 8008e90 <GUI_Touch_Processing+0x1510>)
 8008c84:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008c88:	4640      	mov	r0, r8
 8008c8a:	4649      	mov	r1, r9
 8008c8c:	f04f 0601 	mov.w	r6, #1
 8008c90:	f7f7 ff3a 	bl	8000b08 <__aeabi_dcmple>
 8008c94:	b900      	cbnz	r0, 8008c98 <GUI_Touch_Processing+0x1318>
 8008c96:	4606      	mov	r6, r0
 8008c98:	4034      	ands	r4, r6
 8008c9a:	07e2      	lsls	r2, r4, #31
 8008c9c:	d502      	bpl.n	8008ca4 <GUI_Touch_Processing+0x1324>
 8008c9e:	2d00      	cmp	r5, #0
 8008ca0:	f47f adfe 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8008ca4:	a376      	add	r3, pc, #472	; (adr r3, 8008e80 <GUI_Touch_Processing+0x1500>)
 8008ca6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008caa:	4640      	mov	r0, r8
 8008cac:	4649      	mov	r1, r9
 8008cae:	f04f 0401 	mov.w	r4, #1
 8008cb2:	f7f7 ff33 	bl	8000b1c <__aeabi_dcmpge>
 8008cb6:	b900      	cbnz	r0, 8008cba <GUI_Touch_Processing+0x133a>
 8008cb8:	4604      	mov	r4, r0
 8008cba:	a377      	add	r3, pc, #476	; (adr r3, 8008e98 <GUI_Touch_Processing+0x1518>)
 8008cbc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008cc0:	4640      	mov	r0, r8
 8008cc2:	4649      	mov	r1, r9
 8008cc4:	f04f 0601 	mov.w	r6, #1
 8008cc8:	f7f7 ff1e 	bl	8000b08 <__aeabi_dcmple>
 8008ccc:	b900      	cbnz	r0, 8008cd0 <GUI_Touch_Processing+0x1350>
 8008cce:	4606      	mov	r6, r0
 8008cd0:	4034      	ands	r4, r6
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8008cd2:	07e4      	lsls	r4, r4, #31
 8008cd4:	f57e aee3 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 8008cd8:	2d00      	cmp	r5, #0
 8008cda:	f47e af1d 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
 8008cde:	f7fe bede 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 8008ce2:	4b7f      	ldr	r3, [pc, #508]	; (8008ee0 <GUI_Touch_Processing+0x1560>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)// down
 8008ce4:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 8008ce8:	2209      	movs	r2, #9
 8008cea:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)// down
 8008cec:	f7f7 fc2a 	bl	8000544 <__aeabi_i2d>
 8008cf0:	4680      	mov	r8, r0
 8008cf2:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8008cf6:	4689      	mov	r9, r1
 8008cf8:	f7f7 fc24 	bl	8000544 <__aeabi_i2d>
 8008cfc:	a368      	add	r3, pc, #416	; (adr r3, 8008ea0 <GUI_Touch_Processing+0x1520>)
 8008cfe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008d02:	4606      	mov	r6, r0
 8008d04:	460f      	mov	r7, r1
 8008d06:	f04f 0501 	mov.w	r5, #1
 8008d0a:	f7f7 ff07 	bl	8000b1c <__aeabi_dcmpge>
 8008d0e:	b900      	cbnz	r0, 8008d12 <GUI_Touch_Processing+0x1392>
 8008d10:	4605      	mov	r5, r0
 8008d12:	b2eb      	uxtb	r3, r5
 8008d14:	9300      	str	r3, [sp, #0]
 8008d16:	2200      	movs	r2, #0
 8008d18:	4b72      	ldr	r3, [pc, #456]	; (8008ee4 <GUI_Touch_Processing+0x1564>)
 8008d1a:	4630      	mov	r0, r6
 8008d1c:	4639      	mov	r1, r7
 8008d1e:	f04f 0501 	mov.w	r5, #1
 8008d22:	f7f7 fef1 	bl	8000b08 <__aeabi_dcmple>
 8008d26:	b900      	cbnz	r0, 8008d2a <GUI_Touch_Processing+0x13aa>
 8008d28:	4605      	mov	r5, r0
 8008d2a:	b2eb      	uxtb	r3, r5
 8008d2c:	9302      	str	r3, [sp, #8]
 8008d2e:	4640      	mov	r0, r8
 8008d30:	a35d      	add	r3, pc, #372	; (adr r3, 8008ea8 <GUI_Touch_Processing+0x1528>)
 8008d32:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008d36:	4649      	mov	r1, r9
 8008d38:	f04f 0501 	mov.w	r5, #1
 8008d3c:	f7f7 feee 	bl	8000b1c <__aeabi_dcmpge>
 8008d40:	b900      	cbnz	r0, 8008d44 <GUI_Touch_Processing+0x13c4>
 8008d42:	4605      	mov	r5, r0
 8008d44:	a350      	add	r3, pc, #320	; (adr r3, 8008e88 <GUI_Touch_Processing+0x1508>)
 8008d46:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008d4a:	4640      	mov	r0, r8
 8008d4c:	4649      	mov	r1, r9
 8008d4e:	f04f 0a01 	mov.w	sl, #1
 8008d52:	f7f7 fed9 	bl	8000b08 <__aeabi_dcmple>
 8008d56:	b900      	cbnz	r0, 8008d5a <GUI_Touch_Processing+0x13da>
 8008d58:	4682      	mov	sl, r0
 8008d5a:	9b00      	ldr	r3, [sp, #0]
 8008d5c:	ea05 050a 	and.w	r5, r5, sl
 8008d60:	422b      	tst	r3, r5
 8008d62:	d005      	beq.n	8008d70 <GUI_Touch_Processing+0x13f0>
 8008d64:	9b02      	ldr	r3, [sp, #8]
 8008d66:	b11b      	cbz	r3, 8008d70 <GUI_Touch_Processing+0x13f0>
					GUI_screen_state = DataSet4_Screen;
 8008d68:	230a      	movs	r3, #10
 8008d6a:	7023      	strb	r3, [r4, #0]
 8008d6c:	f7fe be97 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=70*TS_Callib & Touch_y <=(70+54)*TS_Callib) //CIE_XYZ
 8008d70:	2200      	movs	r2, #0
 8008d72:	4b5d      	ldr	r3, [pc, #372]	; (8008ee8 <GUI_Touch_Processing+0x1568>)
 8008d74:	4640      	mov	r0, r8
 8008d76:	4649      	mov	r1, r9
 8008d78:	f04f 0501 	mov.w	r5, #1
 8008d7c:	f7f7 fece 	bl	8000b1c <__aeabi_dcmpge>
 8008d80:	b900      	cbnz	r0, 8008d84 <GUI_Touch_Processing+0x1404>
 8008d82:	4605      	mov	r5, r0
 8008d84:	a34a      	add	r3, pc, #296	; (adr r3, 8008eb0 <GUI_Touch_Processing+0x1530>)
 8008d86:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008d8a:	4640      	mov	r0, r8
 8008d8c:	4649      	mov	r1, r9
 8008d8e:	f04f 0a01 	mov.w	sl, #1
 8008d92:	f7f7 feb9 	bl	8000b08 <__aeabi_dcmple>
 8008d96:	b900      	cbnz	r0, 8008d9a <GUI_Touch_Processing+0x141a>
 8008d98:	4682      	mov	sl, r0
 8008d9a:	ea05 050a 	and.w	r5, r5, sl
 8008d9e:	a346      	add	r3, pc, #280	; (adr r3, 8008eb8 <GUI_Touch_Processing+0x1538>)
 8008da0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008da4:	4630      	mov	r0, r6
 8008da6:	4639      	mov	r1, r7
 8008da8:	b2ed      	uxtb	r5, r5
 8008daa:	f04f 0a01 	mov.w	sl, #1
 8008dae:	f7f7 feb5 	bl	8000b1c <__aeabi_dcmpge>
 8008db2:	b900      	cbnz	r0, 8008db6 <GUI_Touch_Processing+0x1436>
 8008db4:	4682      	mov	sl, r0
 8008db6:	a342      	add	r3, pc, #264	; (adr r3, 8008ec0 <GUI_Touch_Processing+0x1540>)
 8008db8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008dbc:	4630      	mov	r0, r6
 8008dbe:	4639      	mov	r1, r7
 8008dc0:	f04f 0b01 	mov.w	fp, #1
 8008dc4:	f7f7 fea0 	bl	8000b08 <__aeabi_dcmple>
 8008dc8:	b900      	cbnz	r0, 8008dcc <GUI_Touch_Processing+0x144c>
 8008dca:	4683      	mov	fp, r0
 8008dcc:	ea0a 0a0b 	and.w	sl, sl, fp
 8008dd0:	f01a 0f01 	tst.w	sl, #1
 8008dd4:	d00d      	beq.n	8008df2 <GUI_Touch_Processing+0x1472>
 8008dd6:	b165      	cbz	r5, 8008df2 <GUI_Touch_Processing+0x1472>
					Measure_Field ^= CIE_XYZ;
 8008dd8:	4b3f      	ldr	r3, [pc, #252]	; (8008ed8 <GUI_Touch_Processing+0x1558>)
 8008dda:	881a      	ldrh	r2, [r3, #0]
 8008ddc:	f082 0210 	eor.w	r2, r2, #16
 8008de0:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 70, Measure_Field&CIE_XYZ);
 8008de2:	2146      	movs	r1, #70	; 0x46
 8008de4:	f002 0210 	and.w	r2, r2, #16
 8008de8:	20c8      	movs	r0, #200	; 0xc8
 8008dea:	f002 fe79 	bl	800bae0 <GUI_CheckBox>
 8008dee:	f7fe be56 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=133*TS_Callib & Touch_y <=(133+54)*TS_Callib) //CIE_xy
 8008df2:	a335      	add	r3, pc, #212	; (adr r3, 8008ec8 <GUI_Touch_Processing+0x1548>)
 8008df4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008df8:	4630      	mov	r0, r6
 8008dfa:	4639      	mov	r1, r7
 8008dfc:	f04f 0a01 	mov.w	sl, #1
 8008e00:	f7f7 fe8c 	bl	8000b1c <__aeabi_dcmpge>
 8008e04:	b900      	cbnz	r0, 8008e08 <GUI_Touch_Processing+0x1488>
 8008e06:	4682      	mov	sl, r0
 8008e08:	a331      	add	r3, pc, #196	; (adr r3, 8008ed0 <GUI_Touch_Processing+0x1550>)
 8008e0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008e0e:	4630      	mov	r0, r6
 8008e10:	4639      	mov	r1, r7
 8008e12:	f04f 0b01 	mov.w	fp, #1
 8008e16:	f7f7 fe77 	bl	8000b08 <__aeabi_dcmple>
 8008e1a:	b900      	cbnz	r0, 8008e1e <GUI_Touch_Processing+0x149e>
 8008e1c:	4683      	mov	fp, r0
 8008e1e:	ea0a 0a0b 	and.w	sl, sl, fp
 8008e22:	f01a 0f01 	tst.w	sl, #1
 8008e26:	d06b      	beq.n	8008f00 <GUI_Touch_Processing+0x1580>
 8008e28:	2d00      	cmp	r5, #0
 8008e2a:	d069      	beq.n	8008f00 <GUI_Touch_Processing+0x1580>
					Measure_Field ^= CIE_xy;
 8008e2c:	4c2a      	ldr	r4, [pc, #168]	; (8008ed8 <GUI_Touch_Processing+0x1558>)
					GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, Measure_Field&CIE_xy);
 8008e2e:	4d2f      	ldr	r5, [pc, #188]	; (8008eec <GUI_Touch_Processing+0x156c>)
					Measure_Field ^= CIE_xy;
 8008e30:	8822      	ldrh	r2, [r4, #0]
 8008e32:	f082 0220 	eor.w	r2, r2, #32
 8008e36:	8022      	strh	r2, [r4, #0]
					GUI_CheckBox(200, 133, Measure_Field&CIE_xy);
 8008e38:	2185      	movs	r1, #133	; 0x85
 8008e3a:	f002 0220 	and.w	r2, r2, #32
 8008e3e:	20c8      	movs	r0, #200	; 0xc8
 8008e40:	f002 fe4e 	bl	800bae0 <GUI_CheckBox>
					GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, Measure_Field&CIE_xy);
 8008e44:	8823      	ldrh	r3, [r4, #0]
 8008e46:	782a      	ldrb	r2, [r5, #0]
 8008e48:	f003 0320 	and.w	r3, r3, #32
 8008e4c:	f002 0201 	and.w	r2, r2, #1
 8008e50:	21c6      	movs	r1, #198	; 0xc6
 8008e52:	20c8      	movs	r0, #200	; 0xc8
 8008e54:	f002 fe85 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 263, !(Measure_Color_xy&CIE_xy_1931_1964), Measure_Field&CIE_xy);
 8008e58:	782a      	ldrb	r2, [r5, #0]
 8008e5a:	8823      	ldrh	r3, [r4, #0]
 8008e5c:	43d2      	mvns	r2, r2
 8008e5e:	f003 0320 	and.w	r3, r3, #32
 8008e62:	f002 0201 	and.w	r2, r2, #1
 8008e66:	f240 1107 	movw	r1, #263	; 0x107
 8008e6a:	20c8      	movs	r0, #200	; 0xc8
 8008e6c:	f002 fe79 	bl	800bb62 <GUI_RadioBox>
 8008e70:	f7fe be15 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8008e74:	f3af 8000 	nop.w
 8008e78:	33333333 	.word	0x33333333
 8008e7c:	40053333 	.word	0x40053333
 8008e80:	00000000 	.word	0x00000000
 8008e84:	40623800 	.word	0x40623800
 8008e88:	66666666 	.word	0x66666666
 8008e8c:	4081f866 	.word	0x4081f866
 8008e90:	33333333 	.word	0x33333333
 8008e94:	40867133 	.word	0x40867133
 8008e98:	99999999 	.word	0x99999999
 8008e9c:	40720d99 	.word	0x40720d99
 8008ea0:	99999999 	.word	0x99999999
 8008ea4:	4091a399 	.word	0x4091a399
 8008ea8:	33333333 	.word	0x33333333
 8008eac:	407aff33 	.word	0x407aff33
 8008eb0:	cccccccd 	.word	0xcccccccd
 8008eb4:	408508cc 	.word	0x408508cc
 8008eb8:	00000000 	.word	0x00000000
 8008ebc:	40673000 	.word	0x40673000
 8008ec0:	99999999 	.word	0x99999999
 8008ec4:	40748999 	.word	0x40748999
 8008ec8:	33333333 	.word	0x33333333
 8008ecc:	40760733 	.word	0x40760733
 8008ed0:	cccccccd 	.word	0xcccccccd
 8008ed4:	407ef8cc 	.word	0x407ef8cc
 8008ed8:	200002be 	.word	0x200002be
 8008edc:	20084b8d 	.word	0x20084b8d
 8008ee0:	20000176 	.word	0x20000176
 8008ee4:	4093e000 	.word	0x4093e000
 8008ee8:	40809000 	.word	0x40809000
 8008eec:	200002bc 	.word	0x200002bc
 8008ef0:	66666666 	.word	0x66666666
 8008ef4:	408b1466 	.word	0x408b1466
 8008ef8:	33333333 	.word	0x33333333
 8008efc:	408f8d33 	.word	0x408f8d33
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=327*TS_Callib & Touch_y <=(327+54)*TS_Callib) //CIE_Luv
 8008f00:	a3c8      	add	r3, pc, #800	; (adr r3, 8009224 <GUI_Touch_Processing+0x18a4>)
 8008f02:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f06:	4630      	mov	r0, r6
 8008f08:	4639      	mov	r1, r7
 8008f0a:	f04f 0a01 	mov.w	sl, #1
 8008f0e:	f7f7 fe05 	bl	8000b1c <__aeabi_dcmpge>
 8008f12:	b900      	cbnz	r0, 8008f16 <GUI_Touch_Processing+0x1596>
 8008f14:	4682      	mov	sl, r0
 8008f16:	a3c5      	add	r3, pc, #788	; (adr r3, 800922c <GUI_Touch_Processing+0x18ac>)
 8008f18:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f1c:	4630      	mov	r0, r6
 8008f1e:	4639      	mov	r1, r7
 8008f20:	f04f 0b01 	mov.w	fp, #1
 8008f24:	f7f7 fdf0 	bl	8000b08 <__aeabi_dcmple>
 8008f28:	b900      	cbnz	r0, 8008f2c <GUI_Touch_Processing+0x15ac>
 8008f2a:	4683      	mov	fp, r0
 8008f2c:	ea0a 0a0b 	and.w	sl, sl, fp
 8008f30:	f01a 0f01 	tst.w	sl, #1
 8008f34:	d00e      	beq.n	8008f54 <GUI_Touch_Processing+0x15d4>
 8008f36:	b16d      	cbz	r5, 8008f54 <GUI_Touch_Processing+0x15d4>
					Measure_Field ^= CIE_Luv;
 8008f38:	4bb5      	ldr	r3, [pc, #724]	; (8009210 <GUI_Touch_Processing+0x1890>)
 8008f3a:	881a      	ldrh	r2, [r3, #0]
 8008f3c:	f082 0240 	eor.w	r2, r2, #64	; 0x40
 8008f40:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 327, Measure_Field&CIE_Luv);
 8008f42:	f240 1147 	movw	r1, #327	; 0x147
 8008f46:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8008f4a:	20c8      	movs	r0, #200	; 0xc8
 8008f4c:	f002 fdc8 	bl	800bae0 <GUI_CheckBox>
 8008f50:	f7fe bda5 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=198*TS_Callib & Touch_y <=(198+54)*TS_Callib && (Measure_Field&CIE_xy)) //CIE_xy_1931
 8008f54:	a398      	add	r3, pc, #608	; (adr r3, 80091b8 <GUI_Touch_Processing+0x1838>)
 8008f56:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f5a:	4630      	mov	r0, r6
 8008f5c:	4639      	mov	r1, r7
 8008f5e:	f04f 0a01 	mov.w	sl, #1
 8008f62:	f7f7 fddb 	bl	8000b1c <__aeabi_dcmpge>
 8008f66:	b900      	cbnz	r0, 8008f6a <GUI_Touch_Processing+0x15ea>
 8008f68:	4682      	mov	sl, r0
 8008f6a:	ea15 0f0a 	tst.w	r5, sl
 8008f6e:	d02a      	beq.n	8008fc6 <GUI_Touch_Processing+0x1646>
 8008f70:	a393      	add	r3, pc, #588	; (adr r3, 80091c0 <GUI_Touch_Processing+0x1840>)
 8008f72:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f76:	4630      	mov	r0, r6
 8008f78:	4639      	mov	r1, r7
 8008f7a:	f04f 0a01 	mov.w	sl, #1
 8008f7e:	f7f7 fdc3 	bl	8000b08 <__aeabi_dcmple>
 8008f82:	b900      	cbnz	r0, 8008f86 <GUI_Touch_Processing+0x1606>
 8008f84:	4682      	mov	sl, r0
 8008f86:	f01a 0fff 	tst.w	sl, #255	; 0xff
 8008f8a:	d01c      	beq.n	8008fc6 <GUI_Touch_Processing+0x1646>
 8008f8c:	4ba0      	ldr	r3, [pc, #640]	; (8009210 <GUI_Touch_Processing+0x1890>)
 8008f8e:	881b      	ldrh	r3, [r3, #0]
 8008f90:	069b      	lsls	r3, r3, #26
 8008f92:	d518      	bpl.n	8008fc6 <GUI_Touch_Processing+0x1646>
					if(!(Measure_Color_xy&CIE_xy_1931_1964)){
 8008f94:	4c9f      	ldr	r4, [pc, #636]	; (8009214 <GUI_Touch_Processing+0x1894>)
 8008f96:	7822      	ldrb	r2, [r4, #0]
 8008f98:	07d7      	lsls	r7, r2, #31
 8008f9a:	f53e ad80 	bmi.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, 0x01);
 8008f9e:	2301      	movs	r3, #1
						Measure_Color_xy ^= CIE_xy_1931_1964;
 8008fa0:	f082 0201 	eor.w	r2, r2, #1
 8008fa4:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, 0x01);
 8008fa6:	21c6      	movs	r1, #198	; 0xc6
 8008fa8:	401a      	ands	r2, r3
 8008faa:	20c8      	movs	r0, #200	; 0xc8
 8008fac:	f002 fdd9 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 263, !(Measure_Color_xy&CIE_xy_1931_1964), 0x01);
 8008fb0:	7822      	ldrb	r2, [r4, #0]
 8008fb2:	2301      	movs	r3, #1
 8008fb4:	43d2      	mvns	r2, r2
 8008fb6:	401a      	ands	r2, r3
 8008fb8:	f240 1107 	movw	r1, #263	; 0x107
 8008fbc:	20c8      	movs	r0, #200	; 0xc8
 8008fbe:	f002 fdd0 	bl	800bb62 <GUI_RadioBox>
 8008fc2:	f7fe bd6c 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=263*TS_Callib & Touch_y <=(263+54)*TS_Callib && (Measure_Field&CIE_xy)) //CIE_xy_1964
 8008fc6:	a380      	add	r3, pc, #512	; (adr r3, 80091c8 <GUI_Touch_Processing+0x1848>)
 8008fc8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008fcc:	4630      	mov	r0, r6
 8008fce:	4639      	mov	r1, r7
 8008fd0:	f04f 0a01 	mov.w	sl, #1
 8008fd4:	f7f7 fda2 	bl	8000b1c <__aeabi_dcmpge>
 8008fd8:	b900      	cbnz	r0, 8008fdc <GUI_Touch_Processing+0x165c>
 8008fda:	4682      	mov	sl, r0
 8008fdc:	ea15 0f0a 	tst.w	r5, sl
 8008fe0:	d02a      	beq.n	8009038 <GUI_Touch_Processing+0x16b8>
 8008fe2:	a37b      	add	r3, pc, #492	; (adr r3, 80091d0 <GUI_Touch_Processing+0x1850>)
 8008fe4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008fe8:	4630      	mov	r0, r6
 8008fea:	4639      	mov	r1, r7
 8008fec:	f04f 0501 	mov.w	r5, #1
 8008ff0:	f7f7 fd8a 	bl	8000b08 <__aeabi_dcmple>
 8008ff4:	b900      	cbnz	r0, 8008ff8 <GUI_Touch_Processing+0x1678>
 8008ff6:	4605      	mov	r5, r0
 8008ff8:	f015 0fff 	tst.w	r5, #255	; 0xff
 8008ffc:	d01c      	beq.n	8009038 <GUI_Touch_Processing+0x16b8>
 8008ffe:	4b84      	ldr	r3, [pc, #528]	; (8009210 <GUI_Touch_Processing+0x1890>)
 8009000:	881b      	ldrh	r3, [r3, #0]
 8009002:	069e      	lsls	r6, r3, #26
 8009004:	d518      	bpl.n	8009038 <GUI_Touch_Processing+0x16b8>
					if((Measure_Color_xy&CIE_xy_1931_1964)){
 8009006:	4c83      	ldr	r4, [pc, #524]	; (8009214 <GUI_Touch_Processing+0x1894>)
 8009008:	7822      	ldrb	r2, [r4, #0]
 800900a:	07d5      	lsls	r5, r2, #31
 800900c:	f57e ad47 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, 0x01);
 8009010:	2301      	movs	r3, #1
						Measure_Color_xy ^= CIE_xy_1931_1964;
 8009012:	f082 0201 	eor.w	r2, r2, #1
 8009016:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 198, Measure_Color_xy&CIE_xy_1931_1964, 0x01);
 8009018:	21c6      	movs	r1, #198	; 0xc6
 800901a:	401a      	ands	r2, r3
 800901c:	20c8      	movs	r0, #200	; 0xc8
 800901e:	f002 fda0 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 263, !(Measure_Color_xy&CIE_xy_1931_1964), 0x01);
 8009022:	7822      	ldrb	r2, [r4, #0]
 8009024:	2301      	movs	r3, #1
 8009026:	43d2      	mvns	r2, r2
 8009028:	401a      	ands	r2, r3
 800902a:	f240 1107 	movw	r1, #263	; 0x107
 800902e:	20c8      	movs	r0, #200	; 0xc8
 8009030:	f002 fd97 	bl	800bb62 <GUI_RadioBox>
 8009034:	f7fe bd33 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8009038:	9b02      	ldr	r3, [sp, #8]
 800903a:	9e00      	ldr	r6, [sp, #0]
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800903c:	4640      	mov	r0, r8
 800903e:	401e      	ands	r6, r3
 8009040:	4649      	mov	r1, r9
 8009042:	a365      	add	r3, pc, #404	; (adr r3, 80091d8 <GUI_Touch_Processing+0x1858>)
 8009044:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009048:	f04f 0501 	mov.w	r5, #1
 800904c:	f7f7 fd66 	bl	8000b1c <__aeabi_dcmpge>
 8009050:	b900      	cbnz	r0, 8009054 <GUI_Touch_Processing+0x16d4>
 8009052:	4605      	mov	r5, r0
 8009054:	a362      	add	r3, pc, #392	; (adr r3, 80091e0 <GUI_Touch_Processing+0x1860>)
 8009056:	e9d3 2300 	ldrd	r2, r3, [r3]
 800905a:	4640      	mov	r0, r8
 800905c:	4649      	mov	r1, r9
 800905e:	f04f 0701 	mov.w	r7, #1
 8009062:	f7f7 fd51 	bl	8000b08 <__aeabi_dcmple>
 8009066:	b900      	cbnz	r0, 800906a <GUI_Touch_Processing+0x16ea>
 8009068:	4607      	mov	r7, r0
 800906a:	403d      	ands	r5, r7
 800906c:	07e8      	lsls	r0, r5, #31
 800906e:	d502      	bpl.n	8009076 <GUI_Touch_Processing+0x16f6>
 8009070:	2e00      	cmp	r6, #0
 8009072:	f47f ac15 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 8009076:	a35c      	add	r3, pc, #368	; (adr r3, 80091e8 <GUI_Touch_Processing+0x1868>)
 8009078:	e9d3 2300 	ldrd	r2, r3, [r3]
 800907c:	4640      	mov	r0, r8
 800907e:	4649      	mov	r1, r9
 8009080:	f04f 0501 	mov.w	r5, #1
 8009084:	f7f7 fd4a 	bl	8000b1c <__aeabi_dcmpge>
 8009088:	b900      	cbnz	r0, 800908c <GUI_Touch_Processing+0x170c>
 800908a:	4605      	mov	r5, r0
 800908c:	a358      	add	r3, pc, #352	; (adr r3, 80091f0 <GUI_Touch_Processing+0x1870>)
 800908e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009092:	4640      	mov	r0, r8
 8009094:	4649      	mov	r1, r9
 8009096:	f04f 0701 	mov.w	r7, #1
 800909a:	f7f7 fd35 	bl	8000b08 <__aeabi_dcmple>
 800909e:	b900      	cbnz	r0, 80090a2 <GUI_Touch_Processing+0x1722>
 80090a0:	4607      	mov	r7, r0
 80090a2:	403d      	ands	r5, r7
 80090a4:	07e9      	lsls	r1, r5, #31
 80090a6:	d51d      	bpl.n	80090e4 <GUI_Touch_Processing+0x1764>
 80090a8:	b1e6      	cbz	r6, 80090e4 <GUI_Touch_Processing+0x1764>
					GUI_screen_state = Prev_Inf_Screen;
 80090aa:	4b5b      	ldr	r3, [pc, #364]	; (8009218 <GUI_Touch_Processing+0x1898>)
 80090ac:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 80090ae:	1e5a      	subs	r2, r3, #1
 80090b0:	2a05      	cmp	r2, #5
 80090b2:	d804      	bhi.n	80090be <GUI_Touch_Processing+0x173e>
 80090b4:	e8df f002 	tbb	[pc, r2]
 80090b8:	0a030306 	.word	0x0a030306
 80090bc:	0e12      	.short	0x0e12
					GUI_screen_state = Prev_Inf_Screen;
 80090be:	7023      	strb	r3, [r4, #0]
 80090c0:	f7fe bced 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 80090c4:	2301      	movs	r3, #1
 80090c6:	7023      	strb	r3, [r4, #0]
 80090c8:	f7fe bce9 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 80090cc:	2304      	movs	r3, #4
 80090ce:	7023      	strb	r3, [r4, #0]
 80090d0:	f7fe bce5 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 80090d4:	2306      	movs	r3, #6
 80090d6:	7023      	strb	r3, [r4, #0]
 80090d8:	f7fe bce1 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 80090dc:	2305      	movs	r3, #5
 80090de:	7023      	strb	r3, [r4, #0]
 80090e0:	f7fe bcdd 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 80090e4:	a342      	add	r3, pc, #264	; (adr r3, 80091f0 <GUI_Touch_Processing+0x1870>)
 80090e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80090ea:	4640      	mov	r0, r8
 80090ec:	4649      	mov	r1, r9
 80090ee:	f04f 0401 	mov.w	r4, #1
 80090f2:	f7f7 fd13 	bl	8000b1c <__aeabi_dcmpge>
 80090f6:	b900      	cbnz	r0, 80090fa <GUI_Touch_Processing+0x177a>
 80090f8:	4604      	mov	r4, r0
 80090fa:	a33f      	add	r3, pc, #252	; (adr r3, 80091f8 <GUI_Touch_Processing+0x1878>)
 80090fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009100:	4640      	mov	r0, r8
 8009102:	4649      	mov	r1, r9
 8009104:	f04f 0501 	mov.w	r5, #1
 8009108:	f7f7 fcfe 	bl	8000b08 <__aeabi_dcmple>
 800910c:	b900      	cbnz	r0, 8009110 <GUI_Touch_Processing+0x1790>
 800910e:	4605      	mov	r5, r0
 8009110:	402c      	ands	r4, r5
 8009112:	07e2      	lsls	r2, r4, #31
 8009114:	f57e acc3 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 8009118:	2e00      	cmp	r6, #0
 800911a:	f47e acfd 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
 800911e:	f7fe bcbe 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 8009122:	4b3e      	ldr	r3, [pc, #248]	; (800921c <GUI_Touch_Processing+0x189c>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //down
 8009124:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 8009128:	220a      	movs	r2, #10
 800912a:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //down
 800912c:	f7f7 fa0a 	bl	8000544 <__aeabi_i2d>
 8009130:	4680      	mov	r8, r0
 8009132:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8009136:	4689      	mov	r9, r1
 8009138:	f7f7 fa04 	bl	8000544 <__aeabi_i2d>
 800913c:	a330      	add	r3, pc, #192	; (adr r3, 8009200 <GUI_Touch_Processing+0x1880>)
 800913e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009142:	4606      	mov	r6, r0
 8009144:	460f      	mov	r7, r1
 8009146:	f04f 0501 	mov.w	r5, #1
 800914a:	f7f7 fce7 	bl	8000b1c <__aeabi_dcmpge>
 800914e:	b900      	cbnz	r0, 8009152 <GUI_Touch_Processing+0x17d2>
 8009150:	4605      	mov	r5, r0
 8009152:	2200      	movs	r2, #0
 8009154:	4b32      	ldr	r3, [pc, #200]	; (8009220 <GUI_Touch_Processing+0x18a0>)
 8009156:	4630      	mov	r0, r6
 8009158:	4639      	mov	r1, r7
 800915a:	b2ed      	uxtb	r5, r5
 800915c:	f04f 0a01 	mov.w	sl, #1
 8009160:	f7f7 fcd2 	bl	8000b08 <__aeabi_dcmple>
 8009164:	b900      	cbnz	r0, 8009168 <GUI_Touch_Processing+0x17e8>
 8009166:	4682      	mov	sl, r0
 8009168:	fa5f f38a 	uxtb.w	r3, sl
 800916c:	9300      	str	r3, [sp, #0]
 800916e:	4640      	mov	r0, r8
 8009170:	a325      	add	r3, pc, #148	; (adr r3, 8009208 <GUI_Touch_Processing+0x1888>)
 8009172:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009176:	4649      	mov	r1, r9
 8009178:	f04f 0a01 	mov.w	sl, #1
 800917c:	f7f7 fcce 	bl	8000b1c <__aeabi_dcmpge>
 8009180:	b900      	cbnz	r0, 8009184 <GUI_Touch_Processing+0x1804>
 8009182:	4682      	mov	sl, r0
 8009184:	a314      	add	r3, pc, #80	; (adr r3, 80091d8 <GUI_Touch_Processing+0x1858>)
 8009186:	e9d3 2300 	ldrd	r2, r3, [r3]
 800918a:	4640      	mov	r0, r8
 800918c:	4649      	mov	r1, r9
 800918e:	f04f 0b01 	mov.w	fp, #1
 8009192:	f7f7 fcb9 	bl	8000b08 <__aeabi_dcmple>
 8009196:	b900      	cbnz	r0, 800919a <GUI_Touch_Processing+0x181a>
 8009198:	4683      	mov	fp, r0
 800919a:	ea0a 0a0b 	and.w	sl, sl, fp
 800919e:	ea15 0f0a 	tst.w	r5, sl
 80091a2:	d047      	beq.n	8009234 <GUI_Touch_Processing+0x18b4>
 80091a4:	9b00      	ldr	r3, [sp, #0]
 80091a6:	2b00      	cmp	r3, #0
 80091a8:	d044      	beq.n	8009234 <GUI_Touch_Processing+0x18b4>
					GUI_screen_state = DataSet5_Screen;
 80091aa:	230b      	movs	r3, #11
 80091ac:	7023      	strb	r3, [r4, #0]
 80091ae:	f7fe bc76 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 80091b2:	bf00      	nop
 80091b4:	f3af 8000 	nop.w
 80091b8:	99999999 	.word	0x99999999
 80091bc:	40806599 	.word	0x40806599
 80091c0:	66666666 	.word	0x66666666
 80091c4:	4084de66 	.word	0x4084de66
 80091c8:	99999999 	.word	0x99999999
 80091cc:	4085c799 	.word	0x4085c799
 80091d0:	66666666 	.word	0x66666666
 80091d4:	408a4066 	.word	0x408a4066
 80091d8:	66666666 	.word	0x66666666
 80091dc:	4081f866 	.word	0x4081f866
 80091e0:	33333333 	.word	0x33333333
 80091e4:	40867133 	.word	0x40867133
 80091e8:	33333333 	.word	0x33333333
 80091ec:	40053333 	.word	0x40053333
 80091f0:	00000000 	.word	0x00000000
 80091f4:	40623800 	.word	0x40623800
 80091f8:	99999999 	.word	0x99999999
 80091fc:	40720d99 	.word	0x40720d99
 8009200:	99999999 	.word	0x99999999
 8009204:	4091a399 	.word	0x4091a399
 8009208:	33333333 	.word	0x33333333
 800920c:	407aff33 	.word	0x407aff33
 8009210:	200002be 	.word	0x200002be
 8009214:	200002bc 	.word	0x200002bc
 8009218:	20084b8d 	.word	0x20084b8d
 800921c:	20000176 	.word	0x20000176
 8009220:	4093e000 	.word	0x4093e000
 8009224:	66666666 	.word	0x66666666
 8009228:	408b1466 	.word	0x408b1466
 800922c:	33333333 	.word	0x33333333
 8009230:	408f8d33 	.word	0x408f8d33
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=65*TS_Callib & Touch_y <=(65+54)*TS_Callib) //CIE_Lab
 8009234:	2200      	movs	r2, #0
 8009236:	4bbe      	ldr	r3, [pc, #760]	; (8009530 <GUI_Touch_Processing+0x1bb0>)
 8009238:	4640      	mov	r0, r8
 800923a:	4649      	mov	r1, r9
 800923c:	f04f 0401 	mov.w	r4, #1
 8009240:	f7f7 fc6c 	bl	8000b1c <__aeabi_dcmpge>
 8009244:	b900      	cbnz	r0, 8009248 <GUI_Touch_Processing+0x18c8>
 8009246:	4604      	mov	r4, r0
 8009248:	a3a7      	add	r3, pc, #668	; (adr r3, 80094e8 <GUI_Touch_Processing+0x1b68>)
 800924a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800924e:	4640      	mov	r0, r8
 8009250:	4649      	mov	r1, r9
 8009252:	f04f 0a01 	mov.w	sl, #1
 8009256:	f7f7 fc57 	bl	8000b08 <__aeabi_dcmple>
 800925a:	b900      	cbnz	r0, 800925e <GUI_Touch_Processing+0x18de>
 800925c:	4682      	mov	sl, r0
 800925e:	ea04 040a 	and.w	r4, r4, sl
 8009262:	a3a3      	add	r3, pc, #652	; (adr r3, 80094f0 <GUI_Touch_Processing+0x1b70>)
 8009264:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009268:	4630      	mov	r0, r6
 800926a:	4639      	mov	r1, r7
 800926c:	b2e4      	uxtb	r4, r4
 800926e:	f04f 0a01 	mov.w	sl, #1
 8009272:	f7f7 fc53 	bl	8000b1c <__aeabi_dcmpge>
 8009276:	b900      	cbnz	r0, 800927a <GUI_Touch_Processing+0x18fa>
 8009278:	4682      	mov	sl, r0
 800927a:	a39f      	add	r3, pc, #636	; (adr r3, 80094f8 <GUI_Touch_Processing+0x1b78>)
 800927c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009280:	4630      	mov	r0, r6
 8009282:	4639      	mov	r1, r7
 8009284:	f04f 0b01 	mov.w	fp, #1
 8009288:	f7f7 fc3e 	bl	8000b08 <__aeabi_dcmple>
 800928c:	b900      	cbnz	r0, 8009290 <GUI_Touch_Processing+0x1910>
 800928e:	4683      	mov	fp, r0
 8009290:	ea0a 0a0b 	and.w	sl, sl, fp
 8009294:	f01a 0f01 	tst.w	sl, #1
 8009298:	d04c      	beq.n	8009334 <GUI_Touch_Processing+0x19b4>
 800929a:	2c00      	cmp	r4, #0
 800929c:	d04a      	beq.n	8009334 <GUI_Touch_Processing+0x19b4>
					Measure_Field ^= CIE_Lab;
 800929e:	4ca5      	ldr	r4, [pc, #660]	; (8009534 <GUI_Touch_Processing+0x1bb4>)
					GUI_RadioBox(200, 108, Source_Type&Source_A, Measure_Field&CIE_Lab);
 80092a0:	4da5      	ldr	r5, [pc, #660]	; (8009538 <GUI_Touch_Processing+0x1bb8>)
					Measure_Field ^= CIE_Lab;
 80092a2:	8822      	ldrh	r2, [r4, #0]
 80092a4:	f082 0280 	eor.w	r2, r2, #128	; 0x80
 80092a8:	8022      	strh	r2, [r4, #0]
					GUI_CheckBox(200, 65, Measure_Field&CIE_Lab);
 80092aa:	2141      	movs	r1, #65	; 0x41
 80092ac:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80092b0:	20c8      	movs	r0, #200	; 0xc8
 80092b2:	f002 fc15 	bl	800bae0 <GUI_CheckBox>
					GUI_RadioBox(200, 108, Source_Type&Source_A, Measure_Field&CIE_Lab);
 80092b6:	8823      	ldrh	r3, [r4, #0]
 80092b8:	782a      	ldrb	r2, [r5, #0]
 80092ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80092be:	f002 0201 	and.w	r2, r2, #1
 80092c2:	216c      	movs	r1, #108	; 0x6c
 80092c4:	20c8      	movs	r0, #200	; 0xc8
 80092c6:	f002 fc4c 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 143, Source_Type&Source_D65, Measure_Field&CIE_Lab);
 80092ca:	8823      	ldrh	r3, [r4, #0]
 80092cc:	782a      	ldrb	r2, [r5, #0]
 80092ce:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80092d2:	f002 0202 	and.w	r2, r2, #2
 80092d6:	218f      	movs	r1, #143	; 0x8f
 80092d8:	20c8      	movs	r0, #200	; 0xc8
 80092da:	f002 fc42 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 178, Source_Type&Source_C, Measure_Field&CIE_Lab);
 80092de:	8823      	ldrh	r3, [r4, #0]
 80092e0:	782a      	ldrb	r2, [r5, #0]
 80092e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80092e6:	f002 0204 	and.w	r2, r2, #4
 80092ea:	21b2      	movs	r1, #178	; 0xb2
 80092ec:	20c8      	movs	r0, #200	; 0xc8
 80092ee:	f002 fc38 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 213, Source_Type&Source_D50, Measure_Field&CIE_Lab);
 80092f2:	8823      	ldrh	r3, [r4, #0]
 80092f4:	782a      	ldrb	r2, [r5, #0]
 80092f6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80092fa:	f002 0208 	and.w	r2, r2, #8
 80092fe:	21d5      	movs	r1, #213	; 0xd5
 8009300:	20c8      	movs	r0, #200	; 0xc8
 8009302:	f002 fc2e 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 248, Source_Type&Source_D55, Measure_Field&CIE_Lab);
 8009306:	8823      	ldrh	r3, [r4, #0]
 8009308:	782a      	ldrb	r2, [r5, #0]
 800930a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800930e:	f002 0210 	and.w	r2, r2, #16
 8009312:	21f8      	movs	r1, #248	; 0xf8
 8009314:	20c8      	movs	r0, #200	; 0xc8
 8009316:	f002 fc24 	bl	800bb62 <GUI_RadioBox>
					GUI_RadioBox(200, 283, Source_Type&Source_D75, Measure_Field&CIE_Lab);
 800931a:	8823      	ldrh	r3, [r4, #0]
 800931c:	782a      	ldrb	r2, [r5, #0]
 800931e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009322:	f002 0220 	and.w	r2, r2, #32
 8009326:	f240 111b 	movw	r1, #283	; 0x11b
 800932a:	20c8      	movs	r0, #200	; 0xc8
 800932c:	f002 fc19 	bl	800bb62 <GUI_RadioBox>
 8009330:	f7fe bbb5 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=345*TS_Callib & Touch_y <=(345+54)*TS_Callib) //EbEr
 8009334:	a372      	add	r3, pc, #456	; (adr r3, 8009500 <GUI_Touch_Processing+0x1b80>)
 8009336:	e9d3 2300 	ldrd	r2, r3, [r3]
 800933a:	4630      	mov	r0, r6
 800933c:	4639      	mov	r1, r7
 800933e:	f04f 0a01 	mov.w	sl, #1
 8009342:	f7f7 fbeb 	bl	8000b1c <__aeabi_dcmpge>
 8009346:	b900      	cbnz	r0, 800934a <GUI_Touch_Processing+0x19ca>
 8009348:	4682      	mov	sl, r0
 800934a:	a36f      	add	r3, pc, #444	; (adr r3, 8009508 <GUI_Touch_Processing+0x1b88>)
 800934c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009350:	4630      	mov	r0, r6
 8009352:	4639      	mov	r1, r7
 8009354:	f04f 0b01 	mov.w	fp, #1
 8009358:	f7f7 fbd6 	bl	8000b08 <__aeabi_dcmple>
 800935c:	b900      	cbnz	r0, 8009360 <GUI_Touch_Processing+0x19e0>
 800935e:	4683      	mov	fp, r0
 8009360:	ea0a 0a0b 	and.w	sl, sl, fp
 8009364:	f01a 0f01 	tst.w	sl, #1
 8009368:	d00e      	beq.n	8009388 <GUI_Touch_Processing+0x1a08>
 800936a:	b16c      	cbz	r4, 8009388 <GUI_Touch_Processing+0x1a08>
					Measure_Field ^= EbEr;
 800936c:	4b71      	ldr	r3, [pc, #452]	; (8009534 <GUI_Touch_Processing+0x1bb4>)
 800936e:	881a      	ldrh	r2, [r3, #0]
 8009370:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8009374:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 345, Measure_Field&EbEr);
 8009376:	f240 1159 	movw	r1, #345	; 0x159
 800937a:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 800937e:	20c8      	movs	r0, #200	; 0xc8
 8009380:	f002 fbae 	bl	800bae0 <GUI_CheckBox>
 8009384:	f7fe bb8b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=108*TS_Callib & Touch_y <=(108+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_A
 8009388:	a361      	add	r3, pc, #388	; (adr r3, 8009510 <GUI_Touch_Processing+0x1b90>)
 800938a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800938e:	4630      	mov	r0, r6
 8009390:	4639      	mov	r1, r7
 8009392:	f04f 0a01 	mov.w	sl, #1
 8009396:	f7f7 fbc1 	bl	8000b1c <__aeabi_dcmpge>
 800939a:	b900      	cbnz	r0, 800939e <GUI_Touch_Processing+0x1a1e>
 800939c:	4682      	mov	sl, r0
 800939e:	ea14 0f0a 	tst.w	r4, sl
 80093a2:	d049      	beq.n	8009438 <GUI_Touch_Processing+0x1ab8>
 80093a4:	a35c      	add	r3, pc, #368	; (adr r3, 8009518 <GUI_Touch_Processing+0x1b98>)
 80093a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80093aa:	4630      	mov	r0, r6
 80093ac:	4639      	mov	r1, r7
 80093ae:	f04f 0a01 	mov.w	sl, #1
 80093b2:	f7f7 fba9 	bl	8000b08 <__aeabi_dcmple>
 80093b6:	b900      	cbnz	r0, 80093ba <GUI_Touch_Processing+0x1a3a>
 80093b8:	4682      	mov	sl, r0
 80093ba:	f01a 0fff 	tst.w	sl, #255	; 0xff
 80093be:	d03b      	beq.n	8009438 <GUI_Touch_Processing+0x1ab8>
 80093c0:	4b5c      	ldr	r3, [pc, #368]	; (8009534 <GUI_Touch_Processing+0x1bb4>)
 80093c2:	881b      	ldrh	r3, [r3, #0]
 80093c4:	061b      	lsls	r3, r3, #24
 80093c6:	d537      	bpl.n	8009438 <GUI_Touch_Processing+0x1ab8>
					if(!(Source_Type&Source_A))
 80093c8:	4d5b      	ldr	r5, [pc, #364]	; (8009538 <GUI_Touch_Processing+0x1bb8>)
 80093ca:	782b      	ldrb	r3, [r5, #0]
 80093cc:	07dc      	lsls	r4, r3, #31
 80093ce:	f53e ab66 	bmi.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type|=Source_A, 0x01);
 80093d2:	2401      	movs	r4, #1
 80093d4:	4623      	mov	r3, r4
 80093d6:	4622      	mov	r2, r4
 80093d8:	216c      	movs	r1, #108	; 0x6c
 80093da:	20c8      	movs	r0, #200	; 0xc8
 80093dc:	702c      	strb	r4, [r5, #0]
 80093de:	f002 fbc0 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type&Source_D65, 0x01);
 80093e2:	782a      	ldrb	r2, [r5, #0]
 80093e4:	4623      	mov	r3, r4
 80093e6:	f002 0202 	and.w	r2, r2, #2
 80093ea:	218f      	movs	r1, #143	; 0x8f
 80093ec:	20c8      	movs	r0, #200	; 0xc8
 80093ee:	f002 fbb8 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type&Source_C, 0x01);
 80093f2:	782a      	ldrb	r2, [r5, #0]
 80093f4:	4623      	mov	r3, r4
 80093f6:	f002 0204 	and.w	r2, r2, #4
 80093fa:	21b2      	movs	r1, #178	; 0xb2
 80093fc:	20c8      	movs	r0, #200	; 0xc8
 80093fe:	f002 fbb0 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type&Source_D50, 0x01);
 8009402:	782a      	ldrb	r2, [r5, #0]
 8009404:	4623      	mov	r3, r4
 8009406:	f002 0208 	and.w	r2, r2, #8
 800940a:	21d5      	movs	r1, #213	; 0xd5
 800940c:	20c8      	movs	r0, #200	; 0xc8
 800940e:	f002 fba8 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type&Source_D55, 0x01);
 8009412:	782a      	ldrb	r2, [r5, #0]
 8009414:	4623      	mov	r3, r4
 8009416:	f002 0210 	and.w	r2, r2, #16
 800941a:	21f8      	movs	r1, #248	; 0xf8
 800941c:	20c8      	movs	r0, #200	; 0xc8
 800941e:	f002 fba0 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type&Source_D75, 0x01);
 8009422:	782a      	ldrb	r2, [r5, #0]
 8009424:	4623      	mov	r3, r4
 8009426:	f002 0220 	and.w	r2, r2, #32
 800942a:	f240 111b 	movw	r1, #283	; 0x11b
 800942e:	20c8      	movs	r0, #200	; 0xc8
 8009430:	f002 fb97 	bl	800bb62 <GUI_RadioBox>
 8009434:	f7fe bb33 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=143*TS_Callib & Touch_y <=(143+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_D65
 8009438:	a339      	add	r3, pc, #228	; (adr r3, 8009520 <GUI_Touch_Processing+0x1ba0>)
 800943a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800943e:	4630      	mov	r0, r6
 8009440:	4639      	mov	r1, r7
 8009442:	f04f 0a01 	mov.w	sl, #1
 8009446:	f7f7 fb69 	bl	8000b1c <__aeabi_dcmpge>
 800944a:	b900      	cbnz	r0, 800944e <GUI_Touch_Processing+0x1ace>
 800944c:	4682      	mov	sl, r0
 800944e:	ea14 0f0a 	tst.w	r4, sl
 8009452:	d073      	beq.n	800953c <GUI_Touch_Processing+0x1bbc>
 8009454:	a334      	add	r3, pc, #208	; (adr r3, 8009528 <GUI_Touch_Processing+0x1ba8>)
 8009456:	e9d3 2300 	ldrd	r2, r3, [r3]
 800945a:	4630      	mov	r0, r6
 800945c:	4639      	mov	r1, r7
 800945e:	f04f 0a01 	mov.w	sl, #1
 8009462:	f7f7 fb51 	bl	8000b08 <__aeabi_dcmple>
 8009466:	b900      	cbnz	r0, 800946a <GUI_Touch_Processing+0x1aea>
 8009468:	4682      	mov	sl, r0
 800946a:	f01a 0fff 	tst.w	sl, #255	; 0xff
 800946e:	d065      	beq.n	800953c <GUI_Touch_Processing+0x1bbc>
 8009470:	4b30      	ldr	r3, [pc, #192]	; (8009534 <GUI_Touch_Processing+0x1bb4>)
 8009472:	881b      	ldrh	r3, [r3, #0]
 8009474:	0618      	lsls	r0, r3, #24
 8009476:	d561      	bpl.n	800953c <GUI_Touch_Processing+0x1bbc>
					if(!(Source_Type&Source_D65))
 8009478:	4c2f      	ldr	r4, [pc, #188]	; (8009538 <GUI_Touch_Processing+0x1bb8>)
 800947a:	7822      	ldrb	r2, [r4, #0]
 800947c:	f012 0202 	ands.w	r2, r2, #2
 8009480:	f47e ab0d 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009484:	2301      	movs	r3, #1
 8009486:	216c      	movs	r1, #108	; 0x6c
 8009488:	20c8      	movs	r0, #200	; 0xc8
						Source_Type = 0;
 800948a:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 800948c:	f002 fb69 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type|=Source_D65, 0x01);
 8009490:	7822      	ldrb	r2, [r4, #0]
 8009492:	2301      	movs	r3, #1
 8009494:	f042 0202 	orr.w	r2, r2, #2
 8009498:	218f      	movs	r1, #143	; 0x8f
 800949a:	20c8      	movs	r0, #200	; 0xc8
 800949c:	7022      	strb	r2, [r4, #0]
 800949e:	f002 fb60 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type&Source_C, 0x01);
 80094a2:	7822      	ldrb	r2, [r4, #0]
 80094a4:	2301      	movs	r3, #1
 80094a6:	f002 0204 	and.w	r2, r2, #4
 80094aa:	21b2      	movs	r1, #178	; 0xb2
 80094ac:	20c8      	movs	r0, #200	; 0xc8
 80094ae:	f002 fb58 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type&Source_D50, 0x01);
 80094b2:	7822      	ldrb	r2, [r4, #0]
 80094b4:	2301      	movs	r3, #1
 80094b6:	f002 0208 	and.w	r2, r2, #8
 80094ba:	21d5      	movs	r1, #213	; 0xd5
 80094bc:	20c8      	movs	r0, #200	; 0xc8
 80094be:	f002 fb50 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type&Source_D55, 0x01);
 80094c2:	7822      	ldrb	r2, [r4, #0]
 80094c4:	2301      	movs	r3, #1
 80094c6:	f002 0210 	and.w	r2, r2, #16
 80094ca:	21f8      	movs	r1, #248	; 0xf8
 80094cc:	20c8      	movs	r0, #200	; 0xc8
 80094ce:	f002 fb48 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type&Source_D75, 0x01);
 80094d2:	7822      	ldrb	r2, [r4, #0]
 80094d4:	2301      	movs	r3, #1
 80094d6:	f002 0220 	and.w	r2, r2, #32
 80094da:	f240 111b 	movw	r1, #283	; 0x11b
 80094de:	20c8      	movs	r0, #200	; 0xc8
 80094e0:	f002 fb3f 	bl	800bb62 <GUI_RadioBox>
 80094e4:	f7fe badb 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 80094e8:	cccccccd 	.word	0xcccccccd
 80094ec:	408508cc 	.word	0x408508cc
 80094f0:	00000000 	.word	0x00000000
 80094f4:	40658800 	.word	0x40658800
 80094f8:	99999999 	.word	0x99999999
 80094fc:	4073b599 	.word	0x4073b599
 8009500:	00000000 	.word	0x00000000
 8009504:	408c9200 	.word	0x408c9200
 8009508:	66666666 	.word	0x66666666
 800950c:	40908566 	.word	0x40908566
 8009510:	33333333 	.word	0x33333333
 8009514:	4071e333 	.word	0x4071e333
 8009518:	cccccccd 	.word	0xcccccccd
 800951c:	407ad4cc 	.word	0x407ad4cc
 8009520:	33333333 	.word	0x33333333
 8009524:	4077af33 	.word	0x4077af33
 8009528:	66666666 	.word	0x66666666
 800952c:	40805066 	.word	0x40805066
 8009530:	40809000 	.word	0x40809000
 8009534:	200002be 	.word	0x200002be
 8009538:	20084b91 	.word	0x20084b91
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=178*TS_Callib & Touch_y <=(178+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_C
 800953c:	a3be      	add	r3, pc, #760	; (adr r3, 8009838 <GUI_Touch_Processing+0x1eb8>)
 800953e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009542:	4630      	mov	r0, r6
 8009544:	4639      	mov	r1, r7
 8009546:	f04f 0a01 	mov.w	sl, #1
 800954a:	f7f7 fae7 	bl	8000b1c <__aeabi_dcmpge>
 800954e:	b900      	cbnz	r0, 8009552 <GUI_Touch_Processing+0x1bd2>
 8009550:	4682      	mov	sl, r0
 8009552:	ea14 0f0a 	tst.w	r4, sl
 8009556:	d049      	beq.n	80095ec <GUI_Touch_Processing+0x1c6c>
 8009558:	a3b9      	add	r3, pc, #740	; (adr r3, 8009840 <GUI_Touch_Processing+0x1ec0>)
 800955a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800955e:	4630      	mov	r0, r6
 8009560:	4639      	mov	r1, r7
 8009562:	f04f 0a01 	mov.w	sl, #1
 8009566:	f7f7 facf 	bl	8000b08 <__aeabi_dcmple>
 800956a:	b900      	cbnz	r0, 800956e <GUI_Touch_Processing+0x1bee>
 800956c:	4682      	mov	sl, r0
 800956e:	f01a 0fff 	tst.w	sl, #255	; 0xff
 8009572:	d03b      	beq.n	80095ec <GUI_Touch_Processing+0x1c6c>
 8009574:	4bae      	ldr	r3, [pc, #696]	; (8009830 <GUI_Touch_Processing+0x1eb0>)
 8009576:	881b      	ldrh	r3, [r3, #0]
 8009578:	0619      	lsls	r1, r3, #24
 800957a:	d537      	bpl.n	80095ec <GUI_Touch_Processing+0x1c6c>
					if(!(Source_Type&Source_C))
 800957c:	4cad      	ldr	r4, [pc, #692]	; (8009834 <GUI_Touch_Processing+0x1eb4>)
 800957e:	7822      	ldrb	r2, [r4, #0]
 8009580:	f012 0204 	ands.w	r2, r2, #4
 8009584:	f47e aa8b 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009588:	2301      	movs	r3, #1
 800958a:	216c      	movs	r1, #108	; 0x6c
 800958c:	20c8      	movs	r0, #200	; 0xc8
						Source_Type = 0;
 800958e:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009590:	f002 fae7 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type&Source_D65, 0x01);
 8009594:	7822      	ldrb	r2, [r4, #0]
 8009596:	2301      	movs	r3, #1
 8009598:	f002 0202 	and.w	r2, r2, #2
 800959c:	218f      	movs	r1, #143	; 0x8f
 800959e:	20c8      	movs	r0, #200	; 0xc8
 80095a0:	f002 fadf 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type|=Source_C, 0x01);
 80095a4:	7822      	ldrb	r2, [r4, #0]
 80095a6:	2301      	movs	r3, #1
 80095a8:	f042 0204 	orr.w	r2, r2, #4
 80095ac:	21b2      	movs	r1, #178	; 0xb2
 80095ae:	20c8      	movs	r0, #200	; 0xc8
 80095b0:	7022      	strb	r2, [r4, #0]
 80095b2:	f002 fad6 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type&Source_D50, 0x01);
 80095b6:	7822      	ldrb	r2, [r4, #0]
 80095b8:	2301      	movs	r3, #1
 80095ba:	f002 0208 	and.w	r2, r2, #8
 80095be:	21d5      	movs	r1, #213	; 0xd5
 80095c0:	20c8      	movs	r0, #200	; 0xc8
 80095c2:	f002 face 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type&Source_D55, 0x01);
 80095c6:	7822      	ldrb	r2, [r4, #0]
 80095c8:	2301      	movs	r3, #1
 80095ca:	f002 0210 	and.w	r2, r2, #16
 80095ce:	21f8      	movs	r1, #248	; 0xf8
 80095d0:	20c8      	movs	r0, #200	; 0xc8
 80095d2:	f002 fac6 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type&Source_D75, 0x01);
 80095d6:	7822      	ldrb	r2, [r4, #0]
 80095d8:	2301      	movs	r3, #1
 80095da:	f002 0220 	and.w	r2, r2, #32
 80095de:	f240 111b 	movw	r1, #283	; 0x11b
 80095e2:	20c8      	movs	r0, #200	; 0xc8
 80095e4:	f002 fabd 	bl	800bb62 <GUI_RadioBox>
 80095e8:	f7fe ba59 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=213*TS_Callib & Touch_y <=(213+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_D50
 80095ec:	a384      	add	r3, pc, #528	; (adr r3, 8009800 <GUI_Touch_Processing+0x1e80>)
 80095ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095f2:	4630      	mov	r0, r6
 80095f4:	4639      	mov	r1, r7
 80095f6:	f04f 0a01 	mov.w	sl, #1
 80095fa:	f7f7 fa8f 	bl	8000b1c <__aeabi_dcmpge>
 80095fe:	b900      	cbnz	r0, 8009602 <GUI_Touch_Processing+0x1c82>
 8009600:	4682      	mov	sl, r0
 8009602:	ea14 0f0a 	tst.w	r4, sl
 8009606:	d049      	beq.n	800969c <GUI_Touch_Processing+0x1d1c>
 8009608:	a37f      	add	r3, pc, #508	; (adr r3, 8009808 <GUI_Touch_Processing+0x1e88>)
 800960a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800960e:	4630      	mov	r0, r6
 8009610:	4639      	mov	r1, r7
 8009612:	f04f 0a01 	mov.w	sl, #1
 8009616:	f7f7 fa77 	bl	8000b08 <__aeabi_dcmple>
 800961a:	b900      	cbnz	r0, 800961e <GUI_Touch_Processing+0x1c9e>
 800961c:	4682      	mov	sl, r0
 800961e:	f01a 0fff 	tst.w	sl, #255	; 0xff
 8009622:	d03b      	beq.n	800969c <GUI_Touch_Processing+0x1d1c>
 8009624:	4b82      	ldr	r3, [pc, #520]	; (8009830 <GUI_Touch_Processing+0x1eb0>)
 8009626:	881b      	ldrh	r3, [r3, #0]
 8009628:	061a      	lsls	r2, r3, #24
 800962a:	d537      	bpl.n	800969c <GUI_Touch_Processing+0x1d1c>
					if(!(Source_Type&Source_D50))
 800962c:	4c81      	ldr	r4, [pc, #516]	; (8009834 <GUI_Touch_Processing+0x1eb4>)
 800962e:	7822      	ldrb	r2, [r4, #0]
 8009630:	f012 0208 	ands.w	r2, r2, #8
 8009634:	f47e aa33 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009638:	2301      	movs	r3, #1
 800963a:	216c      	movs	r1, #108	; 0x6c
 800963c:	20c8      	movs	r0, #200	; 0xc8
						Source_Type = 0;
 800963e:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009640:	f002 fa8f 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type&Source_D65, 0x01);
 8009644:	7822      	ldrb	r2, [r4, #0]
 8009646:	2301      	movs	r3, #1
 8009648:	f002 0202 	and.w	r2, r2, #2
 800964c:	218f      	movs	r1, #143	; 0x8f
 800964e:	20c8      	movs	r0, #200	; 0xc8
 8009650:	f002 fa87 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type&Source_C, 0x01);
 8009654:	7822      	ldrb	r2, [r4, #0]
 8009656:	2301      	movs	r3, #1
 8009658:	f002 0204 	and.w	r2, r2, #4
 800965c:	21b2      	movs	r1, #178	; 0xb2
 800965e:	20c8      	movs	r0, #200	; 0xc8
 8009660:	f002 fa7f 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type|=Source_D50, 0x01);
 8009664:	7822      	ldrb	r2, [r4, #0]
 8009666:	2301      	movs	r3, #1
 8009668:	f042 0208 	orr.w	r2, r2, #8
 800966c:	21d5      	movs	r1, #213	; 0xd5
 800966e:	20c8      	movs	r0, #200	; 0xc8
 8009670:	7022      	strb	r2, [r4, #0]
 8009672:	f002 fa76 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type&Source_D55, 0x01);
 8009676:	7822      	ldrb	r2, [r4, #0]
 8009678:	2301      	movs	r3, #1
 800967a:	f002 0210 	and.w	r2, r2, #16
 800967e:	21f8      	movs	r1, #248	; 0xf8
 8009680:	20c8      	movs	r0, #200	; 0xc8
 8009682:	f002 fa6e 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type&Source_D75, 0x01);
 8009686:	7822      	ldrb	r2, [r4, #0]
 8009688:	2301      	movs	r3, #1
 800968a:	f002 0220 	and.w	r2, r2, #32
 800968e:	f240 111b 	movw	r1, #283	; 0x11b
 8009692:	20c8      	movs	r0, #200	; 0xc8
 8009694:	f002 fa65 	bl	800bb62 <GUI_RadioBox>
 8009698:	f7fe ba01 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=248*TS_Callib & Touch_y <=(248+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_D55
 800969c:	a35c      	add	r3, pc, #368	; (adr r3, 8009810 <GUI_Touch_Processing+0x1e90>)
 800969e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096a2:	4630      	mov	r0, r6
 80096a4:	4639      	mov	r1, r7
 80096a6:	f04f 0a01 	mov.w	sl, #1
 80096aa:	f7f7 fa37 	bl	8000b1c <__aeabi_dcmpge>
 80096ae:	b900      	cbnz	r0, 80096b2 <GUI_Touch_Processing+0x1d32>
 80096b0:	4682      	mov	sl, r0
 80096b2:	ea14 0f0a 	tst.w	r4, sl
 80096b6:	d049      	beq.n	800974c <GUI_Touch_Processing+0x1dcc>
 80096b8:	a357      	add	r3, pc, #348	; (adr r3, 8009818 <GUI_Touch_Processing+0x1e98>)
 80096ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80096be:	4630      	mov	r0, r6
 80096c0:	4639      	mov	r1, r7
 80096c2:	f04f 0a01 	mov.w	sl, #1
 80096c6:	f7f7 fa1f 	bl	8000b08 <__aeabi_dcmple>
 80096ca:	b900      	cbnz	r0, 80096ce <GUI_Touch_Processing+0x1d4e>
 80096cc:	4682      	mov	sl, r0
 80096ce:	f01a 0fff 	tst.w	sl, #255	; 0xff
 80096d2:	d03b      	beq.n	800974c <GUI_Touch_Processing+0x1dcc>
 80096d4:	4b56      	ldr	r3, [pc, #344]	; (8009830 <GUI_Touch_Processing+0x1eb0>)
 80096d6:	881b      	ldrh	r3, [r3, #0]
 80096d8:	061b      	lsls	r3, r3, #24
 80096da:	d537      	bpl.n	800974c <GUI_Touch_Processing+0x1dcc>
					if(!(Source_Type&Source_D55))
 80096dc:	4c55      	ldr	r4, [pc, #340]	; (8009834 <GUI_Touch_Processing+0x1eb4>)
 80096de:	7822      	ldrb	r2, [r4, #0]
 80096e0:	f012 0210 	ands.w	r2, r2, #16
 80096e4:	f47e a9db 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 80096e8:	2301      	movs	r3, #1
 80096ea:	216c      	movs	r1, #108	; 0x6c
 80096ec:	20c8      	movs	r0, #200	; 0xc8
						Source_Type = 0;
 80096ee:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 80096f0:	f002 fa37 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type&Source_D65, 0x01);
 80096f4:	7822      	ldrb	r2, [r4, #0]
 80096f6:	2301      	movs	r3, #1
 80096f8:	f002 0202 	and.w	r2, r2, #2
 80096fc:	218f      	movs	r1, #143	; 0x8f
 80096fe:	20c8      	movs	r0, #200	; 0xc8
 8009700:	f002 fa2f 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type&Source_C, 0x01);
 8009704:	7822      	ldrb	r2, [r4, #0]
 8009706:	2301      	movs	r3, #1
 8009708:	f002 0204 	and.w	r2, r2, #4
 800970c:	21b2      	movs	r1, #178	; 0xb2
 800970e:	20c8      	movs	r0, #200	; 0xc8
 8009710:	f002 fa27 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type&Source_D50, 0x01);
 8009714:	7822      	ldrb	r2, [r4, #0]
 8009716:	2301      	movs	r3, #1
 8009718:	f002 0208 	and.w	r2, r2, #8
 800971c:	21d5      	movs	r1, #213	; 0xd5
 800971e:	20c8      	movs	r0, #200	; 0xc8
 8009720:	f002 fa1f 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type |= Source_D55, 0x01);
 8009724:	7822      	ldrb	r2, [r4, #0]
 8009726:	2301      	movs	r3, #1
 8009728:	f042 0210 	orr.w	r2, r2, #16
 800972c:	21f8      	movs	r1, #248	; 0xf8
 800972e:	20c8      	movs	r0, #200	; 0xc8
 8009730:	7022      	strb	r2, [r4, #0]
 8009732:	f002 fa16 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type&Source_D75, 0x01);
 8009736:	7822      	ldrb	r2, [r4, #0]
 8009738:	2301      	movs	r3, #1
 800973a:	f002 0220 	and.w	r2, r2, #32
 800973e:	f240 111b 	movw	r1, #283	; 0x11b
 8009742:	20c8      	movs	r0, #200	; 0xc8
 8009744:	f002 fa0d 	bl	800bb62 <GUI_RadioBox>
 8009748:	f7fe b9a9 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=283*TS_Callib & Touch_y <=(283+54)*TS_Callib && (Measure_Field&CIE_Lab)) //Source_D75
 800974c:	a334      	add	r3, pc, #208	; (adr r3, 8009820 <GUI_Touch_Processing+0x1ea0>)
 800974e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009752:	4630      	mov	r0, r6
 8009754:	4639      	mov	r1, r7
 8009756:	f04f 0a01 	mov.w	sl, #1
 800975a:	f7f7 f9df 	bl	8000b1c <__aeabi_dcmpge>
 800975e:	b900      	cbnz	r0, 8009762 <GUI_Touch_Processing+0x1de2>
 8009760:	4682      	mov	sl, r0
 8009762:	ea14 0f0a 	tst.w	r4, sl
 8009766:	d06f      	beq.n	8009848 <GUI_Touch_Processing+0x1ec8>
 8009768:	a32f      	add	r3, pc, #188	; (adr r3, 8009828 <GUI_Touch_Processing+0x1ea8>)
 800976a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800976e:	4630      	mov	r0, r6
 8009770:	4639      	mov	r1, r7
 8009772:	f04f 0401 	mov.w	r4, #1
 8009776:	f7f7 f9c7 	bl	8000b08 <__aeabi_dcmple>
 800977a:	b900      	cbnz	r0, 800977e <GUI_Touch_Processing+0x1dfe>
 800977c:	4604      	mov	r4, r0
 800977e:	f014 0fff 	tst.w	r4, #255	; 0xff
 8009782:	d061      	beq.n	8009848 <GUI_Touch_Processing+0x1ec8>
 8009784:	4b2a      	ldr	r3, [pc, #168]	; (8009830 <GUI_Touch_Processing+0x1eb0>)
 8009786:	881b      	ldrh	r3, [r3, #0]
 8009788:	061f      	lsls	r7, r3, #24
 800978a:	d55d      	bpl.n	8009848 <GUI_Touch_Processing+0x1ec8>
					if(!(Source_Type&Source_D75))
 800978c:	4c29      	ldr	r4, [pc, #164]	; (8009834 <GUI_Touch_Processing+0x1eb4>)
 800978e:	7822      	ldrb	r2, [r4, #0]
 8009790:	f012 0220 	ands.w	r2, r2, #32
 8009794:	f47e a983 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 8009798:	2301      	movs	r3, #1
 800979a:	216c      	movs	r1, #108	; 0x6c
 800979c:	20c8      	movs	r0, #200	; 0xc8
						Source_Type = 0;
 800979e:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 108, Source_Type&Source_A, 0x01);
 80097a0:	f002 f9df 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 143, Source_Type&Source_D65, 0x01);
 80097a4:	7822      	ldrb	r2, [r4, #0]
 80097a6:	2301      	movs	r3, #1
 80097a8:	f002 0202 	and.w	r2, r2, #2
 80097ac:	218f      	movs	r1, #143	; 0x8f
 80097ae:	20c8      	movs	r0, #200	; 0xc8
 80097b0:	f002 f9d7 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 178, Source_Type&Source_C, 0x01);
 80097b4:	7822      	ldrb	r2, [r4, #0]
 80097b6:	2301      	movs	r3, #1
 80097b8:	f002 0204 	and.w	r2, r2, #4
 80097bc:	21b2      	movs	r1, #178	; 0xb2
 80097be:	20c8      	movs	r0, #200	; 0xc8
 80097c0:	f002 f9cf 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 213, Source_Type&Source_D50, 0x01);
 80097c4:	7822      	ldrb	r2, [r4, #0]
 80097c6:	2301      	movs	r3, #1
 80097c8:	f002 0208 	and.w	r2, r2, #8
 80097cc:	21d5      	movs	r1, #213	; 0xd5
 80097ce:	20c8      	movs	r0, #200	; 0xc8
 80097d0:	f002 f9c7 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 248, Source_Type&Source_D55, 0x01);
 80097d4:	7822      	ldrb	r2, [r4, #0]
 80097d6:	2301      	movs	r3, #1
 80097d8:	f002 0210 	and.w	r2, r2, #16
 80097dc:	21f8      	movs	r1, #248	; 0xf8
 80097de:	20c8      	movs	r0, #200	; 0xc8
 80097e0:	f002 f9bf 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 283, Source_Type|=Source_D75, 0x01);
 80097e4:	7822      	ldrb	r2, [r4, #0]
 80097e6:	2301      	movs	r3, #1
 80097e8:	f042 0220 	orr.w	r2, r2, #32
 80097ec:	f240 111b 	movw	r1, #283	; 0x11b
 80097f0:	20c8      	movs	r0, #200	; 0xc8
 80097f2:	7022      	strb	r2, [r4, #0]
 80097f4:	f002 f9b5 	bl	800bb62 <GUI_RadioBox>
 80097f8:	f7fe b951 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 80097fc:	f3af 8000 	nop.w
 8009800:	99999999 	.word	0x99999999
 8009804:	4081a399 	.word	0x4081a399
 8009808:	66666666 	.word	0x66666666
 800980c:	40861c66 	.word	0x40861c66
 8009810:	99999999 	.word	0x99999999
 8009814:	40848999 	.word	0x40848999
 8009818:	66666666 	.word	0x66666666
 800981c:	40890266 	.word	0x40890266
 8009820:	99999999 	.word	0x99999999
 8009824:	40876f99 	.word	0x40876f99
 8009828:	66666666 	.word	0x66666666
 800982c:	408be866 	.word	0x408be866
 8009830:	200002be 	.word	0x200002be
 8009834:	20084b91 	.word	0x20084b91
 8009838:	33333333 	.word	0x33333333
 800983c:	407d7b33 	.word	0x407d7b33
 8009840:	66666666 	.word	0x66666666
 8009844:	40833666 	.word	0x40833666
 8009848:	9b00      	ldr	r3, [sp, #0]
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800984a:	4640      	mov	r0, r8
 800984c:	401d      	ands	r5, r3
 800984e:	4649      	mov	r1, r9
 8009850:	a39d      	add	r3, pc, #628	; (adr r3, 8009ac8 <GUI_Touch_Processing+0x2148>)
 8009852:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009856:	f04f 0401 	mov.w	r4, #1
 800985a:	f7f7 f95f 	bl	8000b1c <__aeabi_dcmpge>
 800985e:	b900      	cbnz	r0, 8009862 <GUI_Touch_Processing+0x1ee2>
 8009860:	4604      	mov	r4, r0
 8009862:	a3a9      	add	r3, pc, #676	; (adr r3, 8009b08 <GUI_Touch_Processing+0x2188>)
 8009864:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009868:	4640      	mov	r0, r8
 800986a:	4649      	mov	r1, r9
 800986c:	f04f 0601 	mov.w	r6, #1
 8009870:	f7f7 f94a 	bl	8000b08 <__aeabi_dcmple>
 8009874:	b900      	cbnz	r0, 8009878 <GUI_Touch_Processing+0x1ef8>
 8009876:	4606      	mov	r6, r0
 8009878:	4034      	ands	r4, r6
 800987a:	07e6      	lsls	r6, r4, #31
 800987c:	d502      	bpl.n	8009884 <GUI_Touch_Processing+0x1f04>
 800987e:	2d00      	cmp	r5, #0
 8009880:	f47f a80e 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 8009884:	a3a2      	add	r3, pc, #648	; (adr r3, 8009b10 <GUI_Touch_Processing+0x2190>)
 8009886:	e9d3 2300 	ldrd	r2, r3, [r3]
 800988a:	4640      	mov	r0, r8
 800988c:	4649      	mov	r1, r9
 800988e:	f04f 0401 	mov.w	r4, #1
 8009892:	f7f7 f943 	bl	8000b1c <__aeabi_dcmpge>
 8009896:	b900      	cbnz	r0, 800989a <GUI_Touch_Processing+0x1f1a>
 8009898:	4604      	mov	r4, r0
 800989a:	a39f      	add	r3, pc, #636	; (adr r3, 8009b18 <GUI_Touch_Processing+0x2198>)
 800989c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098a0:	4640      	mov	r0, r8
 80098a2:	4649      	mov	r1, r9
 80098a4:	f04f 0601 	mov.w	r6, #1
 80098a8:	f7f7 f92e 	bl	8000b08 <__aeabi_dcmple>
 80098ac:	b900      	cbnz	r0, 80098b0 <GUI_Touch_Processing+0x1f30>
 80098ae:	4606      	mov	r6, r0
 80098b0:	4034      	ands	r4, r6
 80098b2:	07e4      	lsls	r4, r4, #31
 80098b4:	f57f a9f6 	bpl.w	8008ca4 <GUI_Touch_Processing+0x1324>
 80098b8:	2d00      	cmp	r5, #0
 80098ba:	f43f a9f3 	beq.w	8008ca4 <GUI_Touch_Processing+0x1324>
					GUI_screen_state = Prev_Inf_Screen;
 80098be:	4b98      	ldr	r3, [pc, #608]	; (8009b20 <GUI_Touch_Processing+0x21a0>)
 80098c0:	781a      	ldrb	r2, [r3, #0]
 80098c2:	4b98      	ldr	r3, [pc, #608]	; (8009b24 <GUI_Touch_Processing+0x21a4>)
					switch (Prev_Inf_Screen){
 80098c4:	1e51      	subs	r1, r2, #1
 80098c6:	2905      	cmp	r1, #5
 80098c8:	d804      	bhi.n	80098d4 <GUI_Touch_Processing+0x1f54>
 80098ca:	e8df f001 	tbb	[pc, r1]
 80098ce:	0306      	.short	0x0306
 80098d0:	0e120a03 	.word	0x0e120a03
					GUI_screen_state = Prev_Inf_Screen;
 80098d4:	701a      	strb	r2, [r3, #0]
 80098d6:	f7fe b8e2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 80098da:	2201      	movs	r2, #1
 80098dc:	701a      	strb	r2, [r3, #0]
 80098de:	f7fe b8de 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 80098e2:	2204      	movs	r2, #4
 80098e4:	701a      	strb	r2, [r3, #0]
 80098e6:	f7fe b8da 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 80098ea:	2206      	movs	r2, #6
 80098ec:	701a      	strb	r2, [r3, #0]
 80098ee:	f7fe b8d6 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 80098f2:	2205      	movs	r2, #5
 80098f4:	701a      	strb	r2, [r3, #0]
 80098f6:	f7fe b8d2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 80098fa:	4b8b      	ldr	r3, [pc, #556]	; (8009b28 <GUI_Touch_Processing+0x21a8>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 80098fc:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 8009900:	220b      	movs	r2, #11
 8009902:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Next
 8009904:	f7f6 fe1e 	bl	8000544 <__aeabi_i2d>
 8009908:	4606      	mov	r6, r0
 800990a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800990e:	460f      	mov	r7, r1
 8009910:	f7f6 fe18 	bl	8000544 <__aeabi_i2d>
 8009914:	a368      	add	r3, pc, #416	; (adr r3, 8009ab8 <GUI_Touch_Processing+0x2138>)
 8009916:	e9d3 2300 	ldrd	r2, r3, [r3]
 800991a:	e9cd 0100 	strd	r0, r1, [sp]
 800991e:	f04f 0901 	mov.w	r9, #1
 8009922:	f7f7 f8fb 	bl	8000b1c <__aeabi_dcmpge>
 8009926:	b900      	cbnz	r0, 800992a <GUI_Touch_Processing+0x1faa>
 8009928:	4681      	mov	r9, r0
 800992a:	2200      	movs	r2, #0
 800992c:	4b7f      	ldr	r3, [pc, #508]	; (8009b2c <GUI_Touch_Processing+0x21ac>)
 800992e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009932:	fa5f f989 	uxtb.w	r9, r9
 8009936:	f04f 0501 	mov.w	r5, #1
 800993a:	f7f7 f8e5 	bl	8000b08 <__aeabi_dcmple>
 800993e:	b900      	cbnz	r0, 8009942 <GUI_Touch_Processing+0x1fc2>
 8009940:	4605      	mov	r5, r0
 8009942:	a35f      	add	r3, pc, #380	; (adr r3, 8009ac0 <GUI_Touch_Processing+0x2140>)
 8009944:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009948:	4630      	mov	r0, r6
 800994a:	4639      	mov	r1, r7
 800994c:	b2ed      	uxtb	r5, r5
 800994e:	f04f 0801 	mov.w	r8, #1
 8009952:	f7f7 f8e3 	bl	8000b1c <__aeabi_dcmpge>
 8009956:	b900      	cbnz	r0, 800995a <GUI_Touch_Processing+0x1fda>
 8009958:	4680      	mov	r8, r0
 800995a:	a35b      	add	r3, pc, #364	; (adr r3, 8009ac8 <GUI_Touch_Processing+0x2148>)
 800995c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009960:	4630      	mov	r0, r6
 8009962:	4639      	mov	r1, r7
 8009964:	f04f 0a01 	mov.w	sl, #1
 8009968:	f7f7 f8ce 	bl	8000b08 <__aeabi_dcmple>
 800996c:	b900      	cbnz	r0, 8009970 <GUI_Touch_Processing+0x1ff0>
 800996e:	4682      	mov	sl, r0
 8009970:	ea08 080a 	and.w	r8, r8, sl
 8009974:	ea19 0f08 	tst.w	r9, r8
 8009978:	d004      	beq.n	8009984 <GUI_Touch_Processing+0x2004>
 800997a:	b11d      	cbz	r5, 8009984 <GUI_Touch_Processing+0x2004>
					GUI_screen_state = DataSet1_Screen;
 800997c:	2307      	movs	r3, #7
 800997e:	7023      	strb	r3, [r4, #0]
 8009980:	f7fe b88d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=70*TS_Callib & Touch_y <=(70+54)*TS_Callib) //EbEr
 8009984:	2200      	movs	r2, #0
 8009986:	4b6a      	ldr	r3, [pc, #424]	; (8009b30 <GUI_Touch_Processing+0x21b0>)
 8009988:	4630      	mov	r0, r6
 800998a:	4639      	mov	r1, r7
 800998c:	f04f 0801 	mov.w	r8, #1
 8009990:	f7f7 f8c4 	bl	8000b1c <__aeabi_dcmpge>
 8009994:	b900      	cbnz	r0, 8009998 <GUI_Touch_Processing+0x2018>
 8009996:	4680      	mov	r8, r0
 8009998:	a34d      	add	r3, pc, #308	; (adr r3, 8009ad0 <GUI_Touch_Processing+0x2150>)
 800999a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800999e:	4630      	mov	r0, r6
 80099a0:	4639      	mov	r1, r7
 80099a2:	f04f 0a01 	mov.w	sl, #1
 80099a6:	f7f7 f8af 	bl	8000b08 <__aeabi_dcmple>
 80099aa:	b900      	cbnz	r0, 80099ae <GUI_Touch_Processing+0x202e>
 80099ac:	4682      	mov	sl, r0
 80099ae:	ea08 080a 	and.w	r8, r8, sl
 80099b2:	a349      	add	r3, pc, #292	; (adr r3, 8009ad8 <GUI_Touch_Processing+0x2158>)
 80099b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80099b8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80099bc:	fa5f f888 	uxtb.w	r8, r8
 80099c0:	f04f 0a01 	mov.w	sl, #1
 80099c4:	f7f7 f8aa 	bl	8000b1c <__aeabi_dcmpge>
 80099c8:	b900      	cbnz	r0, 80099cc <GUI_Touch_Processing+0x204c>
 80099ca:	4682      	mov	sl, r0
 80099cc:	a344      	add	r3, pc, #272	; (adr r3, 8009ae0 <GUI_Touch_Processing+0x2160>)
 80099ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 80099d2:	e9dd 0100 	ldrd	r0, r1, [sp]
 80099d6:	f04f 0b01 	mov.w	fp, #1
 80099da:	f7f7 f895 	bl	8000b08 <__aeabi_dcmple>
 80099de:	b900      	cbnz	r0, 80099e2 <GUI_Touch_Processing+0x2062>
 80099e0:	4683      	mov	fp, r0
 80099e2:	ea0a 0a0b 	and.w	sl, sl, fp
 80099e6:	f01a 0f01 	tst.w	sl, #1
 80099ea:	d00f      	beq.n	8009a0c <GUI_Touch_Processing+0x208c>
 80099ec:	f1b8 0f00 	cmp.w	r8, #0
 80099f0:	d00c      	beq.n	8009a0c <GUI_Touch_Processing+0x208c>
					Measure_Field ^= lambda_d;
 80099f2:	4b50      	ldr	r3, [pc, #320]	; (8009b34 <GUI_Touch_Processing+0x21b4>)
 80099f4:	881a      	ldrh	r2, [r3, #0]
 80099f6:	f482 7200 	eor.w	r2, r2, #512	; 0x200
 80099fa:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 70, Measure_Field&lambda_d);
 80099fc:	2146      	movs	r1, #70	; 0x46
 80099fe:	f402 7200 	and.w	r2, r2, #512	; 0x200
 8009a02:	20c8      	movs	r0, #200	; 0xc8
 8009a04:	f002 f86c 	bl	800bae0 <GUI_CheckBox>
 8009a08:	f7fe b849 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=133*TS_Callib & Touch_y <=(133+54)*TS_Callib) //EbEr
 8009a0c:	a336      	add	r3, pc, #216	; (adr r3, 8009ae8 <GUI_Touch_Processing+0x2168>)
 8009a0e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009a12:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009a16:	f04f 0a01 	mov.w	sl, #1
 8009a1a:	f7f7 f87f 	bl	8000b1c <__aeabi_dcmpge>
 8009a1e:	b900      	cbnz	r0, 8009a22 <GUI_Touch_Processing+0x20a2>
 8009a20:	4682      	mov	sl, r0
 8009a22:	a333      	add	r3, pc, #204	; (adr r3, 8009af0 <GUI_Touch_Processing+0x2170>)
 8009a24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009a28:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009a2c:	f04f 0b01 	mov.w	fp, #1
 8009a30:	f7f7 f86a 	bl	8000b08 <__aeabi_dcmple>
 8009a34:	b900      	cbnz	r0, 8009a38 <GUI_Touch_Processing+0x20b8>
 8009a36:	4683      	mov	fp, r0
 8009a38:	ea0a 0a0b 	and.w	sl, sl, fp
 8009a3c:	f01a 0f01 	tst.w	sl, #1
 8009a40:	d00f      	beq.n	8009a62 <GUI_Touch_Processing+0x20e2>
 8009a42:	f1b8 0f00 	cmp.w	r8, #0
 8009a46:	d00c      	beq.n	8009a62 <GUI_Touch_Processing+0x20e2>
					Measure_Field ^= lambda_c;
 8009a48:	4b3a      	ldr	r3, [pc, #232]	; (8009b34 <GUI_Touch_Processing+0x21b4>)
 8009a4a:	881a      	ldrh	r2, [r3, #0]
 8009a4c:	f482 6280 	eor.w	r2, r2, #1024	; 0x400
 8009a50:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 133, Measure_Field&lambda_c);
 8009a52:	2185      	movs	r1, #133	; 0x85
 8009a54:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8009a58:	20c8      	movs	r0, #200	; 0xc8
 8009a5a:	f002 f841 	bl	800bae0 <GUI_CheckBox>
 8009a5e:	f7fe b81e 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=198*TS_Callib & Touch_y <=(198+54)*TS_Callib) //EbEr
 8009a62:	a325      	add	r3, pc, #148	; (adr r3, 8009af8 <GUI_Touch_Processing+0x2178>)
 8009a64:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009a68:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009a6c:	f04f 0a01 	mov.w	sl, #1
 8009a70:	f7f7 f854 	bl	8000b1c <__aeabi_dcmpge>
 8009a74:	b900      	cbnz	r0, 8009a78 <GUI_Touch_Processing+0x20f8>
 8009a76:	4682      	mov	sl, r0
 8009a78:	a321      	add	r3, pc, #132	; (adr r3, 8009b00 <GUI_Touch_Processing+0x2180>)
 8009a7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009a7e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009a82:	f04f 0b01 	mov.w	fp, #1
 8009a86:	f7f7 f83f 	bl	8000b08 <__aeabi_dcmple>
 8009a8a:	b900      	cbnz	r0, 8009a8e <GUI_Touch_Processing+0x210e>
 8009a8c:	4683      	mov	fp, r0
 8009a8e:	ea0a 0a0b 	and.w	sl, sl, fp
 8009a92:	f01a 0f01 	tst.w	sl, #1
 8009a96:	d04f      	beq.n	8009b38 <GUI_Touch_Processing+0x21b8>
 8009a98:	f1b8 0f00 	cmp.w	r8, #0
 8009a9c:	d04c      	beq.n	8009b38 <GUI_Touch_Processing+0x21b8>
					Measure_Field ^= SP_measure;
 8009a9e:	4b25      	ldr	r3, [pc, #148]	; (8009b34 <GUI_Touch_Processing+0x21b4>)
 8009aa0:	881a      	ldrh	r2, [r3, #0]
 8009aa2:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8009aa6:	801a      	strh	r2, [r3, #0]
					GUI_CheckBox(200, 198, Measure_Field&SP_measure);
 8009aa8:	21c6      	movs	r1, #198	; 0xc6
 8009aaa:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8009aae:	20c8      	movs	r0, #200	; 0xc8
 8009ab0:	f002 f816 	bl	800bae0 <GUI_CheckBox>
 8009ab4:	f7fd bff3 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8009ab8:	99999999 	.word	0x99999999
 8009abc:	4091a399 	.word	0x4091a399
 8009ac0:	33333333 	.word	0x33333333
 8009ac4:	407aff33 	.word	0x407aff33
 8009ac8:	66666666 	.word	0x66666666
 8009acc:	4081f866 	.word	0x4081f866
 8009ad0:	cccccccd 	.word	0xcccccccd
 8009ad4:	408508cc 	.word	0x408508cc
 8009ad8:	00000000 	.word	0x00000000
 8009adc:	40673000 	.word	0x40673000
 8009ae0:	99999999 	.word	0x99999999
 8009ae4:	40748999 	.word	0x40748999
 8009ae8:	33333333 	.word	0x33333333
 8009aec:	40760733 	.word	0x40760733
 8009af0:	cccccccd 	.word	0xcccccccd
 8009af4:	407ef8cc 	.word	0x407ef8cc
 8009af8:	99999999 	.word	0x99999999
 8009afc:	40806599 	.word	0x40806599
 8009b00:	66666666 	.word	0x66666666
 8009b04:	4084de66 	.word	0x4084de66
 8009b08:	33333333 	.word	0x33333333
 8009b0c:	40867133 	.word	0x40867133
 8009b10:	33333333 	.word	0x33333333
 8009b14:	40053333 	.word	0x40053333
 8009b18:	00000000 	.word	0x00000000
 8009b1c:	40623800 	.word	0x40623800
 8009b20:	20084b8d 	.word	0x20084b8d
 8009b24:	200002b9 	.word	0x200002b9
 8009b28:	20000176 	.word	0x20000176
 8009b2c:	4093e000 	.word	0x4093e000
 8009b30:	40809000 	.word	0x40809000
 8009b34:	200002be 	.word	0x200002be
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 8009b38:	a3b9      	add	r3, pc, #740	; (adr r3, 8009e20 <GUI_Touch_Processing+0x24a0>)
 8009b3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b3e:	4630      	mov	r0, r6
 8009b40:	4639      	mov	r1, r7
 8009b42:	ea09 0505 	and.w	r5, r9, r5
 8009b46:	f04f 0801 	mov.w	r8, #1
 8009b4a:	f7f6 ffe7 	bl	8000b1c <__aeabi_dcmpge>
 8009b4e:	b900      	cbnz	r0, 8009b52 <GUI_Touch_Processing+0x21d2>
 8009b50:	4680      	mov	r8, r0
 8009b52:	a3c7      	add	r3, pc, #796	; (adr r3, 8009e70 <GUI_Touch_Processing+0x24f0>)
 8009b54:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b58:	4630      	mov	r0, r6
 8009b5a:	4639      	mov	r1, r7
 8009b5c:	f04f 0901 	mov.w	r9, #1
 8009b60:	f7f6 ffd2 	bl	8000b08 <__aeabi_dcmple>
 8009b64:	b900      	cbnz	r0, 8009b68 <GUI_Touch_Processing+0x21e8>
 8009b66:	4681      	mov	r9, r0
 8009b68:	ea08 0809 	and.w	r8, r8, r9
 8009b6c:	f018 0f01 	tst.w	r8, #1
 8009b70:	d002      	beq.n	8009b78 <GUI_Touch_Processing+0x21f8>
 8009b72:	2d00      	cmp	r5, #0
 8009b74:	f47e ae94 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 8009b78:	a3cd      	add	r3, pc, #820	; (adr r3, 8009eb0 <GUI_Touch_Processing+0x2530>)
 8009b7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b7e:	4630      	mov	r0, r6
 8009b80:	4639      	mov	r1, r7
 8009b82:	f04f 0801 	mov.w	r8, #1
 8009b86:	f7f6 ffc9 	bl	8000b1c <__aeabi_dcmpge>
 8009b8a:	b900      	cbnz	r0, 8009b8e <GUI_Touch_Processing+0x220e>
 8009b8c:	4680      	mov	r8, r0
 8009b8e:	a3ca      	add	r3, pc, #808	; (adr r3, 8009eb8 <GUI_Touch_Processing+0x2538>)
 8009b90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b94:	4630      	mov	r0, r6
 8009b96:	4639      	mov	r1, r7
 8009b98:	f04f 0901 	mov.w	r9, #1
 8009b9c:	f7f6 ffb4 	bl	8000b08 <__aeabi_dcmple>
 8009ba0:	b900      	cbnz	r0, 8009ba4 <GUI_Touch_Processing+0x2224>
 8009ba2:	4681      	mov	r9, r0
 8009ba4:	ea08 0809 	and.w	r8, r8, r9
 8009ba8:	f018 0f01 	tst.w	r8, #1
 8009bac:	f000 874a 	beq.w	800aa44 <GUI_Touch_Processing+0x30c4>
 8009bb0:	2d00      	cmp	r5, #0
 8009bb2:	f000 8747 	beq.w	800aa44 <GUI_Touch_Processing+0x30c4>
					GUI_screen_state = Prev_Inf_Screen;
 8009bb6:	4bb0      	ldr	r3, [pc, #704]	; (8009e78 <GUI_Touch_Processing+0x24f8>)
 8009bb8:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 8009bba:	1e5a      	subs	r2, r3, #1
 8009bbc:	2a05      	cmp	r2, #5
 8009bbe:	d804      	bhi.n	8009bca <GUI_Touch_Processing+0x224a>
 8009bc0:	e8df f002 	tbb	[pc, r2]
 8009bc4:	0a030306 	.word	0x0a030306
 8009bc8:	0e12      	.short	0x0e12
					GUI_screen_state = Prev_Inf_Screen;
 8009bca:	7023      	strb	r3, [r4, #0]
 8009bcc:	f7fd bf67 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 8009bd0:	2301      	movs	r3, #1
 8009bd2:	7023      	strb	r3, [r4, #0]
 8009bd4:	f7fd bf63 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 8009bd8:	2304      	movs	r3, #4
 8009bda:	7023      	strb	r3, [r4, #0]
 8009bdc:	f7fd bf5f 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 8009be0:	2306      	movs	r3, #6
 8009be2:	7023      	strb	r3, [r4, #0]
 8009be4:	f7fd bf5b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 8009be8:	2305      	movs	r3, #5
 8009bea:	7023      	strb	r3, [r4, #0]
 8009bec:	f7fd bf57 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 8009bf0:	4ba2      	ldr	r3, [pc, #648]	; (8009e7c <GUI_Touch_Processing+0x24fc>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 8009bf2:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 8009bf6:	220c      	movs	r2, #12
 8009bf8:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 8009bfa:	f7f6 fca3 	bl	8000544 <__aeabi_i2d>
 8009bfe:	4606      	mov	r6, r0
 8009c00:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8009c04:	460f      	mov	r7, r1
 8009c06:	f7f6 fc9d 	bl	8000544 <__aeabi_i2d>
 8009c0a:	a381      	add	r3, pc, #516	; (adr r3, 8009e10 <GUI_Touch_Processing+0x2490>)
 8009c0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c10:	4680      	mov	r8, r0
 8009c12:	4689      	mov	r9, r1
 8009c14:	f04f 0501 	mov.w	r5, #1
 8009c18:	f7f6 ff80 	bl	8000b1c <__aeabi_dcmpge>
 8009c1c:	b900      	cbnz	r0, 8009c20 <GUI_Touch_Processing+0x22a0>
 8009c1e:	4605      	mov	r5, r0
 8009c20:	b2eb      	uxtb	r3, r5
 8009c22:	9300      	str	r3, [sp, #0]
 8009c24:	2200      	movs	r2, #0
 8009c26:	4b96      	ldr	r3, [pc, #600]	; (8009e80 <GUI_Touch_Processing+0x2500>)
 8009c28:	4640      	mov	r0, r8
 8009c2a:	4649      	mov	r1, r9
 8009c2c:	f04f 0501 	mov.w	r5, #1
 8009c30:	f7f6 ff6a 	bl	8000b08 <__aeabi_dcmple>
 8009c34:	b900      	cbnz	r0, 8009c38 <GUI_Touch_Processing+0x22b8>
 8009c36:	4605      	mov	r5, r0
 8009c38:	b2eb      	uxtb	r3, r5
 8009c3a:	9302      	str	r3, [sp, #8]
 8009c3c:	4630      	mov	r0, r6
 8009c3e:	a376      	add	r3, pc, #472	; (adr r3, 8009e18 <GUI_Touch_Processing+0x2498>)
 8009c40:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c44:	4639      	mov	r1, r7
 8009c46:	f04f 0501 	mov.w	r5, #1
 8009c4a:	f7f6 ff67 	bl	8000b1c <__aeabi_dcmpge>
 8009c4e:	b900      	cbnz	r0, 8009c52 <GUI_Touch_Processing+0x22d2>
 8009c50:	4605      	mov	r5, r0
 8009c52:	a373      	add	r3, pc, #460	; (adr r3, 8009e20 <GUI_Touch_Processing+0x24a0>)
 8009c54:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c58:	4630      	mov	r0, r6
 8009c5a:	4639      	mov	r1, r7
 8009c5c:	f04f 0a01 	mov.w	sl, #1
 8009c60:	f7f6 ff52 	bl	8000b08 <__aeabi_dcmple>
 8009c64:	b900      	cbnz	r0, 8009c68 <GUI_Touch_Processing+0x22e8>
 8009c66:	4682      	mov	sl, r0
 8009c68:	9b00      	ldr	r3, [sp, #0]
 8009c6a:	ea05 050a 	and.w	r5, r5, sl
 8009c6e:	422b      	tst	r3, r5
 8009c70:	d005      	beq.n	8009c7e <GUI_Touch_Processing+0x22fe>
 8009c72:	9b02      	ldr	r3, [sp, #8]
 8009c74:	b11b      	cbz	r3, 8009c7e <GUI_Touch_Processing+0x22fe>
					GUI_screen_state = GraphSet2_Screen;
 8009c76:	230d      	movs	r3, #13
 8009c78:	7023      	strb	r3, [r4, #0]
 8009c7a:	f7fd bf10 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=202*TS_Callib & Touch_y <=(202+54)*TS_Callib) //Mode_EL
 8009c7e:	a36a      	add	r3, pc, #424	; (adr r3, 8009e28 <GUI_Touch_Processing+0x24a8>)
 8009c80:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c84:	4630      	mov	r0, r6
 8009c86:	4639      	mov	r1, r7
 8009c88:	f04f 0501 	mov.w	r5, #1
 8009c8c:	f7f6 ff46 	bl	8000b1c <__aeabi_dcmpge>
 8009c90:	b900      	cbnz	r0, 8009c94 <GUI_Touch_Processing+0x2314>
 8009c92:	4605      	mov	r5, r0
 8009c94:	a366      	add	r3, pc, #408	; (adr r3, 8009e30 <GUI_Touch_Processing+0x24b0>)
 8009c96:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c9a:	4630      	mov	r0, r6
 8009c9c:	4639      	mov	r1, r7
 8009c9e:	f04f 0a01 	mov.w	sl, #1
 8009ca2:	f7f6 ff31 	bl	8000b08 <__aeabi_dcmple>
 8009ca6:	b900      	cbnz	r0, 8009caa <GUI_Touch_Processing+0x232a>
 8009ca8:	4682      	mov	sl, r0
 8009caa:	ea05 050a 	and.w	r5, r5, sl
 8009cae:	a362      	add	r3, pc, #392	; (adr r3, 8009e38 <GUI_Touch_Processing+0x24b8>)
 8009cb0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009cb4:	4640      	mov	r0, r8
 8009cb6:	4649      	mov	r1, r9
 8009cb8:	b2ed      	uxtb	r5, r5
 8009cba:	f04f 0a01 	mov.w	sl, #1
 8009cbe:	f7f6 ff2d 	bl	8000b1c <__aeabi_dcmpge>
 8009cc2:	b900      	cbnz	r0, 8009cc6 <GUI_Touch_Processing+0x2346>
 8009cc4:	4682      	mov	sl, r0
 8009cc6:	a35e      	add	r3, pc, #376	; (adr r3, 8009e40 <GUI_Touch_Processing+0x24c0>)
 8009cc8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ccc:	4640      	mov	r0, r8
 8009cce:	4649      	mov	r1, r9
 8009cd0:	f04f 0b01 	mov.w	fp, #1
 8009cd4:	f7f6 ff18 	bl	8000b08 <__aeabi_dcmple>
 8009cd8:	b900      	cbnz	r0, 8009cdc <GUI_Touch_Processing+0x235c>
 8009cda:	4683      	mov	fp, r0
 8009cdc:	ea0a 0a0b 	and.w	sl, sl, fp
 8009ce0:	f01a 0f01 	tst.w	sl, #1
 8009ce4:	d026      	beq.n	8009d34 <GUI_Touch_Processing+0x23b4>
 8009ce6:	b32d      	cbz	r5, 8009d34 <GUI_Touch_Processing+0x23b4>
					Mode_EL = !Mode_EL;
 8009ce8:	4c66      	ldr	r4, [pc, #408]	; (8009e84 <GUI_Touch_Processing+0x2504>)
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 8009cea:	4b67      	ldr	r3, [pc, #412]	; (8009e88 <GUI_Touch_Processing+0x2508>)
					Mode_EL = !Mode_EL;
 8009cec:	7822      	ldrb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 8009cee:	4867      	ldr	r0, [pc, #412]	; (8009e8c <GUI_Touch_Processing+0x250c>)
					Mode_EL = !Mode_EL;
 8009cf0:	2a00      	cmp	r2, #0
 8009cf2:	bf0c      	ite	eq
 8009cf4:	2201      	moveq	r2, #1
 8009cf6:	2200      	movne	r2, #0
 8009cf8:	7022      	strb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 8009cfa:	bf18      	it	ne
 8009cfc:	4618      	movne	r0, r3
 8009cfe:	4a64      	ldr	r2, [pc, #400]	; (8009e90 <GUI_Touch_Processing+0x2510>)
 8009d00:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009d04:	f7fc fabc 	bl	8006280 <Calibration_Load_Pack>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 8009d08:	7822      	ldrb	r2, [r4, #0]
 8009d0a:	4b62      	ldr	r3, [pc, #392]	; (8009e94 <GUI_Touch_Processing+0x2514>)
 8009d0c:	b982      	cbnz	r2, 8009d30 <GUI_Touch_Processing+0x23b0>
 8009d0e:	4a62      	ldr	r2, [pc, #392]	; (8009e98 <GUI_Touch_Processing+0x2518>)
 8009d10:	edd2 0a00 	vldr	s1, [r2]
 8009d14:	ed93 0a00 	vldr	s0, [r3]
 8009d18:	f006 fba2 	bl	8010460 <Rabs_calc_Factor2_Settings_change>
 8009d1c:	4b5f      	ldr	r3, [pc, #380]	; (8009e9c <GUI_Touch_Processing+0x251c>)
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 8009d1e:	7822      	ldrb	r2, [r4, #0]
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 8009d20:	ed83 0a00 	vstr	s0, [r3]
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 8009d24:	21ca      	movs	r1, #202	; 0xca
 8009d26:	20b6      	movs	r0, #182	; 0xb6
 8009d28:	f001 ffa4 	bl	800bc74 <GUI_Switch_ButtonActive>
 8009d2c:	f7fd beb7 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 8009d30:	4a5b      	ldr	r2, [pc, #364]	; (8009ea0 <GUI_Touch_Processing+0x2520>)
 8009d32:	e7ed      	b.n	8009d10 <GUI_Touch_Processing+0x2390>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=268*TS_Callib & Touch_y <=(268+54)*TS_Callib) //Bluetooth
 8009d34:	a344      	add	r3, pc, #272	; (adr r3, 8009e48 <GUI_Touch_Processing+0x24c8>)
 8009d36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009d3a:	4640      	mov	r0, r8
 8009d3c:	4649      	mov	r1, r9
 8009d3e:	f04f 0a01 	mov.w	sl, #1
 8009d42:	f7f6 feeb 	bl	8000b1c <__aeabi_dcmpge>
 8009d46:	b900      	cbnz	r0, 8009d4a <GUI_Touch_Processing+0x23ca>
 8009d48:	4682      	mov	sl, r0
 8009d4a:	a341      	add	r3, pc, #260	; (adr r3, 8009e50 <GUI_Touch_Processing+0x24d0>)
 8009d4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009d50:	4640      	mov	r0, r8
 8009d52:	4649      	mov	r1, r9
 8009d54:	f04f 0b01 	mov.w	fp, #1
 8009d58:	f7f6 fed6 	bl	8000b08 <__aeabi_dcmple>
 8009d5c:	b900      	cbnz	r0, 8009d60 <GUI_Touch_Processing+0x23e0>
 8009d5e:	4683      	mov	fp, r0
 8009d60:	ea0a 0a0b 	and.w	sl, sl, fp
 8009d64:	f01a 0f01 	tst.w	sl, #1
 8009d68:	d00f      	beq.n	8009d8a <GUI_Touch_Processing+0x240a>
 8009d6a:	b175      	cbz	r5, 8009d8a <GUI_Touch_Processing+0x240a>
					Bluetooth = !Bluetooth;
 8009d6c:	4b4d      	ldr	r3, [pc, #308]	; (8009ea4 <GUI_Touch_Processing+0x2524>)
 8009d6e:	781a      	ldrb	r2, [r3, #0]
 8009d70:	fab2 f282 	clz	r2, r2
 8009d74:	0952      	lsrs	r2, r2, #5
					GUI_Switch_Button(182, 268, Bluetooth);
 8009d76:	f44f 7186 	mov.w	r1, #268	; 0x10c
 8009d7a:	20b6      	movs	r0, #182	; 0xb6
					Bluetooth = !Bluetooth;
 8009d7c:	701a      	strb	r2, [r3, #0]
					GUI_Switch_Button(182, 268, Bluetooth);
 8009d7e:	f001 ff1f 	bl	800bbc0 <GUI_Switch_Button>
					GUI_Up_Panel();
 8009d82:	f7fc fe3b 	bl	80069fc <GUI_Up_Panel>
 8009d86:	f7fd be8a 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=327*TS_Callib & Touch_y <=(327+54)*TS_Callib) //PPF_Bands
 8009d8a:	2200      	movs	r2, #0
 8009d8c:	4b46      	ldr	r3, [pc, #280]	; (8009ea8 <GUI_Touch_Processing+0x2528>)
 8009d8e:	4630      	mov	r0, r6
 8009d90:	4639      	mov	r1, r7
 8009d92:	f04f 0a01 	mov.w	sl, #1
 8009d96:	f7f6 fec1 	bl	8000b1c <__aeabi_dcmpge>
 8009d9a:	b900      	cbnz	r0, 8009d9e <GUI_Touch_Processing+0x241e>
 8009d9c:	4682      	mov	sl, r0
 8009d9e:	a32e      	add	r3, pc, #184	; (adr r3, 8009e58 <GUI_Touch_Processing+0x24d8>)
 8009da0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009da4:	4630      	mov	r0, r6
 8009da6:	4639      	mov	r1, r7
 8009da8:	f04f 0501 	mov.w	r5, #1
 8009dac:	f7f6 feac 	bl	8000b08 <__aeabi_dcmple>
 8009db0:	b900      	cbnz	r0, 8009db4 <GUI_Touch_Processing+0x2434>
 8009db2:	4605      	mov	r5, r0
 8009db4:	a32a      	add	r3, pc, #168	; (adr r3, 8009e60 <GUI_Touch_Processing+0x24e0>)
 8009db6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009dba:	4640      	mov	r0, r8
 8009dbc:	4649      	mov	r1, r9
 8009dbe:	ea0a 0505 	and.w	r5, sl, r5
 8009dc2:	f04f 0a01 	mov.w	sl, #1
 8009dc6:	f7f6 fea9 	bl	8000b1c <__aeabi_dcmpge>
 8009dca:	b900      	cbnz	r0, 8009dce <GUI_Touch_Processing+0x244e>
 8009dcc:	4682      	mov	sl, r0
 8009dce:	ea05 050a 	and.w	r5, r5, sl
 8009dd2:	07e8      	lsls	r0, r5, #31
 8009dd4:	d574      	bpl.n	8009ec0 <GUI_Touch_Processing+0x2540>
 8009dd6:	a324      	add	r3, pc, #144	; (adr r3, 8009e68 <GUI_Touch_Processing+0x24e8>)
 8009dd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ddc:	4640      	mov	r0, r8
 8009dde:	4649      	mov	r1, r9
 8009de0:	f04f 0501 	mov.w	r5, #1
 8009de4:	f7f6 fe90 	bl	8000b08 <__aeabi_dcmple>
 8009de8:	b900      	cbnz	r0, 8009dec <GUI_Touch_Processing+0x246c>
 8009dea:	4605      	mov	r5, r0
 8009dec:	f015 0fff 	tst.w	r5, #255	; 0xff
 8009df0:	d066      	beq.n	8009ec0 <GUI_Touch_Processing+0x2540>
					Graph_Field ^= PPF_Bands;
 8009df2:	4b2e      	ldr	r3, [pc, #184]	; (8009eac <GUI_Touch_Processing+0x252c>)
 8009df4:	781a      	ldrb	r2, [r3, #0]
 8009df6:	f082 0201 	eor.w	r2, r2, #1
 8009dfa:	701a      	strb	r2, [r3, #0]
					GUI_CheckBox(200, 327, Graph_Field&PPF_Bands);
 8009dfc:	f240 1147 	movw	r1, #327	; 0x147
 8009e00:	f002 0201 	and.w	r2, r2, #1
 8009e04:	20c8      	movs	r0, #200	; 0xc8
 8009e06:	f001 fe6b 	bl	800bae0 <GUI_CheckBox>
 8009e0a:	f7fd be48 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 8009e0e:	bf00      	nop
 8009e10:	99999999 	.word	0x99999999
 8009e14:	4091a399 	.word	0x4091a399
 8009e18:	33333333 	.word	0x33333333
 8009e1c:	407aff33 	.word	0x407aff33
 8009e20:	66666666 	.word	0x66666666
 8009e24:	4081f866 	.word	0x4081f866
 8009e28:	cccccccd 	.word	0xcccccccd
 8009e2c:	407e24cc 	.word	0x407e24cc
 8009e30:	33333333 	.word	0x33333333
 8009e34:	40838b33 	.word	0x40838b33
 8009e38:	66666666 	.word	0x66666666
 8009e3c:	4080ba66 	.word	0x4080ba66
 8009e40:	33333333 	.word	0x33333333
 8009e44:	40853333 	.word	0x40853333
 8009e48:	99999999 	.word	0x99999999
 8009e4c:	40863199 	.word	0x40863199
 8009e50:	66666666 	.word	0x66666666
 8009e54:	408aaa66 	.word	0x408aaa66
 8009e58:	cccccccd 	.word	0xcccccccd
 8009e5c:	408508cc 	.word	0x408508cc
 8009e60:	66666666 	.word	0x66666666
 8009e64:	408b1466 	.word	0x408b1466
 8009e68:	33333333 	.word	0x33333333
 8009e6c:	408f8d33 	.word	0x408f8d33
 8009e70:	33333333 	.word	0x33333333
 8009e74:	40867133 	.word	0x40867133
 8009e78:	20084b8d 	.word	0x20084b8d
 8009e7c:	20000176 	.word	0x20000176
 8009e80:	4093e000 	.word	0x4093e000
 8009e84:	2000019c 	.word	0x2000019c
 8009e88:	08101838 	.word	0x08101838
 8009e8c:	08100838 	.word	0x08100838
 8009e90:	20081b18 	.word	0x20081b18
 8009e94:	2000030c 	.word	0x2000030c
 8009e98:	20000308 	.word	0x20000308
 8009e9c:	20000310 	.word	0x20000310
 8009ea0:	20000304 	.word	0x20000304
 8009ea4:	20084b92 	.word	0x20084b92
 8009ea8:	40809000 	.word	0x40809000
 8009eac:	200002ba 	.word	0x200002ba
 8009eb0:	33333333 	.word	0x33333333
 8009eb4:	40053333 	.word	0x40053333
 8009eb8:	00000000 	.word	0x00000000
 8009ebc:	40623800 	.word	0x40623800
 8009ec0:	9b00      	ldr	r3, [sp, #0]
 8009ec2:	9a02      	ldr	r2, [sp, #8]
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 8009ec4:	4630      	mov	r0, r6
 8009ec6:	ea03 0a02 	and.w	sl, r3, r2
 8009eca:	4639      	mov	r1, r7
 8009ecc:	a3c2      	add	r3, pc, #776	; (adr r3, 800a1d8 <GUI_Touch_Processing+0x2858>)
 8009ece:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ed2:	f04f 0501 	mov.w	r5, #1
 8009ed6:	f7f6 fe21 	bl	8000b1c <__aeabi_dcmpge>
 8009eda:	b900      	cbnz	r0, 8009ede <GUI_Touch_Processing+0x255e>
 8009edc:	4605      	mov	r5, r0
 8009ede:	a3cb      	add	r3, pc, #812	; (adr r3, 800a20c <GUI_Touch_Processing+0x288c>)
 8009ee0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ee4:	4630      	mov	r0, r6
 8009ee6:	4639      	mov	r1, r7
 8009ee8:	f04f 0b01 	mov.w	fp, #1
 8009eec:	f7f6 fe0c 	bl	8000b08 <__aeabi_dcmple>
 8009ef0:	b900      	cbnz	r0, 8009ef4 <GUI_Touch_Processing+0x2574>
 8009ef2:	4683      	mov	fp, r0
 8009ef4:	ea05 050b 	and.w	r5, r5, fp
 8009ef8:	07e9      	lsls	r1, r5, #31
 8009efa:	d503      	bpl.n	8009f04 <GUI_Touch_Processing+0x2584>
 8009efc:	f1ba 0f00 	cmp.w	sl, #0
 8009f00:	f47e acce 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 8009f04:	a3c3      	add	r3, pc, #780	; (adr r3, 800a214 <GUI_Touch_Processing+0x2894>)
 8009f06:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f0a:	4630      	mov	r0, r6
 8009f0c:	4639      	mov	r1, r7
 8009f0e:	f04f 0501 	mov.w	r5, #1
 8009f12:	f7f6 fe03 	bl	8000b1c <__aeabi_dcmpge>
 8009f16:	b900      	cbnz	r0, 8009f1a <GUI_Touch_Processing+0x259a>
 8009f18:	4605      	mov	r5, r0
 8009f1a:	a39d      	add	r3, pc, #628	; (adr r3, 800a190 <GUI_Touch_Processing+0x2810>)
 8009f1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f20:	4630      	mov	r0, r6
 8009f22:	4639      	mov	r1, r7
 8009f24:	f04f 0b01 	mov.w	fp, #1
 8009f28:	f7f6 fdee 	bl	8000b08 <__aeabi_dcmple>
 8009f2c:	b900      	cbnz	r0, 8009f30 <GUI_Touch_Processing+0x25b0>
 8009f2e:	4683      	mov	fp, r0
 8009f30:	ea05 050b 	and.w	r5, r5, fp
 8009f34:	07ea      	lsls	r2, r5, #31
 8009f36:	d51f      	bpl.n	8009f78 <GUI_Touch_Processing+0x25f8>
 8009f38:	f1ba 0f00 	cmp.w	sl, #0
 8009f3c:	d01c      	beq.n	8009f78 <GUI_Touch_Processing+0x25f8>
					GUI_screen_state = Prev_Inf_Screen;
 8009f3e:	4bac      	ldr	r3, [pc, #688]	; (800a1f0 <GUI_Touch_Processing+0x2870>)
 8009f40:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 8009f42:	1e5a      	subs	r2, r3, #1
 8009f44:	2a05      	cmp	r2, #5
 8009f46:	d804      	bhi.n	8009f52 <GUI_Touch_Processing+0x25d2>
 8009f48:	e8df f002 	tbb	[pc, r2]
 8009f4c:	0a030306 	.word	0x0a030306
 8009f50:	0e12      	.short	0x0e12
					GUI_screen_state = Prev_Inf_Screen;
 8009f52:	7023      	strb	r3, [r4, #0]
 8009f54:	f7fd bda3 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 8009f58:	2301      	movs	r3, #1
 8009f5a:	7023      	strb	r3, [r4, #0]
 8009f5c:	f7fd bd9f 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 8009f60:	2304      	movs	r3, #4
 8009f62:	7023      	strb	r3, [r4, #0]
 8009f64:	f7fd bd9b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 8009f68:	2306      	movs	r3, #6
 8009f6a:	7023      	strb	r3, [r4, #0]
 8009f6c:	f7fd bd97 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 8009f70:	2305      	movs	r3, #5
 8009f72:	7023      	strb	r3, [r4, #0]
 8009f74:	f7fd bd93 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 8009f78:	a385      	add	r3, pc, #532	; (adr r3, 800a190 <GUI_Touch_Processing+0x2810>)
 8009f7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f7e:	4630      	mov	r0, r6
 8009f80:	4639      	mov	r1, r7
 8009f82:	f04f 0501 	mov.w	r5, #1
 8009f86:	f7f6 fdc9 	bl	8000b1c <__aeabi_dcmpge>
 8009f8a:	b900      	cbnz	r0, 8009f8e <GUI_Touch_Processing+0x260e>
 8009f8c:	4605      	mov	r5, r0
 8009f8e:	a382      	add	r3, pc, #520	; (adr r3, 800a198 <GUI_Touch_Processing+0x2818>)
 8009f90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f94:	4630      	mov	r0, r6
 8009f96:	4639      	mov	r1, r7
 8009f98:	f04f 0b01 	mov.w	fp, #1
 8009f9c:	f7f6 fdb4 	bl	8000b08 <__aeabi_dcmple>
 8009fa0:	b900      	cbnz	r0, 8009fa4 <GUI_Touch_Processing+0x2624>
 8009fa2:	4683      	mov	fp, r0
 8009fa4:	ea05 050b 	and.w	r5, r5, fp
 8009fa8:	07eb      	lsls	r3, r5, #31
 8009faa:	d503      	bpl.n	8009fb4 <GUI_Touch_Processing+0x2634>
 8009fac:	f1ba 0f00 	cmp.w	sl, #0
 8009fb0:	f47d adb2 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=80*TS_Callib & Touch_y <=(120)*TS_Callib) // Language change
 8009fb4:	a37a      	add	r3, pc, #488	; (adr r3, 800a1a0 <GUI_Touch_Processing+0x2820>)
 8009fb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009fba:	4630      	mov	r0, r6
 8009fbc:	4639      	mov	r1, r7
 8009fbe:	f04f 0501 	mov.w	r5, #1
 8009fc2:	f7f6 fdab 	bl	8000b1c <__aeabi_dcmpge>
 8009fc6:	b900      	cbnz	r0, 8009fca <GUI_Touch_Processing+0x264a>
 8009fc8:	4605      	mov	r5, r0
 8009fca:	a377      	add	r3, pc, #476	; (adr r3, 800a1a8 <GUI_Touch_Processing+0x2828>)
 8009fcc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009fd0:	4630      	mov	r0, r6
 8009fd2:	4639      	mov	r1, r7
 8009fd4:	f04f 0a01 	mov.w	sl, #1
 8009fd8:	f7f6 fd96 	bl	8000b08 <__aeabi_dcmple>
 8009fdc:	b900      	cbnz	r0, 8009fe0 <GUI_Touch_Processing+0x2660>
 8009fde:	4682      	mov	sl, r0
 8009fe0:	ea05 050a 	and.w	r5, r5, sl
 8009fe4:	2200      	movs	r2, #0
 8009fe6:	4b83      	ldr	r3, [pc, #524]	; (800a1f4 <GUI_Touch_Processing+0x2874>)
 8009fe8:	4640      	mov	r0, r8
 8009fea:	4649      	mov	r1, r9
 8009fec:	b2ed      	uxtb	r5, r5
 8009fee:	f04f 0601 	mov.w	r6, #1
 8009ff2:	f7f6 fd93 	bl	8000b1c <__aeabi_dcmpge>
 8009ff6:	b900      	cbnz	r0, 8009ffa <GUI_Touch_Processing+0x267a>
 8009ff8:	4606      	mov	r6, r0
 8009ffa:	a36d      	add	r3, pc, #436	; (adr r3, 800a1b0 <GUI_Touch_Processing+0x2830>)
 8009ffc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a000:	4640      	mov	r0, r8
 800a002:	4649      	mov	r1, r9
 800a004:	f04f 0701 	mov.w	r7, #1
 800a008:	f7f6 fd7e 	bl	8000b08 <__aeabi_dcmple>
 800a00c:	b900      	cbnz	r0, 800a010 <GUI_Touch_Processing+0x2690>
 800a00e:	4607      	mov	r7, r0
 800a010:	403e      	ands	r6, r7
 800a012:	07f7      	lsls	r7, r6, #31
 800a014:	d510      	bpl.n	800a038 <GUI_Touch_Processing+0x26b8>
 800a016:	b17d      	cbz	r5, 800a038 <GUI_Touch_Processing+0x26b8>
					if (Language_status == Ru) Language_status=En;
 800a018:	4b77      	ldr	r3, [pc, #476]	; (800a1f8 <GUI_Touch_Processing+0x2878>)
 800a01a:	781b      	ldrb	r3, [r3, #0]
 800a01c:	b923      	cbnz	r3, 800a028 <GUI_Touch_Processing+0x26a8>
 800a01e:	4b76      	ldr	r3, [pc, #472]	; (800a1f8 <GUI_Touch_Processing+0x2878>)
 800a020:	2201      	movs	r2, #1
 800a022:	701a      	strb	r2, [r3, #0]
 800a024:	f7fd bd3b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					else if (Language_status == En) Language_status=Ru;
 800a028:	2b01      	cmp	r3, #1
 800a02a:	f47d ad38 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a02e:	4b72      	ldr	r3, [pc, #456]	; (800a1f8 <GUI_Touch_Processing+0x2878>)
 800a030:	2200      	movs	r2, #0
 800a032:	701a      	strb	r2, [r3, #0]
 800a034:	f7fd bd33 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=124*TS_Callib & Touch_y <=(174)*TS_Callib) // Information
 800a038:	a35f      	add	r3, pc, #380	; (adr r3, 800a1b8 <GUI_Touch_Processing+0x2838>)
 800a03a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a03e:	4640      	mov	r0, r8
 800a040:	4649      	mov	r1, r9
 800a042:	f04f 0601 	mov.w	r6, #1
 800a046:	f7f6 fd69 	bl	8000b1c <__aeabi_dcmpge>
 800a04a:	b900      	cbnz	r0, 800a04e <GUI_Touch_Processing+0x26ce>
 800a04c:	4606      	mov	r6, r0
 800a04e:	a35c      	add	r3, pc, #368	; (adr r3, 800a1c0 <GUI_Touch_Processing+0x2840>)
 800a050:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a054:	4640      	mov	r0, r8
 800a056:	4649      	mov	r1, r9
 800a058:	f04f 0701 	mov.w	r7, #1
 800a05c:	f7f6 fd54 	bl	8000b08 <__aeabi_dcmple>
 800a060:	b900      	cbnz	r0, 800a064 <GUI_Touch_Processing+0x26e4>
 800a062:	4607      	mov	r7, r0
 800a064:	403e      	ands	r6, r7
 800a066:	07f6      	lsls	r6, r6, #31
 800a068:	f57d ad19 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a06c:	2d00      	cmp	r5, #0
 800a06e:	f43d ad16 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
					GUI_screen_state = Information_Screen;
 800a072:	2311      	movs	r3, #17
 800a074:	7023      	strb	r3, [r4, #0]
 800a076:	f7fd bd12 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 800a07a:	4b60      	ldr	r3, [pc, #384]	; (800a1fc <GUI_Touch_Processing+0x287c>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a07c:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 800a080:	220d      	movs	r2, #13
 800a082:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a084:	f7f6 fa5e 	bl	8000544 <__aeabi_i2d>
 800a088:	4606      	mov	r6, r0
 800a08a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800a08e:	460f      	mov	r7, r1
 800a090:	f7f6 fa58 	bl	8000544 <__aeabi_i2d>
 800a094:	a34c      	add	r3, pc, #304	; (adr r3, 800a1c8 <GUI_Touch_Processing+0x2848>)
 800a096:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a09a:	e9cd 0100 	strd	r0, r1, [sp]
 800a09e:	f04f 0901 	mov.w	r9, #1
 800a0a2:	f7f6 fd3b 	bl	8000b1c <__aeabi_dcmpge>
 800a0a6:	b900      	cbnz	r0, 800a0aa <GUI_Touch_Processing+0x272a>
 800a0a8:	4681      	mov	r9, r0
 800a0aa:	2200      	movs	r2, #0
 800a0ac:	4b54      	ldr	r3, [pc, #336]	; (800a200 <GUI_Touch_Processing+0x2880>)
 800a0ae:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a0b2:	fa5f f989 	uxtb.w	r9, r9
 800a0b6:	f04f 0501 	mov.w	r5, #1
 800a0ba:	f7f6 fd25 	bl	8000b08 <__aeabi_dcmple>
 800a0be:	b900      	cbnz	r0, 800a0c2 <GUI_Touch_Processing+0x2742>
 800a0c0:	4605      	mov	r5, r0
 800a0c2:	a343      	add	r3, pc, #268	; (adr r3, 800a1d0 <GUI_Touch_Processing+0x2850>)
 800a0c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a0c8:	4630      	mov	r0, r6
 800a0ca:	4639      	mov	r1, r7
 800a0cc:	b2ed      	uxtb	r5, r5
 800a0ce:	f04f 0801 	mov.w	r8, #1
 800a0d2:	f7f6 fd23 	bl	8000b1c <__aeabi_dcmpge>
 800a0d6:	b900      	cbnz	r0, 800a0da <GUI_Touch_Processing+0x275a>
 800a0d8:	4680      	mov	r8, r0
 800a0da:	a33f      	add	r3, pc, #252	; (adr r3, 800a1d8 <GUI_Touch_Processing+0x2858>)
 800a0dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a0e0:	4630      	mov	r0, r6
 800a0e2:	4639      	mov	r1, r7
 800a0e4:	f04f 0a01 	mov.w	sl, #1
 800a0e8:	f7f6 fd0e 	bl	8000b08 <__aeabi_dcmple>
 800a0ec:	b900      	cbnz	r0, 800a0f0 <GUI_Touch_Processing+0x2770>
 800a0ee:	4682      	mov	sl, r0
 800a0f0:	ea08 080a 	and.w	r8, r8, sl
 800a0f4:	ea19 0f08 	tst.w	r9, r8
 800a0f8:	d004      	beq.n	800a104 <GUI_Touch_Processing+0x2784>
 800a0fa:	b11d      	cbz	r5, 800a104 <GUI_Touch_Processing+0x2784>
					GUI_screen_state = GraphSet1_Screen;
 800a0fc:	230c      	movs	r3, #12
 800a0fe:	7023      	strb	r3, [r4, #0]
 800a100:	f7fd bccd 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=70*TS_Callib & Touch_y <=(70+54)*TS_Callib) //PPF_Bands
 800a104:	2200      	movs	r2, #0
 800a106:	4b3f      	ldr	r3, [pc, #252]	; (800a204 <GUI_Touch_Processing+0x2884>)
 800a108:	4630      	mov	r0, r6
 800a10a:	4639      	mov	r1, r7
 800a10c:	f04f 0801 	mov.w	r8, #1
 800a110:	f7f6 fd04 	bl	8000b1c <__aeabi_dcmpge>
 800a114:	b900      	cbnz	r0, 800a118 <GUI_Touch_Processing+0x2798>
 800a116:	4680      	mov	r8, r0
 800a118:	a331      	add	r3, pc, #196	; (adr r3, 800a1e0 <GUI_Touch_Processing+0x2860>)
 800a11a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a11e:	4630      	mov	r0, r6
 800a120:	4639      	mov	r1, r7
 800a122:	f04f 0a01 	mov.w	sl, #1
 800a126:	f7f6 fcef 	bl	8000b08 <__aeabi_dcmple>
 800a12a:	b900      	cbnz	r0, 800a12e <GUI_Touch_Processing+0x27ae>
 800a12c:	4682      	mov	sl, r0
 800a12e:	ea08 080a 	and.w	r8, r8, sl
 800a132:	a32d      	add	r3, pc, #180	; (adr r3, 800a1e8 <GUI_Touch_Processing+0x2868>)
 800a134:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a138:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a13c:	fa5f f888 	uxtb.w	r8, r8
 800a140:	f04f 0a01 	mov.w	sl, #1
 800a144:	f7f6 fcea 	bl	8000b1c <__aeabi_dcmpge>
 800a148:	b900      	cbnz	r0, 800a14c <GUI_Touch_Processing+0x27cc>
 800a14a:	4682      	mov	sl, r0
 800a14c:	a31a      	add	r3, pc, #104	; (adr r3, 800a1b8 <GUI_Touch_Processing+0x2838>)
 800a14e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a152:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a156:	f04f 0b01 	mov.w	fp, #1
 800a15a:	f7f6 fcd5 	bl	8000b08 <__aeabi_dcmple>
 800a15e:	b900      	cbnz	r0, 800a162 <GUI_Touch_Processing+0x27e2>
 800a160:	4683      	mov	fp, r0
 800a162:	ea0a 0a0b 	and.w	sl, sl, fp
 800a166:	f01a 0f01 	tst.w	sl, #1
 800a16a:	d057      	beq.n	800a21c <GUI_Touch_Processing+0x289c>
 800a16c:	f1b8 0f00 	cmp.w	r8, #0
 800a170:	d054      	beq.n	800a21c <GUI_Touch_Processing+0x289c>
					Graph_Field ^= EbEr_graph;
 800a172:	4b25      	ldr	r3, [pc, #148]	; (800a208 <GUI_Touch_Processing+0x2888>)
 800a174:	781a      	ldrb	r2, [r3, #0]
 800a176:	f082 0202 	eor.w	r2, r2, #2
 800a17a:	701a      	strb	r2, [r3, #0]
					GUI_CheckBox(200, 70, Graph_Field&EbEr_graph);
 800a17c:	2146      	movs	r1, #70	; 0x46
 800a17e:	f002 0202 	and.w	r2, r2, #2
 800a182:	20c8      	movs	r0, #200	; 0xc8
 800a184:	f001 fcac 	bl	800bae0 <GUI_CheckBox>
 800a188:	f7fd bc89 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a18c:	f3af 8000 	nop.w
 800a190:	00000000 	.word	0x00000000
 800a194:	40623800 	.word	0x40623800
 800a198:	99999999 	.word	0x99999999
 800a19c:	40720d99 	.word	0x40720d99
 800a1a0:	33333333 	.word	0x33333333
 800a1a4:	40353333 	.word	0x40353333
 800a1a8:	00000000 	.word	0x00000000
 800a1ac:	4084b400 	.word	0x4084b400
 800a1b0:	00000000 	.word	0x00000000
 800a1b4:	4073e000 	.word	0x4073e000
 800a1b8:	99999999 	.word	0x99999999
 800a1bc:	40748999 	.word	0x40748999
 800a1c0:	99999999 	.word	0x99999999
 800a1c4:	407cd199 	.word	0x407cd199
 800a1c8:	99999999 	.word	0x99999999
 800a1cc:	4091a399 	.word	0x4091a399
 800a1d0:	33333333 	.word	0x33333333
 800a1d4:	407aff33 	.word	0x407aff33
 800a1d8:	66666666 	.word	0x66666666
 800a1dc:	4081f866 	.word	0x4081f866
 800a1e0:	cccccccd 	.word	0xcccccccd
 800a1e4:	408508cc 	.word	0x408508cc
 800a1e8:	00000000 	.word	0x00000000
 800a1ec:	40673000 	.word	0x40673000
 800a1f0:	20084b8d 	.word	0x20084b8d
 800a1f4:	406a8000 	.word	0x406a8000
 800a1f8:	200002bb 	.word	0x200002bb
 800a1fc:	20000176 	.word	0x20000176
 800a200:	4093e000 	.word	0x4093e000
 800a204:	40809000 	.word	0x40809000
 800a208:	200002ba 	.word	0x200002ba
 800a20c:	33333333 	.word	0x33333333
 800a210:	40867133 	.word	0x40867133
 800a214:	33333333 	.word	0x33333333
 800a218:	40053333 	.word	0x40053333
				if(Touch_x >= 200*TS_Callib & Touch_x <= (200+54)*TS_Callib & Touch_y >=133*TS_Callib & Touch_y <=(133+54)*TS_Callib) //PPF_Bands
 800a21c:	a3cf      	add	r3, pc, #828	; (adr r3, 800a55c <GUI_Touch_Processing+0x2bdc>)
 800a21e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a222:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a226:	f04f 0a01 	mov.w	sl, #1
 800a22a:	f7f6 fc77 	bl	8000b1c <__aeabi_dcmpge>
 800a22e:	b900      	cbnz	r0, 800a232 <GUI_Touch_Processing+0x28b2>
 800a230:	4682      	mov	sl, r0
 800a232:	a3cc      	add	r3, pc, #816	; (adr r3, 800a564 <GUI_Touch_Processing+0x2be4>)
 800a234:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a238:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a23c:	f04f 0b01 	mov.w	fp, #1
 800a240:	f7f6 fc62 	bl	8000b08 <__aeabi_dcmple>
 800a244:	b900      	cbnz	r0, 800a248 <GUI_Touch_Processing+0x28c8>
 800a246:	4683      	mov	fp, r0
 800a248:	ea0a 0a0b 	and.w	sl, sl, fp
 800a24c:	f01a 0f01 	tst.w	sl, #1
 800a250:	d00f      	beq.n	800a272 <GUI_Touch_Processing+0x28f2>
 800a252:	f1b8 0f00 	cmp.w	r8, #0
 800a256:	d00c      	beq.n	800a272 <GUI_Touch_Processing+0x28f2>
					Graph_Field ^= V_lambda;
 800a258:	4bb3      	ldr	r3, [pc, #716]	; (800a528 <GUI_Touch_Processing+0x2ba8>)
 800a25a:	781a      	ldrb	r2, [r3, #0]
 800a25c:	f082 0204 	eor.w	r2, r2, #4
 800a260:	701a      	strb	r2, [r3, #0]
					GUI_CheckBox(200, 133, Graph_Field&V_lambda);
 800a262:	2185      	movs	r1, #133	; 0x85
 800a264:	f002 0204 	and.w	r2, r2, #4
 800a268:	20c8      	movs	r0, #200	; 0xc8
 800a26a:	f001 fc39 	bl	800bae0 <GUI_CheckBox>
 800a26e:	f7fd bc16 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800a272:	a395      	add	r3, pc, #596	; (adr r3, 800a4c8 <GUI_Touch_Processing+0x2b48>)
 800a274:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a278:	4630      	mov	r0, r6
 800a27a:	4639      	mov	r1, r7
 800a27c:	ea09 0505 	and.w	r5, r9, r5
 800a280:	f04f 0801 	mov.w	r8, #1
 800a284:	f7f6 fc4a 	bl	8000b1c <__aeabi_dcmpge>
 800a288:	b900      	cbnz	r0, 800a28c <GUI_Touch_Processing+0x290c>
 800a28a:	4680      	mov	r8, r0
 800a28c:	a390      	add	r3, pc, #576	; (adr r3, 800a4d0 <GUI_Touch_Processing+0x2b50>)
 800a28e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a292:	4630      	mov	r0, r6
 800a294:	4639      	mov	r1, r7
 800a296:	f04f 0901 	mov.w	r9, #1
 800a29a:	f7f6 fc35 	bl	8000b08 <__aeabi_dcmple>
 800a29e:	b900      	cbnz	r0, 800a2a2 <GUI_Touch_Processing+0x2922>
 800a2a0:	4681      	mov	r9, r0
 800a2a2:	ea08 0809 	and.w	r8, r8, r9
 800a2a6:	f018 0f01 	tst.w	r8, #1
 800a2aa:	d002      	beq.n	800a2b2 <GUI_Touch_Processing+0x2932>
 800a2ac:	2d00      	cmp	r5, #0
 800a2ae:	f47e aaf7 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 800a2b2:	a389      	add	r3, pc, #548	; (adr r3, 800a4d8 <GUI_Touch_Processing+0x2b58>)
 800a2b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a2b8:	4630      	mov	r0, r6
 800a2ba:	4639      	mov	r1, r7
 800a2bc:	f04f 0801 	mov.w	r8, #1
 800a2c0:	f7f6 fc2c 	bl	8000b1c <__aeabi_dcmpge>
 800a2c4:	b900      	cbnz	r0, 800a2c8 <GUI_Touch_Processing+0x2948>
 800a2c6:	4680      	mov	r8, r0
 800a2c8:	a385      	add	r3, pc, #532	; (adr r3, 800a4e0 <GUI_Touch_Processing+0x2b60>)
 800a2ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a2ce:	4630      	mov	r0, r6
 800a2d0:	4639      	mov	r1, r7
 800a2d2:	f04f 0901 	mov.w	r9, #1
 800a2d6:	f7f6 fc17 	bl	8000b08 <__aeabi_dcmple>
 800a2da:	b900      	cbnz	r0, 800a2de <GUI_Touch_Processing+0x295e>
 800a2dc:	4681      	mov	r9, r0
 800a2de:	ea08 0809 	and.w	r8, r8, r9
 800a2e2:	f018 0f01 	tst.w	r8, #1
 800a2e6:	f000 83ad 	beq.w	800aa44 <GUI_Touch_Processing+0x30c4>
 800a2ea:	2d00      	cmp	r5, #0
 800a2ec:	f000 83aa 	beq.w	800aa44 <GUI_Touch_Processing+0x30c4>
					GUI_screen_state = Prev_Inf_Screen;
 800a2f0:	4b8e      	ldr	r3, [pc, #568]	; (800a52c <GUI_Touch_Processing+0x2bac>)
 800a2f2:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 800a2f4:	1e5a      	subs	r2, r3, #1
 800a2f6:	2a05      	cmp	r2, #5
 800a2f8:	d804      	bhi.n	800a304 <GUI_Touch_Processing+0x2984>
 800a2fa:	e8df f002 	tbb	[pc, r2]
 800a2fe:	0306      	.short	0x0306
 800a300:	0e120a03 	.word	0x0e120a03
					GUI_screen_state = Prev_Inf_Screen;
 800a304:	7023      	strb	r3, [r4, #0]
 800a306:	f7fd bbca 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 800a30a:	2301      	movs	r3, #1
 800a30c:	7023      	strb	r3, [r4, #0]
 800a30e:	f7fd bbc6 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 800a312:	2304      	movs	r3, #4
 800a314:	7023      	strb	r3, [r4, #0]
 800a316:	f7fd bbc2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 800a31a:	2306      	movs	r3, #6
 800a31c:	7023      	strb	r3, [r4, #0]
 800a31e:	f7fd bbbe 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 800a322:	2305      	movs	r3, #5
 800a324:	7023      	strb	r3, [r4, #0]
 800a326:	f7fd bbba 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 800a32a:	4b81      	ldr	r3, [pc, #516]	; (800a530 <GUI_Touch_Processing+0x2bb0>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a32c:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 800a330:	220e      	movs	r2, #14
 800a332:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a334:	f7f6 f906 	bl	8000544 <__aeabi_i2d>
 800a338:	4606      	mov	r6, r0
 800a33a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800a33e:	460f      	mov	r7, r1
 800a340:	f7f6 f900 	bl	8000544 <__aeabi_i2d>
 800a344:	a368      	add	r3, pc, #416	; (adr r3, 800a4e8 <GUI_Touch_Processing+0x2b68>)
 800a346:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a34a:	4682      	mov	sl, r0
 800a34c:	468b      	mov	fp, r1
 800a34e:	f04f 0501 	mov.w	r5, #1
 800a352:	f7f6 fbe3 	bl	8000b1c <__aeabi_dcmpge>
 800a356:	b900      	cbnz	r0, 800a35a <GUI_Touch_Processing+0x29da>
 800a358:	4605      	mov	r5, r0
 800a35a:	b2eb      	uxtb	r3, r5
 800a35c:	9300      	str	r3, [sp, #0]
 800a35e:	2200      	movs	r2, #0
 800a360:	4b74      	ldr	r3, [pc, #464]	; (800a534 <GUI_Touch_Processing+0x2bb4>)
 800a362:	4650      	mov	r0, sl
 800a364:	4659      	mov	r1, fp
 800a366:	f04f 0501 	mov.w	r5, #1
 800a36a:	f7f6 fbcd 	bl	8000b08 <__aeabi_dcmple>
 800a36e:	b900      	cbnz	r0, 800a372 <GUI_Touch_Processing+0x29f2>
 800a370:	4605      	mov	r5, r0
 800a372:	b2eb      	uxtb	r3, r5
 800a374:	9302      	str	r3, [sp, #8]
 800a376:	4630      	mov	r0, r6
 800a378:	a35d      	add	r3, pc, #372	; (adr r3, 800a4f0 <GUI_Touch_Processing+0x2b70>)
 800a37a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a37e:	4639      	mov	r1, r7
 800a380:	f04f 0501 	mov.w	r5, #1
 800a384:	f7f6 fbca 	bl	8000b1c <__aeabi_dcmpge>
 800a388:	b900      	cbnz	r0, 800a38c <GUI_Touch_Processing+0x2a0c>
 800a38a:	4605      	mov	r5, r0
 800a38c:	a34e      	add	r3, pc, #312	; (adr r3, 800a4c8 <GUI_Touch_Processing+0x2b48>)
 800a38e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a392:	4630      	mov	r0, r6
 800a394:	4639      	mov	r1, r7
 800a396:	f04f 0801 	mov.w	r8, #1
 800a39a:	f7f6 fbb5 	bl	8000b08 <__aeabi_dcmple>
 800a39e:	b900      	cbnz	r0, 800a3a2 <GUI_Touch_Processing+0x2a22>
 800a3a0:	4680      	mov	r8, r0
 800a3a2:	9b00      	ldr	r3, [sp, #0]
 800a3a4:	ea05 0508 	and.w	r5, r5, r8
 800a3a8:	422b      	tst	r3, r5
 800a3aa:	d005      	beq.n	800a3b8 <GUI_Touch_Processing+0x2a38>
 800a3ac:	9b02      	ldr	r3, [sp, #8]
 800a3ae:	b11b      	cbz	r3, 800a3b8 <GUI_Touch_Processing+0x2a38>
					GUI_screen_state = ColorSet2_Screen;
 800a3b0:	230f      	movs	r3, #15
 800a3b2:	7023      	strb	r3, [r4, #0]
 800a3b4:	f7fd bb73 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=202*TS_Callib & Touch_y <=(202+54)*TS_Callib) //Mode_EL
 800a3b8:	a34f      	add	r3, pc, #316	; (adr r3, 800a4f8 <GUI_Touch_Processing+0x2b78>)
 800a3ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a3be:	4630      	mov	r0, r6
 800a3c0:	4639      	mov	r1, r7
 800a3c2:	f04f 0501 	mov.w	r5, #1
 800a3c6:	f7f6 fba9 	bl	8000b1c <__aeabi_dcmpge>
 800a3ca:	b900      	cbnz	r0, 800a3ce <GUI_Touch_Processing+0x2a4e>
 800a3cc:	4605      	mov	r5, r0
 800a3ce:	a34c      	add	r3, pc, #304	; (adr r3, 800a500 <GUI_Touch_Processing+0x2b80>)
 800a3d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a3d4:	4630      	mov	r0, r6
 800a3d6:	4639      	mov	r1, r7
 800a3d8:	f04f 0801 	mov.w	r8, #1
 800a3dc:	f7f6 fb94 	bl	8000b08 <__aeabi_dcmple>
 800a3e0:	b900      	cbnz	r0, 800a3e4 <GUI_Touch_Processing+0x2a64>
 800a3e2:	4680      	mov	r8, r0
 800a3e4:	ea05 0508 	and.w	r5, r5, r8
 800a3e8:	a347      	add	r3, pc, #284	; (adr r3, 800a508 <GUI_Touch_Processing+0x2b88>)
 800a3ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a3ee:	4650      	mov	r0, sl
 800a3f0:	4659      	mov	r1, fp
 800a3f2:	b2ed      	uxtb	r5, r5
 800a3f4:	f04f 0801 	mov.w	r8, #1
 800a3f8:	f7f6 fb90 	bl	8000b1c <__aeabi_dcmpge>
 800a3fc:	b900      	cbnz	r0, 800a400 <GUI_Touch_Processing+0x2a80>
 800a3fe:	4680      	mov	r8, r0
 800a400:	a343      	add	r3, pc, #268	; (adr r3, 800a510 <GUI_Touch_Processing+0x2b90>)
 800a402:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a406:	4650      	mov	r0, sl
 800a408:	4659      	mov	r1, fp
 800a40a:	f04f 0901 	mov.w	r9, #1
 800a40e:	f7f6 fb7b 	bl	8000b08 <__aeabi_dcmple>
 800a412:	b900      	cbnz	r0, 800a416 <GUI_Touch_Processing+0x2a96>
 800a414:	4681      	mov	r9, r0
 800a416:	ea08 0809 	and.w	r8, r8, r9
 800a41a:	f018 0f01 	tst.w	r8, #1
 800a41e:	d026      	beq.n	800a46e <GUI_Touch_Processing+0x2aee>
 800a420:	b32d      	cbz	r5, 800a46e <GUI_Touch_Processing+0x2aee>
					Mode_EL = !Mode_EL;
 800a422:	4c45      	ldr	r4, [pc, #276]	; (800a538 <GUI_Touch_Processing+0x2bb8>)
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800a424:	4b45      	ldr	r3, [pc, #276]	; (800a53c <GUI_Touch_Processing+0x2bbc>)
					Mode_EL = !Mode_EL;
 800a426:	7822      	ldrb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800a428:	4845      	ldr	r0, [pc, #276]	; (800a540 <GUI_Touch_Processing+0x2bc0>)
					Mode_EL = !Mode_EL;
 800a42a:	2a00      	cmp	r2, #0
 800a42c:	bf0c      	ite	eq
 800a42e:	2201      	moveq	r2, #1
 800a430:	2200      	movne	r2, #0
 800a432:	7022      	strb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800a434:	bf18      	it	ne
 800a436:	4618      	movne	r0, r3
 800a438:	4a42      	ldr	r2, [pc, #264]	; (800a544 <GUI_Touch_Processing+0x2bc4>)
 800a43a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800a43e:	f7fb ff1f 	bl	8006280 <Calibration_Load_Pack>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800a442:	7822      	ldrb	r2, [r4, #0]
 800a444:	4b40      	ldr	r3, [pc, #256]	; (800a548 <GUI_Touch_Processing+0x2bc8>)
 800a446:	b982      	cbnz	r2, 800a46a <GUI_Touch_Processing+0x2aea>
 800a448:	4a40      	ldr	r2, [pc, #256]	; (800a54c <GUI_Touch_Processing+0x2bcc>)
 800a44a:	edd2 0a00 	vldr	s1, [r2]
 800a44e:	ed93 0a00 	vldr	s0, [r3]
 800a452:	f006 f805 	bl	8010460 <Rabs_calc_Factor2_Settings_change>
 800a456:	4b3e      	ldr	r3, [pc, #248]	; (800a550 <GUI_Touch_Processing+0x2bd0>)
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 800a458:	7822      	ldrb	r2, [r4, #0]
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800a45a:	ed83 0a00 	vstr	s0, [r3]
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 800a45e:	21ca      	movs	r1, #202	; 0xca
 800a460:	20b6      	movs	r0, #182	; 0xb6
 800a462:	f001 fc07 	bl	800bc74 <GUI_Switch_ButtonActive>
 800a466:	f7fd bb1a 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800a46a:	4a3a      	ldr	r2, [pc, #232]	; (800a554 <GUI_Touch_Processing+0x2bd4>)
 800a46c:	e7ed      	b.n	800a44a <GUI_Touch_Processing+0x2aca>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=268*TS_Callib & Touch_y <=(268+54)*TS_Callib) //Bluetooth
 800a46e:	a32a      	add	r3, pc, #168	; (adr r3, 800a518 <GUI_Touch_Processing+0x2b98>)
 800a470:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a474:	4650      	mov	r0, sl
 800a476:	4659      	mov	r1, fp
 800a478:	f04f 0801 	mov.w	r8, #1
 800a47c:	f7f6 fb4e 	bl	8000b1c <__aeabi_dcmpge>
 800a480:	b900      	cbnz	r0, 800a484 <GUI_Touch_Processing+0x2b04>
 800a482:	4680      	mov	r8, r0
 800a484:	a326      	add	r3, pc, #152	; (adr r3, 800a520 <GUI_Touch_Processing+0x2ba0>)
 800a486:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a48a:	4650      	mov	r0, sl
 800a48c:	4659      	mov	r1, fp
 800a48e:	f04f 0901 	mov.w	r9, #1
 800a492:	f7f6 fb39 	bl	8000b08 <__aeabi_dcmple>
 800a496:	b900      	cbnz	r0, 800a49a <GUI_Touch_Processing+0x2b1a>
 800a498:	4681      	mov	r9, r0
 800a49a:	ea08 0809 	and.w	r8, r8, r9
 800a49e:	f018 0f01 	tst.w	r8, #1
 800a4a2:	d063      	beq.n	800a56c <GUI_Touch_Processing+0x2bec>
 800a4a4:	2d00      	cmp	r5, #0
 800a4a6:	d061      	beq.n	800a56c <GUI_Touch_Processing+0x2bec>
					Bluetooth = !Bluetooth;
 800a4a8:	4b2b      	ldr	r3, [pc, #172]	; (800a558 <GUI_Touch_Processing+0x2bd8>)
 800a4aa:	781a      	ldrb	r2, [r3, #0]
 800a4ac:	fab2 f282 	clz	r2, r2
 800a4b0:	0952      	lsrs	r2, r2, #5
					GUI_Switch_Button(182, 268, Bluetooth);
 800a4b2:	f44f 7186 	mov.w	r1, #268	; 0x10c
 800a4b6:	20b6      	movs	r0, #182	; 0xb6
					Bluetooth = !Bluetooth;
 800a4b8:	701a      	strb	r2, [r3, #0]
					GUI_Switch_Button(182, 268, Bluetooth);
 800a4ba:	f001 fb81 	bl	800bbc0 <GUI_Switch_Button>
					GUI_Up_Panel();
 800a4be:	f7fc fa9d 	bl	80069fc <GUI_Up_Panel>
 800a4c2:	f7fd baec 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a4c6:	bf00      	nop
 800a4c8:	66666666 	.word	0x66666666
 800a4cc:	4081f866 	.word	0x4081f866
 800a4d0:	33333333 	.word	0x33333333
 800a4d4:	40867133 	.word	0x40867133
 800a4d8:	33333333 	.word	0x33333333
 800a4dc:	40053333 	.word	0x40053333
 800a4e0:	00000000 	.word	0x00000000
 800a4e4:	40623800 	.word	0x40623800
 800a4e8:	99999999 	.word	0x99999999
 800a4ec:	4091a399 	.word	0x4091a399
 800a4f0:	33333333 	.word	0x33333333
 800a4f4:	407aff33 	.word	0x407aff33
 800a4f8:	cccccccd 	.word	0xcccccccd
 800a4fc:	407e24cc 	.word	0x407e24cc
 800a500:	33333333 	.word	0x33333333
 800a504:	40838b33 	.word	0x40838b33
 800a508:	66666666 	.word	0x66666666
 800a50c:	4080ba66 	.word	0x4080ba66
 800a510:	33333333 	.word	0x33333333
 800a514:	40853333 	.word	0x40853333
 800a518:	99999999 	.word	0x99999999
 800a51c:	40863199 	.word	0x40863199
 800a520:	66666666 	.word	0x66666666
 800a524:	408aaa66 	.word	0x408aaa66
 800a528:	200002ba 	.word	0x200002ba
 800a52c:	20084b8d 	.word	0x20084b8d
 800a530:	20000176 	.word	0x20000176
 800a534:	4093e000 	.word	0x4093e000
 800a538:	2000019c 	.word	0x2000019c
 800a53c:	08101838 	.word	0x08101838
 800a540:	08100838 	.word	0x08100838
 800a544:	20081b18 	.word	0x20081b18
 800a548:	2000030c 	.word	0x2000030c
 800a54c:	20000308 	.word	0x20000308
 800a550:	20000310 	.word	0x20000310
 800a554:	20000304 	.word	0x20000304
 800a558:	20084b92 	.word	0x20084b92
 800a55c:	33333333 	.word	0x33333333
 800a560:	40760733 	.word	0x40760733
 800a564:	cccccccd 	.word	0xcccccccd
 800a568:	407ef8cc 	.word	0x407ef8cc
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=124*TS_Callib & Touch_y <=(174)*TS_Callib) // Information
 800a56c:	a3e4      	add	r3, pc, #912	; (adr r3, 800a900 <GUI_Touch_Processing+0x2f80>)
 800a56e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a572:	4630      	mov	r0, r6
 800a574:	4639      	mov	r1, r7
 800a576:	f04f 0801 	mov.w	r8, #1
 800a57a:	f7f6 facf 	bl	8000b1c <__aeabi_dcmpge>
 800a57e:	b900      	cbnz	r0, 800a582 <GUI_Touch_Processing+0x2c02>
 800a580:	4680      	mov	r8, r0
 800a582:	a3e1      	add	r3, pc, #900	; (adr r3, 800a908 <GUI_Touch_Processing+0x2f88>)
 800a584:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a588:	4630      	mov	r0, r6
 800a58a:	4639      	mov	r1, r7
 800a58c:	f04f 0901 	mov.w	r9, #1
 800a590:	f7f6 faba 	bl	8000b08 <__aeabi_dcmple>
 800a594:	b900      	cbnz	r0, 800a598 <GUI_Touch_Processing+0x2c18>
 800a596:	4681      	mov	r9, r0
 800a598:	ea08 0809 	and.w	r8, r8, r9
 800a59c:	fa5f f388 	uxtb.w	r3, r8
 800a5a0:	9303      	str	r3, [sp, #12]
 800a5a2:	4650      	mov	r0, sl
 800a5a4:	a3ce      	add	r3, pc, #824	; (adr r3, 800a8e0 <GUI_Touch_Processing+0x2f60>)
 800a5a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5aa:	4659      	mov	r1, fp
 800a5ac:	f04f 0901 	mov.w	r9, #1
 800a5b0:	f7f6 fab4 	bl	8000b1c <__aeabi_dcmpge>
 800a5b4:	b900      	cbnz	r0, 800a5b8 <GUI_Touch_Processing+0x2c38>
 800a5b6:	4681      	mov	r9, r0
 800a5b8:	a3d5      	add	r3, pc, #852	; (adr r3, 800a910 <GUI_Touch_Processing+0x2f90>)
 800a5ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5be:	4650      	mov	r0, sl
 800a5c0:	4659      	mov	r1, fp
 800a5c2:	f04f 0801 	mov.w	r8, #1
 800a5c6:	f7f6 fa9f 	bl	8000b08 <__aeabi_dcmple>
 800a5ca:	b900      	cbnz	r0, 800a5ce <GUI_Touch_Processing+0x2c4e>
 800a5cc:	4680      	mov	r8, r0
 800a5ce:	ea09 0908 	and.w	r9, r9, r8
 800a5d2:	f019 0f01 	tst.w	r9, #1
 800a5d6:	d003      	beq.n	800a5e0 <GUI_Touch_Processing+0x2c60>
 800a5d8:	9b03      	ldr	r3, [sp, #12]
 800a5da:	2b00      	cmp	r3, #0
 800a5dc:	f47f ad49 	bne.w	800a072 <GUI_Touch_Processing+0x26f2>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=327*TS_Callib & Touch_y <=(327+54)*TS_Callib) //Color_CIE_xy
 800a5e0:	a3cd      	add	r3, pc, #820	; (adr r3, 800a918 <GUI_Touch_Processing+0x2f98>)
 800a5e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5e6:	4650      	mov	r0, sl
 800a5e8:	4659      	mov	r1, fp
 800a5ea:	f04f 0401 	mov.w	r4, #1
 800a5ee:	f7f6 fa95 	bl	8000b1c <__aeabi_dcmpge>
 800a5f2:	b900      	cbnz	r0, 800a5f6 <GUI_Touch_Processing+0x2c76>
 800a5f4:	4604      	mov	r4, r0
 800a5f6:	a3ca      	add	r3, pc, #808	; (adr r3, 800a920 <GUI_Touch_Processing+0x2fa0>)
 800a5f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5fc:	4650      	mov	r0, sl
 800a5fe:	4659      	mov	r1, fp
 800a600:	f04f 0901 	mov.w	r9, #1
 800a604:	f7f6 fa80 	bl	8000b08 <__aeabi_dcmple>
 800a608:	b900      	cbnz	r0, 800a60c <GUI_Touch_Processing+0x2c8c>
 800a60a:	4681      	mov	r9, r0
 800a60c:	ea04 0409 	and.w	r4, r4, r9
 800a610:	07e0      	lsls	r0, r4, #31
 800a612:	d50f      	bpl.n	800a634 <GUI_Touch_Processing+0x2cb4>
 800a614:	b175      	cbz	r5, 800a634 <GUI_Touch_Processing+0x2cb4>
					if(!(Color_Field&Color_CIE_xy))
 800a616:	4ab4      	ldr	r2, [pc, #720]	; (800a8e8 <GUI_Touch_Processing+0x2f68>)
 800a618:	7813      	ldrb	r3, [r2, #0]
 800a61a:	07d9      	lsls	r1, r3, #31
 800a61c:	f53d aa3f 	bmi.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 327, Color_Field|=Color_CIE_xy, 0x01);
 800a620:	2301      	movs	r3, #1
 800a622:	7013      	strb	r3, [r2, #0]
 800a624:	f240 1147 	movw	r1, #327	; 0x147
 800a628:	461a      	mov	r2, r3
 800a62a:	20c8      	movs	r0, #200	; 0xc8
 800a62c:	f001 fa99 	bl	800bb62 <GUI_RadioBox>
 800a630:	f7fd ba35 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a634:	9b02      	ldr	r3, [sp, #8]
 800a636:	9c00      	ldr	r4, [sp, #0]
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800a638:	4630      	mov	r0, r6
 800a63a:	401c      	ands	r4, r3
 800a63c:	4639      	mov	r1, r7
 800a63e:	a392      	add	r3, pc, #584	; (adr r3, 800a888 <GUI_Touch_Processing+0x2f08>)
 800a640:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a644:	f04f 0501 	mov.w	r5, #1
 800a648:	f7f6 fa68 	bl	8000b1c <__aeabi_dcmpge>
 800a64c:	b900      	cbnz	r0, 800a650 <GUI_Touch_Processing+0x2cd0>
 800a64e:	4605      	mov	r5, r0
 800a650:	a38f      	add	r3, pc, #572	; (adr r3, 800a890 <GUI_Touch_Processing+0x2f10>)
 800a652:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a656:	4630      	mov	r0, r6
 800a658:	4639      	mov	r1, r7
 800a65a:	f04f 0901 	mov.w	r9, #1
 800a65e:	f7f6 fa53 	bl	8000b08 <__aeabi_dcmple>
 800a662:	b900      	cbnz	r0, 800a666 <GUI_Touch_Processing+0x2ce6>
 800a664:	4681      	mov	r9, r0
 800a666:	ea05 0309 	and.w	r3, r5, r9
 800a66a:	07da      	lsls	r2, r3, #31
 800a66c:	d502      	bpl.n	800a674 <GUI_Touch_Processing+0x2cf4>
 800a66e:	2c00      	cmp	r4, #0
 800a670:	f47e a916 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 800a674:	a388      	add	r3, pc, #544	; (adr r3, 800a898 <GUI_Touch_Processing+0x2f18>)
 800a676:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a67a:	4630      	mov	r0, r6
 800a67c:	4639      	mov	r1, r7
 800a67e:	f04f 0501 	mov.w	r5, #1
 800a682:	f7f6 fa4b 	bl	8000b1c <__aeabi_dcmpge>
 800a686:	b900      	cbnz	r0, 800a68a <GUI_Touch_Processing+0x2d0a>
 800a688:	4605      	mov	r5, r0
 800a68a:	a385      	add	r3, pc, #532	; (adr r3, 800a8a0 <GUI_Touch_Processing+0x2f20>)
 800a68c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a690:	4630      	mov	r0, r6
 800a692:	4639      	mov	r1, r7
 800a694:	f04f 0901 	mov.w	r9, #1
 800a698:	f7f6 fa36 	bl	8000b08 <__aeabi_dcmple>
 800a69c:	b900      	cbnz	r0, 800a6a0 <GUI_Touch_Processing+0x2d20>
 800a69e:	4681      	mov	r9, r0
 800a6a0:	ea05 0309 	and.w	r3, r5, r9
 800a6a4:	07db      	lsls	r3, r3, #31
 800a6a6:	d51e      	bpl.n	800a6e6 <GUI_Touch_Processing+0x2d66>
 800a6a8:	b1ec      	cbz	r4, 800a6e6 <GUI_Touch_Processing+0x2d66>
					GUI_screen_state = Prev_Inf_Screen;
 800a6aa:	4b90      	ldr	r3, [pc, #576]	; (800a8ec <GUI_Touch_Processing+0x2f6c>)
 800a6ac:	781a      	ldrb	r2, [r3, #0]
 800a6ae:	4b90      	ldr	r3, [pc, #576]	; (800a8f0 <GUI_Touch_Processing+0x2f70>)
					switch (Prev_Inf_Screen){
 800a6b0:	1e51      	subs	r1, r2, #1
 800a6b2:	2905      	cmp	r1, #5
 800a6b4:	d804      	bhi.n	800a6c0 <GUI_Touch_Processing+0x2d40>
 800a6b6:	e8df f001 	tbb	[pc, r1]
 800a6ba:	0306      	.short	0x0306
 800a6bc:	0e120a03 	.word	0x0e120a03
					GUI_screen_state = Prev_Inf_Screen;
 800a6c0:	701a      	strb	r2, [r3, #0]
 800a6c2:	f7fd b9ec 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 800a6c6:	2201      	movs	r2, #1
 800a6c8:	701a      	strb	r2, [r3, #0]
 800a6ca:	f7fd b9e8 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 800a6ce:	2204      	movs	r2, #4
 800a6d0:	701a      	strb	r2, [r3, #0]
 800a6d2:	f7fd b9e4 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 800a6d6:	2206      	movs	r2, #6
 800a6d8:	701a      	strb	r2, [r3, #0]
 800a6da:	f7fd b9e0 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 800a6de:	2205      	movs	r2, #5
 800a6e0:	701a      	strb	r2, [r3, #0]
 800a6e2:	f7fd b9dc 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 800a6e6:	a36e      	add	r3, pc, #440	; (adr r3, 800a8a0 <GUI_Touch_Processing+0x2f20>)
 800a6e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a6ec:	4630      	mov	r0, r6
 800a6ee:	4639      	mov	r1, r7
 800a6f0:	f04f 0501 	mov.w	r5, #1
 800a6f4:	f7f6 fa12 	bl	8000b1c <__aeabi_dcmpge>
 800a6f8:	b900      	cbnz	r0, 800a6fc <GUI_Touch_Processing+0x2d7c>
 800a6fa:	4605      	mov	r5, r0
 800a6fc:	a36a      	add	r3, pc, #424	; (adr r3, 800a8a8 <GUI_Touch_Processing+0x2f28>)
 800a6fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a702:	4630      	mov	r0, r6
 800a704:	4639      	mov	r1, r7
 800a706:	f04f 0901 	mov.w	r9, #1
 800a70a:	f7f6 f9fd 	bl	8000b08 <__aeabi_dcmple>
 800a70e:	b900      	cbnz	r0, 800a712 <GUI_Touch_Processing+0x2d92>
 800a710:	4681      	mov	r9, r0
 800a712:	ea05 0309 	and.w	r3, r5, r9
 800a716:	07df      	lsls	r7, r3, #31
 800a718:	d502      	bpl.n	800a720 <GUI_Touch_Processing+0x2da0>
 800a71a:	2c00      	cmp	r4, #0
 800a71c:	f47d a9fc 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=80*TS_Callib & Touch_y <=(120)*TS_Callib) // Language change
 800a720:	2200      	movs	r2, #0
 800a722:	4b74      	ldr	r3, [pc, #464]	; (800a8f4 <GUI_Touch_Processing+0x2f74>)
 800a724:	4650      	mov	r0, sl
 800a726:	4659      	mov	r1, fp
 800a728:	f04f 0401 	mov.w	r4, #1
 800a72c:	f7f6 f9f6 	bl	8000b1c <__aeabi_dcmpge>
 800a730:	b900      	cbnz	r0, 800a734 <GUI_Touch_Processing+0x2db4>
 800a732:	4604      	mov	r4, r0
 800a734:	a35e      	add	r3, pc, #376	; (adr r3, 800a8b0 <GUI_Touch_Processing+0x2f30>)
 800a736:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a73a:	4650      	mov	r0, sl
 800a73c:	4659      	mov	r1, fp
 800a73e:	f04f 0501 	mov.w	r5, #1
 800a742:	f7f6 f9e1 	bl	8000b08 <__aeabi_dcmple>
 800a746:	b900      	cbnz	r0, 800a74a <GUI_Touch_Processing+0x2dca>
 800a748:	4605      	mov	r5, r0
 800a74a:	402c      	ands	r4, r5
 800a74c:	07e6      	lsls	r6, r4, #31
 800a74e:	f57d a9a6 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a752:	9b03      	ldr	r3, [sp, #12]
 800a754:	2b00      	cmp	r3, #0
 800a756:	f47f ac5f 	bne.w	800a018 <GUI_Touch_Processing+0x2698>
 800a75a:	f7fd b9a0 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					preGUI_screen_state = GUI_screen_state;
 800a75e:	4b66      	ldr	r3, [pc, #408]	; (800a8f8 <GUI_Touch_Processing+0x2f78>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a760:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 800a764:	220f      	movs	r2, #15
 800a766:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //next
 800a768:	f7f5 feec 	bl	8000544 <__aeabi_i2d>
 800a76c:	4606      	mov	r6, r0
 800a76e:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800a772:	460f      	mov	r7, r1
 800a774:	f7f5 fee6 	bl	8000544 <__aeabi_i2d>
 800a778:	a34f      	add	r3, pc, #316	; (adr r3, 800a8b8 <GUI_Touch_Processing+0x2f38>)
 800a77a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a77e:	e9cd 0100 	strd	r0, r1, [sp]
 800a782:	f04f 0901 	mov.w	r9, #1
 800a786:	f7f6 f9c9 	bl	8000b1c <__aeabi_dcmpge>
 800a78a:	b900      	cbnz	r0, 800a78e <GUI_Touch_Processing+0x2e0e>
 800a78c:	4681      	mov	r9, r0
 800a78e:	2200      	movs	r2, #0
 800a790:	4b5a      	ldr	r3, [pc, #360]	; (800a8fc <GUI_Touch_Processing+0x2f7c>)
 800a792:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a796:	fa5f f989 	uxtb.w	r9, r9
 800a79a:	f04f 0501 	mov.w	r5, #1
 800a79e:	f7f6 f9b3 	bl	8000b08 <__aeabi_dcmple>
 800a7a2:	b900      	cbnz	r0, 800a7a6 <GUI_Touch_Processing+0x2e26>
 800a7a4:	4605      	mov	r5, r0
 800a7a6:	a346      	add	r3, pc, #280	; (adr r3, 800a8c0 <GUI_Touch_Processing+0x2f40>)
 800a7a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7ac:	4630      	mov	r0, r6
 800a7ae:	4639      	mov	r1, r7
 800a7b0:	b2ed      	uxtb	r5, r5
 800a7b2:	f04f 0801 	mov.w	r8, #1
 800a7b6:	f7f6 f9b1 	bl	8000b1c <__aeabi_dcmpge>
 800a7ba:	b900      	cbnz	r0, 800a7be <GUI_Touch_Processing+0x2e3e>
 800a7bc:	4680      	mov	r8, r0
 800a7be:	a332      	add	r3, pc, #200	; (adr r3, 800a888 <GUI_Touch_Processing+0x2f08>)
 800a7c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7c4:	4630      	mov	r0, r6
 800a7c6:	4639      	mov	r1, r7
 800a7c8:	f04f 0a01 	mov.w	sl, #1
 800a7cc:	f7f6 f99c 	bl	8000b08 <__aeabi_dcmple>
 800a7d0:	b900      	cbnz	r0, 800a7d4 <GUI_Touch_Processing+0x2e54>
 800a7d2:	4682      	mov	sl, r0
 800a7d4:	ea08 080a 	and.w	r8, r8, sl
 800a7d8:	ea19 0f08 	tst.w	r9, r8
 800a7dc:	d004      	beq.n	800a7e8 <GUI_Touch_Processing+0x2e68>
 800a7de:	b11d      	cbz	r5, 800a7e8 <GUI_Touch_Processing+0x2e68>
					GUI_screen_state = ColorSet1_Screen;
 800a7e0:	230e      	movs	r3, #14
 800a7e2:	7023      	strb	r3, [r4, #0]
 800a7e4:	f7fd b95b 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=70*TS_Callib & Touch_y <=(70+54)*TS_Callib) //Color_CIE_Luv
 800a7e8:	a337      	add	r3, pc, #220	; (adr r3, 800a8c8 <GUI_Touch_Processing+0x2f48>)
 800a7ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7ee:	4630      	mov	r0, r6
 800a7f0:	4639      	mov	r1, r7
 800a7f2:	f04f 0801 	mov.w	r8, #1
 800a7f6:	f7f6 f991 	bl	8000b1c <__aeabi_dcmpge>
 800a7fa:	b900      	cbnz	r0, 800a7fe <GUI_Touch_Processing+0x2e7e>
 800a7fc:	4680      	mov	r8, r0
 800a7fe:	a334      	add	r3, pc, #208	; (adr r3, 800a8d0 <GUI_Touch_Processing+0x2f50>)
 800a800:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a804:	4630      	mov	r0, r6
 800a806:	4639      	mov	r1, r7
 800a808:	f04f 0a01 	mov.w	sl, #1
 800a80c:	f7f6 f97c 	bl	8000b08 <__aeabi_dcmple>
 800a810:	b900      	cbnz	r0, 800a814 <GUI_Touch_Processing+0x2e94>
 800a812:	4682      	mov	sl, r0
 800a814:	ea08 080a 	and.w	r8, r8, sl
 800a818:	a32f      	add	r3, pc, #188	; (adr r3, 800a8d8 <GUI_Touch_Processing+0x2f58>)
 800a81a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a81e:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a822:	fa5f f888 	uxtb.w	r8, r8
 800a826:	f04f 0a01 	mov.w	sl, #1
 800a82a:	f7f6 f977 	bl	8000b1c <__aeabi_dcmpge>
 800a82e:	b900      	cbnz	r0, 800a832 <GUI_Touch_Processing+0x2eb2>
 800a830:	4682      	mov	sl, r0
 800a832:	a32b      	add	r3, pc, #172	; (adr r3, 800a8e0 <GUI_Touch_Processing+0x2f60>)
 800a834:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a838:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a83c:	f04f 0b01 	mov.w	fp, #1
 800a840:	f7f6 f962 	bl	8000b08 <__aeabi_dcmple>
 800a844:	b900      	cbnz	r0, 800a848 <GUI_Touch_Processing+0x2ec8>
 800a846:	4683      	mov	fp, r0
 800a848:	ea0a 0a0b 	and.w	sl, sl, fp
 800a84c:	f01a 0f01 	tst.w	sl, #1
 800a850:	d06a      	beq.n	800a928 <GUI_Touch_Processing+0x2fa8>
 800a852:	f1b8 0f00 	cmp.w	r8, #0
 800a856:	d067      	beq.n	800a928 <GUI_Touch_Processing+0x2fa8>
					if(!(Color_Field&Color_CIE_Luv))
 800a858:	4c23      	ldr	r4, [pc, #140]	; (800a8e8 <GUI_Touch_Processing+0x2f68>)
 800a85a:	7823      	ldrb	r3, [r4, #0]
 800a85c:	075d      	lsls	r5, r3, #29
 800a85e:	f53d a91e 	bmi.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 70, Color_Field|=Color_CIE_Luv, 0x01);
 800a862:	2204      	movs	r2, #4
 800a864:	2301      	movs	r3, #1
 800a866:	2146      	movs	r1, #70	; 0x46
 800a868:	20c8      	movs	r0, #200	; 0xc8
 800a86a:	7022      	strb	r2, [r4, #0]
 800a86c:	f001 f979 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 133, Color_Field&Color_CIE_Lab, 0x01);
 800a870:	7822      	ldrb	r2, [r4, #0]
 800a872:	2301      	movs	r3, #1
 800a874:	f002 0202 	and.w	r2, r2, #2
 800a878:	2185      	movs	r1, #133	; 0x85
 800a87a:	20c8      	movs	r0, #200	; 0xc8
 800a87c:	f001 f971 	bl	800bb62 <GUI_RadioBox>
 800a880:	f7fd b90d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800a884:	f3af 8000 	nop.w
 800a888:	66666666 	.word	0x66666666
 800a88c:	4081f866 	.word	0x4081f866
 800a890:	33333333 	.word	0x33333333
 800a894:	40867133 	.word	0x40867133
 800a898:	33333333 	.word	0x33333333
 800a89c:	40053333 	.word	0x40053333
 800a8a0:	00000000 	.word	0x00000000
 800a8a4:	40623800 	.word	0x40623800
 800a8a8:	99999999 	.word	0x99999999
 800a8ac:	40720d99 	.word	0x40720d99
 800a8b0:	00000000 	.word	0x00000000
 800a8b4:	4073e000 	.word	0x4073e000
 800a8b8:	99999999 	.word	0x99999999
 800a8bc:	4091a399 	.word	0x4091a399
 800a8c0:	33333333 	.word	0x33333333
 800a8c4:	407aff33 	.word	0x407aff33
 800a8c8:	cccccccd 	.word	0xcccccccd
 800a8cc:	407e24cc 	.word	0x407e24cc
 800a8d0:	33333333 	.word	0x33333333
 800a8d4:	40838b33 	.word	0x40838b33
 800a8d8:	00000000 	.word	0x00000000
 800a8dc:	40673000 	.word	0x40673000
 800a8e0:	99999999 	.word	0x99999999
 800a8e4:	40748999 	.word	0x40748999
 800a8e8:	200002b7 	.word	0x200002b7
 800a8ec:	20084b8d 	.word	0x20084b8d
 800a8f0:	200002b9 	.word	0x200002b9
 800a8f4:	406a8000 	.word	0x406a8000
 800a8f8:	20000176 	.word	0x20000176
 800a8fc:	4093e000 	.word	0x4093e000
 800a900:	33333333 	.word	0x33333333
 800a904:	40353333 	.word	0x40353333
 800a908:	00000000 	.word	0x00000000
 800a90c:	4084b400 	.word	0x4084b400
 800a910:	99999999 	.word	0x99999999
 800a914:	407cd199 	.word	0x407cd199
 800a918:	66666666 	.word	0x66666666
 800a91c:	408b1466 	.word	0x408b1466
 800a920:	33333333 	.word	0x33333333
 800a924:	408f8d33 	.word	0x408f8d33
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=133*TS_Callib & Touch_y <=(133+54)*TS_Callib) //Color_CIE_Lab
 800a928:	a3c7      	add	r3, pc, #796	; (adr r3, 800ac48 <GUI_Touch_Processing+0x32c8>)
 800a92a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a92e:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a932:	f04f 0a01 	mov.w	sl, #1
 800a936:	f7f6 f8f1 	bl	8000b1c <__aeabi_dcmpge>
 800a93a:	b900      	cbnz	r0, 800a93e <GUI_Touch_Processing+0x2fbe>
 800a93c:	4682      	mov	sl, r0
 800a93e:	a3c4      	add	r3, pc, #784	; (adr r3, 800ac50 <GUI_Touch_Processing+0x32d0>)
 800a940:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a944:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a948:	f04f 0b01 	mov.w	fp, #1
 800a94c:	f7f6 f8dc 	bl	8000b08 <__aeabi_dcmple>
 800a950:	b900      	cbnz	r0, 800a954 <GUI_Touch_Processing+0x2fd4>
 800a952:	4683      	mov	fp, r0
 800a954:	ea0a 0a0b 	and.w	sl, sl, fp
 800a958:	f01a 0f01 	tst.w	sl, #1
 800a95c:	d019      	beq.n	800a992 <GUI_Touch_Processing+0x3012>
 800a95e:	f1b8 0f00 	cmp.w	r8, #0
 800a962:	d016      	beq.n	800a992 <GUI_Touch_Processing+0x3012>
					if(!(Color_Field&Color_CIE_Lab))
 800a964:	4cac      	ldr	r4, [pc, #688]	; (800ac18 <GUI_Touch_Processing+0x3298>)
 800a966:	7822      	ldrb	r2, [r4, #0]
 800a968:	f012 0202 	ands.w	r2, r2, #2
 800a96c:	f47d a897 	bne.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(200, 70, Color_Field&Color_CIE_Luv, 0x01);
 800a970:	2301      	movs	r3, #1
 800a972:	2146      	movs	r1, #70	; 0x46
 800a974:	20c8      	movs	r0, #200	; 0xc8
						Color_Field = 0;
 800a976:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(200, 70, Color_Field&Color_CIE_Luv, 0x01);
 800a978:	f001 f8f3 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(200, 133, Color_Field|=Color_CIE_Lab, 0x01);
 800a97c:	7822      	ldrb	r2, [r4, #0]
 800a97e:	2301      	movs	r3, #1
 800a980:	f042 0202 	orr.w	r2, r2, #2
 800a984:	2185      	movs	r1, #133	; 0x85
 800a986:	20c8      	movs	r0, #200	; 0xc8
 800a988:	7022      	strb	r2, [r4, #0]
 800a98a:	f001 f8ea 	bl	800bb62 <GUI_RadioBox>
 800a98e:	f7fd b886 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800a992:	a38b      	add	r3, pc, #556	; (adr r3, 800abc0 <GUI_Touch_Processing+0x3240>)
 800a994:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a998:	4630      	mov	r0, r6
 800a99a:	4639      	mov	r1, r7
 800a99c:	ea09 0505 	and.w	r5, r9, r5
 800a9a0:	f04f 0801 	mov.w	r8, #1
 800a9a4:	f7f6 f8ba 	bl	8000b1c <__aeabi_dcmpge>
 800a9a8:	b900      	cbnz	r0, 800a9ac <GUI_Touch_Processing+0x302c>
 800a9aa:	4680      	mov	r8, r0
 800a9ac:	a386      	add	r3, pc, #536	; (adr r3, 800abc8 <GUI_Touch_Processing+0x3248>)
 800a9ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a9b2:	4630      	mov	r0, r6
 800a9b4:	4639      	mov	r1, r7
 800a9b6:	f04f 0901 	mov.w	r9, #1
 800a9ba:	f7f6 f8a5 	bl	8000b08 <__aeabi_dcmple>
 800a9be:	b900      	cbnz	r0, 800a9c2 <GUI_Touch_Processing+0x3042>
 800a9c0:	4681      	mov	r9, r0
 800a9c2:	ea08 0809 	and.w	r8, r8, r9
 800a9c6:	f018 0f01 	tst.w	r8, #1
 800a9ca:	d002      	beq.n	800a9d2 <GUI_Touch_Processing+0x3052>
 800a9cc:	2d00      	cmp	r5, #0
 800a9ce:	f47d af67 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 800a9d2:	a37f      	add	r3, pc, #508	; (adr r3, 800abd0 <GUI_Touch_Processing+0x3250>)
 800a9d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a9d8:	4630      	mov	r0, r6
 800a9da:	4639      	mov	r1, r7
 800a9dc:	f04f 0801 	mov.w	r8, #1
 800a9e0:	f7f6 f89c 	bl	8000b1c <__aeabi_dcmpge>
 800a9e4:	b900      	cbnz	r0, 800a9e8 <GUI_Touch_Processing+0x3068>
 800a9e6:	4680      	mov	r8, r0
 800a9e8:	a37b      	add	r3, pc, #492	; (adr r3, 800abd8 <GUI_Touch_Processing+0x3258>)
 800a9ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a9ee:	4630      	mov	r0, r6
 800a9f0:	4639      	mov	r1, r7
 800a9f2:	f04f 0901 	mov.w	r9, #1
 800a9f6:	f7f6 f887 	bl	8000b08 <__aeabi_dcmple>
 800a9fa:	b900      	cbnz	r0, 800a9fe <GUI_Touch_Processing+0x307e>
 800a9fc:	4681      	mov	r9, r0
 800a9fe:	ea08 0809 	and.w	r8, r8, r9
 800aa02:	f018 0f01 	tst.w	r8, #1
 800aa06:	d01d      	beq.n	800aa44 <GUI_Touch_Processing+0x30c4>
 800aa08:	b1e5      	cbz	r5, 800aa44 <GUI_Touch_Processing+0x30c4>
					GUI_screen_state = Prev_Inf_Screen;
 800aa0a:	4b84      	ldr	r3, [pc, #528]	; (800ac1c <GUI_Touch_Processing+0x329c>)
 800aa0c:	781b      	ldrb	r3, [r3, #0]
					switch (Prev_Inf_Screen){
 800aa0e:	1e5a      	subs	r2, r3, #1
 800aa10:	2a05      	cmp	r2, #5
 800aa12:	d804      	bhi.n	800aa1e <GUI_Touch_Processing+0x309e>
 800aa14:	e8df f002 	tbb	[pc, r2]
 800aa18:	0a030306 	.word	0x0a030306
 800aa1c:	0e12      	.short	0x0e12
					GUI_screen_state = Prev_Inf_Screen;
 800aa1e:	7023      	strb	r3, [r4, #0]
 800aa20:	f7fd b83d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 800aa24:	2301      	movs	r3, #1
 800aa26:	7023      	strb	r3, [r4, #0]
 800aa28:	f7fd b839 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 800aa2c:	2304      	movs	r3, #4
 800aa2e:	7023      	strb	r3, [r4, #0]
 800aa30:	f7fd b835 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 800aa34:	2306      	movs	r3, #6
 800aa36:	7023      	strb	r3, [r4, #0]
 800aa38:	f7fd b831 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 800aa3c:	2305      	movs	r3, #5
 800aa3e:	7023      	strb	r3, [r4, #0]
 800aa40:	f7fd b82d 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 800aa44:	a364      	add	r3, pc, #400	; (adr r3, 800abd8 <GUI_Touch_Processing+0x3258>)
 800aa46:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa4a:	4630      	mov	r0, r6
 800aa4c:	4639      	mov	r1, r7
 800aa4e:	f04f 0401 	mov.w	r4, #1
 800aa52:	f7f6 f863 	bl	8000b1c <__aeabi_dcmpge>
 800aa56:	b900      	cbnz	r0, 800aa5a <GUI_Touch_Processing+0x30da>
 800aa58:	4604      	mov	r4, r0
 800aa5a:	a361      	add	r3, pc, #388	; (adr r3, 800abe0 <GUI_Touch_Processing+0x3260>)
 800aa5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa60:	4630      	mov	r0, r6
 800aa62:	4639      	mov	r1, r7
 800aa64:	f04f 0801 	mov.w	r8, #1
 800aa68:	f7f6 f84e 	bl	8000b08 <__aeabi_dcmple>
 800aa6c:	b900      	cbnz	r0, 800aa70 <GUI_Touch_Processing+0x30f0>
 800aa6e:	4680      	mov	r8, r0
 800aa70:	ea04 0408 	and.w	r4, r4, r8
 800aa74:	f7fe b92d 	b.w	8008cd2 <GUI_Touch_Processing+0x1352>
					preGUI_screen_state = GUI_screen_state;
 800aa78:	4b69      	ldr	r3, [pc, #420]	; (800ac20 <GUI_Touch_Processing+0x32a0>)
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)//next
 800aa7a:	f8bd 0014 	ldrh.w	r0, [sp, #20]
					preGUI_screen_state = GUI_screen_state;
 800aa7e:	2210      	movs	r2, #16
 800aa80:	701a      	strb	r2, [r3, #0]
				if(Touch_x >= 163*TS_Callib & Touch_x <= (163+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)//next
 800aa82:	f7f5 fd5f 	bl	8000544 <__aeabi_i2d>
 800aa86:	4606      	mov	r6, r0
 800aa88:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800aa8c:	460f      	mov	r7, r1
 800aa8e:	f7f5 fd59 	bl	8000544 <__aeabi_i2d>
 800aa92:	a355      	add	r3, pc, #340	; (adr r3, 800abe8 <GUI_Touch_Processing+0x3268>)
 800aa94:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa98:	4680      	mov	r8, r0
 800aa9a:	4689      	mov	r9, r1
 800aa9c:	f04f 0501 	mov.w	r5, #1
 800aaa0:	f7f6 f83c 	bl	8000b1c <__aeabi_dcmpge>
 800aaa4:	b900      	cbnz	r0, 800aaa8 <GUI_Touch_Processing+0x3128>
 800aaa6:	4605      	mov	r5, r0
 800aaa8:	b2eb      	uxtb	r3, r5
 800aaaa:	9300      	str	r3, [sp, #0]
 800aaac:	2200      	movs	r2, #0
 800aaae:	4b5d      	ldr	r3, [pc, #372]	; (800ac24 <GUI_Touch_Processing+0x32a4>)
 800aab0:	4640      	mov	r0, r8
 800aab2:	4649      	mov	r1, r9
 800aab4:	f04f 0501 	mov.w	r5, #1
 800aab8:	f7f6 f826 	bl	8000b08 <__aeabi_dcmple>
 800aabc:	b900      	cbnz	r0, 800aac0 <GUI_Touch_Processing+0x3140>
 800aabe:	4605      	mov	r5, r0
 800aac0:	b2eb      	uxtb	r3, r5
 800aac2:	9302      	str	r3, [sp, #8]
 800aac4:	4630      	mov	r0, r6
 800aac6:	a34a      	add	r3, pc, #296	; (adr r3, 800abf0 <GUI_Touch_Processing+0x3270>)
 800aac8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aacc:	4639      	mov	r1, r7
 800aace:	f04f 0501 	mov.w	r5, #1
 800aad2:	f7f6 f823 	bl	8000b1c <__aeabi_dcmpge>
 800aad6:	b900      	cbnz	r0, 800aada <GUI_Touch_Processing+0x315a>
 800aad8:	4605      	mov	r5, r0
 800aada:	a339      	add	r3, pc, #228	; (adr r3, 800abc0 <GUI_Touch_Processing+0x3240>)
 800aadc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aae0:	4630      	mov	r0, r6
 800aae2:	4639      	mov	r1, r7
 800aae4:	f04f 0a01 	mov.w	sl, #1
 800aae8:	f7f6 f80e 	bl	8000b08 <__aeabi_dcmple>
 800aaec:	b900      	cbnz	r0, 800aaf0 <GUI_Touch_Processing+0x3170>
 800aaee:	4682      	mov	sl, r0
 800aaf0:	9b00      	ldr	r3, [sp, #0]
 800aaf2:	ea05 050a 	and.w	r5, r5, sl
 800aaf6:	422b      	tst	r3, r5
 800aaf8:	d005      	beq.n	800ab06 <GUI_Touch_Processing+0x3186>
 800aafa:	9b02      	ldr	r3, [sp, #8]
 800aafc:	b11b      	cbz	r3, 800ab06 <GUI_Touch_Processing+0x3186>
					GUI_screen_state = Color_Rendition_Screen;
 800aafe:	2306      	movs	r3, #6
 800ab00:	7023      	strb	r3, [r4, #0]
 800ab02:	f7fc bfcc 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=202*TS_Callib & Touch_y <=(202+54)*TS_Callib) //Mode_EL
 800ab06:	a33c      	add	r3, pc, #240	; (adr r3, 800abf8 <GUI_Touch_Processing+0x3278>)
 800ab08:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab0c:	4630      	mov	r0, r6
 800ab0e:	4639      	mov	r1, r7
 800ab10:	f04f 0501 	mov.w	r5, #1
 800ab14:	f7f6 f802 	bl	8000b1c <__aeabi_dcmpge>
 800ab18:	b900      	cbnz	r0, 800ab1c <GUI_Touch_Processing+0x319c>
 800ab1a:	4605      	mov	r5, r0
 800ab1c:	a338      	add	r3, pc, #224	; (adr r3, 800ac00 <GUI_Touch_Processing+0x3280>)
 800ab1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab22:	4630      	mov	r0, r6
 800ab24:	4639      	mov	r1, r7
 800ab26:	f04f 0a01 	mov.w	sl, #1
 800ab2a:	f7f5 ffed 	bl	8000b08 <__aeabi_dcmple>
 800ab2e:	b900      	cbnz	r0, 800ab32 <GUI_Touch_Processing+0x31b2>
 800ab30:	4682      	mov	sl, r0
 800ab32:	ea05 050a 	and.w	r5, r5, sl
 800ab36:	a334      	add	r3, pc, #208	; (adr r3, 800ac08 <GUI_Touch_Processing+0x3288>)
 800ab38:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab3c:	4640      	mov	r0, r8
 800ab3e:	4649      	mov	r1, r9
 800ab40:	b2ed      	uxtb	r5, r5
 800ab42:	f04f 0a01 	mov.w	sl, #1
 800ab46:	f7f5 ffe9 	bl	8000b1c <__aeabi_dcmpge>
 800ab4a:	b900      	cbnz	r0, 800ab4e <GUI_Touch_Processing+0x31ce>
 800ab4c:	4682      	mov	sl, r0
 800ab4e:	a330      	add	r3, pc, #192	; (adr r3, 800ac10 <GUI_Touch_Processing+0x3290>)
 800ab50:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab54:	4640      	mov	r0, r8
 800ab56:	4649      	mov	r1, r9
 800ab58:	f04f 0b01 	mov.w	fp, #1
 800ab5c:	f7f5 ffd4 	bl	8000b08 <__aeabi_dcmple>
 800ab60:	b900      	cbnz	r0, 800ab64 <GUI_Touch_Processing+0x31e4>
 800ab62:	4683      	mov	fp, r0
 800ab64:	ea0a 0a0b 	and.w	sl, sl, fp
 800ab68:	f01a 0f01 	tst.w	sl, #1
 800ab6c:	d074      	beq.n	800ac58 <GUI_Touch_Processing+0x32d8>
 800ab6e:	2d00      	cmp	r5, #0
 800ab70:	d072      	beq.n	800ac58 <GUI_Touch_Processing+0x32d8>
					Mode_EL = !Mode_EL;
 800ab72:	4c2d      	ldr	r4, [pc, #180]	; (800ac28 <GUI_Touch_Processing+0x32a8>)
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800ab74:	4b2d      	ldr	r3, [pc, #180]	; (800ac2c <GUI_Touch_Processing+0x32ac>)
					Mode_EL = !Mode_EL;
 800ab76:	7822      	ldrb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800ab78:	482d      	ldr	r0, [pc, #180]	; (800ac30 <GUI_Touch_Processing+0x32b0>)
					Mode_EL = !Mode_EL;
 800ab7a:	2a00      	cmp	r2, #0
 800ab7c:	bf0c      	ite	eq
 800ab7e:	2201      	moveq	r2, #1
 800ab80:	2200      	movne	r2, #0
 800ab82:	7022      	strb	r2, [r4, #0]
					Calibration_Load_Pack(Mode_EL == 0x00 ? SPECTRAL_CORRECTION_L:SPECTRAL_CORRECTION_E, 0x400, Spectral_Corection_Buff);
 800ab84:	bf18      	it	ne
 800ab86:	4618      	movne	r0, r3
 800ab88:	4a2a      	ldr	r2, [pc, #168]	; (800ac34 <GUI_Touch_Processing+0x32b4>)
 800ab8a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800ab8e:	f7fb fb77 	bl	8006280 <Calibration_Load_Pack>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800ab92:	7822      	ldrb	r2, [r4, #0]
 800ab94:	4b28      	ldr	r3, [pc, #160]	; (800ac38 <GUI_Touch_Processing+0x32b8>)
 800ab96:	b982      	cbnz	r2, 800abba <GUI_Touch_Processing+0x323a>
 800ab98:	4a28      	ldr	r2, [pc, #160]	; (800ac3c <GUI_Touch_Processing+0x32bc>)
 800ab9a:	edd2 0a00 	vldr	s1, [r2]
 800ab9e:	ed93 0a00 	vldr	s0, [r3]
 800aba2:	f005 fc5d 	bl	8010460 <Rabs_calc_Factor2_Settings_change>
 800aba6:	4b26      	ldr	r3, [pc, #152]	; (800ac40 <GUI_Touch_Processing+0x32c0>)
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 800aba8:	7822      	ldrb	r2, [r4, #0]
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800abaa:	ed83 0a00 	vstr	s0, [r3]
					GUI_Switch_ButtonActive(182, 202, Mode_EL);
 800abae:	21ca      	movs	r1, #202	; 0xca
 800abb0:	20b6      	movs	r0, #182	; 0xb6
 800abb2:	f001 f85f 	bl	800bc74 <GUI_Switch_ButtonActive>
 800abb6:	f7fc bf72 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
					Factor2 = (Mode_EL == 0x00 ? Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_L) : Rabs_calc_Factor2_Settings_change(Exposure_Factor, EnergyFactor_E));
 800abba:	4a22      	ldr	r2, [pc, #136]	; (800ac44 <GUI_Touch_Processing+0x32c4>)
 800abbc:	e7ed      	b.n	800ab9a <GUI_Touch_Processing+0x321a>
 800abbe:	bf00      	nop
 800abc0:	66666666 	.word	0x66666666
 800abc4:	4081f866 	.word	0x4081f866
 800abc8:	33333333 	.word	0x33333333
 800abcc:	40867133 	.word	0x40867133
 800abd0:	33333333 	.word	0x33333333
 800abd4:	40053333 	.word	0x40053333
 800abd8:	00000000 	.word	0x00000000
 800abdc:	40623800 	.word	0x40623800
 800abe0:	99999999 	.word	0x99999999
 800abe4:	40720d99 	.word	0x40720d99
 800abe8:	99999999 	.word	0x99999999
 800abec:	4091a399 	.word	0x4091a399
 800abf0:	33333333 	.word	0x33333333
 800abf4:	407aff33 	.word	0x407aff33
 800abf8:	cccccccd 	.word	0xcccccccd
 800abfc:	407e24cc 	.word	0x407e24cc
 800ac00:	33333333 	.word	0x33333333
 800ac04:	40838b33 	.word	0x40838b33
 800ac08:	66666666 	.word	0x66666666
 800ac0c:	4080ba66 	.word	0x4080ba66
 800ac10:	33333333 	.word	0x33333333
 800ac14:	40853333 	.word	0x40853333
 800ac18:	200002b7 	.word	0x200002b7
 800ac1c:	20084b8d 	.word	0x20084b8d
 800ac20:	20000176 	.word	0x20000176
 800ac24:	4093e000 	.word	0x4093e000
 800ac28:	2000019c 	.word	0x2000019c
 800ac2c:	08101838 	.word	0x08101838
 800ac30:	08100838 	.word	0x08100838
 800ac34:	20081b18 	.word	0x20081b18
 800ac38:	2000030c 	.word	0x2000030c
 800ac3c:	20000308 	.word	0x20000308
 800ac40:	20000310 	.word	0x20000310
 800ac44:	20000304 	.word	0x20000304
 800ac48:	33333333 	.word	0x33333333
 800ac4c:	40760733 	.word	0x40760733
 800ac50:	cccccccd 	.word	0xcccccccd
 800ac54:	407ef8cc 	.word	0x407ef8cc
				if(Touch_x >= 182*TS_Callib & Touch_x <= (182+54)*TS_Callib & Touch_y >=268*TS_Callib & Touch_y <=(268+54)*TS_Callib) //Bluetooth
 800ac58:	a3c1      	add	r3, pc, #772	; (adr r3, 800af60 <GUI_Touch_Processing+0x35e0>)
 800ac5a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac5e:	4640      	mov	r0, r8
 800ac60:	4649      	mov	r1, r9
 800ac62:	f04f 0a01 	mov.w	sl, #1
 800ac66:	f7f5 ff59 	bl	8000b1c <__aeabi_dcmpge>
 800ac6a:	b900      	cbnz	r0, 800ac6e <GUI_Touch_Processing+0x32ee>
 800ac6c:	4682      	mov	sl, r0
 800ac6e:	a3be      	add	r3, pc, #760	; (adr r3, 800af68 <GUI_Touch_Processing+0x35e8>)
 800ac70:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac74:	4640      	mov	r0, r8
 800ac76:	4649      	mov	r1, r9
 800ac78:	f04f 0b01 	mov.w	fp, #1
 800ac7c:	f7f5 ff44 	bl	8000b08 <__aeabi_dcmple>
 800ac80:	b900      	cbnz	r0, 800ac84 <GUI_Touch_Processing+0x3304>
 800ac82:	4683      	mov	fp, r0
 800ac84:	ea0a 0a0b 	and.w	sl, sl, fp
 800ac88:	f01a 0f01 	tst.w	sl, #1
 800ac8c:	d00f      	beq.n	800acae <GUI_Touch_Processing+0x332e>
 800ac8e:	b175      	cbz	r5, 800acae <GUI_Touch_Processing+0x332e>
					Bluetooth = !Bluetooth;
 800ac90:	4baf      	ldr	r3, [pc, #700]	; (800af50 <GUI_Touch_Processing+0x35d0>)
 800ac92:	781a      	ldrb	r2, [r3, #0]
 800ac94:	fab2 f282 	clz	r2, r2
 800ac98:	0952      	lsrs	r2, r2, #5
					GUI_Switch_Button(182, 268, Bluetooth);
 800ac9a:	f44f 7186 	mov.w	r1, #268	; 0x10c
 800ac9e:	20b6      	movs	r0, #182	; 0xb6
					Bluetooth = !Bluetooth;
 800aca0:	701a      	strb	r2, [r3, #0]
					GUI_Switch_Button(182, 268, Bluetooth);
 800aca2:	f000 ff8d 	bl	800bbc0 <GUI_Switch_Button>
					GUI_Up_Panel();
 800aca6:	f7fb fea9 	bl	80069fc <GUI_Up_Panel>
 800acaa:	f7fc bef8 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=124*TS_Callib & Touch_y <=(174)*TS_Callib) // Information
 800acae:	a38c      	add	r3, pc, #560	; (adr r3, 800aee0 <GUI_Touch_Processing+0x3560>)
 800acb0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800acb4:	4630      	mov	r0, r6
 800acb6:	4639      	mov	r1, r7
 800acb8:	f04f 0501 	mov.w	r5, #1
 800acbc:	f7f5 ff2e 	bl	8000b1c <__aeabi_dcmpge>
 800acc0:	b900      	cbnz	r0, 800acc4 <GUI_Touch_Processing+0x3344>
 800acc2:	4605      	mov	r5, r0
 800acc4:	a388      	add	r3, pc, #544	; (adr r3, 800aee8 <GUI_Touch_Processing+0x3568>)
 800acc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800acca:	4630      	mov	r0, r6
 800accc:	4639      	mov	r1, r7
 800acce:	f04f 0a01 	mov.w	sl, #1
 800acd2:	f7f5 ff19 	bl	8000b08 <__aeabi_dcmple>
 800acd6:	b900      	cbnz	r0, 800acda <GUI_Touch_Processing+0x335a>
 800acd8:	4682      	mov	sl, r0
 800acda:	ea05 050a 	and.w	r5, r5, sl
 800acde:	a384      	add	r3, pc, #528	; (adr r3, 800aef0 <GUI_Touch_Processing+0x3570>)
 800ace0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ace4:	4640      	mov	r0, r8
 800ace6:	4649      	mov	r1, r9
 800ace8:	b2ed      	uxtb	r5, r5
 800acea:	f04f 0a01 	mov.w	sl, #1
 800acee:	f7f5 ff15 	bl	8000b1c <__aeabi_dcmpge>
 800acf2:	b900      	cbnz	r0, 800acf6 <GUI_Touch_Processing+0x3376>
 800acf4:	4682      	mov	sl, r0
 800acf6:	a380      	add	r3, pc, #512	; (adr r3, 800aef8 <GUI_Touch_Processing+0x3578>)
 800acf8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800acfc:	4640      	mov	r0, r8
 800acfe:	4649      	mov	r1, r9
 800ad00:	f04f 0b01 	mov.w	fp, #1
 800ad04:	f7f5 ff00 	bl	8000b08 <__aeabi_dcmple>
 800ad08:	b900      	cbnz	r0, 800ad0c <GUI_Touch_Processing+0x338c>
 800ad0a:	4683      	mov	fp, r0
 800ad0c:	ea0a 0a0b 	and.w	sl, sl, fp
 800ad10:	f01a 0f01 	tst.w	sl, #1
 800ad14:	d002      	beq.n	800ad1c <GUI_Touch_Processing+0x339c>
 800ad16:	2d00      	cmp	r5, #0
 800ad18:	f47f a9ab 	bne.w	800a072 <GUI_Touch_Processing+0x26f2>
				if(Touch_x >= 185*TS_Callib & Touch_x <= (185+54)*TS_Callib & Touch_y >=318*TS_Callib & Touch_y <=(318+54)*TS_Callib) //CRI
 800ad1c:	a378      	add	r3, pc, #480	; (adr r3, 800af00 <GUI_Touch_Processing+0x3580>)
 800ad1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ad22:	4630      	mov	r0, r6
 800ad24:	4639      	mov	r1, r7
 800ad26:	f04f 0401 	mov.w	r4, #1
 800ad2a:	f7f5 fef7 	bl	8000b1c <__aeabi_dcmpge>
 800ad2e:	b900      	cbnz	r0, 800ad32 <GUI_Touch_Processing+0x33b2>
 800ad30:	4604      	mov	r4, r0
 800ad32:	a375      	add	r3, pc, #468	; (adr r3, 800af08 <GUI_Touch_Processing+0x3588>)
 800ad34:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ad38:	4630      	mov	r0, r6
 800ad3a:	4639      	mov	r1, r7
 800ad3c:	f04f 0a01 	mov.w	sl, #1
 800ad40:	f7f5 fee2 	bl	8000b08 <__aeabi_dcmple>
 800ad44:	b900      	cbnz	r0, 800ad48 <GUI_Touch_Processing+0x33c8>
 800ad46:	4682      	mov	sl, r0
 800ad48:	ea04 040a 	and.w	r4, r4, sl
 800ad4c:	a370      	add	r3, pc, #448	; (adr r3, 800af10 <GUI_Touch_Processing+0x3590>)
 800ad4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ad52:	4640      	mov	r0, r8
 800ad54:	4649      	mov	r1, r9
 800ad56:	b2e4      	uxtb	r4, r4
 800ad58:	f04f 0a01 	mov.w	sl, #1
 800ad5c:	f7f5 fede 	bl	8000b1c <__aeabi_dcmpge>
 800ad60:	b900      	cbnz	r0, 800ad64 <GUI_Touch_Processing+0x33e4>
 800ad62:	4682      	mov	sl, r0
 800ad64:	a36c      	add	r3, pc, #432	; (adr r3, 800af18 <GUI_Touch_Processing+0x3598>)
 800ad66:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ad6a:	4640      	mov	r0, r8
 800ad6c:	4649      	mov	r1, r9
 800ad6e:	f04f 0b01 	mov.w	fp, #1
 800ad72:	f7f5 fec9 	bl	8000b08 <__aeabi_dcmple>
 800ad76:	b900      	cbnz	r0, 800ad7a <GUI_Touch_Processing+0x33fa>
 800ad78:	4683      	mov	fp, r0
 800ad7a:	ea0a 0a0b 	and.w	sl, sl, fp
 800ad7e:	f01a 0f01 	tst.w	sl, #1
 800ad82:	d01a      	beq.n	800adba <GUI_Touch_Processing+0x343a>
 800ad84:	b1cc      	cbz	r4, 800adba <GUI_Touch_Processing+0x343a>
					if(!(Color_rend_Field & CRI_CQS)){
 800ad86:	4c73      	ldr	r4, [pc, #460]	; (800af54 <GUI_Touch_Processing+0x35d4>)
 800ad88:	7822      	ldrb	r2, [r4, #0]
 800ad8a:	07d0      	lsls	r0, r2, #31
 800ad8c:	f53c ae87 	bmi.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 800ad90:	2301      	movs	r3, #1
						Color_rend_Field ^= CRI_CQS;
 800ad92:	f082 0201 	eor.w	r2, r2, #1
 800ad96:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 800ad98:	f44f 719f 	mov.w	r1, #318	; 0x13e
 800ad9c:	401a      	ands	r2, r3
 800ad9e:	20b9      	movs	r0, #185	; 0xb9
 800ada0:	f000 fedf 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(185, 362, !(Color_rend_Field&CRI_CQS), 0x01);
 800ada4:	7822      	ldrb	r2, [r4, #0]
 800ada6:	2301      	movs	r3, #1
 800ada8:	43d2      	mvns	r2, r2
 800adaa:	401a      	ands	r2, r3
 800adac:	f44f 71b5 	mov.w	r1, #362	; 0x16a
 800adb0:	20b9      	movs	r0, #185	; 0xb9
 800adb2:	f000 fed6 	bl	800bb62 <GUI_RadioBox>
 800adb6:	f7fc be72 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
				if(Touch_x >= 185*TS_Callib & Touch_x <= (185+54)*TS_Callib & Touch_y >=362*TS_Callib & Touch_y <=(362+54)*TS_Callib) //CQS
 800adba:	a359      	add	r3, pc, #356	; (adr r3, 800af20 <GUI_Touch_Processing+0x35a0>)
 800adbc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800adc0:	4640      	mov	r0, r8
 800adc2:	4649      	mov	r1, r9
 800adc4:	f04f 0a01 	mov.w	sl, #1
 800adc8:	f7f5 fea8 	bl	8000b1c <__aeabi_dcmpge>
 800adcc:	b900      	cbnz	r0, 800add0 <GUI_Touch_Processing+0x3450>
 800adce:	4682      	mov	sl, r0
 800add0:	a355      	add	r3, pc, #340	; (adr r3, 800af28 <GUI_Touch_Processing+0x35a8>)
 800add2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800add6:	4640      	mov	r0, r8
 800add8:	4649      	mov	r1, r9
 800adda:	f04f 0b01 	mov.w	fp, #1
 800adde:	f7f5 fe93 	bl	8000b08 <__aeabi_dcmple>
 800ade2:	b900      	cbnz	r0, 800ade6 <GUI_Touch_Processing+0x3466>
 800ade4:	4683      	mov	fp, r0
 800ade6:	ea0a 0a0b 	and.w	sl, sl, fp
 800adea:	f01a 0f01 	tst.w	sl, #1
 800adee:	d01a      	beq.n	800ae26 <GUI_Touch_Processing+0x34a6>
 800adf0:	b1cc      	cbz	r4, 800ae26 <GUI_Touch_Processing+0x34a6>
					if((Color_rend_Field&CRI_CQS)){
 800adf2:	4c58      	ldr	r4, [pc, #352]	; (800af54 <GUI_Touch_Processing+0x35d4>)
 800adf4:	7822      	ldrb	r2, [r4, #0]
 800adf6:	07d1      	lsls	r1, r2, #31
 800adf8:	f57c ae51 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
						GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 800adfc:	2301      	movs	r3, #1
						Color_rend_Field ^= CRI_CQS;
 800adfe:	f082 0201 	eor.w	r2, r2, #1
 800ae02:	7022      	strb	r2, [r4, #0]
						GUI_RadioBox(185, 318, Color_rend_Field&CRI_CQS, 0x01);
 800ae04:	f44f 719f 	mov.w	r1, #318	; 0x13e
 800ae08:	401a      	ands	r2, r3
 800ae0a:	20b9      	movs	r0, #185	; 0xb9
 800ae0c:	f000 fea9 	bl	800bb62 <GUI_RadioBox>
						GUI_RadioBox(185, 362, !(Color_rend_Field&CRI_CQS), 0x01);
 800ae10:	7822      	ldrb	r2, [r4, #0]
 800ae12:	2301      	movs	r3, #1
 800ae14:	43d2      	mvns	r2, r2
 800ae16:	401a      	ands	r2, r3
 800ae18:	f44f 71b5 	mov.w	r1, #362	; 0x16a
 800ae1c:	20b9      	movs	r0, #185	; 0xb9
 800ae1e:	f000 fea0 	bl	800bb62 <GUI_RadioBox>
 800ae22:	f7fc be3c 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800ae26:	9b02      	ldr	r3, [sp, #8]
 800ae28:	9c00      	ldr	r4, [sp, #0]
				if(Touch_x >= 217*TS_Callib & Touch_x <= (217+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Display_Off
 800ae2a:	4630      	mov	r0, r6
 800ae2c:	401c      	ands	r4, r3
 800ae2e:	4639      	mov	r1, r7
 800ae30:	a33f      	add	r3, pc, #252	; (adr r3, 800af30 <GUI_Touch_Processing+0x35b0>)
 800ae32:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae36:	f04f 0a01 	mov.w	sl, #1
 800ae3a:	f7f5 fe6f 	bl	8000b1c <__aeabi_dcmpge>
 800ae3e:	b900      	cbnz	r0, 800ae42 <GUI_Touch_Processing+0x34c2>
 800ae40:	4682      	mov	sl, r0
 800ae42:	a33d      	add	r3, pc, #244	; (adr r3, 800af38 <GUI_Touch_Processing+0x35b8>)
 800ae44:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae48:	4630      	mov	r0, r6
 800ae4a:	4639      	mov	r1, r7
 800ae4c:	f04f 0b01 	mov.w	fp, #1
 800ae50:	f7f5 fe5a 	bl	8000b08 <__aeabi_dcmple>
 800ae54:	b900      	cbnz	r0, 800ae58 <GUI_Touch_Processing+0x34d8>
 800ae56:	4683      	mov	fp, r0
 800ae58:	ea0a 030b 	and.w	r3, sl, fp
 800ae5c:	07da      	lsls	r2, r3, #31
 800ae5e:	d502      	bpl.n	800ae66 <GUI_Touch_Processing+0x34e6>
 800ae60:	2c00      	cmp	r4, #0
 800ae62:	f47d ad1d 	bne.w	80088a0 <GUI_Touch_Processing+0xf20>
				if(Touch_x >= 1*TS_Callib & Touch_x <= (1+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //Back
 800ae66:	a336      	add	r3, pc, #216	; (adr r3, 800af40 <GUI_Touch_Processing+0x35c0>)
 800ae68:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae6c:	4630      	mov	r0, r6
 800ae6e:	4639      	mov	r1, r7
 800ae70:	f04f 0a01 	mov.w	sl, #1
 800ae74:	f7f5 fe52 	bl	8000b1c <__aeabi_dcmpge>
 800ae78:	b900      	cbnz	r0, 800ae7c <GUI_Touch_Processing+0x34fc>
 800ae7a:	4682      	mov	sl, r0
 800ae7c:	a332      	add	r3, pc, #200	; (adr r3, 800af48 <GUI_Touch_Processing+0x35c8>)
 800ae7e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae82:	4630      	mov	r0, r6
 800ae84:	4639      	mov	r1, r7
 800ae86:	f04f 0b01 	mov.w	fp, #1
 800ae8a:	f7f5 fe3d 	bl	8000b08 <__aeabi_dcmple>
 800ae8e:	b900      	cbnz	r0, 800ae92 <GUI_Touch_Processing+0x3512>
 800ae90:	4683      	mov	fp, r0
 800ae92:	ea0a 030b 	and.w	r3, sl, fp
 800ae96:	07db      	lsls	r3, r3, #31
 800ae98:	d56a      	bpl.n	800af70 <GUI_Touch_Processing+0x35f0>
 800ae9a:	2c00      	cmp	r4, #0
 800ae9c:	d068      	beq.n	800af70 <GUI_Touch_Processing+0x35f0>
					GUI_screen_state = Prev_Inf_Screen;
 800ae9e:	4b2e      	ldr	r3, [pc, #184]	; (800af58 <GUI_Touch_Processing+0x35d8>)
 800aea0:	781a      	ldrb	r2, [r3, #0]
 800aea2:	4b2e      	ldr	r3, [pc, #184]	; (800af5c <GUI_Touch_Processing+0x35dc>)
					switch (Prev_Inf_Screen){
 800aea4:	1e51      	subs	r1, r2, #1
 800aea6:	2905      	cmp	r1, #5
 800aea8:	d804      	bhi.n	800aeb4 <GUI_Touch_Processing+0x3534>
 800aeaa:	e8df f001 	tbb	[pc, r1]
 800aeae:	0306      	.short	0x0306
 800aeb0:	0e120a03 	.word	0x0e120a03
					GUI_screen_state = Prev_Inf_Screen;
 800aeb4:	701a      	strb	r2, [r3, #0]
 800aeb6:	f7fc bdf2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Measure_Screen: GUI_screen_state = Measure_Screen; 		break;
 800aeba:	2201      	movs	r2, #1
 800aebc:	701a      	strb	r2, [r3, #0]
 800aebe:	f7fc bdee 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Graph_Screen:  GUI_screen_state = Graph_Screen; 		break;
 800aec2:	2204      	movs	r2, #4
 800aec4:	701a      	strb	r2, [r3, #0]
 800aec6:	f7fc bdea 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Rendition_Screen: GUI_screen_state = Color_Rendition_Screen; break;
 800aeca:	2206      	movs	r2, #6
 800aecc:	701a      	strb	r2, [r3, #0]
 800aece:	f7fc bde6 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case Color_Screen: GUI_screen_state = Color_Screen; break;
 800aed2:	2205      	movs	r2, #5
 800aed4:	701a      	strb	r2, [r3, #0]
 800aed6:	f7fc bde2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800aeda:	bf00      	nop
 800aedc:	f3af 8000 	nop.w
 800aee0:	33333333 	.word	0x33333333
 800aee4:	40353333 	.word	0x40353333
 800aee8:	00000000 	.word	0x00000000
 800aeec:	4084b400 	.word	0x4084b400
 800aef0:	99999999 	.word	0x99999999
 800aef4:	40748999 	.word	0x40748999
 800aef8:	99999999 	.word	0x99999999
 800aefc:	407cd199 	.word	0x407cd199
 800af00:	00000000 	.word	0x00000000
 800af04:	407ea400 	.word	0x407ea400
 800af08:	cccccccd 	.word	0xcccccccd
 800af0c:	4083cacc 	.word	0x4083cacc
 800af10:	99999999 	.word	0x99999999
 800af14:	408a5599 	.word	0x408a5599
 800af18:	66666666 	.word	0x66666666
 800af1c:	408ece66 	.word	0x408ece66
 800af20:	66666666 	.word	0x66666666
 800af24:	408dfa66 	.word	0x408dfa66
 800af28:	99999999 	.word	0x99999999
 800af2c:	40913999 	.word	0x40913999
 800af30:	66666666 	.word	0x66666666
 800af34:	4081f866 	.word	0x4081f866
 800af38:	33333333 	.word	0x33333333
 800af3c:	40867133 	.word	0x40867133
 800af40:	33333333 	.word	0x33333333
 800af44:	40053333 	.word	0x40053333
 800af48:	00000000 	.word	0x00000000
 800af4c:	40623800 	.word	0x40623800
 800af50:	20084b92 	.word	0x20084b92
 800af54:	200002b8 	.word	0x200002b8
 800af58:	20084b8d 	.word	0x20084b8d
 800af5c:	200002b9 	.word	0x200002b9
 800af60:	99999999 	.word	0x99999999
 800af64:	40863199 	.word	0x40863199
 800af68:	66666666 	.word	0x66666666
 800af6c:	408aaa66 	.word	0x408aaa66
				if(Touch_x >= 55*TS_Callib & Touch_x <= (55+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib) //SD_Card
 800af70:	a3ad      	add	r3, pc, #692	; (adr r3, 800b228 <GUI_Touch_Processing+0x38a8>)
 800af72:	e9d3 2300 	ldrd	r2, r3, [r3]
 800af76:	4630      	mov	r0, r6
 800af78:	4639      	mov	r1, r7
 800af7a:	f04f 0a01 	mov.w	sl, #1
 800af7e:	f7f5 fdcd 	bl	8000b1c <__aeabi_dcmpge>
 800af82:	b900      	cbnz	r0, 800af86 <GUI_Touch_Processing+0x3606>
 800af84:	4682      	mov	sl, r0
 800af86:	a3aa      	add	r3, pc, #680	; (adr r3, 800b230 <GUI_Touch_Processing+0x38b0>)
 800af88:	e9d3 2300 	ldrd	r2, r3, [r3]
 800af8c:	4630      	mov	r0, r6
 800af8e:	4639      	mov	r1, r7
 800af90:	f04f 0b01 	mov.w	fp, #1
 800af94:	f7f5 fdb8 	bl	8000b08 <__aeabi_dcmple>
 800af98:	b900      	cbnz	r0, 800af9c <GUI_Touch_Processing+0x361c>
 800af9a:	4683      	mov	fp, r0
 800af9c:	ea0a 030b 	and.w	r3, sl, fp
 800afa0:	07d8      	lsls	r0, r3, #31
 800afa2:	d502      	bpl.n	800afaa <GUI_Touch_Processing+0x362a>
 800afa4:	2c00      	cmp	r4, #0
 800afa6:	f47c adb7 	bne.w	8007b18 <GUI_Touch_Processing+0x198>
				if(Touch_x >= 8*TS_Callib & Touch_x <= (250)*TS_Callib & Touch_y >=80*TS_Callib & Touch_y <=(120)*TS_Callib) // Language change
 800afaa:	2200      	movs	r2, #0
 800afac:	4b9a      	ldr	r3, [pc, #616]	; (800b218 <GUI_Touch_Processing+0x3898>)
 800afae:	4640      	mov	r0, r8
 800afb0:	4649      	mov	r1, r9
 800afb2:	f04f 0401 	mov.w	r4, #1
 800afb6:	f7f5 fdb1 	bl	8000b1c <__aeabi_dcmpge>
 800afba:	b900      	cbnz	r0, 800afbe <GUI_Touch_Processing+0x363e>
 800afbc:	4604      	mov	r4, r0
 800afbe:	a38e      	add	r3, pc, #568	; (adr r3, 800b1f8 <GUI_Touch_Processing+0x3878>)
 800afc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800afc4:	4640      	mov	r0, r8
 800afc6:	4649      	mov	r1, r9
 800afc8:	f04f 0601 	mov.w	r6, #1
 800afcc:	f7f5 fd9c 	bl	8000b08 <__aeabi_dcmple>
 800afd0:	b900      	cbnz	r0, 800afd4 <GUI_Touch_Processing+0x3654>
 800afd2:	4606      	mov	r6, r0
 800afd4:	4034      	ands	r4, r6
 800afd6:	07e1      	lsls	r1, r4, #31
 800afd8:	f57c ad61 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 800afdc:	2d00      	cmp	r5, #0
 800afde:	f47f a81b 	bne.w	800a018 <GUI_Touch_Processing+0x2698>
 800afe2:	f7fc bd5c 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 8*TS_Callib & Touch_x <= (270)*TS_Callib & Touch_y >=8*TS_Callib & Touch_y <=(470)*TS_Callib) // Information
 800afe6:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 800afea:	f7f5 faab 	bl	8000544 <__aeabi_i2d>
 800afee:	4680      	mov	r8, r0
 800aff0:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800aff4:	4689      	mov	r9, r1
 800aff6:	f7f5 faa5 	bl	8000544 <__aeabi_i2d>
 800affa:	a381      	add	r3, pc, #516	; (adr r3, 800b200 <GUI_Touch_Processing+0x3880>)
 800affc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b000:	4606      	mov	r6, r0
 800b002:	460f      	mov	r7, r1
 800b004:	4640      	mov	r0, r8
 800b006:	4649      	mov	r1, r9
 800b008:	f04f 0501 	mov.w	r5, #1
 800b00c:	f7f5 fd86 	bl	8000b1c <__aeabi_dcmpge>
 800b010:	b900      	cbnz	r0, 800b014 <GUI_Touch_Processing+0x3694>
 800b012:	4605      	mov	r5, r0
 800b014:	a37c      	add	r3, pc, #496	; (adr r3, 800b208 <GUI_Touch_Processing+0x3888>)
 800b016:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b01a:	4640      	mov	r0, r8
 800b01c:	4649      	mov	r1, r9
 800b01e:	f04f 0a01 	mov.w	sl, #1
 800b022:	f7f5 fd71 	bl	8000b08 <__aeabi_dcmple>
 800b026:	b900      	cbnz	r0, 800b02a <GUI_Touch_Processing+0x36aa>
 800b028:	4682      	mov	sl, r0
 800b02a:	a375      	add	r3, pc, #468	; (adr r3, 800b200 <GUI_Touch_Processing+0x3880>)
 800b02c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b030:	4630      	mov	r0, r6
 800b032:	4639      	mov	r1, r7
 800b034:	ea05 050a 	and.w	r5, r5, sl
 800b038:	f04f 0801 	mov.w	r8, #1
 800b03c:	f7f5 fd6e 	bl	8000b1c <__aeabi_dcmpge>
 800b040:	b900      	cbnz	r0, 800b044 <GUI_Touch_Processing+0x36c4>
 800b042:	4680      	mov	r8, r0
 800b044:	ea05 0508 	and.w	r5, r5, r8
 800b048:	07ea      	lsls	r2, r5, #31
 800b04a:	f57c ad28 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 800b04e:	a370      	add	r3, pc, #448	; (adr r3, 800b210 <GUI_Touch_Processing+0x3890>)
 800b050:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b054:	4630      	mov	r0, r6
 800b056:	4639      	mov	r1, r7
 800b058:	f04f 0501 	mov.w	r5, #1
 800b05c:	f7f5 fd54 	bl	8000b08 <__aeabi_dcmple>
 800b060:	b900      	cbnz	r0, 800b064 <GUI_Touch_Processing+0x36e4>
 800b062:	4605      	mov	r5, r0
 800b064:	f015 0fff 	tst.w	r5, #255	; 0xff
 800b068:	f43c ad19 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
					GUI_screen_state = preGUI_screen_state;
 800b06c:	4b6b      	ldr	r3, [pc, #428]	; (800b21c <GUI_Touch_Processing+0x389c>)
 800b06e:	781a      	ldrb	r2, [r3, #0]
 800b070:	7022      	strb	r2, [r4, #0]
					preGUI_screen_state = Information_Screen;
 800b072:	2211      	movs	r2, #17
 800b074:	701a      	strb	r2, [r3, #0]
						switch (Prev_Inf_Screen2){
 800b076:	4b6a      	ldr	r3, [pc, #424]	; (800b220 <GUI_Touch_Processing+0x38a0>)
 800b078:	781b      	ldrb	r3, [r3, #0]
 800b07a:	3b07      	subs	r3, #7
 800b07c:	2b09      	cmp	r3, #9
 800b07e:	f63c ad0e 	bhi.w	8007a9e <GUI_Touch_Processing+0x11e>
 800b082:	a201      	add	r2, pc, #4	; (adr r2, 800b088 <GUI_Touch_Processing+0x3708>)
 800b084:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b088:	0800b0b1 	.word	0x0800b0b1
 800b08c:	08007a9f 	.word	0x08007a9f
 800b090:	08007a9f 	.word	0x08007a9f
 800b094:	08007a9f 	.word	0x08007a9f
 800b098:	08007a9f 	.word	0x08007a9f
 800b09c:	0800b0bf 	.word	0x0800b0bf
 800b0a0:	08007a9f 	.word	0x08007a9f
 800b0a4:	0800b0cd 	.word	0x0800b0cd
 800b0a8:	08007a9f 	.word	0x08007a9f
 800b0ac:	0800b0db 	.word	0x0800b0db
						case DataSet1_Screen: GUI_screen_state = DataSet1_Screen; 	Prev_Inf_Screen = Measure_Screen;	break;
 800b0b0:	2307      	movs	r3, #7
 800b0b2:	7023      	strb	r3, [r4, #0]
 800b0b4:	4b5b      	ldr	r3, [pc, #364]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b0b6:	2201      	movs	r2, #1
 800b0b8:	701a      	strb	r2, [r3, #0]
 800b0ba:	f7fc bcf0 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case GraphSet1_Screen: GUI_screen_state = GraphSet1_Screen; Prev_Inf_Screen = Graph_Screen; 		break;
 800b0be:	230c      	movs	r3, #12
 800b0c0:	7023      	strb	r3, [r4, #0]
 800b0c2:	4b58      	ldr	r3, [pc, #352]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b0c4:	2204      	movs	r2, #4
 800b0c6:	701a      	strb	r2, [r3, #0]
 800b0c8:	f7fc bce9 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case ColorSet1_Screen: GUI_screen_state = ColorSet1_Screen; Prev_Inf_Screen = Color_Screen; break;
 800b0cc:	230e      	movs	r3, #14
 800b0ce:	7023      	strb	r3, [r4, #0]
 800b0d0:	4b54      	ldr	r3, [pc, #336]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b0d2:	2205      	movs	r2, #5
 800b0d4:	701a      	strb	r2, [r3, #0]
 800b0d6:	f7fc bce2 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case ColorRendSet_Screen: GUI_screen_state = ColorRendSet_Screen; Prev_Inf_Screen = Color_Rendition_Screen; break;
 800b0da:	2310      	movs	r3, #16
 800b0dc:	7023      	strb	r3, [r4, #0]
 800b0de:	4b51      	ldr	r3, [pc, #324]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b0e0:	2206      	movs	r2, #6
 800b0e2:	701a      	strb	r2, [r3, #0]
 800b0e4:	f7fc bcdb 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
			if(Touch_x >= 8*TS_Callib & Touch_x <= (270)*TS_Callib & Touch_y >=8*TS_Callib & Touch_y <=(470)*TS_Callib) // Information
 800b0e8:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 800b0ec:	f7f5 fa2a 	bl	8000544 <__aeabi_i2d>
 800b0f0:	4680      	mov	r8, r0
 800b0f2:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 800b0f6:	4689      	mov	r9, r1
 800b0f8:	f7f5 fa24 	bl	8000544 <__aeabi_i2d>
 800b0fc:	a340      	add	r3, pc, #256	; (adr r3, 800b200 <GUI_Touch_Processing+0x3880>)
 800b0fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b102:	4606      	mov	r6, r0
 800b104:	460f      	mov	r7, r1
 800b106:	4640      	mov	r0, r8
 800b108:	4649      	mov	r1, r9
 800b10a:	f04f 0501 	mov.w	r5, #1
 800b10e:	f7f5 fd05 	bl	8000b1c <__aeabi_dcmpge>
 800b112:	b900      	cbnz	r0, 800b116 <GUI_Touch_Processing+0x3796>
 800b114:	4605      	mov	r5, r0
 800b116:	a33c      	add	r3, pc, #240	; (adr r3, 800b208 <GUI_Touch_Processing+0x3888>)
 800b118:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b11c:	4640      	mov	r0, r8
 800b11e:	4649      	mov	r1, r9
 800b120:	f04f 0a01 	mov.w	sl, #1
 800b124:	f7f5 fcf0 	bl	8000b08 <__aeabi_dcmple>
 800b128:	b900      	cbnz	r0, 800b12c <GUI_Touch_Processing+0x37ac>
 800b12a:	4682      	mov	sl, r0
 800b12c:	a334      	add	r3, pc, #208	; (adr r3, 800b200 <GUI_Touch_Processing+0x3880>)
 800b12e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b132:	4630      	mov	r0, r6
 800b134:	4639      	mov	r1, r7
 800b136:	ea05 050a 	and.w	r5, r5, sl
 800b13a:	f04f 0801 	mov.w	r8, #1
 800b13e:	f7f5 fced 	bl	8000b1c <__aeabi_dcmpge>
 800b142:	b900      	cbnz	r0, 800b146 <GUI_Touch_Processing+0x37c6>
 800b144:	4680      	mov	r8, r0
 800b146:	ea05 0508 	and.w	r5, r5, r8
 800b14a:	07eb      	lsls	r3, r5, #31
 800b14c:	f57c aca7 	bpl.w	8007a9e <GUI_Touch_Processing+0x11e>
 800b150:	a32f      	add	r3, pc, #188	; (adr r3, 800b210 <GUI_Touch_Processing+0x3890>)
 800b152:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b156:	4630      	mov	r0, r6
 800b158:	4639      	mov	r1, r7
 800b15a:	f04f 0501 	mov.w	r5, #1
 800b15e:	f7f5 fcd3 	bl	8000b08 <__aeabi_dcmple>
 800b162:	b900      	cbnz	r0, 800b166 <GUI_Touch_Processing+0x37e6>
 800b164:	4605      	mov	r5, r0
 800b166:	f015 0fff 	tst.w	r5, #255	; 0xff
 800b16a:	f43c ac98 	beq.w	8007a9e <GUI_Touch_Processing+0x11e>
					GUI_screen_state = preGUI_screen_state;
 800b16e:	4b2b      	ldr	r3, [pc, #172]	; (800b21c <GUI_Touch_Processing+0x389c>)
 800b170:	781a      	ldrb	r2, [r3, #0]
 800b172:	7022      	strb	r2, [r4, #0]
					preGUI_screen_state = SD_Write_Screen;
 800b174:	2212      	movs	r2, #18
 800b176:	701a      	strb	r2, [r3, #0]
						switch (Prev_Inf_Screen2){
 800b178:	4b29      	ldr	r3, [pc, #164]	; (800b220 <GUI_Touch_Processing+0x38a0>)
 800b17a:	781b      	ldrb	r3, [r3, #0]
 800b17c:	3b07      	subs	r3, #7
 800b17e:	2b09      	cmp	r3, #9
 800b180:	f63c ac8d 	bhi.w	8007a9e <GUI_Touch_Processing+0x11e>
 800b184:	a201      	add	r2, pc, #4	; (adr r2, 800b18c <GUI_Touch_Processing+0x380c>)
 800b186:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b18a:	bf00      	nop
 800b18c:	0800b1b5 	.word	0x0800b1b5
 800b190:	08007a9f 	.word	0x08007a9f
 800b194:	08007a9f 	.word	0x08007a9f
 800b198:	08007a9f 	.word	0x08007a9f
 800b19c:	08007a9f 	.word	0x08007a9f
 800b1a0:	0800b1c3 	.word	0x0800b1c3
 800b1a4:	08007a9f 	.word	0x08007a9f
 800b1a8:	0800b1d1 	.word	0x0800b1d1
 800b1ac:	08007a9f 	.word	0x08007a9f
 800b1b0:	0800b1df 	.word	0x0800b1df
						case DataSet1_Screen: GUI_screen_state = DataSet1_Screen; 	Prev_Inf_Screen = Measure_Screen;	break;
 800b1b4:	2307      	movs	r3, #7
 800b1b6:	7023      	strb	r3, [r4, #0]
 800b1b8:	4b1a      	ldr	r3, [pc, #104]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b1ba:	2201      	movs	r2, #1
 800b1bc:	701a      	strb	r2, [r3, #0]
 800b1be:	f7fc bc6e 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case GraphSet1_Screen: GUI_screen_state = GraphSet1_Screen; Prev_Inf_Screen = Graph_Screen; 		break;
 800b1c2:	230c      	movs	r3, #12
 800b1c4:	7023      	strb	r3, [r4, #0]
 800b1c6:	4b17      	ldr	r3, [pc, #92]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b1c8:	2204      	movs	r2, #4
 800b1ca:	701a      	strb	r2, [r3, #0]
 800b1cc:	f7fc bc67 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case ColorSet1_Screen: GUI_screen_state = ColorSet1_Screen; Prev_Inf_Screen = Color_Screen; break;
 800b1d0:	230e      	movs	r3, #14
 800b1d2:	7023      	strb	r3, [r4, #0]
 800b1d4:	4b13      	ldr	r3, [pc, #76]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b1d6:	2205      	movs	r2, #5
 800b1d8:	701a      	strb	r2, [r3, #0]
 800b1da:	f7fc bc60 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
						case ColorRendSet_Screen: GUI_screen_state = ColorRendSet_Screen; Prev_Inf_Screen = Color_Rendition_Screen; break;
 800b1de:	2310      	movs	r3, #16
 800b1e0:	7023      	strb	r3, [r4, #0]
 800b1e2:	4b10      	ldr	r3, [pc, #64]	; (800b224 <GUI_Touch_Processing+0x38a4>)
 800b1e4:	2206      	movs	r2, #6
 800b1e6:	701a      	strb	r2, [r3, #0]
 800b1e8:	f7fc bc59 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
		default: preGUI_screen_state = Measure_Screen;
 800b1ec:	4b0b      	ldr	r3, [pc, #44]	; (800b21c <GUI_Touch_Processing+0x389c>)
 800b1ee:	2201      	movs	r2, #1
 800b1f0:	701a      	strb	r2, [r3, #0]
}
 800b1f2:	f7fc bc54 	b.w	8007a9e <GUI_Touch_Processing+0x11e>
 800b1f6:	bf00      	nop
 800b1f8:	00000000 	.word	0x00000000
 800b1fc:	4073e000 	.word	0x4073e000
 800b200:	33333333 	.word	0x33333333
 800b204:	40353333 	.word	0x40353333
 800b208:	00000000 	.word	0x00000000
 800b20c:	40865c00 	.word	0x40865c00
 800b210:	00000000 	.word	0x00000000
 800b214:	40937600 	.word	0x40937600
 800b218:	406a8000 	.word	0x406a8000
 800b21c:	20000176 	.word	0x20000176
 800b220:	20085120 	.word	0x20085120
 800b224:	20084b8d 	.word	0x20084b8d
 800b228:	00000000 	.word	0x00000000
 800b22c:	40623800 	.word	0x40623800
 800b230:	99999999 	.word	0x99999999
 800b234:	40720d99 	.word	0x40720d99

0800b238 <GUI_Bluetooth_Logo>:

extern UART_HandleTypeDef hlpuart1;
extern uint8_t BluetoothStat=0;

void GUI_Bluetooth_Logo(uint16_t X, uint16_t Y)
{
 800b238:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	TFT_DrawFilledRoundedRectangle(X, Y, X+20, Y+30, 5, TFT_Blue_Off); 
 800b23c:	f101 031e 	add.w	r3, r1, #30
{
 800b240:	460c      	mov	r4, r1
 800b242:	4605      	mov	r5, r0
	TFT_DrawFilledRoundedRectangle(X, Y, X+20, Y+30, 5, TFT_Blue_Off); 
 800b244:	f100 0214 	add.w	r2, r0, #20
 800b248:	2605      	movs	r6, #5
 800b24a:	f241 3776 	movw	r7, #4982	; 0x1376
 800b24e:	e88d 00c0 	stmia.w	sp, {r6, r7}
 800b252:	b29b      	uxth	r3, r3
 800b254:	b292      	uxth	r2, r2
	TFT_DrawLine(X+10, Y+4, X+10, Y+26, TFT_White);
 800b256:	f105 060a 	add.w	r6, r5, #10
 800b25a:	f104 0a1a 	add.w	sl, r4, #26
	TFT_DrawFilledRoundedRectangle(X, Y, X+20, Y+30, 5, TFT_Blue_Off); 
 800b25e:	f005 fcf1 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
	TFT_DrawLine(X+10, Y+4, X+10, Y+26, TFT_White);
 800b262:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800b266:	b2b6      	uxth	r6, r6
 800b268:	fa1f fa8a 	uxth.w	sl, sl
 800b26c:	1d21      	adds	r1, r4, #4
 800b26e:	4653      	mov	r3, sl
 800b270:	4632      	mov	r2, r6
 800b272:	4630      	mov	r0, r6
 800b274:	f8cd 8000 	str.w	r8, [sp]
 800b278:	b289      	uxth	r1, r1
	TFT_DrawLine(X+10, Y+5, X+15, Y+11, TFT_White);
 800b27a:	f105 070f 	add.w	r7, r5, #15
 800b27e:	f104 090b 	add.w	r9, r4, #11
	TFT_DrawLine(X+10, Y+4, X+10, Y+26, TFT_White);
 800b282:	f005 fafd 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+10, Y+5, X+15, Y+11, TFT_White);
 800b286:	b2bf      	uxth	r7, r7
 800b288:	fa1f f989 	uxth.w	r9, r9
 800b28c:	1d61      	adds	r1, r4, #5
	TFT_DrawLine(X+6, Y+20, X+15, Y+11, TFT_White);
 800b28e:	3506      	adds	r5, #6
 800b290:	3414      	adds	r4, #20
 800b292:	b2a4      	uxth	r4, r4
	TFT_DrawLine(X+10, Y+5, X+15, Y+11, TFT_White);
 800b294:	464b      	mov	r3, r9
 800b296:	463a      	mov	r2, r7
 800b298:	4630      	mov	r0, r6
	TFT_DrawLine(X+6, Y+20, X+15, Y+11, TFT_White);
 800b29a:	b2ad      	uxth	r5, r5
	TFT_DrawLine(X+10, Y+5, X+15, Y+11, TFT_White);
 800b29c:	f8cd 8000 	str.w	r8, [sp]
 800b2a0:	b289      	uxth	r1, r1
 800b2a2:	f005 faed 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+6, Y+20, X+15, Y+11, TFT_White);
 800b2a6:	464b      	mov	r3, r9
 800b2a8:	463a      	mov	r2, r7
 800b2aa:	4621      	mov	r1, r4
 800b2ac:	4628      	mov	r0, r5
 800b2ae:	f8cd 8000 	str.w	r8, [sp]
 800b2b2:	f005 fae5 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+6, Y+11, X+15, Y+20, TFT_White);
 800b2b6:	4623      	mov	r3, r4
 800b2b8:	463a      	mov	r2, r7
 800b2ba:	4649      	mov	r1, r9
 800b2bc:	4628      	mov	r0, r5
 800b2be:	f8cd 8000 	str.w	r8, [sp]
 800b2c2:	f005 fadd 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+10, Y+26, X+15, Y+20,TFT_White);
 800b2c6:	f8cd 8000 	str.w	r8, [sp]
 800b2ca:	4623      	mov	r3, r4
 800b2cc:	463a      	mov	r2, r7
 800b2ce:	4651      	mov	r1, sl
 800b2d0:	4630      	mov	r0, r6
 800b2d2:	f005 fad5 	bl	8010880 <TFT_DrawLine>
}
 800b2d6:	b002      	add	sp, #8
 800b2d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800b2dc <GUI_Button_Settings>:


void GUI_Button_Settings(uint16_t X, uint16_t Y)
{
 800b2dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b2e0:	f101 0336 	add.w	r3, r1, #54	; 0x36
{
 800b2e4:	4605      	mov	r5, r0
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b2e6:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b2ea:	f241 3676 	movw	r6, #4982	; 0x1376
{
 800b2ee:	460c      	mov	r4, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b2f0:	9600      	str	r6, [sp, #0]
 800b2f2:	b29b      	uxth	r3, r3
 800b2f4:	b292      	uxth	r2, r2
	TFT_DrawFilledRoundedRectangle(X+8, Y+13, X+47, Y+19, 2, TFT_White);
 800b2f6:	f105 0608 	add.w	r6, r5, #8
 800b2fa:	352f      	adds	r5, #47	; 0x2f
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b2fc:	f005 fb1d 	bl	801093a <TFT_FillRectangle>
	TFT_DrawFilledRoundedRectangle(X+8, Y+13, X+47, Y+19, 2, TFT_White);
 800b300:	b2b6      	uxth	r6, r6
 800b302:	b2ad      	uxth	r5, r5
 800b304:	2702      	movs	r7, #2
 800b306:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800b30a:	f104 0313 	add.w	r3, r4, #19
 800b30e:	f104 010d 	add.w	r1, r4, #13
 800b312:	462a      	mov	r2, r5
 800b314:	4630      	mov	r0, r6
 800b316:	e88d 0180 	stmia.w	sp, {r7, r8}
 800b31a:	b29b      	uxth	r3, r3
 800b31c:	b289      	uxth	r1, r1
 800b31e:	f005 fc91 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
	TFT_DrawFilledRoundedRectangle(X+8, Y+25, X+47, Y+31, 2, TFT_White);
 800b322:	f104 031f 	add.w	r3, r4, #31
 800b326:	f104 0119 	add.w	r1, r4, #25
 800b32a:	462a      	mov	r2, r5
 800b32c:	4630      	mov	r0, r6
 800b32e:	e88d 0180 	stmia.w	sp, {r7, r8}
 800b332:	b29b      	uxth	r3, r3
 800b334:	b289      	uxth	r1, r1
 800b336:	f005 fc85 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
	TFT_DrawFilledRoundedRectangle(X+8, Y+37, X+47, Y+43, 2, TFT_White);
 800b33a:	f104 032b 	add.w	r3, r4, #43	; 0x2b
 800b33e:	f104 0125 	add.w	r1, r4, #37	; 0x25
 800b342:	e88d 0180 	stmia.w	sp, {r7, r8}
 800b346:	b29b      	uxth	r3, r3
 800b348:	462a      	mov	r2, r5
 800b34a:	b289      	uxth	r1, r1
 800b34c:	4630      	mov	r0, r6
 800b34e:	f005 fc79 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
}
 800b352:	b002      	add	sp, #8
 800b354:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b358 <GUI_Button_Down>:

void GUI_Button_Down(uint16_t X, uint16_t Y)
{
 800b358:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b35c:	f101 0336 	add.w	r3, r1, #54	; 0x36
{
 800b360:	4604      	mov	r4, r0
 800b362:	460d      	mov	r5, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b364:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b368:	f241 3676 	movw	r6, #4982	; 0x1376
 800b36c:	9600      	str	r6, [sp, #0]
 800b36e:	b29b      	uxth	r3, r3
 800b370:	b292      	uxth	r2, r2
	TFT_DrawLine(X+12, Y+18, X+28, Y+40, TFT_White);
 800b372:	f105 0612 	add.w	r6, r5, #18
 800b376:	f104 081c 	add.w	r8, r4, #28
 800b37a:	3528      	adds	r5, #40	; 0x28
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b37c:	f005 fadd 	bl	801093a <TFT_FillRectangle>
	TFT_DrawLine(X+12, Y+18, X+28, Y+40, TFT_White);
 800b380:	b2b6      	uxth	r6, r6
 800b382:	b2ad      	uxth	r5, r5
 800b384:	f64f 77ff 	movw	r7, #65535	; 0xffff
 800b388:	fa1f f888 	uxth.w	r8, r8
 800b38c:	f104 000c 	add.w	r0, r4, #12
 800b390:	462b      	mov	r3, r5
 800b392:	4642      	mov	r2, r8
 800b394:	4631      	mov	r1, r6
 800b396:	9700      	str	r7, [sp, #0]
 800b398:	b280      	uxth	r0, r0
 800b39a:	f005 fa71 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+13, Y+18, X+29, Y+40, TFT_White);
 800b39e:	f104 021d 	add.w	r2, r4, #29
 800b3a2:	f104 000d 	add.w	r0, r4, #13
 800b3a6:	462b      	mov	r3, r5
 800b3a8:	4631      	mov	r1, r6
 800b3aa:	9700      	str	r7, [sp, #0]
 800b3ac:	b292      	uxth	r2, r2
 800b3ae:	b280      	uxth	r0, r0
 800b3b0:	f005 fa66 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+43, Y+18, X+28, Y+40, TFT_White);
 800b3b4:	f104 002b 	add.w	r0, r4, #43	; 0x2b
 800b3b8:	462b      	mov	r3, r5
 800b3ba:	4642      	mov	r2, r8
 800b3bc:	4631      	mov	r1, r6
 800b3be:	9700      	str	r7, [sp, #0]
 800b3c0:	b280      	uxth	r0, r0
 800b3c2:	f005 fa5d 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+42, Y+18, X+27, Y+40, TFT_White);
 800b3c6:	f104 021b 	add.w	r2, r4, #27
 800b3ca:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 800b3ce:	9700      	str	r7, [sp, #0]
 800b3d0:	462b      	mov	r3, r5
 800b3d2:	b292      	uxth	r2, r2
 800b3d4:	4631      	mov	r1, r6
 800b3d6:	b280      	uxth	r0, r0
 800b3d8:	f005 fa52 	bl	8010880 <TFT_DrawLine>
}
 800b3dc:	b002      	add	sp, #8
 800b3de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b3e2 <GUI_Button_Down_Active>:

void GUI_Button_Down_Active(uint16_t X, uint16_t Y, uint8_t Active)
{
 800b3e2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800b3e6:	f101 0336 	add.w	r3, r1, #54	; 0x36
 800b3ea:	4604      	mov	r4, r0
 800b3ec:	460d      	mov	r5, r1
 800b3ee:	f100 0636 	add.w	r6, r0, #54	; 0x36
	if(Active){TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);}
 800b3f2:	2a00      	cmp	r2, #0
 800b3f4:	d03c      	beq.n	800b470 <GUI_Button_Down_Active+0x8e>
 800b3f6:	f241 3276 	movw	r2, #4982	; 0x1376
	else {TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b3fa:	9200      	str	r2, [sp, #0]
 800b3fc:	b29b      	uxth	r3, r3
 800b3fe:	b2b2      	uxth	r2, r6
	
	TFT_DrawLine(X+12, Y+18, X+28, Y+40, TFT_White);
 800b400:	f104 081c 	add.w	r8, r4, #28
 800b404:	f105 0612 	add.w	r6, r5, #18
 800b408:	3528      	adds	r5, #40	; 0x28
	else {TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b40a:	f005 fa96 	bl	801093a <TFT_FillRectangle>
	TFT_DrawLine(X+12, Y+18, X+28, Y+40, TFT_White);
 800b40e:	b2b6      	uxth	r6, r6
 800b410:	b2ad      	uxth	r5, r5
 800b412:	f64f 77ff 	movw	r7, #65535	; 0xffff
 800b416:	fa1f f888 	uxth.w	r8, r8
 800b41a:	f104 000c 	add.w	r0, r4, #12
 800b41e:	462b      	mov	r3, r5
 800b420:	4642      	mov	r2, r8
 800b422:	4631      	mov	r1, r6
 800b424:	9700      	str	r7, [sp, #0]
 800b426:	b280      	uxth	r0, r0
 800b428:	f005 fa2a 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+13, Y+18, X+29, Y+40, TFT_White);
 800b42c:	f104 021d 	add.w	r2, r4, #29
 800b430:	f104 000d 	add.w	r0, r4, #13
 800b434:	462b      	mov	r3, r5
 800b436:	4631      	mov	r1, r6
 800b438:	9700      	str	r7, [sp, #0]
 800b43a:	b292      	uxth	r2, r2
 800b43c:	b280      	uxth	r0, r0
 800b43e:	f005 fa1f 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+43, Y+18, X+28, Y+40, TFT_White);
 800b442:	f104 002b 	add.w	r0, r4, #43	; 0x2b
 800b446:	462b      	mov	r3, r5
 800b448:	4642      	mov	r2, r8
 800b44a:	4631      	mov	r1, r6
 800b44c:	9700      	str	r7, [sp, #0]
 800b44e:	b280      	uxth	r0, r0
 800b450:	f005 fa16 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+42, Y+18, X+27, Y+40, TFT_White);
 800b454:	f104 021b 	add.w	r2, r4, #27
 800b458:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 800b45c:	9700      	str	r7, [sp, #0]
 800b45e:	462b      	mov	r3, r5
 800b460:	b292      	uxth	r2, r2
 800b462:	4631      	mov	r1, r6
 800b464:	b280      	uxth	r0, r0
 800b466:	f005 fa0b 	bl	8010880 <TFT_DrawLine>
}
 800b46a:	b002      	add	sp, #8
 800b46c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else {TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b470:	f64d 721c 	movw	r2, #57116	; 0xdf1c
 800b474:	e7c1      	b.n	800b3fa <GUI_Button_Down_Active+0x18>

0800b476 <GUI_Button_Right>:

void GUI_Button_Right(uint16_t X, uint16_t Y)
{
 800b476:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b47a:	4604      	mov	r4, r0
 800b47c:	460d      	mov	r5, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b47e:	f241 3676 	movw	r6, #4982	; 0x1376
 800b482:	f101 0336 	add.w	r3, r1, #54	; 0x36
 800b486:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b48a:	9600      	str	r6, [sp, #0]
	TFT_DrawLine(X+19, Y+12, X+40, Y+27, TFT_White);
 800b48c:	f104 0a13 	add.w	sl, r4, #19
 800b490:	f105 0b0c 	add.w	fp, r5, #12
 800b494:	f104 0928 	add.w	r9, r4, #40	; 0x28
 800b498:	f105 061b 	add.w	r6, r5, #27
 800b49c:	b2b6      	uxth	r6, r6
 800b49e:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800b4a2:	fa1f fa8a 	uxth.w	sl, sl
 800b4a6:	fa1f fb8b 	uxth.w	fp, fp
 800b4aa:	fa1f f989 	uxth.w	r9, r9
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b4ae:	b29b      	uxth	r3, r3
 800b4b0:	b292      	uxth	r2, r2
	TFT_DrawLine(X+18, Y+12, X+39, Y+27, TFT_White);
 800b4b2:	f104 0712 	add.w	r7, r4, #18
 800b4b6:	3427      	adds	r4, #39	; 0x27
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b4b8:	f005 fa3f 	bl	801093a <TFT_FillRectangle>
	TFT_DrawLine(X+18, Y+12, X+39, Y+27, TFT_White);
 800b4bc:	b2bf      	uxth	r7, r7
	TFT_DrawLine(X+19, Y+12, X+40, Y+27, TFT_White);
 800b4be:	4633      	mov	r3, r6
 800b4c0:	464a      	mov	r2, r9
 800b4c2:	4659      	mov	r1, fp
 800b4c4:	4650      	mov	r0, sl
	TFT_DrawLine(X+18, Y+12, X+39, Y+27, TFT_White);
 800b4c6:	b2a4      	uxth	r4, r4
	TFT_DrawLine(X+19, Y+12, X+40, Y+27, TFT_White);
 800b4c8:	f8cd 8000 	str.w	r8, [sp]
	TFT_DrawLine(X+40, Y+27, X+19, Y+42, TFT_White);
 800b4cc:	352a      	adds	r5, #42	; 0x2a
	TFT_DrawLine(X+19, Y+12, X+40, Y+27, TFT_White);
 800b4ce:	f005 f9d7 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+40, Y+27, X+19, Y+42, TFT_White);
 800b4d2:	b2ad      	uxth	r5, r5
	TFT_DrawLine(X+18, Y+12, X+39, Y+27, TFT_White);
 800b4d4:	4633      	mov	r3, r6
 800b4d6:	4622      	mov	r2, r4
 800b4d8:	4659      	mov	r1, fp
 800b4da:	4638      	mov	r0, r7
 800b4dc:	f8cd 8000 	str.w	r8, [sp]
 800b4e0:	f005 f9ce 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+40, Y+27, X+19, Y+42, TFT_White);
 800b4e4:	462b      	mov	r3, r5
 800b4e6:	4652      	mov	r2, sl
 800b4e8:	4631      	mov	r1, r6
 800b4ea:	4648      	mov	r0, r9
 800b4ec:	f8cd 8000 	str.w	r8, [sp]
 800b4f0:	f005 f9c6 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+39, Y+27, X+18, Y+42, TFT_White);
 800b4f4:	f8cd 8000 	str.w	r8, [sp]
 800b4f8:	462b      	mov	r3, r5
 800b4fa:	463a      	mov	r2, r7
 800b4fc:	4631      	mov	r1, r6
 800b4fe:	4620      	mov	r0, r4
 800b500:	f005 f9be 	bl	8010880 <TFT_DrawLine>
}
 800b504:	b003      	add	sp, #12
 800b506:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800b50a <GUI_Button_TFT_On_Off>:

void GUI_Button_TFT_On_Off(uint16_t X, uint16_t Y)
{
 800b50a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b50c:	f101 0336 	add.w	r3, r1, #54	; 0x36
 800b510:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b514:	f241 3676 	movw	r6, #4982	; 0x1376
{
 800b518:	4604      	mov	r4, r0
 800b51a:	460d      	mov	r5, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b51c:	9600      	str	r6, [sp, #0]
 800b51e:	b29b      	uxth	r3, r3
 800b520:	b292      	uxth	r2, r2
 800b522:	f005 fa0a 	bl	801093a <TFT_FillRectangle>
	TFT_DrawRectangle(X+8, Y+16, X+48, Y+39, TFT_White);
 800b526:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800b52a:	f105 0327 	add.w	r3, r5, #39	; 0x27
 800b52e:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800b532:	f105 0110 	add.w	r1, r5, #16
 800b536:	f104 0008 	add.w	r0, r4, #8
 800b53a:	9600      	str	r6, [sp, #0]
 800b53c:	b29b      	uxth	r3, r3
 800b53e:	b292      	uxth	r2, r2
 800b540:	b289      	uxth	r1, r1
 800b542:	b280      	uxth	r0, r0
 800b544:	f005 fa11 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawLine(X+6, Y+5, X+51, Y+48, TFT_White);
 800b548:	f105 0330 	add.w	r3, r5, #48	; 0x30
 800b54c:	f104 0233 	add.w	r2, r4, #51	; 0x33
 800b550:	1d69      	adds	r1, r5, #5
 800b552:	1da0      	adds	r0, r4, #6
 800b554:	9600      	str	r6, [sp, #0]
 800b556:	b29b      	uxth	r3, r3
 800b558:	b292      	uxth	r2, r2
 800b55a:	b289      	uxth	r1, r1
 800b55c:	b280      	uxth	r0, r0
 800b55e:	f005 f98f 	bl	8010880 <TFT_DrawLine>
}
 800b562:	b002      	add	sp, #8
 800b564:	bd70      	pop	{r4, r5, r6, pc}

0800b566 <GUI_Button_TFT_Rotate>:

void GUI_Button_TFT_Rotate(uint16_t X, uint16_t Y)
{
 800b566:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b56a:	f101 0336 	add.w	r3, r1, #54	; 0x36
{
 800b56e:	4605      	mov	r5, r0
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b570:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b574:	f241 3676 	movw	r6, #4982	; 0x1376
{
 800b578:	460c      	mov	r4, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b57a:	9600      	str	r6, [sp, #0]
 800b57c:	b29b      	uxth	r3, r3
 800b57e:	b292      	uxth	r2, r2
	TFT_DrawRectangle(X+9, Y+9, X+28, Y+43, TFT_White);
 800b580:	f105 071c 	add.w	r7, r5, #28
 800b584:	f64f 76ff 	movw	r6, #65535	; 0xffff
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b588:	f005 f9d7 	bl	801093a <TFT_FillRectangle>
	TFT_DrawRectangle(X+9, Y+9, X+28, Y+43, TFT_White);
 800b58c:	b2bf      	uxth	r7, r7
 800b58e:	f104 032b 	add.w	r3, r4, #43	; 0x2b
 800b592:	f104 0109 	add.w	r1, r4, #9
 800b596:	f105 0009 	add.w	r0, r5, #9
 800b59a:	463a      	mov	r2, r7
 800b59c:	9600      	str	r6, [sp, #0]
 800b59e:	b29b      	uxth	r3, r3
 800b5a0:	b289      	uxth	r1, r1
 800b5a2:	b280      	uxth	r0, r0
	TFT_DrawRectangle(X+18, Y+30, X+49, Y+48, TFT_White);
 800b5a4:	f104 081e 	add.w	r8, r4, #30
	TFT_DrawRectangle(X+9, Y+9, X+28, Y+43, TFT_White);
 800b5a8:	f005 f9df 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawRectangle(X+18, Y+30, X+49, Y+48, TFT_White);
 800b5ac:	fa1f f888 	uxth.w	r8, r8
 800b5b0:	f104 0330 	add.w	r3, r4, #48	; 0x30
 800b5b4:	f105 0231 	add.w	r2, r5, #49	; 0x31
 800b5b8:	f105 0012 	add.w	r0, r5, #18
 800b5bc:	4641      	mov	r1, r8
 800b5be:	9600      	str	r6, [sp, #0]
 800b5c0:	b29b      	uxth	r3, r3
 800b5c2:	b292      	uxth	r2, r2
 800b5c4:	b280      	uxth	r0, r0
 800b5c6:	f005 f9d0 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawCircleCorner(X+28, Y+30, 16, 2, TFT_White);
	
	TFT_DrawLine(X+29, Y+14, X+33, Y+19, TFT_White); //arrow up left
 800b5ca:	f105 0921 	add.w	r9, r5, #33	; 0x21
	TFT_DrawCircleCorner(X+28, Y+30, 16, 2, TFT_White);
 800b5ce:	fa0f f188 	sxth.w	r1, r8
 800b5d2:	b238      	sxth	r0, r7
 800b5d4:	9600      	str	r6, [sp, #0]
 800b5d6:	2302      	movs	r3, #2
 800b5d8:	2210      	movs	r2, #16
	TFT_DrawLine(X+29, Y+14, X+33, Y+19, TFT_White); //arrow up left
 800b5da:	f105 071d 	add.w	r7, r5, #29
 800b5de:	f104 080e 	add.w	r8, r4, #14
	TFT_DrawCircleCorner(X+28, Y+30, 16, 2, TFT_White);
 800b5e2:	f005 f803 	bl	80105ec <TFT_DrawCircleCorner>
	TFT_DrawLine(X+29, Y+14, X+33, Y+19, TFT_White); //arrow up left
 800b5e6:	b2bf      	uxth	r7, r7
 800b5e8:	fa1f f888 	uxth.w	r8, r8
 800b5ec:	fa1f f989 	uxth.w	r9, r9
 800b5f0:	f104 0313 	add.w	r3, r4, #19
 800b5f4:	464a      	mov	r2, r9
 800b5f6:	4641      	mov	r1, r8
 800b5f8:	4638      	mov	r0, r7
 800b5fa:	9600      	str	r6, [sp, #0]
 800b5fc:	b29b      	uxth	r3, r3
 800b5fe:	f005 f93f 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+29, Y+14, X+33, Y+11, TFT_White);
 800b602:	f104 030b 	add.w	r3, r4, #11
 800b606:	464a      	mov	r2, r9
 800b608:	4641      	mov	r1, r8
 800b60a:	4638      	mov	r0, r7
 800b60c:	9600      	str	r6, [sp, #0]
 800b60e:	b29b      	uxth	r3, r3
	
	TFT_DrawLine(X+44, Y+29, X+39, Y+25, TFT_White); //arrow down right
 800b610:	f105 072c 	add.w	r7, r5, #44	; 0x2c
 800b614:	f104 081d 	add.w	r8, r4, #29
 800b618:	3419      	adds	r4, #25
	TFT_DrawLine(X+29, Y+14, X+33, Y+11, TFT_White);
 800b61a:	f005 f931 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+44, Y+29, X+39, Y+25, TFT_White); //arrow down right
 800b61e:	b2bf      	uxth	r7, r7
 800b620:	fa1f f888 	uxth.w	r8, r8
 800b624:	b2a4      	uxth	r4, r4
 800b626:	f105 0227 	add.w	r2, r5, #39	; 0x27
 800b62a:	4623      	mov	r3, r4
 800b62c:	4641      	mov	r1, r8
 800b62e:	4638      	mov	r0, r7
 800b630:	9600      	str	r6, [sp, #0]
 800b632:	b292      	uxth	r2, r2
 800b634:	f005 f924 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+44, Y+29, X+47, Y+25, TFT_White);
 800b638:	f105 022f 	add.w	r2, r5, #47	; 0x2f
 800b63c:	9600      	str	r6, [sp, #0]
 800b63e:	4623      	mov	r3, r4
 800b640:	b292      	uxth	r2, r2
 800b642:	4641      	mov	r1, r8
 800b644:	4638      	mov	r0, r7
 800b646:	f005 f91b 	bl	8010880 <TFT_DrawLine>
}
 800b64a:	b003      	add	sp, #12
 800b64c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800b650 <GUI_Button_SD_Card>:

void GUI_Button_SD_Card(uint16_t X, uint16_t Y, uint8_t Active)
{
 800b650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b654:	b085      	sub	sp, #20
 800b656:	4604      	mov	r4, r0
	
	if(Active){TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);}
 800b658:	9203      	str	r2, [sp, #12]
 800b65a:	9e03      	ldr	r6, [sp, #12]
{
 800b65c:	460d      	mov	r5, r1
 800b65e:	f101 0336 	add.w	r3, r1, #54	; 0x36
 800b662:	f100 0236 	add.w	r2, r0, #54	; 0x36
	if(Active){TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);}
 800b666:	2e00      	cmp	r6, #0
 800b668:	f000 80b6 	beq.w	800b7d8 <GUI_Button_SD_Card+0x188>
 800b66c:	f241 3676 	movw	r6, #4982	; 0x1376
	else{TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
	
	TFT_FillRectangle(X+21, Y+5, X+46, Y+7, TFT_White); //SD contour
 800b670:	f104 0715 	add.w	r7, r4, #21
 800b674:	f105 0b05 	add.w	fp, r5, #5
 800b678:	f104 092e 	add.w	r9, r4, #46	; 0x2e
 800b67c:	f105 0a07 	add.w	sl, r5, #7
 800b680:	b2bf      	uxth	r7, r7
 800b682:	fa1f f989 	uxth.w	r9, r9
	else{TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b686:	9600      	str	r6, [sp, #0]
 800b688:	b29b      	uxth	r3, r3
	TFT_FillRectangle(X+21, Y+5, X+46, Y+7, TFT_White); //SD contour
 800b68a:	f64f 76ff 	movw	r6, #65535	; 0xffff
	else{TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b68e:	b292      	uxth	r2, r2
	TFT_FillRectangle(X+21, Y+5, X+46, Y+7, TFT_White); //SD contour
 800b690:	fa1f fb8b 	uxth.w	fp, fp
 800b694:	fa1f fa8a 	uxth.w	sl, sl
	else{TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b698:	f005 f94f 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+44, Y+8, X+46, Y+50, TFT_White);
 800b69c:	f105 0832 	add.w	r8, r5, #50	; 0x32
	TFT_FillRectangle(X+21, Y+5, X+46, Y+7, TFT_White); //SD contour
 800b6a0:	464a      	mov	r2, r9
 800b6a2:	4638      	mov	r0, r7
 800b6a4:	4653      	mov	r3, sl
 800b6a6:	4659      	mov	r1, fp
 800b6a8:	9600      	str	r6, [sp, #0]
 800b6aa:	f005 f946 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+44, Y+8, X+46, Y+50, TFT_White);
 800b6ae:	fa1f f888 	uxth.w	r8, r8
 800b6b2:	f105 0108 	add.w	r1, r5, #8
 800b6b6:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b6ba:	4643      	mov	r3, r8
 800b6bc:	464a      	mov	r2, r9
 800b6be:	b289      	uxth	r1, r1
 800b6c0:	b280      	uxth	r0, r0
 800b6c2:	9600      	str	r6, [sp, #0]
	TFT_FillRectangle(X+43, Y+48, X+10, Y+50, TFT_White);
 800b6c4:	f104 090a 	add.w	r9, r4, #10
	TFT_FillRectangle(X+44, Y+8, X+46, Y+50, TFT_White);
 800b6c8:	f005 f937 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+43, Y+48, X+10, Y+50, TFT_White);
 800b6cc:	fa1f f989 	uxth.w	r9, r9
 800b6d0:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800b6d4:	f104 002b 	add.w	r0, r4, #43	; 0x2b
 800b6d8:	4643      	mov	r3, r8
 800b6da:	464a      	mov	r2, r9
 800b6dc:	b289      	uxth	r1, r1
 800b6de:	b280      	uxth	r0, r0
 800b6e0:	9600      	str	r6, [sp, #0]
 800b6e2:	f005 f92a 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+10, Y+16, X+12, Y+47, TFT_White);
 800b6e6:	f104 030c 	add.w	r3, r4, #12
 800b6ea:	b29b      	uxth	r3, r3
 800b6ec:	f105 0810 	add.w	r8, r5, #16
 800b6f0:	fa1f f888 	uxth.w	r8, r8
 800b6f4:	9302      	str	r3, [sp, #8]
 800b6f6:	f105 032f 	add.w	r3, r5, #47	; 0x2f
 800b6fa:	4641      	mov	r1, r8
 800b6fc:	4648      	mov	r0, r9
 800b6fe:	b29b      	uxth	r3, r3
 800b700:	9a02      	ldr	r2, [sp, #8]
 800b702:	9600      	str	r6, [sp, #0]
 800b704:	f005 f919 	bl	801093a <TFT_FillRectangle>
	
	TFT_DrawLine(X+10, Y+16, X+21, Y+5, TFT_White);
 800b708:	463a      	mov	r2, r7
 800b70a:	4641      	mov	r1, r8
 800b70c:	4648      	mov	r0, r9
 800b70e:	465b      	mov	r3, fp
 800b710:	9600      	str	r6, [sp, #0]
 800b712:	f005 f8b5 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+11, Y+16, X+21, Y+6, TFT_White);
 800b716:	1dab      	adds	r3, r5, #6
 800b718:	f104 000b 	add.w	r0, r4, #11
 800b71c:	463a      	mov	r2, r7
 800b71e:	4641      	mov	r1, r8
 800b720:	b29b      	uxth	r3, r3
 800b722:	b280      	uxth	r0, r0
 800b724:	9600      	str	r6, [sp, #0]
 800b726:	f005 f8ab 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+12, Y+16, X+21, Y+7, TFT_White);
	
	TFT_FillRectangle(X+19, Y+13, X+21, Y+19, TFT_White); //SD pins
 800b72a:	f105 0913 	add.w	r9, r5, #19
	TFT_DrawLine(X+12, Y+16, X+21, Y+7, TFT_White);
 800b72e:	463a      	mov	r2, r7
 800b730:	4641      	mov	r1, r8
 800b732:	4653      	mov	r3, sl
 800b734:	9802      	ldr	r0, [sp, #8]
 800b736:	9600      	str	r6, [sp, #0]
	TFT_FillRectangle(X+19, Y+13, X+21, Y+19, TFT_White); //SD pins
 800b738:	f105 080d 	add.w	r8, r5, #13
	TFT_DrawLine(X+12, Y+16, X+21, Y+7, TFT_White);
 800b73c:	f005 f8a0 	bl	8010880 <TFT_DrawLine>
	TFT_FillRectangle(X+19, Y+13, X+21, Y+19, TFT_White); //SD pins
 800b740:	fa1f f888 	uxth.w	r8, r8
 800b744:	fa1f f989 	uxth.w	r9, r9
 800b748:	f104 0013 	add.w	r0, r4, #19
 800b74c:	463a      	mov	r2, r7
 800b74e:	464b      	mov	r3, r9
 800b750:	4641      	mov	r1, r8
 800b752:	b280      	uxth	r0, r0
 800b754:	9600      	str	r6, [sp, #0]
	TFT_FillRectangle(X+25, Y+13, X+27, Y+19, TFT_White);
 800b756:	f104 071b 	add.w	r7, r4, #27
	TFT_FillRectangle(X+19, Y+13, X+21, Y+19, TFT_White); //SD pins
 800b75a:	f005 f8ee 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+25, Y+13, X+27, Y+19, TFT_White);
 800b75e:	b2bf      	uxth	r7, r7
 800b760:	f104 0019 	add.w	r0, r4, #25
 800b764:	464b      	mov	r3, r9
 800b766:	463a      	mov	r2, r7
 800b768:	4641      	mov	r1, r8
 800b76a:	b280      	uxth	r0, r0
 800b76c:	9600      	str	r6, [sp, #0]
 800b76e:	f005 f8e4 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+31, Y+13, X+33, Y+19, TFT_White);
 800b772:	f104 0221 	add.w	r2, r4, #33	; 0x21
 800b776:	f104 001f 	add.w	r0, r4, #31
 800b77a:	464b      	mov	r3, r9
 800b77c:	b292      	uxth	r2, r2
 800b77e:	4641      	mov	r1, r8
 800b780:	b280      	uxth	r0, r0
 800b782:	9600      	str	r6, [sp, #0]
 800b784:	f005 f8d9 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+37, Y+13, X+39, Y+19, TFT_White);
 800b788:	f104 0227 	add.w	r2, r4, #39	; 0x27
 800b78c:	f104 0025 	add.w	r0, r4, #37	; 0x25
 800b790:	464b      	mov	r3, r9
 800b792:	b292      	uxth	r2, r2
 800b794:	4641      	mov	r1, r8
 800b796:	b280      	uxth	r0, r0
 800b798:	9600      	str	r6, [sp, #0]
 800b79a:	f005 f8ce 	bl	801093a <TFT_FillRectangle>
	
	TFT_SetFont(&Font20);
 800b79e:	4811      	ldr	r0, [pc, #68]	; (800b7e4 <GUI_Button_SD_Card+0x194>)
 800b7a0:	f005 face 	bl	8010d40 <TFT_SetFont>
	TFT_SetTextColor(TFT_White);
 800b7a4:	4630      	mov	r0, r6
 800b7a6:	f005 fad1 	bl	8010d4c <TFT_SetTextColor>
	Active ? TFT_SetBackColor(TFT_Blue_Off) : TFT_SetBackColor(TFT_GreyMain);
 800b7aa:	9b03      	ldr	r3, [sp, #12]
 800b7ac:	b1bb      	cbz	r3, 800b7de <GUI_Button_SD_Card+0x18e>
 800b7ae:	f241 3076 	movw	r0, #4982	; 0x1376
	TFT_DrawChar(X+16, Y+28, 'S');
 800b7b2:	351c      	adds	r5, #28
	Active ? TFT_SetBackColor(TFT_Blue_Off) : TFT_SetBackColor(TFT_GreyMain);
 800b7b4:	f005 fad0 	bl	8010d58 <TFT_SetBackColor>
	TFT_DrawChar(X+16, Y+28, 'S');
 800b7b8:	b2ad      	uxth	r5, r5
 800b7ba:	f104 0010 	add.w	r0, r4, #16
 800b7be:	4629      	mov	r1, r5
 800b7c0:	2253      	movs	r2, #83	; 0x53
 800b7c2:	b280      	uxth	r0, r0
 800b7c4:	f005 fb32 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y+28, 'D');
 800b7c8:	2244      	movs	r2, #68	; 0x44
 800b7ca:	4629      	mov	r1, r5
 800b7cc:	4638      	mov	r0, r7
}
 800b7ce:	b005      	add	sp, #20
 800b7d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	TFT_DrawChar(X+27, Y+28, 'D');
 800b7d4:	f005 bb2a 	b.w	8010e2c <TFT_DrawChar>
	else{TFT_FillRectangle(X, Y, X+54, Y+54, TFT_GreyMain);}
 800b7d8:	f64d 761c 	movw	r6, #57116	; 0xdf1c
 800b7dc:	e748      	b.n	800b670 <GUI_Button_SD_Card+0x20>
	Active ? TFT_SetBackColor(TFT_Blue_Off) : TFT_SetBackColor(TFT_GreyMain);
 800b7de:	f64d 701c 	movw	r0, #57116	; 0xdf1c
 800b7e2:	e7e6      	b.n	800b7b2 <GUI_Button_SD_Card+0x162>
 800b7e4:	20000128 	.word	0x20000128

0800b7e8 <GUI_Button_Measure_Start_Pause>:

void GUI_Button_Measure_Start_Pause(uint16_t X, uint16_t Y)
{
 800b7e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b7ec:	b085      	sub	sp, #20
 800b7ee:	460c      	mov	r4, r1
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b7f0:	f101 0336 	add.w	r3, r1, #54	; 0x36
 800b7f4:	f100 0236 	add.w	r2, r0, #54	; 0x36
 800b7f8:	f241 3676 	movw	r6, #4982	; 0x1376
{
 800b7fc:	4605      	mov	r5, r0
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b7fe:	9600      	str	r6, [sp, #0]
 800b800:	b29b      	uxth	r3, r3
 800b802:	b292      	uxth	r2, r2
	
	TFT_FillRectangle(X+35, Y+11, X+37, Y+43, TFT_White); //Pause
 800b804:	f104 090b 	add.w	r9, r4, #11
 800b808:	f104 072b 	add.w	r7, r4, #43	; 0x2b
 800b80c:	f64f 76ff 	movw	r6, #65535	; 0xffff
	TFT_FillRectangle(X, Y, X+54, Y+54, TFT_Blue_Off);
 800b810:	f005 f893 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+35, Y+11, X+37, Y+43, TFT_White); //Pause
 800b814:	fa1f f989 	uxth.w	r9, r9
 800b818:	b2bf      	uxth	r7, r7
 800b81a:	f105 0225 	add.w	r2, r5, #37	; 0x25
 800b81e:	f105 0023 	add.w	r0, r5, #35	; 0x23
 800b822:	463b      	mov	r3, r7
 800b824:	4649      	mov	r1, r9
 800b826:	9600      	str	r6, [sp, #0]
 800b828:	b292      	uxth	r2, r2
 800b82a:	b280      	uxth	r0, r0
 800b82c:	f005 f885 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+48, Y+11, X+50, Y+43, TFT_White);
 800b830:	f105 0232 	add.w	r2, r5, #50	; 0x32
 800b834:	f105 0030 	add.w	r0, r5, #48	; 0x30
 800b838:	463b      	mov	r3, r7
 800b83a:	4649      	mov	r1, r9
 800b83c:	9600      	str	r6, [sp, #0]
 800b83e:	b292      	uxth	r2, r2
 800b840:	b280      	uxth	r0, r0
	
	TFT_DrawLine(X+6, Y+11, X+6, Y+44, TFT_White); //Play
 800b842:	f105 0806 	add.w	r8, r5, #6
	TFT_FillRectangle(X+48, Y+11, X+50, Y+43, TFT_White);
 800b846:	f005 f878 	bl	801093a <TFT_FillRectangle>
	TFT_DrawLine(X+6, Y+11, X+6, Y+44, TFT_White); //Play
 800b84a:	fa1f f888 	uxth.w	r8, r8
 800b84e:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	TFT_DrawLine(X+6, Y+11, X+30, Y+27, TFT_White);
 800b852:	f105 0a1e 	add.w	sl, r5, #30
 800b856:	f104 0b1b 	add.w	fp, r4, #27
 800b85a:	fa1f fa8a 	uxth.w	sl, sl
 800b85e:	fa1f fb8b 	uxth.w	fp, fp
	TFT_DrawLine(X+6, Y+11, X+6, Y+44, TFT_White); //Play
 800b862:	b29b      	uxth	r3, r3
 800b864:	4642      	mov	r2, r8
 800b866:	4649      	mov	r1, r9
 800b868:	4640      	mov	r0, r8
 800b86a:	9600      	str	r6, [sp, #0]
 800b86c:	9303      	str	r3, [sp, #12]
 800b86e:	f005 f807 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+6, Y+11, X+30, Y+27, TFT_White);
 800b872:	465b      	mov	r3, fp
 800b874:	4652      	mov	r2, sl
 800b876:	4649      	mov	r1, r9
 800b878:	4640      	mov	r0, r8
 800b87a:	9600      	str	r6, [sp, #0]
 800b87c:	f005 f800 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+6, Y+44, X+30, Y+27, TFT_White);
 800b880:	465b      	mov	r3, fp
 800b882:	4652      	mov	r2, sl
 800b884:	9903      	ldr	r1, [sp, #12]
 800b886:	9600      	str	r6, [sp, #0]
 800b888:	4640      	mov	r0, r8
 800b88a:	f004 fff9 	bl	8010880 <TFT_DrawLine>
	
	//paint white
	TFT_DrawLine(X+7, Y+12, X+7, Y+43, TFT_White);
 800b88e:	f104 080c 	add.w	r8, r4, #12
 800b892:	1dea      	adds	r2, r5, #7
 800b894:	b292      	uxth	r2, r2
 800b896:	fa1f f888 	uxth.w	r8, r8
 800b89a:	463b      	mov	r3, r7
 800b89c:	4641      	mov	r1, r8
 800b89e:	4610      	mov	r0, r2
 800b8a0:	9600      	str	r6, [sp, #0]
 800b8a2:	f004 ffed 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+8, Y+12, X+8, Y+43, TFT_White);
 800b8a6:	f105 0208 	add.w	r2, r5, #8
 800b8aa:	b292      	uxth	r2, r2
 800b8ac:	463b      	mov	r3, r7
 800b8ae:	4641      	mov	r1, r8
 800b8b0:	4610      	mov	r0, r2
 800b8b2:	9600      	str	r6, [sp, #0]
 800b8b4:	f004 ffe4 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+9, Y+13, X+9, Y+42, TFT_White);
 800b8b8:	f105 0209 	add.w	r2, r5, #9
 800b8bc:	b292      	uxth	r2, r2
 800b8be:	f104 032a 	add.w	r3, r4, #42	; 0x2a
 800b8c2:	f104 010d 	add.w	r1, r4, #13
 800b8c6:	4610      	mov	r0, r2
 800b8c8:	9600      	str	r6, [sp, #0]
 800b8ca:	b29b      	uxth	r3, r3
 800b8cc:	b289      	uxth	r1, r1
 800b8ce:	f004 ffd7 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+10, Y+14, X+10, Y+41, TFT_White);
 800b8d2:	f104 080e 	add.w	r8, r4, #14
 800b8d6:	f105 020a 	add.w	r2, r5, #10
 800b8da:	b292      	uxth	r2, r2
 800b8dc:	fa1f f888 	uxth.w	r8, r8
 800b8e0:	f104 0329 	add.w	r3, r4, #41	; 0x29
 800b8e4:	4641      	mov	r1, r8
 800b8e6:	4610      	mov	r0, r2
 800b8e8:	9600      	str	r6, [sp, #0]
 800b8ea:	b29b      	uxth	r3, r3
 800b8ec:	f004 ffc8 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+11, Y+14, X+11, Y+40, TFT_White);
 800b8f0:	f104 0728 	add.w	r7, r4, #40	; 0x28
 800b8f4:	f105 020b 	add.w	r2, r5, #11
 800b8f8:	b292      	uxth	r2, r2
 800b8fa:	b2bf      	uxth	r7, r7
 800b8fc:	463b      	mov	r3, r7
 800b8fe:	4641      	mov	r1, r8
 800b900:	4610      	mov	r0, r2
 800b902:	9600      	str	r6, [sp, #0]
 800b904:	f004 ffbc 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+12, Y+15, X+12, Y+40, TFT_White);
 800b908:	f105 020c 	add.w	r2, r5, #12
 800b90c:	b292      	uxth	r2, r2
 800b90e:	f104 010f 	add.w	r1, r4, #15
 800b912:	463b      	mov	r3, r7
 800b914:	4610      	mov	r0, r2
 800b916:	9600      	str	r6, [sp, #0]
 800b918:	b289      	uxth	r1, r1
 800b91a:	f004 ffb1 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+13, Y+16, X+13, Y+39, TFT_White);
 800b91e:	f104 0810 	add.w	r8, r4, #16
 800b922:	f105 020d 	add.w	r2, r5, #13
 800b926:	b292      	uxth	r2, r2
 800b928:	fa1f f888 	uxth.w	r8, r8
 800b92c:	f104 0327 	add.w	r3, r4, #39	; 0x27
 800b930:	4641      	mov	r1, r8
 800b932:	4610      	mov	r0, r2
 800b934:	9600      	str	r6, [sp, #0]
 800b936:	b29b      	uxth	r3, r3
 800b938:	f004 ffa2 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+14, Y+16, X+14, Y+38, TFT_White);
 800b93c:	f104 0726 	add.w	r7, r4, #38	; 0x26
 800b940:	f105 020e 	add.w	r2, r5, #14
 800b944:	b292      	uxth	r2, r2
 800b946:	b2bf      	uxth	r7, r7
 800b948:	463b      	mov	r3, r7
 800b94a:	4641      	mov	r1, r8
 800b94c:	4610      	mov	r0, r2
 800b94e:	9600      	str	r6, [sp, #0]
 800b950:	f004 ff96 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+15, Y+17, X+15, Y+38, TFT_White);
 800b954:	f105 020f 	add.w	r2, r5, #15
 800b958:	b292      	uxth	r2, r2
 800b95a:	f104 0111 	add.w	r1, r4, #17
 800b95e:	463b      	mov	r3, r7
 800b960:	4610      	mov	r0, r2
 800b962:	9600      	str	r6, [sp, #0]
 800b964:	b289      	uxth	r1, r1
 800b966:	f004 ff8b 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+16, Y+18, X+16, Y+37, TFT_White);
 800b96a:	f104 0812 	add.w	r8, r4, #18
 800b96e:	f105 0210 	add.w	r2, r5, #16
 800b972:	b292      	uxth	r2, r2
 800b974:	fa1f f888 	uxth.w	r8, r8
 800b978:	f104 0325 	add.w	r3, r4, #37	; 0x25
 800b97c:	4641      	mov	r1, r8
 800b97e:	4610      	mov	r0, r2
 800b980:	9600      	str	r6, [sp, #0]
 800b982:	b29b      	uxth	r3, r3
 800b984:	f004 ff7c 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+17, Y+18, X+17, Y+36, TFT_White);
 800b988:	f104 0724 	add.w	r7, r4, #36	; 0x24
 800b98c:	f105 0211 	add.w	r2, r5, #17
 800b990:	b292      	uxth	r2, r2
 800b992:	b2bf      	uxth	r7, r7
 800b994:	463b      	mov	r3, r7
 800b996:	4641      	mov	r1, r8
 800b998:	4610      	mov	r0, r2
 800b99a:	9600      	str	r6, [sp, #0]
 800b99c:	f004 ff70 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+18, Y+19, X+18, Y+36, TFT_White);
 800b9a0:	f105 0212 	add.w	r2, r5, #18
 800b9a4:	b292      	uxth	r2, r2
 800b9a6:	f104 0113 	add.w	r1, r4, #19
 800b9aa:	463b      	mov	r3, r7
 800b9ac:	4610      	mov	r0, r2
 800b9ae:	9600      	str	r6, [sp, #0]
 800b9b0:	b289      	uxth	r1, r1
 800b9b2:	f004 ff65 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+19, Y+20, X+19, Y+35, TFT_White);
 800b9b6:	f104 0714 	add.w	r7, r4, #20
 800b9ba:	f105 0213 	add.w	r2, r5, #19
 800b9be:	b292      	uxth	r2, r2
 800b9c0:	b2bf      	uxth	r7, r7
 800b9c2:	f104 0323 	add.w	r3, r4, #35	; 0x23
 800b9c6:	4639      	mov	r1, r7
 800b9c8:	4610      	mov	r0, r2
 800b9ca:	9600      	str	r6, [sp, #0]
 800b9cc:	b29b      	uxth	r3, r3
 800b9ce:	f004 ff57 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+20, Y+20, X+20, Y+34, TFT_White);
 800b9d2:	f105 0214 	add.w	r2, r5, #20
 800b9d6:	b292      	uxth	r2, r2
 800b9d8:	f104 0322 	add.w	r3, r4, #34	; 0x22
 800b9dc:	4639      	mov	r1, r7
 800b9de:	4610      	mov	r0, r2
 800b9e0:	9600      	str	r6, [sp, #0]
 800b9e2:	b29b      	uxth	r3, r3
 800b9e4:	f004 ff4c 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+21, Y+21, X+21, Y+33, TFT_White);
 800b9e8:	f104 0821 	add.w	r8, r4, #33	; 0x21
 800b9ec:	f105 0215 	add.w	r2, r5, #21
 800b9f0:	b292      	uxth	r2, r2
 800b9f2:	fa1f f888 	uxth.w	r8, r8
 800b9f6:	f104 0115 	add.w	r1, r4, #21
 800b9fa:	4643      	mov	r3, r8
 800b9fc:	4610      	mov	r0, r2
 800b9fe:	9600      	str	r6, [sp, #0]
 800ba00:	b289      	uxth	r1, r1
 800ba02:	f004 ff3d 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+22, Y+22, X+22, Y+33, TFT_White);
 800ba06:	f104 0716 	add.w	r7, r4, #22
 800ba0a:	f105 0216 	add.w	r2, r5, #22
 800ba0e:	b292      	uxth	r2, r2
 800ba10:	b2bf      	uxth	r7, r7
 800ba12:	4643      	mov	r3, r8
 800ba14:	4639      	mov	r1, r7
 800ba16:	4610      	mov	r0, r2
 800ba18:	9600      	str	r6, [sp, #0]
 800ba1a:	f004 ff31 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+23, Y+22, X+23, Y+32, TFT_White);
 800ba1e:	f105 0217 	add.w	r2, r5, #23
 800ba22:	b292      	uxth	r2, r2
 800ba24:	f104 0320 	add.w	r3, r4, #32
 800ba28:	4639      	mov	r1, r7
 800ba2a:	4610      	mov	r0, r2
 800ba2c:	9600      	str	r6, [sp, #0]
 800ba2e:	b29b      	uxth	r3, r3
 800ba30:	f004 ff26 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+24, Y+23, X+24, Y+31, TFT_White);
 800ba34:	f104 081f 	add.w	r8, r4, #31
 800ba38:	f105 0218 	add.w	r2, r5, #24
 800ba3c:	b292      	uxth	r2, r2
 800ba3e:	fa1f f888 	uxth.w	r8, r8
 800ba42:	f104 0117 	add.w	r1, r4, #23
 800ba46:	4643      	mov	r3, r8
 800ba48:	4610      	mov	r0, r2
 800ba4a:	9600      	str	r6, [sp, #0]
 800ba4c:	b289      	uxth	r1, r1
 800ba4e:	f004 ff17 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+25, Y+24, X+25, Y+31, TFT_White);
 800ba52:	f104 0718 	add.w	r7, r4, #24
 800ba56:	f105 0219 	add.w	r2, r5, #25
 800ba5a:	b292      	uxth	r2, r2
 800ba5c:	b2bf      	uxth	r7, r7
 800ba5e:	4643      	mov	r3, r8
 800ba60:	4639      	mov	r1, r7
 800ba62:	4610      	mov	r0, r2
 800ba64:	9600      	str	r6, [sp, #0]
 800ba66:	f004 ff0b 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+26, Y+24, X+26, Y+30, TFT_White);
 800ba6a:	f105 021a 	add.w	r2, r5, #26
 800ba6e:	b292      	uxth	r2, r2
 800ba70:	f104 031e 	add.w	r3, r4, #30
 800ba74:	4639      	mov	r1, r7
 800ba76:	4610      	mov	r0, r2
 800ba78:	9600      	str	r6, [sp, #0]
 800ba7a:	b29b      	uxth	r3, r3
 800ba7c:	f004 ff00 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+27, Y+25, X+27, Y+29, TFT_White);
 800ba80:	f104 0819 	add.w	r8, r4, #25
 800ba84:	f105 021b 	add.w	r2, r5, #27
 800ba88:	b292      	uxth	r2, r2
 800ba8a:	fa1f f888 	uxth.w	r8, r8
 800ba8e:	f104 031d 	add.w	r3, r4, #29
 800ba92:	4641      	mov	r1, r8
 800ba94:	4610      	mov	r0, r2
 800ba96:	9600      	str	r6, [sp, #0]
 800ba98:	b29b      	uxth	r3, r3
 800ba9a:	f004 fef1 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+28, Y+25, X+28, Y+28, TFT_White);
 800ba9e:	f104 071c 	add.w	r7, r4, #28
 800baa2:	f105 021c 	add.w	r2, r5, #28
 800baa6:	b292      	uxth	r2, r2
 800baa8:	b2bf      	uxth	r7, r7
 800baaa:	463b      	mov	r3, r7
 800baac:	4641      	mov	r1, r8
 800baae:	4610      	mov	r0, r2
 800bab0:	9600      	str	r6, [sp, #0]
 800bab2:	f004 fee5 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+29, Y+26, X+29, Y+28, TFT_White);
 800bab6:	f105 021d 	add.w	r2, r5, #29
 800baba:	b292      	uxth	r2, r2
 800babc:	f104 011a 	add.w	r1, r4, #26
 800bac0:	463b      	mov	r3, r7
 800bac2:	4610      	mov	r0, r2
 800bac4:	9600      	str	r6, [sp, #0]
 800bac6:	b289      	uxth	r1, r1
 800bac8:	f004 feda 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+30, Y+27, X+30, Y+27, TFT_White);
 800bacc:	9600      	str	r6, [sp, #0]
 800bace:	465b      	mov	r3, fp
 800bad0:	4652      	mov	r2, sl
 800bad2:	4659      	mov	r1, fp
 800bad4:	4650      	mov	r0, sl
 800bad6:	f004 fed3 	bl	8010880 <TFT_DrawLine>
}
 800bada:	b005      	add	sp, #20
 800badc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800bae0 <GUI_CheckBox>:



void GUI_CheckBox(uint16_t X, uint16_t Y, uint16_t Check)
{
 800bae0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_DrawRectangle(X, Y, X+35, Y+35, TFT_Blue_Off);
 800bae4:	f101 0323 	add.w	r3, r1, #35	; 0x23
{
 800bae8:	4616      	mov	r6, r2
	TFT_DrawRectangle(X, Y, X+35, Y+35, TFT_Blue_Off);
 800baea:	f241 3876 	movw	r8, #4982	; 0x1376
 800baee:	f100 0223 	add.w	r2, r0, #35	; 0x23
 800baf2:	f8cd 8000 	str.w	r8, [sp]
 800baf6:	b29b      	uxth	r3, r3
 800baf8:	b292      	uxth	r2, r2
{
 800bafa:	4604      	mov	r4, r0
 800bafc:	460d      	mov	r5, r1
	TFT_DrawRectangle(X, Y, X+35, Y+35, TFT_Blue_Off);
 800bafe:	f004 ff34 	bl	801096a <TFT_DrawRectangle>
	if(Check)
 800bb02:	b1fe      	cbz	r6, 800bb44 <GUI_CheckBox+0x64>
		{
			TFT_DrawLine(X+8, Y+17, X+16, Y+26, TFT_Blue_Off);
 800bb04:	f104 0610 	add.w	r6, r4, #16
 800bb08:	f105 071a 	add.w	r7, r5, #26
 800bb0c:	b2b6      	uxth	r6, r6
 800bb0e:	b2bf      	uxth	r7, r7
 800bb10:	f105 0111 	add.w	r1, r5, #17
 800bb14:	f104 0008 	add.w	r0, r4, #8
 800bb18:	463b      	mov	r3, r7
 800bb1a:	4632      	mov	r2, r6
 800bb1c:	b289      	uxth	r1, r1
 800bb1e:	b280      	uxth	r0, r0
 800bb20:	f8cd 8000 	str.w	r8, [sp]
 800bb24:	f004 feac 	bl	8010880 <TFT_DrawLine>
			TFT_DrawLine(X+16, Y+26, X+29, Y+5, TFT_Blue_Off);
 800bb28:	1d6b      	adds	r3, r5, #5
 800bb2a:	f104 021d 	add.w	r2, r4, #29
 800bb2e:	f8cd 8000 	str.w	r8, [sp]
 800bb32:	b29b      	uxth	r3, r3
 800bb34:	b292      	uxth	r2, r2
 800bb36:	4639      	mov	r1, r7
 800bb38:	4630      	mov	r0, r6
 800bb3a:	f004 fea1 	bl	8010880 <TFT_DrawLine>
		} else {
			TFT_FillRectangle(X+2, Y+2, X+32, Y+32, TFT_Black_Bkgr); //Pause
		}
}
 800bb3e:	b002      	add	sp, #8
 800bb40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			TFT_FillRectangle(X+2, Y+2, X+32, Y+32, TFT_Black_Bkgr); //Pause
 800bb44:	f105 0320 	add.w	r3, r5, #32
 800bb48:	f104 0220 	add.w	r2, r4, #32
 800bb4c:	1ca9      	adds	r1, r5, #2
 800bb4e:	1ca0      	adds	r0, r4, #2
 800bb50:	2463      	movs	r4, #99	; 0x63
 800bb52:	9400      	str	r4, [sp, #0]
 800bb54:	b29b      	uxth	r3, r3
 800bb56:	b292      	uxth	r2, r2
 800bb58:	b289      	uxth	r1, r1
 800bb5a:	b280      	uxth	r0, r0
 800bb5c:	f004 feed 	bl	801093a <TFT_FillRectangle>
}
 800bb60:	e7ed      	b.n	800bb3e <GUI_CheckBox+0x5e>

0800bb62 <GUI_RadioBox>:



void GUI_RadioBox(uint16_t X, uint16_t Y, uint16_t Check, uint16_t Active)
{
 800bb62:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bb66:	f100 0411 	add.w	r4, r0, #17
 800bb6a:	f101 0511 	add.w	r5, r1, #17
 800bb6e:	4690      	mov	r8, r2
	if(Active){
		TFT_DrawCircle(X+17, Y+17, 15, TFT_Blue_Off);
 800bb70:	b226      	sxth	r6, r4
 800bb72:	b22f      	sxth	r7, r5
	if(Active){
 800bb74:	b173      	cbz	r3, 800bb94 <GUI_RadioBox+0x32>
		TFT_DrawCircle(X+17, Y+17, 15, TFT_Blue_Off);
 800bb76:	f241 3376 	movw	r3, #4982	; 0x1376
 800bb7a:	220f      	movs	r2, #15
 800bb7c:	4639      	mov	r1, r7
 800bb7e:	4630      	mov	r0, r6
 800bb80:	f004 fdde 	bl	8010740 <TFT_DrawCircle>
	} else
	{
		TFT_DrawCircle(X+17, Y+17, 15, TFT_GreyMain);
	}
	if(Check)
 800bb84:	f1b8 0f00 	cmp.w	r8, #0
 800bb88:	d111      	bne.n	800bbae <GUI_RadioBox+0x4c>
			if(Active)
				{	TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_Blue_Off);} else
				{	TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_GreyMain);}
		} else
		{
			TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_Black_Bkgr);
 800bb8a:	2363      	movs	r3, #99	; 0x63
 800bb8c:	220a      	movs	r2, #10
 800bb8e:	b229      	sxth	r1, r5
 800bb90:	b220      	sxth	r0, r4
 800bb92:	e011      	b.n	800bbb8 <GUI_RadioBox+0x56>
		TFT_DrawCircle(X+17, Y+17, 15, TFT_GreyMain);
 800bb94:	f64d 731c 	movw	r3, #57116	; 0xdf1c
 800bb98:	220f      	movs	r2, #15
 800bb9a:	4639      	mov	r1, r7
 800bb9c:	4630      	mov	r0, r6
 800bb9e:	f004 fdcf 	bl	8010740 <TFT_DrawCircle>
	if(Check)
 800bba2:	f1b8 0f00 	cmp.w	r8, #0
 800bba6:	d0f0      	beq.n	800bb8a <GUI_RadioBox+0x28>
				{	TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_GreyMain);}
 800bba8:	f64d 731c 	movw	r3, #57116	; 0xdf1c
 800bbac:	e001      	b.n	800bbb2 <GUI_RadioBox+0x50>
				{	TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_Blue_Off);} else
 800bbae:	f241 3376 	movw	r3, #4982	; 0x1376
				{	TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_GreyMain);}
 800bbb2:	220a      	movs	r2, #10
 800bbb4:	4639      	mov	r1, r7
 800bbb6:	4630      	mov	r0, r6
		}
}
 800bbb8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			TFT_DrawFilledCircle(X+17, Y+17, 10, TFT_Black_Bkgr);
 800bbbc:	f004 bef9 	b.w	80109b2 <TFT_DrawFilledCircle>

0800bbc0 <GUI_Switch_Button>:

void GUI_Switch_Button(uint16_t X, uint16_t Y, uint8_t Check)
{
 800bbc0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bbc4:	f101 031c 	add.w	r3, r1, #28
 800bbc8:	2663      	movs	r6, #99	; 0x63
{
 800bbca:	4617      	mov	r7, r2
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bbcc:	f100 0224 	add.w	r2, r0, #36	; 0x24
{
 800bbd0:	460d      	mov	r5, r1
 800bbd2:	4604      	mov	r4, r0
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bbd4:	9600      	str	r6, [sp, #0]
 800bbd6:	b29b      	uxth	r3, r3
 800bbd8:	b292      	uxth	r2, r2
 800bbda:	f004 feae 	bl	801093a <TFT_FillRectangle>
 800bbde:	f105 0611 	add.w	r6, r5, #17
 800bbe2:	f105 0318 	add.w	r3, r5, #24
 800bbe6:	f105 010a 	add.w	r1, r5, #10
 800bbea:	f104 0223 	add.w	r2, r4, #35	; 0x23
 800bbee:	4d1f      	ldr	r5, [pc, #124]	; (800bc6c <GUI_Switch_Button+0xac>)
	if(Check)
 800bbf0:	b1ef      	cbz	r7, 800bc2e <GUI_Switch_Button+0x6e>
		{
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_Blue_On);
 800bbf2:	f242 409b 	movw	r0, #9371	; 0x249b
 800bbf6:	270a      	movs	r7, #10
 800bbf8:	9001      	str	r0, [sp, #4]
 800bbfa:	b29b      	uxth	r3, r3
 800bbfc:	b292      	uxth	r2, r2
 800bbfe:	b289      	uxth	r1, r1
 800bc00:	4620      	mov	r0, r4
 800bc02:	9700      	str	r7, [sp, #0]
 800bc04:	f005 f81e 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
			TFT_DrawFilledCircle(X+25, Y+17, 10, TFT_Blue_Off);
 800bc08:	f104 0019 	add.w	r0, r4, #25
 800bc0c:	f241 3376 	movw	r3, #4982	; 0x1376
 800bc10:	463a      	mov	r2, r7
 800bc12:	b231      	sxth	r1, r6
 800bc14:	b200      	sxth	r0, r0
 800bc16:	f004 fecc 	bl	80109b2 <TFT_DrawFilledCircle>
			if(BluetoothStat == 0x00){
 800bc1a:	782b      	ldrb	r3, [r5, #0]
 800bc1c:	b923      	cbnz	r3, 800bc28 <GUI_Switch_Button+0x68>
				HAL_UART_MspInit(&hlpuart1); //Enable Bluetooth
 800bc1e:	4814      	ldr	r0, [pc, #80]	; (800bc70 <GUI_Switch_Button+0xb0>)
 800bc20:	f005 ff7c 	bl	8011b1c <HAL_UART_MspInit>
				BluetoothStat = 0x01;
 800bc24:	2301      	movs	r3, #1
 800bc26:	702b      	strb	r3, [r5, #0]
			if(BluetoothStat == 0x01){
				HAL_UART_MspDeInit(&hlpuart1); //Disable Bluetooth
				BluetoothStat = 0x00;
			}
		}
}
 800bc28:	b002      	add	sp, #8
 800bc2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_LightGrey);
 800bc2e:	f04f 080a 	mov.w	r8, #10
 800bc32:	f24c 6018 	movw	r0, #50712	; 0xc618
 800bc36:	9001      	str	r0, [sp, #4]
 800bc38:	b29b      	uxth	r3, r3
 800bc3a:	b292      	uxth	r2, r2
 800bc3c:	b289      	uxth	r1, r1
 800bc3e:	4620      	mov	r0, r4
 800bc40:	f8cd 8000 	str.w	r8, [sp]
 800bc44:	f004 fffe 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
			TFT_DrawFilledCircle(X+10, Y+17, 10, TFT_White);
 800bc48:	eb04 0008 	add.w	r0, r4, r8
 800bc4c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800bc50:	4642      	mov	r2, r8
 800bc52:	b231      	sxth	r1, r6
 800bc54:	b200      	sxth	r0, r0
 800bc56:	f004 feac 	bl	80109b2 <TFT_DrawFilledCircle>
			if(BluetoothStat == 0x01){
 800bc5a:	782b      	ldrb	r3, [r5, #0]
 800bc5c:	2b01      	cmp	r3, #1
 800bc5e:	d1e3      	bne.n	800bc28 <GUI_Switch_Button+0x68>
				HAL_UART_MspDeInit(&hlpuart1); //Disable Bluetooth
 800bc60:	4803      	ldr	r0, [pc, #12]	; (800bc70 <GUI_Switch_Button+0xb0>)
 800bc62:	f005 ff87 	bl	8011b74 <HAL_UART_MspDeInit>
				BluetoothStat = 0x00;
 800bc66:	702f      	strb	r7, [r5, #0]
}
 800bc68:	e7de      	b.n	800bc28 <GUI_Switch_Button+0x68>
 800bc6a:	bf00      	nop
 800bc6c:	200002fd 	.word	0x200002fd
 800bc70:	20085a98 	.word	0x20085a98

0800bc74 <GUI_Switch_ButtonActive>:

void GUI_Switch_ButtonActive(uint16_t X, uint16_t Y, uint8_t Check)
{
 800bc74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bc76:	f101 031c 	add.w	r3, r1, #28
{
 800bc7a:	4616      	mov	r6, r2
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bc7c:	2763      	movs	r7, #99	; 0x63
 800bc7e:	f100 0224 	add.w	r2, r0, #36	; 0x24
 800bc82:	b29b      	uxth	r3, r3
 800bc84:	b292      	uxth	r2, r2
 800bc86:	9700      	str	r7, [sp, #0]
{
 800bc88:	460d      	mov	r5, r1
 800bc8a:	4604      	mov	r4, r0
	TFT_FillRectangle(X, Y, X+36, Y+28, TFT_Black_Bkgr);
 800bc8c:	f004 fe55 	bl	801093a <TFT_FillRectangle>
	if(Check)
		{
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_Blue_On);
 800bc90:	f242 409b 	movw	r0, #9371	; 0x249b
 800bc94:	f105 0318 	add.w	r3, r5, #24
 800bc98:	f105 010a 	add.w	r1, r5, #10
 800bc9c:	f104 0223 	add.w	r2, r4, #35	; 0x23
 800bca0:	3511      	adds	r5, #17
 800bca2:	9001      	str	r0, [sp, #4]
	if(Check)
 800bca4:	b19e      	cbz	r6, 800bcce <GUI_Switch_ButtonActive+0x5a>
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_Blue_On);
 800bca6:	260a      	movs	r6, #10
 800bca8:	b29b      	uxth	r3, r3
 800bcaa:	4620      	mov	r0, r4
 800bcac:	9600      	str	r6, [sp, #0]
 800bcae:	b292      	uxth	r2, r2
 800bcb0:	b289      	uxth	r1, r1
 800bcb2:	f004 ffc7 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
			TFT_DrawFilledCircle(X+25, Y+17, 10, TFT_Blue_Off);
 800bcb6:	f104 0019 	add.w	r0, r4, #25
 800bcba:	f241 3376 	movw	r3, #4982	; 0x1376
		} else
		{
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_Blue_On);
			TFT_DrawFilledCircle(X+10, Y+17, 10, TFT_White);
 800bcbe:	4632      	mov	r2, r6
 800bcc0:	b229      	sxth	r1, r5
 800bcc2:	b200      	sxth	r0, r0
		}
}
 800bcc4:	b003      	add	sp, #12
 800bcc6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			TFT_DrawFilledCircle(X+10, Y+17, 10, TFT_White);
 800bcca:	f004 be72 	b.w	80109b2 <TFT_DrawFilledCircle>
			TFT_DrawFilledRoundedRectangle(X, Y+10, X+35, Y+24, 10, TFT_Blue_On);
 800bcce:	260a      	movs	r6, #10
 800bcd0:	b29b      	uxth	r3, r3
 800bcd2:	4620      	mov	r0, r4
 800bcd4:	9600      	str	r6, [sp, #0]
 800bcd6:	b292      	uxth	r2, r2
 800bcd8:	b289      	uxth	r1, r1
 800bcda:	f004 ffb3 	bl	8010c44 <TFT_DrawFilledRoundedRectangle>
			TFT_DrawFilledCircle(X+10, Y+17, 10, TFT_White);
 800bcde:	19a0      	adds	r0, r4, r6
 800bce0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800bce4:	e7eb      	b.n	800bcbe <GUI_Switch_ButtonActive+0x4a>

0800bce6 <GUI_Flag_Ru>:


void GUI_Flag_Ru(uint16_t X, uint16_t Y)
{
 800bce6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_FillRectangle(X, Y, X+35, Y+7, TFT_White);
 800bcea:	f100 0423 	add.w	r4, r0, #35	; 0x23
 800bcee:	1dcf      	adds	r7, r1, #7
{
 800bcf0:	460d      	mov	r5, r1
	TFT_FillRectangle(X, Y, X+35, Y+7, TFT_White);
 800bcf2:	b2a4      	uxth	r4, r4
 800bcf4:	b2bf      	uxth	r7, r7
 800bcf6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800bcfa:	9300      	str	r3, [sp, #0]
 800bcfc:	4622      	mov	r2, r4
 800bcfe:	463b      	mov	r3, r7
	TFT_FillRectangle(X, Y+7, X+35, Y+14, TFT_RuBlue);
 800bd00:	f105 060e 	add.w	r6, r5, #14
{
 800bd04:	4680      	mov	r8, r0
	TFT_FillRectangle(X, Y+7, X+35, Y+14, TFT_RuBlue);
 800bd06:	b2b6      	uxth	r6, r6
	TFT_FillRectangle(X, Y, X+35, Y+7, TFT_White);
 800bd08:	f004 fe17 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X, Y+7, X+35, Y+14, TFT_RuBlue);
 800bd0c:	f44f 73ea 	mov.w	r3, #468	; 0x1d4
 800bd10:	9300      	str	r3, [sp, #0]
 800bd12:	4622      	mov	r2, r4
 800bd14:	4633      	mov	r3, r6
 800bd16:	4639      	mov	r1, r7
 800bd18:	4640      	mov	r0, r8
 800bd1a:	f004 fe0e 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X, Y+14, X+35, Y+21, TFT_RuRed);
 800bd1e:	f105 0315 	add.w	r3, r5, #21
 800bd22:	f64c 1243 	movw	r2, #51523	; 0xc943
 800bd26:	9200      	str	r2, [sp, #0]
 800bd28:	b29b      	uxth	r3, r3
 800bd2a:	4622      	mov	r2, r4
 800bd2c:	4631      	mov	r1, r6
 800bd2e:	4640      	mov	r0, r8
 800bd30:	f004 fe03 	bl	801093a <TFT_FillRectangle>
}
 800bd34:	b002      	add	sp, #8
 800bd36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800bd3a <GUI_Flag_En>:

void GUI_Flag_En(uint16_t X, uint16_t Y)
{
 800bd3a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	TFT_FillRectangle(X, Y, X+15, Y+9, TFT_Navy);
 800bd3e:	f100 030f 	add.w	r3, r0, #15
{
 800bd42:	b08d      	sub	sp, #52	; 0x34
	TFT_FillRectangle(X, Y, X+15, Y+9, TFT_Navy);
 800bd44:	b29b      	uxth	r3, r3
 800bd46:	270f      	movs	r7, #15
 800bd48:	9302      	str	r3, [sp, #8]
 800bd4a:	f101 0309 	add.w	r3, r1, #9
{
 800bd4e:	4604      	mov	r4, r0
	TFT_FillRectangle(X, Y, X+15, Y+9, TFT_Navy);
 800bd50:	b29b      	uxth	r3, r3
 800bd52:	9700      	str	r7, [sp, #0]
 800bd54:	9a02      	ldr	r2, [sp, #8]
 800bd56:	9303      	str	r3, [sp, #12]
{
 800bd58:	460d      	mov	r5, r1
	TFT_FillRectangle(X, Y, X+15, Y+9, TFT_Navy);
 800bd5a:	f004 fdee 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+20, Y, X+34, Y+9, TFT_Navy);
 800bd5e:	f104 0314 	add.w	r3, r4, #20
 800bd62:	b29b      	uxth	r3, r3
 800bd64:	f104 0822 	add.w	r8, r4, #34	; 0x22
 800bd68:	fa1f f888 	uxth.w	r8, r8
 800bd6c:	9304      	str	r3, [sp, #16]
 800bd6e:	9700      	str	r7, [sp, #0]
 800bd70:	9b03      	ldr	r3, [sp, #12]
 800bd72:	9804      	ldr	r0, [sp, #16]
 800bd74:	4642      	mov	r2, r8
 800bd76:	4629      	mov	r1, r5
 800bd78:	f004 fddf 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X, Y+14, X+15, Y+21, TFT_Navy);
 800bd7c:	f105 030e 	add.w	r3, r5, #14
 800bd80:	b29b      	uxth	r3, r3
 800bd82:	f105 0615 	add.w	r6, r5, #21
 800bd86:	b2b6      	uxth	r6, r6
 800bd88:	9305      	str	r3, [sp, #20]
 800bd8a:	9700      	str	r7, [sp, #0]
 800bd8c:	4633      	mov	r3, r6
 800bd8e:	9a02      	ldr	r2, [sp, #8]
 800bd90:	9905      	ldr	r1, [sp, #20]
 800bd92:	4620      	mov	r0, r4
 800bd94:	f004 fdd1 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+20, Y+14, X+34, Y+21, TFT_Navy);
 800bd98:	9700      	str	r7, [sp, #0]
 800bd9a:	4633      	mov	r3, r6
 800bd9c:	4642      	mov	r2, r8
 800bd9e:	9905      	ldr	r1, [sp, #20]
 800bda0:	9804      	ldr	r0, [sp, #16]
 800bda2:	f004 fdca 	bl	801093a <TFT_FillRectangle>
	
	TFT_DrawLine(X, Y+2, X+29, Y+21, TFT_White);
 800bda6:	1cab      	adds	r3, r5, #2
 800bda8:	b29b      	uxth	r3, r3
 800bdaa:	f104 091d 	add.w	r9, r4, #29
 800bdae:	f64f 77ff 	movw	r7, #65535	; 0xffff
 800bdb2:	9307      	str	r3, [sp, #28]
 800bdb4:	fa1f f989 	uxth.w	r9, r9
 800bdb8:	9700      	str	r7, [sp, #0]
 800bdba:	4633      	mov	r3, r6
 800bdbc:	464a      	mov	r2, r9
 800bdbe:	9907      	ldr	r1, [sp, #28]
 800bdc0:	4620      	mov	r0, r4
 800bdc2:	f004 fd5d 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X, Y+1, X+29, Y+21, TFT_White);
 800bdc6:	1c6b      	adds	r3, r5, #1
 800bdc8:	b29b      	uxth	r3, r3
 800bdca:	9308      	str	r3, [sp, #32]
 800bdcc:	9700      	str	r7, [sp, #0]
 800bdce:	4633      	mov	r3, r6
 800bdd0:	464a      	mov	r2, r9
 800bdd2:	9908      	ldr	r1, [sp, #32]
 800bdd4:	4620      	mov	r0, r4
 800bdd6:	f004 fd53 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X, Y, X+30, Y+21, TFT_White);
 800bdda:	f104 021e 	add.w	r2, r4, #30
 800bdde:	9700      	str	r7, [sp, #0]
 800bde0:	4633      	mov	r3, r6
 800bde2:	4629      	mov	r1, r5
 800bde4:	4620      	mov	r0, r4
 800bde6:	b292      	uxth	r2, r2
 800bde8:	f004 fd4a 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+1, Y, X+31, Y+21, TFT_White);
 800bdec:	1c63      	adds	r3, r4, #1
 800bdee:	b29b      	uxth	r3, r3
 800bdf0:	f104 0a1f 	add.w	sl, r4, #31
 800bdf4:	9309      	str	r3, [sp, #36]	; 0x24
 800bdf6:	fa1f fa8a 	uxth.w	sl, sl
 800bdfa:	9700      	str	r7, [sp, #0]
 800bdfc:	4633      	mov	r3, r6
 800bdfe:	4652      	mov	r2, sl
 800be00:	4629      	mov	r1, r5
 800be02:	9809      	ldr	r0, [sp, #36]	; 0x24
 800be04:	f004 fd3c 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+2, Y, X+31, Y+21, TFT_White);
 800be08:	1ca3      	adds	r3, r4, #2
 800be0a:	b29b      	uxth	r3, r3
 800be0c:	930a      	str	r3, [sp, #40]	; 0x28
 800be0e:	9700      	str	r7, [sp, #0]
 800be10:	4633      	mov	r3, r6
 800be12:	4652      	mov	r2, sl
 800be14:	4629      	mov	r1, r5
 800be16:	980a      	ldr	r0, [sp, #40]	; 0x28
 800be18:	f004 fd32 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+3, Y, X+32, Y+21, TFT_White);
 800be1c:	1ce3      	adds	r3, r4, #3
 800be1e:	b29b      	uxth	r3, r3
 800be20:	f104 0920 	add.w	r9, r4, #32
 800be24:	930b      	str	r3, [sp, #44]	; 0x2c
 800be26:	fa1f f989 	uxth.w	r9, r9
 800be2a:	9700      	str	r7, [sp, #0]
 800be2c:	4633      	mov	r3, r6
 800be2e:	464a      	mov	r2, r9
 800be30:	4629      	mov	r1, r5
 800be32:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800be34:	f004 fd24 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+4, Y, X+33, Y+21, TFT_White);
 800be38:	1d23      	adds	r3, r4, #4
 800be3a:	b29b      	uxth	r3, r3
 800be3c:	f104 0b21 	add.w	fp, r4, #33	; 0x21
 800be40:	9306      	str	r3, [sp, #24]
 800be42:	fa1f fb8b 	uxth.w	fp, fp
 800be46:	9700      	str	r7, [sp, #0]
 800be48:	4633      	mov	r3, r6
 800be4a:	465a      	mov	r2, fp
 800be4c:	4629      	mov	r1, r5
 800be4e:	9806      	ldr	r0, [sp, #24]
 800be50:	f004 fd16 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+4, Y, X+34, Y+21, TFT_White);
 800be54:	9700      	str	r7, [sp, #0]
 800be56:	4633      	mov	r3, r6
 800be58:	4642      	mov	r2, r8
 800be5a:	4629      	mov	r1, r5
 800be5c:	9806      	ldr	r0, [sp, #24]
 800be5e:	f004 fd0f 	bl	8010880 <TFT_DrawLine>
	
	TFT_DrawLine(X, Y+21, X+31, Y, TFT_White);
 800be62:	9700      	str	r7, [sp, #0]
 800be64:	462b      	mov	r3, r5
 800be66:	4652      	mov	r2, sl
 800be68:	4631      	mov	r1, r6
 800be6a:	4620      	mov	r0, r4
 800be6c:	f004 fd08 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+1, Y+21, X+32, Y, TFT_White);
 800be70:	9700      	str	r7, [sp, #0]
 800be72:	462b      	mov	r3, r5
 800be74:	464a      	mov	r2, r9
 800be76:	4631      	mov	r1, r6
 800be78:	9809      	ldr	r0, [sp, #36]	; 0x24
 800be7a:	f004 fd01 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+2, Y+21, X+32, Y, TFT_White);
 800be7e:	9700      	str	r7, [sp, #0]
 800be80:	462b      	mov	r3, r5
 800be82:	464a      	mov	r2, r9
 800be84:	4631      	mov	r1, r6
 800be86:	980a      	ldr	r0, [sp, #40]	; 0x28
 800be88:	f004 fcfa 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+3, Y+21, X+33, Y, TFT_White);
 800be8c:	9700      	str	r7, [sp, #0]
 800be8e:	462b      	mov	r3, r5
 800be90:	465a      	mov	r2, fp
 800be92:	4631      	mov	r1, r6
 800be94:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800be96:	f004 fcf3 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+4, Y+21, X+34, Y, TFT_White);
 800be9a:	9700      	str	r7, [sp, #0]
 800be9c:	462b      	mov	r3, r5
 800be9e:	4642      	mov	r2, r8
 800bea0:	4631      	mov	r1, r6
 800bea2:	9806      	ldr	r0, [sp, #24]
 800bea4:	f004 fcec 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+5, Y+21, X+34, Y+1, TFT_White);
 800bea8:	1d60      	adds	r0, r4, #5
 800beaa:	9700      	str	r7, [sp, #0]
 800beac:	9b08      	ldr	r3, [sp, #32]
 800beae:	4642      	mov	r2, r8
 800beb0:	4631      	mov	r1, r6
 800beb2:	b280      	uxth	r0, r0
 800beb4:	f004 fce4 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(X+6, Y+21, X+34, Y+2, TFT_White);
 800beb8:	1da0      	adds	r0, r4, #6
 800beba:	9700      	str	r7, [sp, #0]
 800bebc:	9b07      	ldr	r3, [sp, #28]
 800bebe:	4642      	mov	r2, r8
 800bec0:	4631      	mov	r1, r6
 800bec2:	b280      	uxth	r0, r0
 800bec4:	f004 fcdc 	bl	8010880 <TFT_DrawLine>
	
	TFT_FillRectangle(X, Y+9, X+34, Y+14, TFT_White);
 800bec8:	9700      	str	r7, [sp, #0]
 800beca:	9b05      	ldr	r3, [sp, #20]
 800becc:	9903      	ldr	r1, [sp, #12]
 800bece:	4642      	mov	r2, r8
 800bed0:	4620      	mov	r0, r4
 800bed2:	f004 fd32 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+15, Y, X+20, Y+21, TFT_White);
 800bed6:	9700      	str	r7, [sp, #0]
 800bed8:	4633      	mov	r3, r6
 800beda:	9a04      	ldr	r2, [sp, #16]
 800bedc:	9802      	ldr	r0, [sp, #8]
 800bede:	4629      	mov	r1, r5
 800bee0:	f004 fd2b 	bl	801093a <TFT_FillRectangle>
	
	TFT_FillRectangle(X+16, Y, X+19, Y+21, TFT_Red);
 800bee4:	f44f 4778 	mov.w	r7, #63488	; 0xf800
 800bee8:	f104 0213 	add.w	r2, r4, #19
 800beec:	f104 0010 	add.w	r0, r4, #16
 800bef0:	4633      	mov	r3, r6
 800bef2:	4629      	mov	r1, r5
 800bef4:	9700      	str	r7, [sp, #0]
 800bef6:	b292      	uxth	r2, r2
 800bef8:	b280      	uxth	r0, r0
 800befa:	f004 fd1e 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X, Y+10, X+34, Y+13, TFT_Red);
 800befe:	f105 030d 	add.w	r3, r5, #13
 800bf02:	f105 010a 	add.w	r1, r5, #10
 800bf06:	9700      	str	r7, [sp, #0]
 800bf08:	b29b      	uxth	r3, r3
 800bf0a:	4642      	mov	r2, r8
 800bf0c:	b289      	uxth	r1, r1
 800bf0e:	4620      	mov	r0, r4
 800bf10:	f004 fd13 	bl	801093a <TFT_FillRectangle>
	
}
 800bf14:	b00d      	add	sp, #52	; 0x34
 800bf16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800bf1c <GUI_Bar_Measure>:
#include "GUI_Measure_Elements.h"

extern uint8_t Language_status;

void GUI_Bar_Measure(uint16_t X, uint16_t Y, float Value)
{
 800bf1c:	b570      	push	{r4, r5, r6, lr}
 800bf1e:	ed2d 8b02 	vpush	{d8}
	TFT_FillRectangle(X, Y, X+110, Y+10, TFT_White);	
 800bf22:	f101 040a 	add.w	r4, r1, #10
{
 800bf26:	b084      	sub	sp, #16
	TFT_FillRectangle(X, Y, X+110, Y+10, TFT_White);	
 800bf28:	b2a4      	uxth	r4, r4
 800bf2a:	f100 026e 	add.w	r2, r0, #110	; 0x6e
 800bf2e:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 800bf32:	4605      	mov	r5, r0
	TFT_FillRectangle(X, Y, X+110, Y+10, TFT_White);	
 800bf34:	9300      	str	r3, [sp, #0]
 800bf36:	b292      	uxth	r2, r2
 800bf38:	4623      	mov	r3, r4
{
 800bf3a:	eeb0 8a40 	vmov.f32	s16, s0
 800bf3e:	460e      	mov	r6, r1
	TFT_FillRectangle(X, Y, X+110, Y+10, TFT_White);	
 800bf40:	f004 fcfb 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X, Y, X+110*Value, Y+10, TFT_Blue_Off);
 800bf44:	ee07 5a90 	vmov	s15, r5
 800bf48:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 800bf78 <GUI_Bar_Measure+0x5c>
 800bf4c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800bf50:	f241 3376 	movw	r3, #4982	; 0x1376
 800bf54:	eee8 7a07 	vfma.f32	s15, s16, s14
 800bf58:	9300      	str	r3, [sp, #0]
 800bf5a:	4631      	mov	r1, r6
 800bf5c:	4623      	mov	r3, r4
 800bf5e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800bf62:	4628      	mov	r0, r5
 800bf64:	edcd 7a03 	vstr	s15, [sp, #12]
 800bf68:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 800bf6c:	f004 fce5 	bl	801093a <TFT_FillRectangle>
}
 800bf70:	b004      	add	sp, #16
 800bf72:	ecbd 8b02 	vpop	{d8}
 800bf76:	bd70      	pop	{r4, r5, r6, pc}
 800bf78:	42dc0000 	.word	0x42dc0000

0800bf7c <GUI_Text_E_Measure>:
}

uint8_t old_meas_type_E = 2, old_num_e = 10, old_num_n = 10;
uint8_t old_meas_type_L = 2, old_numL_e = 10, old_numL_n = 10;
void GUI_Text_E_Measure(uint16_t X, uint16_t Y, float Value, uint8_t energy_light)
{
 800bf7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800bf80:	ed2d 8b02 	vpush	{d8}
 800bf84:	b086      	sub	sp, #24
	char buffer[9] = {0};
 800bf86:	2300      	movs	r3, #0
{
 800bf88:	4605      	mov	r5, r0
	uint8_t	delta_pos = 122, deg = 0, number = 0, meas_type; 
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800bf8a:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800bf8e:	460c      	mov	r4, r1
 800bf90:	eeb0 8a40 	vmov.f32	s16, s0
 800bf94:	4691      	mov	r9, r2
	char buffer[9] = {0};
 800bf96:	9303      	str	r3, [sp, #12]
 800bf98:	9304      	str	r3, [sp, #16]
 800bf9a:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800bf9e:	f004 fed5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800bfa2:	2063      	movs	r0, #99	; 0x63
 800bfa4:	f004 fed8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_big);
 800bfa8:	48ad      	ldr	r0, [pc, #692]	; (800c260 <GUI_Text_E_Measure+0x2e4>)
 800bfaa:	f004 fec9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+2, 'E'-33);
 800bfae:	1ca1      	adds	r1, r4, #2
 800bfb0:	4628      	mov	r0, r5
 800bfb2:	2224      	movs	r2, #36	; 0x24
 800bfb4:	b289      	uxth	r1, r1
 800bfb6:	f004 ff39 	bl	8010e2c <TFT_DrawChar>
	
	if(energy_light) {
	TFT_SetFont(&Font16EN_arch_small);
 800bfba:	48aa      	ldr	r0, [pc, #680]	; (800c264 <GUI_Text_E_Measure+0x2e8>)
	if(energy_light) {
 800bfbc:	f1b9 0f00 	cmp.w	r9, #0
 800bfc0:	f000 80b8 	beq.w	800c134 <GUI_Text_E_Measure+0x1b8>
	TFT_SetFont(&Font16EN_arch_small);
 800bfc4:	f004 febc 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+20, Y+14, 'e');}
 800bfc8:	f104 010e 	add.w	r1, r4, #14
 800bfcc:	f105 0014 	add.w	r0, r5, #20
 800bfd0:	2265      	movs	r2, #101	; 0x65
	else {
		TFT_SetFont(&Font16EN_arch_small);
		TFT_DrawChar(X+23, Y+13, 'z'+1);
 800bfd2:	b289      	uxth	r1, r1
 800bfd4:	b280      	uxth	r0, r0
 800bfd6:	f004 ff29 	bl	8010e2c <TFT_DrawChar>
	}
	
	if((Value/1000.0) >= 1.0)
 800bfda:	ee18 0a10 	vmov	r0, s16
 800bfde:	f7f4 fac3 	bl	8000568 <__aeabi_f2d>
 800bfe2:	2200      	movs	r2, #0
 800bfe4:	4ba0      	ldr	r3, [pc, #640]	; (800c268 <GUI_Text_E_Measure+0x2ec>)
 800bfe6:	f7f4 fc3d 	bl	8000864 <__aeabi_ddiv>
 800bfea:	2200      	movs	r2, #0
 800bfec:	4b9f      	ldr	r3, [pc, #636]	; (800c26c <GUI_Text_E_Measure+0x2f0>)
 800bfee:	f7f4 fd95 	bl	8000b1c <__aeabi_dcmpge>
 800bff2:	2800      	cmp	r0, #0
 800bff4:	f000 80a6 	beq.w	800c144 <GUI_Text_E_Measure+0x1c8>
	{
		Value = Value/(1000.0);
 800bff8:	eddf 7a9d 	vldr	s15, [pc, #628]	; 800c270 <GUI_Text_E_Measure+0x2f4>
 800bffc:	ee88 8a27 	vdiv.f32	s16, s16, s15
		deg = 1;
 800c000:	2701      	movs	r7, #1
		meas_type = 1;
	}else {meas_type = 0;}
	
	TFT_SetTextColor(TFT_White);
 800c002:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800c006:	f004 fea1 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c00a:	2063      	movs	r0, #99	; 0x63
 800c00c:	f004 fea4 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800c010:	4898      	ldr	r0, [pc, #608]	; (800c274 <GUI_Text_E_Measure+0x2f8>)
 800c012:	f004 fe95 	bl	8010d40 <TFT_SetFont>
	
	if(energy_light){
		sprintf (buffer, "%.2f", Value);}
 800c016:	ee18 0a10 	vmov	r0, s16
	if(energy_light){
 800c01a:	f1b9 0f00 	cmp.w	r9, #0
 800c01e:	f000 8093 	beq.w	800c148 <GUI_Text_E_Measure+0x1cc>
		sprintf (buffer, "%.2f", Value);}
 800c022:	f7f4 faa1 	bl	8000568 <__aeabi_f2d>
 800c026:	460b      	mov	r3, r1
 800c028:	4993      	ldr	r1, [pc, #588]	; (800c278 <GUI_Text_E_Measure+0x2fc>)
 800c02a:	4602      	mov	r2, r0
	else{
		sprintf (buffer, "%.1f", Value);
 800c02c:	a803      	add	r0, sp, #12
 800c02e:	f006 f9ad 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800c032:	220a      	movs	r2, #10
	uint8_t	delta_pos = 122, deg = 0, number = 0, meas_type; 
 800c034:	2304      	movs	r3, #4
 800c036:	2600      	movs	r6, #0
 800c038:	f04f 087a 	mov.w	r8, #122	; 0x7a
	}
	
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800c03c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800c040:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800c042:	ee07 2a10 	vmov	s14, r2
 800c046:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800c04a:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800c04e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800c052:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c056:	db06      	blt.n	800c066 <GUI_Text_E_Measure+0xea>
			delta_pos-=23;
 800c058:	f1a8 0817 	sub.w	r8, r8, #23
			number++;
 800c05c:	3601      	adds	r6, #1
			dec *= 10;
 800c05e:	434a      	muls	r2, r1
			delta_pos-=23;
 800c060:	fa5f f888 	uxtb.w	r8, r8
			number++;
 800c064:	b2f6      	uxtb	r6, r6
 800c066:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800c068:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c06c:	d1e9      	bne.n	800c042 <GUI_Text_E_Measure+0xc6>
		}
	}
	
	if(energy_light && number < old_num_e )
 800c06e:	f1b9 0f00 	cmp.w	r9, #0
 800c072:	d06f      	beq.n	800c154 <GUI_Text_E_Measure+0x1d8>
 800c074:	4b81      	ldr	r3, [pc, #516]	; (800c27c <GUI_Text_E_Measure+0x300>)
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+26, TFT_Black_Bkgr);
	} 
	else if(!energy_light && number < old_num_n)
 800c076:	781a      	ldrb	r2, [r3, #0]
 800c078:	42b2      	cmp	r2, r6
 800c07a:	469a      	mov	sl, r3
 800c07c:	d90d      	bls.n	800c09a <GUI_Text_E_Measure+0x11e>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+26, TFT_Black_Bkgr);
 800c07e:	2163      	movs	r1, #99	; 0x63
 800c080:	f104 031a 	add.w	r3, r4, #26
 800c084:	f105 02c5 	add.w	r2, r5, #197	; 0xc5
 800c088:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800c08c:	9100      	str	r1, [sp, #0]
 800c08e:	b29b      	uxth	r3, r3
 800c090:	b292      	uxth	r2, r2
 800c092:	4621      	mov	r1, r4
 800c094:	b280      	uxth	r0, r0
 800c096:	f004 fc50 	bl	801093a <TFT_FillRectangle>
		old_num_e = number;}
	else{
		old_num_n = number;
	}
	
	buffer[8] = 0;
 800c09a:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c09c:	eb05 0008 	add.w	r0, r5, r8
		old_num_n = number;
 800c0a0:	f88a 6000 	strb.w	r6, [sl]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c0a4:	aa03      	add	r2, sp, #12
	buffer[8] = 0;
 800c0a6:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c0aa:	4621      	mov	r1, r4
 800c0ac:	2303      	movs	r3, #3
 800c0ae:	b280      	uxth	r0, r0
 800c0b0:	f004 ff14 	bl	8010edc <TFT_DisplayString>
	
	if (Language_status == Ru && !energy_light)
 800c0b4:	4b72      	ldr	r3, [pc, #456]	; (800c280 <GUI_Text_E_Measure+0x304>)
 800c0b6:	f893 8000 	ldrb.w	r8, [r3]
 800c0ba:	f1b8 0f00 	cmp.w	r8, #0
 800c0be:	d16c      	bne.n	800c19a <GUI_Text_E_Measure+0x21e>
 800c0c0:	f1b9 0f00 	cmp.w	r9, #0
 800c0c4:	f040 80c1 	bne.w	800c24a <GUI_Text_E_Measure+0x2ce>
 800c0c8:	4e6e      	ldr	r6, [pc, #440]	; (800c284 <GUI_Text_E_Measure+0x308>)
	{
		if (deg && old_meas_type_E != meas_type){
 800c0ca:	7833      	ldrb	r3, [r6, #0]
 800c0cc:	2f00      	cmp	r7, #0
 800c0ce:	d043      	beq.n	800c158 <GUI_Text_E_Measure+0x1dc>
 800c0d0:	2b01      	cmp	r3, #1
 800c0d2:	d02a      	beq.n	800c12a <GUI_Text_E_Measure+0x1ae>
			TFT_FillRectangle(X+198, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c0d4:	f104 031a 	add.w	r3, r4, #26
 800c0d8:	1ce1      	adds	r1, r4, #3
 800c0da:	f105 02fa 	add.w	r2, r5, #250	; 0xfa
 800c0de:	f105 00c6 	add.w	r0, r5, #198	; 0xc6
 800c0e2:	2763      	movs	r7, #99	; 0x63
 800c0e4:	b292      	uxth	r2, r2
 800c0e6:	b289      	uxth	r1, r1
 800c0e8:	b29b      	uxth	r3, r3
 800c0ea:	b280      	uxth	r0, r0
 800c0ec:	9700      	str	r7, [sp, #0]
 800c0ee:	f004 fc24 	bl	801093a <TFT_FillRectangle>
			old_meas_type_E = 1;
			TFT_SetFont(&Font26RU_arch_small);
			TFT_DrawCharRus(X+200, Y+4, '');
 800c0f2:	3404      	adds	r4, #4
			old_meas_type_E = 1;
 800c0f4:	2301      	movs	r3, #1
			TFT_SetFont(&Font26RU_arch_small);
 800c0f6:	4864      	ldr	r0, [pc, #400]	; (800c288 <GUI_Text_E_Measure+0x30c>)
			old_meas_type_E = 1;
 800c0f8:	7033      	strb	r3, [r6, #0]
			TFT_DrawCharRus(X+200, Y+4, '');
 800c0fa:	b2a4      	uxth	r4, r4
			TFT_SetFont(&Font26RU_arch_small);
 800c0fc:	f004 fe20 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X+200, Y+4, '');
 800c100:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 800c104:	22ba      	movs	r2, #186	; 0xba
 800c106:	4621      	mov	r1, r4
 800c108:	b280      	uxth	r0, r0
 800c10a:	f004 fe2b 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+215, Y+4, '');
 800c10e:	f105 00d7 	add.w	r0, r5, #215	; 0xd7
 800c112:	b280      	uxth	r0, r0
 800c114:	22bb      	movs	r2, #187	; 0xbb
 800c116:	4621      	mov	r1, r4
 800c118:	f004 fe24 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+232, Y+4, '');
 800c11c:	f105 00e8 	add.w	r0, r5, #232	; 0xe8
		}else if((!deg && old_meas_type_E != meas_type)){
			old_meas_type_E = 0;
			TFT_FillRectangle(X+198, Y+3, X+250, Y+26, TFT_Black_Bkgr);
			TFT_SetFont(&Font26RU_arch_small);
			TFT_DrawCharRus(X+200, Y+4, '');
			TFT_DrawCharRus(X+215, Y+4, '');
 800c120:	22ba      	movs	r2, #186	; 0xba
 800c122:	4621      	mov	r1, r4
 800c124:	b280      	uxth	r0, r0
 800c126:	f004 fe1d 	bl	8010d64 <TFT_DrawCharRus>
	{
		GUI_TextEn_W_m2(244, Y);
	}
	

}
 800c12a:	b006      	add	sp, #24
 800c12c:	ecbd 8b02 	vpop	{d8}
 800c130:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		TFT_SetFont(&Font16EN_arch_small);
 800c134:	f004 fe04 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+23, Y+13, 'z'+1);
 800c138:	f104 010d 	add.w	r1, r4, #13
 800c13c:	f105 0017 	add.w	r0, r5, #23
 800c140:	227b      	movs	r2, #123	; 0x7b
 800c142:	e746      	b.n	800bfd2 <GUI_Text_E_Measure+0x56>
	uint8_t	delta_pos = 122, deg = 0, number = 0, meas_type; 
 800c144:	4607      	mov	r7, r0
 800c146:	e75c      	b.n	800c002 <GUI_Text_E_Measure+0x86>
		sprintf (buffer, "%.1f", Value);
 800c148:	f7f4 fa0e 	bl	8000568 <__aeabi_f2d>
 800c14c:	460b      	mov	r3, r1
 800c14e:	4602      	mov	r2, r0
 800c150:	494e      	ldr	r1, [pc, #312]	; (800c28c <GUI_Text_E_Measure+0x310>)
 800c152:	e76b      	b.n	800c02c <GUI_Text_E_Measure+0xb0>
	else if(!energy_light && number < old_num_n)
 800c154:	4b4e      	ldr	r3, [pc, #312]	; (800c290 <GUI_Text_E_Measure+0x314>)
 800c156:	e78e      	b.n	800c076 <GUI_Text_E_Measure+0xfa>
		}else if((!deg && old_meas_type_E != meas_type)){
 800c158:	2b00      	cmp	r3, #0
 800c15a:	d0e6      	beq.n	800c12a <GUI_Text_E_Measure+0x1ae>
			old_meas_type_E = 0;
 800c15c:	7037      	strb	r7, [r6, #0]
			TFT_FillRectangle(X+198, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c15e:	f104 031a 	add.w	r3, r4, #26
 800c162:	1ce1      	adds	r1, r4, #3
 800c164:	f105 02fa 	add.w	r2, r5, #250	; 0xfa
 800c168:	f105 00c6 	add.w	r0, r5, #198	; 0xc6
 800c16c:	2663      	movs	r6, #99	; 0x63
 800c16e:	b29b      	uxth	r3, r3
 800c170:	b292      	uxth	r2, r2
 800c172:	b289      	uxth	r1, r1
 800c174:	b280      	uxth	r0, r0
 800c176:	9600      	str	r6, [sp, #0]
 800c178:	f004 fbdf 	bl	801093a <TFT_FillRectangle>
			TFT_DrawCharRus(X+200, Y+4, '');
 800c17c:	3404      	adds	r4, #4
			TFT_SetFont(&Font26RU_arch_small);
 800c17e:	4842      	ldr	r0, [pc, #264]	; (800c288 <GUI_Text_E_Measure+0x30c>)
 800c180:	f004 fdde 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X+200, Y+4, '');
 800c184:	b2a4      	uxth	r4, r4
 800c186:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 800c18a:	b280      	uxth	r0, r0
 800c18c:	22bb      	movs	r2, #187	; 0xbb
 800c18e:	4621      	mov	r1, r4
 800c190:	f004 fde8 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+215, Y+4, '');
 800c194:	f105 00d7 	add.w	r0, r5, #215	; 0xd7
 800c198:	e7c2      	b.n	800c120 <GUI_Text_E_Measure+0x1a4>
	} else if (Language_status == En && !energy_light)
 800c19a:	f1b8 0f01 	cmp.w	r8, #1
 800c19e:	d1c4      	bne.n	800c12a <GUI_Text_E_Measure+0x1ae>
 800c1a0:	f1b9 0f00 	cmp.w	r9, #0
 800c1a4:	d156      	bne.n	800c254 <GUI_Text_E_Measure+0x2d8>
 800c1a6:	4e37      	ldr	r6, [pc, #220]	; (800c284 <GUI_Text_E_Measure+0x308>)
		if (deg && old_meas_type_E != meas_type){
 800c1a8:	7833      	ldrb	r3, [r6, #0]
 800c1aa:	b36f      	cbz	r7, 800c208 <GUI_Text_E_Measure+0x28c>
 800c1ac:	2b01      	cmp	r3, #1
 800c1ae:	d0bc      	beq.n	800c12a <GUI_Text_E_Measure+0x1ae>
			TFT_FillRectangle(X+198, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c1b0:	f104 031a 	add.w	r3, r4, #26
 800c1b4:	1ce1      	adds	r1, r4, #3
 800c1b6:	f105 02fa 	add.w	r2, r5, #250	; 0xfa
 800c1ba:	f105 00c6 	add.w	r0, r5, #198	; 0xc6
 800c1be:	2763      	movs	r7, #99	; 0x63
 800c1c0:	b29b      	uxth	r3, r3
 800c1c2:	b292      	uxth	r2, r2
 800c1c4:	b289      	uxth	r1, r1
 800c1c6:	b280      	uxth	r0, r0
 800c1c8:	9700      	str	r7, [sp, #0]
 800c1ca:	f004 fbb6 	bl	801093a <TFT_FillRectangle>
			TFT_DrawChar(X+214, Y+4, 'l'-65);
 800c1ce:	3404      	adds	r4, #4
			TFT_SetFont(&Font26EN_arch_small);
 800c1d0:	4830      	ldr	r0, [pc, #192]	; (800c294 <GUI_Text_E_Measure+0x318>)
			old_meas_type_E = 1;
 800c1d2:	f886 8000 	strb.w	r8, [r6]
			TFT_DrawChar(X+214, Y+4, 'l'-65);
 800c1d6:	b2a4      	uxth	r4, r4
			TFT_SetFont(&Font26EN_arch_small);
 800c1d8:	f004 fdb2 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X+214, Y+4, 'l'-65);
 800c1dc:	f105 00d6 	add.w	r0, r5, #214	; 0xd6
 800c1e0:	222b      	movs	r2, #43	; 0x2b
 800c1e2:	4621      	mov	r1, r4
 800c1e4:	b280      	uxth	r0, r0
 800c1e6:	f004 fe21 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+200, Y+4, 'k'-65);
 800c1ea:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 800c1ee:	b280      	uxth	r0, r0
 800c1f0:	222a      	movs	r2, #42	; 0x2a
 800c1f2:	4621      	mov	r1, r4
 800c1f4:	f004 fe1a 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+226, Y+4, 'x'-65);
 800c1f8:	f105 00e2 	add.w	r0, r5, #226	; 0xe2
			TFT_DrawChar(X+212, Y+4, 'x'-65);
 800c1fc:	2237      	movs	r2, #55	; 0x37
 800c1fe:	4621      	mov	r1, r4
 800c200:	b280      	uxth	r0, r0
 800c202:	f004 fe13 	bl	8010e2c <TFT_DrawChar>
 800c206:	e790      	b.n	800c12a <GUI_Text_E_Measure+0x1ae>
		}else if((!deg && old_meas_type_E != meas_type)){
 800c208:	2b00      	cmp	r3, #0
 800c20a:	d08e      	beq.n	800c12a <GUI_Text_E_Measure+0x1ae>
			old_meas_type_E = 0;
 800c20c:	7037      	strb	r7, [r6, #0]
			TFT_FillRectangle(X+198, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c20e:	f104 031a 	add.w	r3, r4, #26
 800c212:	1ce1      	adds	r1, r4, #3
 800c214:	f105 02fa 	add.w	r2, r5, #250	; 0xfa
 800c218:	f105 00c6 	add.w	r0, r5, #198	; 0xc6
 800c21c:	2663      	movs	r6, #99	; 0x63
 800c21e:	b29b      	uxth	r3, r3
 800c220:	b292      	uxth	r2, r2
 800c222:	b289      	uxth	r1, r1
 800c224:	b280      	uxth	r0, r0
 800c226:	9600      	str	r6, [sp, #0]
 800c228:	f004 fb87 	bl	801093a <TFT_FillRectangle>
			TFT_DrawChar(X+200, Y+4, 'l'-65);
 800c22c:	3404      	adds	r4, #4
			TFT_SetFont(&Font26EN_arch_small);
 800c22e:	4819      	ldr	r0, [pc, #100]	; (800c294 <GUI_Text_E_Measure+0x318>)
 800c230:	f004 fd86 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X+200, Y+4, 'l'-65);
 800c234:	b2a4      	uxth	r4, r4
 800c236:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 800c23a:	b280      	uxth	r0, r0
 800c23c:	222b      	movs	r2, #43	; 0x2b
 800c23e:	4621      	mov	r1, r4
 800c240:	f004 fdf4 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+212, Y+4, 'x'-65);
 800c244:	f105 00d4 	add.w	r0, r5, #212	; 0xd4
 800c248:	e7d8      	b.n	800c1fc <GUI_Text_E_Measure+0x280>
		GUI_TextRu_W_m2(244, Y);
 800c24a:	4621      	mov	r1, r4
 800c24c:	20f4      	movs	r0, #244	; 0xf4
 800c24e:	f003 fecf 	bl	800fff0 <GUI_TextRu_W_m2>
 800c252:	e76a      	b.n	800c12a <GUI_Text_E_Measure+0x1ae>
		GUI_TextEn_W_m2(244, Y);
 800c254:	4621      	mov	r1, r4
 800c256:	20f4      	movs	r0, #244	; 0xf4
 800c258:	f002 fe14 	bl	800ee84 <GUI_TextEn_W_m2>
}
 800c25c:	e765      	b.n	800c12a <GUI_Text_E_Measure+0x1ae>
 800c25e:	bf00      	nop
 800c260:	20000130 	.word	0x20000130
 800c264:	20000108 	.word	0x20000108
 800c268:	408f4000 	.word	0x408f4000
 800c26c:	3ff00000 	.word	0x3ff00000
 800c270:	447a0000 	.word	0x447a0000
 800c274:	20000138 	.word	0x20000138
 800c278:	0801f553 	.word	0x0801f553
 800c27c:	2000018f 	.word	0x2000018f
 800c280:	200002bb 	.word	0x200002bb
 800c284:	2000017a 	.word	0x2000017a
 800c288:	20000150 	.word	0x20000150
 800c28c:	0801f558 	.word	0x0801f558
 800c290:	20000190 	.word	0x20000190
 800c294:	20000140 	.word	0x20000140

0800c298 <GUI_Text_L_Measure>:


void GUI_Text_L_Measure(uint16_t X, uint16_t Y, float Value, uint8_t energy_light)
{
 800c298:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c29c:	ed2d 8b02 	vpush	{d8}
 800c2a0:	b086      	sub	sp, #24
	char buffer[9] = {0};
 800c2a2:	2300      	movs	r3, #0
{
 800c2a4:	4604      	mov	r4, r0
	uint8_t	delta_pos = 117, deg = 0, number = 0, meas_type;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800c2a6:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800c2aa:	460d      	mov	r5, r1
 800c2ac:	eeb0 8a40 	vmov.f32	s16, s0
 800c2b0:	4691      	mov	r9, r2
	char buffer[9] = {0};
 800c2b2:	9303      	str	r3, [sp, #12]
 800c2b4:	9304      	str	r3, [sp, #16]
 800c2b6:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800c2ba:	f004 fd47 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c2be:	2063      	movs	r0, #99	; 0x63
 800c2c0:	f004 fd4a 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_big);
 800c2c4:	4890      	ldr	r0, [pc, #576]	; (800c508 <GUI_Text_L_Measure+0x270>)
 800c2c6:	f004 fd3b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+2, 'L'-33);
 800c2ca:	1ca9      	adds	r1, r5, #2
 800c2cc:	4620      	mov	r0, r4
 800c2ce:	222b      	movs	r2, #43	; 0x2b
 800c2d0:	b289      	uxth	r1, r1
 800c2d2:	f004 fdab 	bl	8010e2c <TFT_DrawChar>
	
	if(energy_light) {
	TFT_SetFont(&Font16EN_arch_small);
 800c2d6:	488d      	ldr	r0, [pc, #564]	; (800c50c <GUI_Text_L_Measure+0x274>)
	if(energy_light) {
 800c2d8:	f1b9 0f00 	cmp.w	r9, #0
 800c2dc:	f000 80a2 	beq.w	800c424 <GUI_Text_L_Measure+0x18c>
	TFT_SetFont(&Font16EN_arch_small);
 800c2e0:	f004 fd2e 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+20, Y+14, 'e');}
 800c2e4:	f105 010e 	add.w	r1, r5, #14
 800c2e8:	f104 0014 	add.w	r0, r4, #20
 800c2ec:	2265      	movs	r2, #101	; 0x65
	else {
		TFT_SetFont(&Font16EN_arch_small);
		TFT_DrawChar(X+23, Y+13, 'z'+1);
 800c2ee:	b289      	uxth	r1, r1
 800c2f0:	b280      	uxth	r0, r0
 800c2f2:	f004 fd9b 	bl	8010e2c <TFT_DrawChar>
	}
	
	if((Value/1000.0) >= 1.0)
 800c2f6:	ee18 0a10 	vmov	r0, s16
 800c2fa:	f7f4 f935 	bl	8000568 <__aeabi_f2d>
 800c2fe:	2200      	movs	r2, #0
 800c300:	4b83      	ldr	r3, [pc, #524]	; (800c510 <GUI_Text_L_Measure+0x278>)
 800c302:	f7f4 faaf 	bl	8000864 <__aeabi_ddiv>
 800c306:	2200      	movs	r2, #0
 800c308:	4b82      	ldr	r3, [pc, #520]	; (800c514 <GUI_Text_L_Measure+0x27c>)
 800c30a:	f7f4 fc07 	bl	8000b1c <__aeabi_dcmpge>
 800c30e:	2800      	cmp	r0, #0
 800c310:	f000 8090 	beq.w	800c434 <GUI_Text_L_Measure+0x19c>
	{
		Value = Value/(1000.0);
 800c314:	eddf 7a80 	vldr	s15, [pc, #512]	; 800c518 <GUI_Text_L_Measure+0x280>
 800c318:	ee88 8a27 	vdiv.f32	s16, s16, s15
		deg = 1;
 800c31c:	2601      	movs	r6, #1
		meas_type = 1;
	}else {meas_type = 0;}
	
	TFT_SetTextColor(TFT_White);
 800c31e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800c322:	f004 fd13 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c326:	2063      	movs	r0, #99	; 0x63
 800c328:	f004 fd16 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800c32c:	487b      	ldr	r0, [pc, #492]	; (800c51c <GUI_Text_L_Measure+0x284>)
 800c32e:	f004 fd07 	bl	8010d40 <TFT_SetFont>
	
	if(energy_light){
		sprintf (buffer, "%.2f", Value);}
 800c332:	ee18 0a10 	vmov	r0, s16
	if(energy_light){
 800c336:	f1b9 0f00 	cmp.w	r9, #0
 800c33a:	d07d      	beq.n	800c438 <GUI_Text_L_Measure+0x1a0>
		sprintf (buffer, "%.2f", Value);}
 800c33c:	f7f4 f914 	bl	8000568 <__aeabi_f2d>
 800c340:	460b      	mov	r3, r1
 800c342:	4977      	ldr	r1, [pc, #476]	; (800c520 <GUI_Text_L_Measure+0x288>)
 800c344:	4602      	mov	r2, r0
	else{
		sprintf (buffer, "%.1f", Value);
 800c346:	a803      	add	r0, sp, #12
 800c348:	f006 f820 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800c34c:	220a      	movs	r2, #10
	uint8_t	delta_pos = 117, deg = 0, number = 0, meas_type;
 800c34e:	2304      	movs	r3, #4
 800c350:	2700      	movs	r7, #0
 800c352:	f04f 0875 	mov.w	r8, #117	; 0x75
	}

for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800c356:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800c35a:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800c35c:	ee07 2a10 	vmov	s14, r2
 800c360:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800c364:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800c368:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800c36c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c370:	db06      	blt.n	800c380 <GUI_Text_L_Measure+0xe8>
			delta_pos-=23;
 800c372:	f1a8 0817 	sub.w	r8, r8, #23
			number++;
 800c376:	3701      	adds	r7, #1
			dec *= 10;
 800c378:	434a      	muls	r2, r1
			delta_pos-=23;
 800c37a:	fa5f f888 	uxtb.w	r8, r8
			number++;
 800c37e:	b2ff      	uxtb	r7, r7
 800c380:	3b01      	subs	r3, #1
for (uint8_t i = 1; i <= 4; i++)
 800c382:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c386:	d1e9      	bne.n	800c35c <GUI_Text_L_Measure+0xc4>
		}
	}
	
	if(energy_light && number < old_numL_e )
 800c388:	f1b9 0f00 	cmp.w	r9, #0
 800c38c:	d05a      	beq.n	800c444 <GUI_Text_L_Measure+0x1ac>
 800c38e:	4b65      	ldr	r3, [pc, #404]	; (800c524 <GUI_Text_L_Measure+0x28c>)
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+26, TFT_Black_Bkgr);
	} 
	else if(!energy_light && number < old_numL_n)
 800c390:	781a      	ldrb	r2, [r3, #0]
 800c392:	42ba      	cmp	r2, r7
 800c394:	469a      	mov	sl, r3
 800c396:	d90d      	bls.n	800c3b4 <GUI_Text_L_Measure+0x11c>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+26, TFT_Black_Bkgr);
 800c398:	2163      	movs	r1, #99	; 0x63
 800c39a:	f105 031a 	add.w	r3, r5, #26
 800c39e:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800c3a2:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800c3a6:	9100      	str	r1, [sp, #0]
 800c3a8:	b29b      	uxth	r3, r3
 800c3aa:	b292      	uxth	r2, r2
 800c3ac:	4629      	mov	r1, r5
 800c3ae:	b280      	uxth	r0, r0
 800c3b0:	f004 fac3 	bl	801093a <TFT_FillRectangle>
		old_numL_e = number;}
	else{
		old_numL_n = number;
	}
	
	buffer[8] = 0;
 800c3b4:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c3b6:	eb04 0008 	add.w	r0, r4, r8
		old_numL_n = number;
 800c3ba:	f88a 7000 	strb.w	r7, [sl]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c3be:	aa03      	add	r2, sp, #12
	buffer[8] = 0;
 800c3c0:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c3c4:	4629      	mov	r1, r5
 800c3c6:	2303      	movs	r3, #3
 800c3c8:	b280      	uxth	r0, r0
 800c3ca:	f004 fd87 	bl	8010edc <TFT_DisplayString>
	if (Language_status == Ru && !energy_light)
 800c3ce:	4b56      	ldr	r3, [pc, #344]	; (800c528 <GUI_Text_L_Measure+0x290>)
 800c3d0:	f893 8000 	ldrb.w	r8, [r3]
 800c3d4:	f1b8 0f00 	cmp.w	r8, #0
 800c3d8:	d14b      	bne.n	800c472 <GUI_Text_L_Measure+0x1da>
 800c3da:	f1b9 0f00 	cmp.w	r9, #0
 800c3de:	f040 8084 	bne.w	800c4ea <GUI_Text_L_Measure+0x252>
 800c3e2:	4f52      	ldr	r7, [pc, #328]	; (800c52c <GUI_Text_L_Measure+0x294>)
	{
		if (deg && old_meas_type_L != meas_type){
 800c3e4:	783b      	ldrb	r3, [r7, #0]
 800c3e6:	b37e      	cbz	r6, 800c448 <GUI_Text_L_Measure+0x1b0>
 800c3e8:	2b01      	cmp	r3, #1
 800c3ea:	d016      	beq.n	800c41a <GUI_Text_L_Measure+0x182>
			TFT_FillRectangle(X+195, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c3ec:	f105 031a 	add.w	r3, r5, #26
 800c3f0:	f104 02fa 	add.w	r2, r4, #250	; 0xfa
 800c3f4:	1ce9      	adds	r1, r5, #3
 800c3f6:	f104 00c3 	add.w	r0, r4, #195	; 0xc3
 800c3fa:	2663      	movs	r6, #99	; 0x63
 800c3fc:	b292      	uxth	r2, r2
 800c3fe:	b280      	uxth	r0, r0
 800c400:	9600      	str	r6, [sp, #0]
 800c402:	b29b      	uxth	r3, r3
 800c404:	b289      	uxth	r1, r1
 800c406:	f004 fa98 	bl	801093a <TFT_FillRectangle>
			old_meas_type_L = 1;
 800c40a:	2201      	movs	r2, #1
 800c40c:	703a      	strb	r2, [r7, #0]
			GUI_TextRu_Cd_m2(X+192, Y, 1);
 800c40e:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
		}else if(!deg && old_meas_type_L != meas_type){
			old_meas_type_L = 0;
			TFT_FillRectangle(X+193, Y, X+251, Y+26, TFT_Black_Bkgr);
			GUI_TextRu_Cd_m2(X+192, Y, 0);
 800c412:	4629      	mov	r1, r5
 800c414:	b280      	uxth	r0, r0
 800c416:	f003 fe8f 	bl	8010138 <GUI_TextRu_Cd_m2>
		GUI_TextRu_W_m2_sr(X+210, Y);
	}else if (Language_status == En && energy_light)
	{
		GUI_TextEn_W_m2_sr(X+210, Y);
	}
}
 800c41a:	b006      	add	sp, #24
 800c41c:	ecbd 8b02 	vpop	{d8}
 800c420:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		TFT_SetFont(&Font16EN_arch_small);
 800c424:	f004 fc8c 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+23, Y+13, 'z'+1);
 800c428:	f105 010d 	add.w	r1, r5, #13
 800c42c:	f104 0017 	add.w	r0, r4, #23
 800c430:	227b      	movs	r2, #123	; 0x7b
 800c432:	e75c      	b.n	800c2ee <GUI_Text_L_Measure+0x56>
	uint8_t	delta_pos = 117, deg = 0, number = 0, meas_type;
 800c434:	4606      	mov	r6, r0
 800c436:	e772      	b.n	800c31e <GUI_Text_L_Measure+0x86>
		sprintf (buffer, "%.1f", Value);
 800c438:	f7f4 f896 	bl	8000568 <__aeabi_f2d>
 800c43c:	460b      	mov	r3, r1
 800c43e:	4602      	mov	r2, r0
 800c440:	493b      	ldr	r1, [pc, #236]	; (800c530 <GUI_Text_L_Measure+0x298>)
 800c442:	e780      	b.n	800c346 <GUI_Text_L_Measure+0xae>
	else if(!energy_light && number < old_numL_n)
 800c444:	4b3b      	ldr	r3, [pc, #236]	; (800c534 <GUI_Text_L_Measure+0x29c>)
 800c446:	e7a3      	b.n	800c390 <GUI_Text_L_Measure+0xf8>
		}else if(!deg && old_meas_type_L != meas_type){
 800c448:	2b00      	cmp	r3, #0
 800c44a:	d0e6      	beq.n	800c41a <GUI_Text_L_Measure+0x182>
			TFT_FillRectangle(X+193, Y, X+251, Y+26, TFT_Black_Bkgr);
 800c44c:	2163      	movs	r1, #99	; 0x63
 800c44e:	f105 031a 	add.w	r3, r5, #26
 800c452:	f104 02fb 	add.w	r2, r4, #251	; 0xfb
 800c456:	f104 00c1 	add.w	r0, r4, #193	; 0xc1
			old_meas_type_L = 0;
 800c45a:	703e      	strb	r6, [r7, #0]
			TFT_FillRectangle(X+193, Y, X+251, Y+26, TFT_Black_Bkgr);
 800c45c:	b292      	uxth	r2, r2
 800c45e:	9100      	str	r1, [sp, #0]
 800c460:	b280      	uxth	r0, r0
 800c462:	b29b      	uxth	r3, r3
 800c464:	4629      	mov	r1, r5
 800c466:	f004 fa68 	bl	801093a <TFT_FillRectangle>
			GUI_TextRu_Cd_m2(X+192, Y, 0);
 800c46a:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
 800c46e:	4632      	mov	r2, r6
 800c470:	e7cf      	b.n	800c412 <GUI_Text_L_Measure+0x17a>
	else if (Language_status == En && !energy_light)
 800c472:	f1b8 0f01 	cmp.w	r8, #1
 800c476:	d1d0      	bne.n	800c41a <GUI_Text_L_Measure+0x182>
 800c478:	f1b9 0f00 	cmp.w	r9, #0
 800c47c:	d13c      	bne.n	800c4f8 <GUI_Text_L_Measure+0x260>
 800c47e:	4f2b      	ldr	r7, [pc, #172]	; (800c52c <GUI_Text_L_Measure+0x294>)
		if (deg && old_meas_type_L != meas_type){
 800c480:	783b      	ldrb	r3, [r7, #0]
 800c482:	b1d6      	cbz	r6, 800c4ba <GUI_Text_L_Measure+0x222>
 800c484:	2b01      	cmp	r3, #1
 800c486:	d0c8      	beq.n	800c41a <GUI_Text_L_Measure+0x182>
			TFT_FillRectangle(X+195, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c488:	f104 06c3 	add.w	r6, r4, #195	; 0xc3
 800c48c:	b2b6      	uxth	r6, r6
 800c48e:	2063      	movs	r0, #99	; 0x63
 800c490:	f105 031a 	add.w	r3, r5, #26
 800c494:	f104 02fa 	add.w	r2, r4, #250	; 0xfa
 800c498:	1ce9      	adds	r1, r5, #3
 800c49a:	9000      	str	r0, [sp, #0]
 800c49c:	b292      	uxth	r2, r2
 800c49e:	b289      	uxth	r1, r1
 800c4a0:	4630      	mov	r0, r6
 800c4a2:	b29b      	uxth	r3, r3
 800c4a4:	f004 fa49 	bl	801093a <TFT_FillRectangle>
			GUI_TextEn_cd_m2(X+195, Y-4, 1);
 800c4a8:	1f29      	subs	r1, r5, #4
			old_meas_type_L = 1;
 800c4aa:	f887 8000 	strb.w	r8, [r7]
			GUI_TextEn_cd_m2(X+195, Y-4, 1);
 800c4ae:	4642      	mov	r2, r8
 800c4b0:	b289      	uxth	r1, r1
 800c4b2:	4630      	mov	r0, r6
			GUI_TextEn_cd_m2(X+195, Y-4, 0);
 800c4b4:	f002 fd78 	bl	800efa8 <GUI_TextEn_cd_m2>
 800c4b8:	e7af      	b.n	800c41a <GUI_Text_L_Measure+0x182>
		}else if(!deg && old_meas_type_L != meas_type){
 800c4ba:	2b00      	cmp	r3, #0
 800c4bc:	d0ad      	beq.n	800c41a <GUI_Text_L_Measure+0x182>
			old_meas_type_L = 0;
 800c4be:	703e      	strb	r6, [r7, #0]
			TFT_FillRectangle(X+195, Y+3, X+250, Y+26, TFT_Black_Bkgr);
 800c4c0:	f104 07c3 	add.w	r7, r4, #195	; 0xc3
 800c4c4:	b2bf      	uxth	r7, r7
 800c4c6:	2063      	movs	r0, #99	; 0x63
 800c4c8:	f105 031a 	add.w	r3, r5, #26
 800c4cc:	f104 02fa 	add.w	r2, r4, #250	; 0xfa
 800c4d0:	1ce9      	adds	r1, r5, #3
 800c4d2:	9000      	str	r0, [sp, #0]
 800c4d4:	b292      	uxth	r2, r2
 800c4d6:	b289      	uxth	r1, r1
 800c4d8:	4638      	mov	r0, r7
 800c4da:	b29b      	uxth	r3, r3
 800c4dc:	f004 fa2d 	bl	801093a <TFT_FillRectangle>
			GUI_TextEn_cd_m2(X+195, Y-4, 0);
 800c4e0:	1f29      	subs	r1, r5, #4
 800c4e2:	4632      	mov	r2, r6
 800c4e4:	b289      	uxth	r1, r1
 800c4e6:	4638      	mov	r0, r7
 800c4e8:	e7e4      	b.n	800c4b4 <GUI_Text_L_Measure+0x21c>
		GUI_TextRu_W_m2_sr(X+210, Y);
 800c4ea:	f104 00d2 	add.w	r0, r4, #210	; 0xd2
 800c4ee:	4629      	mov	r1, r5
 800c4f0:	b280      	uxth	r0, r0
 800c4f2:	f003 fdbf 	bl	8010074 <GUI_TextRu_W_m2_sr>
 800c4f6:	e790      	b.n	800c41a <GUI_Text_L_Measure+0x182>
		GUI_TextEn_W_m2_sr(X+210, Y);
 800c4f8:	f104 00d2 	add.w	r0, r4, #210	; 0xd2
 800c4fc:	4629      	mov	r1, r5
 800c4fe:	b280      	uxth	r0, r0
 800c500:	f002 fcfa 	bl	800eef8 <GUI_TextEn_W_m2_sr>
}
 800c504:	e789      	b.n	800c41a <GUI_Text_L_Measure+0x182>
 800c506:	bf00      	nop
 800c508:	20000130 	.word	0x20000130
 800c50c:	20000108 	.word	0x20000108
 800c510:	408f4000 	.word	0x408f4000
 800c514:	3ff00000 	.word	0x3ff00000
 800c518:	447a0000 	.word	0x447a0000
 800c51c:	20000138 	.word	0x20000138
 800c520:	0801f553 	.word	0x0801f553
 800c524:	2000017d 	.word	0x2000017d
 800c528:	200002bb 	.word	0x200002bb
 800c52c:	2000017b 	.word	0x2000017b
 800c530:	0801f558 	.word	0x0801f558
 800c534:	2000017e 	.word	0x2000017e

0800c538 <GUI_Text_PPF_Measure>:

	char buffer[9] = {0};
	uint8_t	delta_pos = 122, deg = 0, number;
	uint32_t dec = 10;

	if((Value/1000) >= 1.0)
 800c538:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 800c6b8 <GUI_Text_PPF_Measure+0x180>
 800c53c:	eec0 7a07 	vdiv.f32	s15, s0, s14
{	
 800c540:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char buffer[9] = {0};
 800c544:	2300      	movs	r3, #0
{	
 800c546:	4604      	mov	r4, r0
	{
		Value = Value/(1000);
		deg = 1;
	}
	
	TFT_SetTextColor(TFT_White);
 800c548:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	
 800c54c:	460e      	mov	r6, r1
	uint8_t	delta_pos = 122, deg = 0, number;
 800c54e:	257a      	movs	r5, #122	; 0x7a
{	
 800c550:	ed2d 8b02 	vpush	{d8}
	if((Value/1000) >= 1.0)
 800c554:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
{	
 800c558:	b086      	sub	sp, #24
	uint8_t	delta_pos = 122, deg = 0, number;
 800c55a:	eef4 7ae8 	vcmpe.f32	s15, s17
 800c55e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{	
 800c562:	eeb0 8a40 	vmov.f32	s16, s0
	uint8_t	delta_pos = 122, deg = 0, number;
 800c566:	bfb8      	it	lt
 800c568:	461f      	movlt	r7, r3
 800c56a:	bfa8      	it	ge
 800c56c:	eeb0 8a67 	vmovge.f32	s16, s15
	char buffer[9] = {0};
 800c570:	9303      	str	r3, [sp, #12]
 800c572:	9304      	str	r3, [sp, #16]
 800c574:	f88d 3014 	strb.w	r3, [sp, #20]
	uint8_t	delta_pos = 122, deg = 0, number;
 800c578:	bfa8      	it	ge
 800c57a:	2701      	movge	r7, #1
	TFT_SetTextColor(TFT_White);
 800c57c:	f004 fbe6 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c580:	2063      	movs	r0, #99	; 0x63
 800c582:	f004 fbe9 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800c586:	484d      	ldr	r0, [pc, #308]	; (800c6bc <GUI_Text_PPF_Measure+0x184>)
 800c588:	f004 fbda 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", Value);
 800c58c:	ee18 0a10 	vmov	r0, s16
 800c590:	f7f3 ffea 	bl	8000568 <__aeabi_f2d>
 800c594:	4602      	mov	r2, r0
 800c596:	460b      	mov	r3, r1
 800c598:	a803      	add	r0, sp, #12
 800c59a:	4949      	ldr	r1, [pc, #292]	; (800c6c0 <GUI_Text_PPF_Measure+0x188>)
 800c59c:	f005 fef6 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800c5a0:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", Value);
 800c5a2:	2304      	movs	r3, #4

	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
		{
			dec *= 10;
 800c5a4:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800c5a6:	ee07 2a90 	vmov	s15, r2
 800c5aa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800c5ae:	eec8 7a07 	vdiv.f32	s15, s16, s14
 800c5b2:	eef4 7ae8 	vcmpe.f32	s15, s17
 800c5b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5ba:	db06      	blt.n	800c5ca <GUI_Text_PPF_Measure+0x92>
			delta_pos-=23;
 800c5bc:	3d17      	subs	r5, #23
			number++;
 800c5be:	f108 0801 	add.w	r8, r8, #1
			dec *= 10;
 800c5c2:	434a      	muls	r2, r1
			delta_pos-=23;
 800c5c4:	b2ed      	uxtb	r5, r5
			number++;
 800c5c6:	fa5f f888 	uxtb.w	r8, r8
 800c5ca:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800c5cc:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c5d0:	d1e9      	bne.n	800c5a6 <GUI_Text_PPF_Measure+0x6e>
		}
	}
	
	if(number < old_numPPF )
 800c5d2:	4b3c      	ldr	r3, [pc, #240]	; (800c6c4 <GUI_Text_PPF_Measure+0x18c>)
 800c5d4:	781a      	ldrb	r2, [r3, #0]
 800c5d6:	4542      	cmp	r2, r8
 800c5d8:	4699      	mov	r9, r3
 800c5da:	d90d      	bls.n	800c5f8 <GUI_Text_PPF_Measure+0xc0>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+26, TFT_Black_Bkgr);
 800c5dc:	2163      	movs	r1, #99	; 0x63
 800c5de:	f106 031a 	add.w	r3, r6, #26
 800c5e2:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800c5e6:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800c5ea:	9100      	str	r1, [sp, #0]
 800c5ec:	b29b      	uxth	r3, r3
 800c5ee:	b292      	uxth	r2, r2
 800c5f0:	4631      	mov	r1, r6
 800c5f2:	b280      	uxth	r0, r0
 800c5f4:	f004 f9a1 	bl	801093a <TFT_FillRectangle>
	} 

	old_numPPF = number;

	buffer[8] = 0;
 800c5f8:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c5fa:	1960      	adds	r0, r4, r5
 800c5fc:	aa03      	add	r2, sp, #12
 800c5fe:	4631      	mov	r1, r6
	buffer[8] = 0;
 800c600:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c604:	b280      	uxth	r0, r0
 800c606:	2303      	movs	r3, #3
	old_numPPF = number;
 800c608:	f889 8000 	strb.w	r8, [r9]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c60c:	f004 fc66 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetTextColor(TFT_White);
 800c610:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800c614:	f004 fb9a 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c618:	2063      	movs	r0, #99	; 0x63
 800c61a:	f004 fb9d 	bl	8010d58 <TFT_SetBackColor>
	if(Language_status == Ru ){
 800c61e:	4b2a      	ldr	r3, [pc, #168]	; (800c6c8 <GUI_Text_PPF_Measure+0x190>)
 800c620:	781b      	ldrb	r3, [r3, #0]
 800c622:	f104 0a18 	add.w	sl, r4, #24
 800c626:	f104 0930 	add.w	r9, r4, #48	; 0x30
 800c62a:	1cb5      	adds	r5, r6, #2
 800c62c:	f104 08c8 	add.w	r8, r4, #200	; 0xc8
 800c630:	b9f3      	cbnz	r3, 800c670 <GUI_Text_PPF_Measure+0x138>
			TFT_SetFont(&Font26RU_arch_big);
 800c632:	4826      	ldr	r0, [pc, #152]	; (800c6cc <GUI_Text_PPF_Measure+0x194>)
 800c634:	f004 fb84 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X, Y, ''-17);
 800c638:	2293      	movs	r2, #147	; 0x93
 800c63a:	4631      	mov	r1, r6
 800c63c:	4620      	mov	r0, r4
 800c63e:	f004 fb91 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+24, Y, ''-17);
 800c642:	227f      	movs	r2, #127	; 0x7f
 800c644:	4631      	mov	r1, r6
 800c646:	fa1f f08a 	uxth.w	r0, sl
 800c64a:	f004 fb8b 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+48, Y, ''-17);
 800c64e:	228f      	movs	r2, #143	; 0x8f
 800c650:	4631      	mov	r1, r6
 800c652:	fa1f f089 	uxth.w	r0, r9
 800c656:	f004 fb85 	bl	8010d64 <TFT_DrawCharRus>
			GUI_TextRu_umol(X+200, Y+2, deg);
 800c65a:	463a      	mov	r2, r7
 800c65c:	b2a9      	uxth	r1, r5
 800c65e:	fa1f f088 	uxth.w	r0, r8
 800c662:	f003 fc57 	bl	800ff14 <GUI_TextRu_umol>
			TFT_DrawChar(X+24, Y+2, 'P'-33);
			TFT_DrawChar(X+48, Y+2, 'F'-33);
			TFT_DrawChar(X+72, Y+2, 'D'-33);
			GUI_TextEn_umol(X+200, Y+2, deg);
		}	
}
 800c666:	b006      	add	sp, #24
 800c668:	ecbd 8b02 	vpop	{d8}
 800c66c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			TFT_DrawChar(X, Y+2, 'P'-33);
 800c670:	b2ad      	uxth	r5, r5
			TFT_SetFont(&Font26EN_arch_big);
 800c672:	4817      	ldr	r0, [pc, #92]	; (800c6d0 <GUI_Text_PPF_Measure+0x198>)
 800c674:	f004 fb64 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y+2, 'P'-33);
 800c678:	4629      	mov	r1, r5
 800c67a:	4620      	mov	r0, r4
 800c67c:	222f      	movs	r2, #47	; 0x2f
 800c67e:	f004 fbd5 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+24, Y+2, 'P'-33);
 800c682:	4629      	mov	r1, r5
 800c684:	fa1f f08a 	uxth.w	r0, sl
 800c688:	222f      	movs	r2, #47	; 0x2f
 800c68a:	f004 fbcf 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+48, Y+2, 'F'-33);
 800c68e:	4629      	mov	r1, r5
 800c690:	fa1f f089 	uxth.w	r0, r9
 800c694:	2225      	movs	r2, #37	; 0x25
 800c696:	f004 fbc9 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+72, Y+2, 'D'-33);
 800c69a:	f104 0048 	add.w	r0, r4, #72	; 0x48
 800c69e:	4629      	mov	r1, r5
 800c6a0:	2223      	movs	r2, #35	; 0x23
 800c6a2:	b280      	uxth	r0, r0
 800c6a4:	f004 fbc2 	bl	8010e2c <TFT_DrawChar>
			GUI_TextEn_umol(X+200, Y+2, deg);
 800c6a8:	463a      	mov	r2, r7
 800c6aa:	4629      	mov	r1, r5
 800c6ac:	fa1f f088 	uxth.w	r0, r8
 800c6b0:	f001 ff5e 	bl	800e570 <GUI_TextEn_umol>
}
 800c6b4:	e7d7      	b.n	800c666 <GUI_Text_PPF_Measure+0x12e>
 800c6b6:	bf00      	nop
 800c6b8:	447a0000 	.word	0x447a0000
 800c6bc:	20000138 	.word	0x20000138
 800c6c0:	0801f558 	.word	0x0801f558
 800c6c4:	2000017f 	.word	0x2000017f
 800c6c8:	200002bb 	.word	0x200002bb
 800c6cc:	20000148 	.word	0x20000148
 800c6d0:	20000130 	.word	0x20000130

0800c6d4 <GUI_Text_PPFRGB_Measure>:
uint8_t old_numPPFR = 10, old_numPPFG = 10, old_numPPFB = 10, old_numPPFFR = 10;
void GUI_Text_PPFRGB_Measure(uint16_t X, uint16_t Y, float ValueR, float ValueG, float ValueB, float ValueFR)
{
 800c6d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c6d8:	ed2d 8b06 	vpush	{d8-d10}
	char buffer[9] = {0};
	uint8_t	delta_pos = 140, deg = 0, number=0;
	uint32_t dec = 10;
	
	if((ValueB/1000) >= 1.0)
 800c6dc:	eddf 8ad3 	vldr	s17, [pc, #844]	; 800ca2c <GUI_Text_PPFRGB_Measure+0x358>
 800c6e0:	eec1 7a28 	vdiv.f32	s15, s2, s17
{
 800c6e4:	b086      	sub	sp, #24
	char buffer[9] = {0};
 800c6e6:	2600      	movs	r6, #0
{
 800c6e8:	4604      	mov	r4, r0
		ValueB = ValueB/(1000);
		deg = 1;
	}
	else deg=0;
	
	TFT_SetTextColor(TFT_White);
 800c6ea:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800c6ee:	460d      	mov	r5, r1
	char buffer[9] = {0};
 800c6f0:	9603      	str	r6, [sp, #12]
 800c6f2:	9604      	str	r6, [sp, #16]
 800c6f4:	f88d 6014 	strb.w	r6, [sp, #20]
	uint8_t	delta_pos = 140, deg = 0, number=0;
 800c6f8:	278c      	movs	r7, #140	; 0x8c
 800c6fa:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	else deg=0;
 800c6fe:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c702:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800c706:	eef0 aa41 	vmov.f32	s21, s2
	else deg=0;
 800c70a:	bfa8      	it	ge
 800c70c:	eef0 aa67 	vmovge.f32	s21, s15
{
 800c710:	eef0 9a40 	vmov.f32	s19, s0
 800c714:	eeb0 aa60 	vmov.f32	s20, s1
 800c718:	eeb0 9a61 	vmov.f32	s18, s3
	else deg=0;
 800c71c:	bfac      	ite	ge
 800c71e:	f04f 0901 	movge.w	r9, #1
 800c722:	46b1      	movlt	r9, r6
	TFT_SetTextColor(TFT_White);
 800c724:	f004 fb12 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800c728:	2063      	movs	r0, #99	; 0x63
 800c72a:	f004 fb15 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800c72e:	48c0      	ldr	r0, [pc, #768]	; (800ca30 <GUI_Text_PPFRGB_Measure+0x35c>)
 800c730:	f004 fb06 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", ValueB);
 800c734:	ee1a 0a90 	vmov	r0, s21
 800c738:	f7f3 ff16 	bl	8000568 <__aeabi_f2d>
 800c73c:	4602      	mov	r2, r0
 800c73e:	460b      	mov	r3, r1
 800c740:	a803      	add	r0, sp, #12
 800c742:	49bc      	ldr	r1, [pc, #752]	; (800ca34 <GUI_Text_PPFRGB_Measure+0x360>)
 800c744:	f005 fe22 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800c748:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", ValueB);
 800c74a:	2304      	movs	r3, #4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueB/(dec)) >= 1.0)
		{
			dec *= 10;
 800c74c:	4611      	mov	r1, r2
		if((ValueB/(dec)) >= 1.0)
 800c74e:	ee07 2a90 	vmov	s15, r2
 800c752:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800c756:	eeca 7a87 	vdiv.f32	s15, s21, s14
 800c75a:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c75e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c762:	db04      	blt.n	800c76e <GUI_Text_PPFRGB_Measure+0x9a>
			delta_pos-=23;
 800c764:	3f17      	subs	r7, #23
			number++;
 800c766:	3601      	adds	r6, #1
			dec *= 10;
 800c768:	434a      	muls	r2, r1
			delta_pos-=23;
 800c76a:	b2ff      	uxtb	r7, r7
			number++;
 800c76c:	b2f6      	uxtb	r6, r6
 800c76e:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800c770:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c774:	d1eb      	bne.n	800c74e <GUI_Text_PPFRGB_Measure+0x7a>
		}
	}
	
		if(number < old_numPPFB )
 800c776:	4bb0      	ldr	r3, [pc, #704]	; (800ca38 <GUI_Text_PPFRGB_Measure+0x364>)
 800c778:	781a      	ldrb	r2, [r3, #0]
 800c77a:	42b2      	cmp	r2, r6
 800c77c:	4698      	mov	r8, r3
 800c77e:	d90d      	bls.n	800c79c <GUI_Text_PPFRGB_Measure+0xc8>
	{
		TFT_FillRectangle(X+20, Y, X+197, Y+20, TFT_Black_Bkgr);
 800c780:	2163      	movs	r1, #99	; 0x63
 800c782:	f105 0314 	add.w	r3, r5, #20
 800c786:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800c78a:	f104 0014 	add.w	r0, r4, #20
 800c78e:	9100      	str	r1, [sp, #0]
 800c790:	b29b      	uxth	r3, r3
 800c792:	b292      	uxth	r2, r2
 800c794:	4629      	mov	r1, r5
 800c796:	b280      	uxth	r0, r0
 800c798:	f004 f8cf 	bl	801093a <TFT_FillRectangle>
	} 
	old_numPPFB = number;
	number = 0;
	buffer[8] = 0;
 800c79c:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c79e:	19e0      	adds	r0, r4, r7
	buffer[8] = 0;
 800c7a0:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c7a4:	aa03      	add	r2, sp, #12
 800c7a6:	2303      	movs	r3, #3
 800c7a8:	4629      	mov	r1, r5
 800c7aa:	b280      	uxth	r0, r0
	old_numPPFB = number;
 800c7ac:	f888 6000 	strb.w	r6, [r8]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800c7b0:	f004 fb94 	bl	8010edc <TFT_DisplayString>
	
	if (Language_status==Ru)
 800c7b4:	4aa1      	ldr	r2, [pc, #644]	; (800ca3c <GUI_Text_PPFRGB_Measure+0x368>)
 800c7b6:	7813      	ldrb	r3, [r2, #0]
 800c7b8:	4690      	mov	r8, r2
 800c7ba:	2b00      	cmp	r3, #0
 800c7bc:	f040 81b3 	bne.w	800cb26 <GUI_Text_PPFRGB_Measure+0x452>
	{
		TFT_SetFont(&Font16RU_arch_big);
 800c7c0:	489f      	ldr	r0, [pc, #636]	; (800ca40 <GUI_Text_PPFRGB_Measure+0x36c>)
 800c7c2:	f004 fabd 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+40, Y, '');
 800c7c6:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800c7ca:	22a1      	movs	r2, #161	; 0xa1
 800c7cc:	4629      	mov	r1, r5
 800c7ce:	b280      	uxth	r0, r0
 800c7d0:	f004 fac8 	bl	8010d64 <TFT_DrawCharRus>
		TFT_SetFont(&Font16RU_arch_small);
		TFT_DrawCharRus(X+54, Y+5, '');
 800c7d4:	1d6e      	adds	r6, r5, #5
		TFT_SetFont(&Font16RU_arch_small);
 800c7d6:	489b      	ldr	r0, [pc, #620]	; (800ca44 <GUI_Text_PPFRGB_Measure+0x370>)
 800c7d8:	f004 fab2 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+54, Y+5, '');
 800c7dc:	b2b6      	uxth	r6, r6
 800c7de:	f104 0036 	add.w	r0, r4, #54	; 0x36
 800c7e2:	22b8      	movs	r2, #184	; 0xb8
 800c7e4:	4631      	mov	r1, r6
 800c7e6:	b280      	uxth	r0, r0
 800c7e8:	f004 fabc 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+66, Y+5, '');
 800c7ec:	f104 0042 	add.w	r0, r4, #66	; 0x42
 800c7f0:	22bd      	movs	r2, #189	; 0xbd
 800c7f2:	4631      	mov	r1, r6
 800c7f4:	b280      	uxth	r0, r0
 800c7f6:	f004 fab5 	bl	8010d64 <TFT_DrawCharRus>
		GUI_TextRu_umol(X+202, Y, deg);
 800c7fa:	f104 00ca 	add.w	r0, r4, #202	; 0xca
 800c7fe:	464a      	mov	r2, r9
 800c800:	4629      	mov	r1, r5
 800c802:	b280      	uxth	r0, r0
 800c804:	f003 fb86 	bl	800ff14 <GUI_TextRu_umol>
		GUI_TextEn_Blue(X+34, Y);
		GUI_TextEn_umol(X+200, Y, deg);
	}
	
	
	if((ValueG/1000) >= 1.0)
 800c808:	eeca 7a28 	vdiv.f32	s15, s20, s17
	}
	else deg=0;
	
	delta_pos = 140;
	dec = 10;
	TFT_SetFont(&Font16EN_arch_big);
 800c80c:	4888      	ldr	r0, [pc, #544]	; (800ca30 <GUI_Text_PPFRGB_Measure+0x35c>)
	number = 0;
 800c80e:	2600      	movs	r6, #0
	delta_pos = 140;
 800c810:	278c      	movs	r7, #140	; 0x8c
	else deg=0;
 800c812:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c816:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c81a:	bfa8      	it	ge
 800c81c:	eeb0 aa67 	vmovge.f32	s20, s15
 800c820:	bfac      	ite	ge
 800c822:	f04f 0901 	movge.w	r9, #1
 800c826:	f04f 0900 	movlt.w	r9, #0
	TFT_SetFont(&Font16EN_arch_big);
 800c82a:	f004 fa89 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", ValueG);
 800c82e:	ee1a 0a10 	vmov	r0, s20
 800c832:	f7f3 fe99 	bl	8000568 <__aeabi_f2d>
 800c836:	4602      	mov	r2, r0
 800c838:	460b      	mov	r3, r1
 800c83a:	a803      	add	r0, sp, #12
 800c83c:	497d      	ldr	r1, [pc, #500]	; (800ca34 <GUI_Text_PPFRGB_Measure+0x360>)
 800c83e:	f005 fda5 	bl	801238c <siprintf>
	dec = 10;
 800c842:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", ValueG);
 800c844:	2304      	movs	r3, #4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueG/(dec)) >= 1.0)
		{
			dec *= 10;
 800c846:	4611      	mov	r1, r2
		if((ValueG/(dec)) >= 1.0)
 800c848:	ee07 2a90 	vmov	s15, r2
 800c84c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800c850:	eeca 7a07 	vdiv.f32	s15, s20, s14
 800c854:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c858:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c85c:	db04      	blt.n	800c868 <GUI_Text_PPFRGB_Measure+0x194>
			delta_pos-=23;
 800c85e:	3f17      	subs	r7, #23
			number++;
 800c860:	3601      	adds	r6, #1
			dec *= 10;
 800c862:	434a      	muls	r2, r1
			delta_pos-=23;
 800c864:	b2ff      	uxtb	r7, r7
			number++;
 800c866:	b2f6      	uxtb	r6, r6
 800c868:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800c86a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c86e:	d1eb      	bne.n	800c848 <GUI_Text_PPFRGB_Measure+0x174>
		}
	}
	
		if(number < old_numPPFG )
 800c870:	4b75      	ldr	r3, [pc, #468]	; (800ca48 <GUI_Text_PPFRGB_Measure+0x374>)
 800c872:	781a      	ldrb	r2, [r3, #0]
 800c874:	42b2      	cmp	r2, r6
 800c876:	469a      	mov	sl, r3
 800c878:	d911      	bls.n	800c89e <GUI_Text_PPFRGB_Measure+0x1ca>
	{
		TFT_FillRectangle(X+20, Y+21, X+197, Y+41, TFT_Black_Bkgr);
 800c87a:	f105 0329 	add.w	r3, r5, #41	; 0x29
 800c87e:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800c882:	f105 0115 	add.w	r1, r5, #21
 800c886:	f104 0014 	add.w	r0, r4, #20
 800c88a:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800c88e:	f8cd e000 	str.w	lr, [sp]
 800c892:	b29b      	uxth	r3, r3
 800c894:	b292      	uxth	r2, r2
 800c896:	b289      	uxth	r1, r1
 800c898:	b280      	uxth	r0, r0
 800c89a:	f004 f84e 	bl	801093a <TFT_FillRectangle>
	} 
	old_numPPFG = number;
 800c89e:	f88a 6000 	strb.w	r6, [sl]
	number = 0;
	buffer[8] = 0;
	TFT_DisplayString(X+delta_pos, Y+22, (uint8_t *)buffer, LEFT_MODE);
 800c8a2:	f105 0616 	add.w	r6, r5, #22
	buffer[8] = 0;
 800c8a6:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y+22, (uint8_t *)buffer, LEFT_MODE);
 800c8a8:	b2b6      	uxth	r6, r6
 800c8aa:	19e0      	adds	r0, r4, r7
	buffer[8] = 0;
 800c8ac:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y+22, (uint8_t *)buffer, LEFT_MODE);
 800c8b0:	aa03      	add	r2, sp, #12
 800c8b2:	2303      	movs	r3, #3
 800c8b4:	4631      	mov	r1, r6
 800c8b6:	b280      	uxth	r0, r0
 800c8b8:	f004 fb10 	bl	8010edc <TFT_DisplayString>
	
	if (Language_status==Ru)
 800c8bc:	f898 3000 	ldrb.w	r3, [r8]
 800c8c0:	2b00      	cmp	r3, #0
 800c8c2:	f040 8141 	bne.w	800cb48 <GUI_Text_PPFRGB_Measure+0x474>
	{
		TFT_SetFont(&Font16RU_arch_big);
 800c8c6:	485e      	ldr	r0, [pc, #376]	; (800ca40 <GUI_Text_PPFRGB_Measure+0x36c>)
 800c8c8:	f004 fa3a 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+40, Y+22, '');
 800c8cc:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800c8d0:	2297      	movs	r2, #151	; 0x97
 800c8d2:	4631      	mov	r1, r6
 800c8d4:	b280      	uxth	r0, r0
 800c8d6:	f004 fa45 	bl	8010d64 <TFT_DrawCharRus>
		TFT_SetFont(&Font16RU_arch_small);
		TFT_DrawCharRus(X+54, Y+27, '');
 800c8da:	f105 071b 	add.w	r7, r5, #27
		TFT_SetFont(&Font16RU_arch_small);
 800c8de:	4859      	ldr	r0, [pc, #356]	; (800ca44 <GUI_Text_PPFRGB_Measure+0x370>)
 800c8e0:	f004 fa2e 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+54, Y+27, '');
 800c8e4:	b2bf      	uxth	r7, r7
 800c8e6:	f104 0036 	add.w	r0, r4, #54	; 0x36
 800c8ea:	22b5      	movs	r2, #181	; 0xb5
 800c8ec:	4639      	mov	r1, r7
 800c8ee:	b280      	uxth	r0, r0
 800c8f0:	f004 fa38 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+66, Y+27, '');
 800c8f4:	f104 0042 	add.w	r0, r4, #66	; 0x42
 800c8f8:	22bb      	movs	r2, #187	; 0xbb
 800c8fa:	4639      	mov	r1, r7
 800c8fc:	b280      	uxth	r0, r0
 800c8fe:	f004 fa31 	bl	8010d64 <TFT_DrawCharRus>
		GUI_TextRu_umol(X+202, Y+22, deg);
 800c902:	f104 00ca 	add.w	r0, r4, #202	; 0xca
 800c906:	464a      	mov	r2, r9
 800c908:	4631      	mov	r1, r6
 800c90a:	b280      	uxth	r0, r0
 800c90c:	f003 fb02 	bl	800ff14 <GUI_TextRu_umol>
		GUI_TextEn_umol(X+200, Y+22, deg);
	}
	
	
	
	if((ValueR/1000) >= 1.0)
 800c910:	eec9 7aa8 	vdiv.f32	s15, s19, s17
	}
	else deg=0;
	
	delta_pos = 140;
	dec = 10;
	TFT_SetFont(&Font16EN_arch_big);
 800c914:	4846      	ldr	r0, [pc, #280]	; (800ca30 <GUI_Text_PPFRGB_Measure+0x35c>)
	number = 0;
 800c916:	2600      	movs	r6, #0
	delta_pos = 140;
 800c918:	278c      	movs	r7, #140	; 0x8c
	else deg=0;
 800c91a:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c91e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c922:	bfa8      	it	ge
 800c924:	eef0 9a67 	vmovge.f32	s19, s15
 800c928:	bfac      	ite	ge
 800c92a:	f04f 0901 	movge.w	r9, #1
 800c92e:	f04f 0900 	movlt.w	r9, #0
	TFT_SetFont(&Font16EN_arch_big);
 800c932:	f004 fa05 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", ValueR);
 800c936:	ee19 0a90 	vmov	r0, s19
 800c93a:	f7f3 fe15 	bl	8000568 <__aeabi_f2d>
 800c93e:	4602      	mov	r2, r0
 800c940:	460b      	mov	r3, r1
 800c942:	a803      	add	r0, sp, #12
 800c944:	493b      	ldr	r1, [pc, #236]	; (800ca34 <GUI_Text_PPFRGB_Measure+0x360>)
 800c946:	f005 fd21 	bl	801238c <siprintf>
	dec = 10;
 800c94a:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", ValueR);
 800c94c:	2304      	movs	r3, #4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueR/(dec)) >= 1.0)
		{
			dec *= 10;
 800c94e:	4611      	mov	r1, r2
		if((ValueR/(dec)) >= 1.0)
 800c950:	ee07 2a90 	vmov	s15, r2
 800c954:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800c958:	eec9 7a87 	vdiv.f32	s15, s19, s14
 800c95c:	eef4 7ac8 	vcmpe.f32	s15, s16
 800c960:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c964:	db04      	blt.n	800c970 <GUI_Text_PPFRGB_Measure+0x29c>
			delta_pos-=23;
 800c966:	3f17      	subs	r7, #23
			number++;
 800c968:	3601      	adds	r6, #1
			dec *= 10;
 800c96a:	434a      	muls	r2, r1
			delta_pos-=23;
 800c96c:	b2ff      	uxtb	r7, r7
			number++;
 800c96e:	b2f6      	uxtb	r6, r6
 800c970:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800c972:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800c976:	d1eb      	bne.n	800c950 <GUI_Text_PPFRGB_Measure+0x27c>
		}
	}
	
	if(number < old_numPPFR )
 800c978:	4b34      	ldr	r3, [pc, #208]	; (800ca4c <GUI_Text_PPFRGB_Measure+0x378>)
 800c97a:	781a      	ldrb	r2, [r3, #0]
 800c97c:	42b2      	cmp	r2, r6
 800c97e:	469a      	mov	sl, r3
 800c980:	d911      	bls.n	800c9a6 <GUI_Text_PPFRGB_Measure+0x2d2>
	{
		TFT_FillRectangle(X+20, Y+42, X+197, Y+63, TFT_Black_Bkgr);
 800c982:	f105 033f 	add.w	r3, r5, #63	; 0x3f
 800c986:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800c98a:	f105 012a 	add.w	r1, r5, #42	; 0x2a
 800c98e:	f104 0014 	add.w	r0, r4, #20
 800c992:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800c996:	f8cd e000 	str.w	lr, [sp]
 800c99a:	b29b      	uxth	r3, r3
 800c99c:	b292      	uxth	r2, r2
 800c99e:	b289      	uxth	r1, r1
 800c9a0:	b280      	uxth	r0, r0
 800c9a2:	f003 ffca 	bl	801093a <TFT_FillRectangle>
	} 
	old_numPPFR = number;
 800c9a6:	f88a 6000 	strb.w	r6, [sl]
	number = 0;
	buffer[8] = 0;
	TFT_DisplayString(X+delta_pos, Y+44, (uint8_t *)buffer, LEFT_MODE);
 800c9aa:	f105 062c 	add.w	r6, r5, #44	; 0x2c
	buffer[8] = 0;
 800c9ae:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y+44, (uint8_t *)buffer, LEFT_MODE);
 800c9b0:	b2b6      	uxth	r6, r6
 800c9b2:	19e0      	adds	r0, r4, r7
	buffer[8] = 0;
 800c9b4:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y+44, (uint8_t *)buffer, LEFT_MODE);
 800c9b8:	aa03      	add	r2, sp, #12
 800c9ba:	2303      	movs	r3, #3
 800c9bc:	4631      	mov	r1, r6
 800c9be:	b280      	uxth	r0, r0
 800c9c0:	f004 fa8c 	bl	8010edc <TFT_DisplayString>
	
	if (Language_status==Ru)
 800c9c4:	f898 3000 	ldrb.w	r3, [r8]
 800c9c8:	2b00      	cmp	r3, #0
 800c9ca:	f040 80ce 	bne.w	800cb6a <GUI_Text_PPFRGB_Measure+0x496>
	{
		TFT_SetFont(&Font16RU_arch_big);
 800c9ce:	481c      	ldr	r0, [pc, #112]	; (800ca40 <GUI_Text_PPFRGB_Measure+0x36c>)
 800c9d0:	f004 f9b6 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+40, Y+44, '');
 800c9d4:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800c9d8:	229a      	movs	r2, #154	; 0x9a
 800c9da:	4631      	mov	r1, r6
 800c9dc:	b280      	uxth	r0, r0
 800c9de:	f004 f9c1 	bl	8010d64 <TFT_DrawCharRus>
		TFT_SetFont(&Font16RU_arch_small);
 800c9e2:	4818      	ldr	r0, [pc, #96]	; (800ca44 <GUI_Text_PPFRGB_Measure+0x370>)
 800c9e4:	f004 f9ac 	bl	8010d40 <TFT_SetFont>
		TFT_DrawCharRus(X+55, Y+49, '');
 800c9e8:	f105 0131 	add.w	r1, r5, #49	; 0x31
 800c9ec:	f104 0037 	add.w	r0, r4, #55	; 0x37
 800c9f0:	2280      	movs	r2, #128	; 0x80
 800c9f2:	b289      	uxth	r1, r1
 800c9f4:	b280      	uxth	r0, r0
 800c9f6:	f004 f9b5 	bl	8010d64 <TFT_DrawCharRus>
		GUI_TextRu_umol(X+202, Y+44, deg);
 800c9fa:	f104 00ca 	add.w	r0, r4, #202	; 0xca
 800c9fe:	464a      	mov	r2, r9
 800ca00:	4631      	mov	r1, r6
 800ca02:	b280      	uxth	r0, r0
 800ca04:	f003 fa86 	bl	800ff14 <GUI_TextRu_umol>
	{
		GUI_TextEn_Red(X+37, Y+44);
		GUI_TextEn_umol(X+200, Y+44, deg);
	}

	if((ValueFR/1000) >= 1.0)
 800ca08:	eec9 7a28 	vdiv.f32	s15, s18, s17
	}
	else deg=0;
	
	delta_pos = 140;
	dec = 10;
	TFT_SetFont(&Font16EN_arch_big);
 800ca0c:	4808      	ldr	r0, [pc, #32]	; (800ca30 <GUI_Text_PPFRGB_Measure+0x35c>)
	number = 0;
 800ca0e:	f04f 0900 	mov.w	r9, #0
	delta_pos = 140;
 800ca12:	268c      	movs	r6, #140	; 0x8c
	else deg=0;
 800ca14:	eef4 7ac8 	vcmpe.f32	s15, s16
 800ca18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca1c:	bfa8      	it	ge
 800ca1e:	eeb0 9a67 	vmovge.f32	s18, s15
 800ca22:	bfac      	ite	ge
 800ca24:	2701      	movge	r7, #1
 800ca26:	2700      	movlt	r7, #0
 800ca28:	e012      	b.n	800ca50 <GUI_Text_PPFRGB_Measure+0x37c>
 800ca2a:	bf00      	nop
 800ca2c:	447a0000 	.word	0x447a0000
 800ca30:	200000f8 	.word	0x200000f8
 800ca34:	0801f558 	.word	0x0801f558
 800ca38:	20000180 	.word	0x20000180
 800ca3c:	200002bb 	.word	0x200002bb
 800ca40:	20000118 	.word	0x20000118
 800ca44:	20000120 	.word	0x20000120
 800ca48:	20000182 	.word	0x20000182
 800ca4c:	20000183 	.word	0x20000183
	TFT_SetFont(&Font16EN_arch_big);
 800ca50:	f004 f976 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", ValueFR);
 800ca54:	ee19 0a10 	vmov	r0, s18
 800ca58:	f7f3 fd86 	bl	8000568 <__aeabi_f2d>
 800ca5c:	4602      	mov	r2, r0
 800ca5e:	460b      	mov	r3, r1
 800ca60:	a803      	add	r0, sp, #12
 800ca62:	494f      	ldr	r1, [pc, #316]	; (800cba0 <GUI_Text_PPFRGB_Measure+0x4cc>)
 800ca64:	f005 fc92 	bl	801238c <siprintf>
	dec = 10;
 800ca68:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", ValueFR);
 800ca6a:	2304      	movs	r3, #4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueFR/(dec)) >= 1.0)
		{
			dec *= 10;
 800ca6c:	4611      	mov	r1, r2
		if((ValueFR/(dec)) >= 1.0)
 800ca6e:	ee07 2a90 	vmov	s15, r2
 800ca72:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800ca76:	eec9 7a07 	vdiv.f32	s15, s18, s14
 800ca7a:	eef4 7ac8 	vcmpe.f32	s15, s16
 800ca7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca82:	db06      	blt.n	800ca92 <GUI_Text_PPFRGB_Measure+0x3be>
			delta_pos-=23;
 800ca84:	3e17      	subs	r6, #23
			number++;
 800ca86:	f109 0901 	add.w	r9, r9, #1
			dec *= 10;
 800ca8a:	434a      	muls	r2, r1
			delta_pos-=23;
 800ca8c:	b2f6      	uxtb	r6, r6
			number++;
 800ca8e:	fa5f f989 	uxtb.w	r9, r9
 800ca92:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800ca94:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800ca98:	d1e9      	bne.n	800ca6e <GUI_Text_PPFRGB_Measure+0x39a>
		}
	}
	
	if(number < old_numPPFFR )
 800ca9a:	4b42      	ldr	r3, [pc, #264]	; (800cba4 <GUI_Text_PPFRGB_Measure+0x4d0>)
 800ca9c:	781a      	ldrb	r2, [r3, #0]
 800ca9e:	454a      	cmp	r2, r9
 800caa0:	469a      	mov	sl, r3
 800caa2:	d911      	bls.n	800cac8 <GUI_Text_PPFRGB_Measure+0x3f4>
	{
		TFT_FillRectangle(X+20, Y+65, X+197, Y+87, TFT_Black_Bkgr);
 800caa4:	f105 0357 	add.w	r3, r5, #87	; 0x57
 800caa8:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800caac:	f105 0141 	add.w	r1, r5, #65	; 0x41
 800cab0:	f104 0014 	add.w	r0, r4, #20
 800cab4:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800cab8:	f8cd e000 	str.w	lr, [sp]
 800cabc:	b29b      	uxth	r3, r3
 800cabe:	b292      	uxth	r2, r2
 800cac0:	b289      	uxth	r1, r1
 800cac2:	b280      	uxth	r0, r0
 800cac4:	f003 ff39 	bl	801093a <TFT_FillRectangle>
	} 
	old_numPPFFR = number;
	number = 0;
	
	buffer[8] = 0;
	TFT_DisplayString(X+delta_pos, Y+66, (uint8_t *)buffer, LEFT_MODE);
 800cac8:	3542      	adds	r5, #66	; 0x42
 800caca:	b2ad      	uxth	r5, r5
	buffer[8] = 0;
 800cacc:	2300      	movs	r3, #0
	TFT_DisplayString(X+delta_pos, Y+66, (uint8_t *)buffer, LEFT_MODE);
 800cace:	19a0      	adds	r0, r4, r6
 800cad0:	aa03      	add	r2, sp, #12
 800cad2:	4629      	mov	r1, r5
	buffer[8] = 0;
 800cad4:	f88d 3014 	strb.w	r3, [sp, #20]
	TFT_DisplayString(X+delta_pos, Y+66, (uint8_t *)buffer, LEFT_MODE);
 800cad8:	b280      	uxth	r0, r0
 800cada:	2303      	movs	r3, #3
	old_numPPFFR = number;
 800cadc:	f88a 9000 	strb.w	r9, [sl]
	TFT_DisplayString(X+delta_pos, Y+66, (uint8_t *)buffer, LEFT_MODE);
 800cae0:	f004 f9fc 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetFont(&Font16EN_arch_big);
 800cae4:	4830      	ldr	r0, [pc, #192]	; (800cba8 <GUI_Text_PPFRGB_Measure+0x4d4>)
 800cae6:	f004 f92b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+37, Y+66, 'F');
 800caea:	f104 0025 	add.w	r0, r4, #37	; 0x25
 800caee:	2246      	movs	r2, #70	; 0x46
 800caf0:	4629      	mov	r1, r5
 800caf2:	b280      	uxth	r0, r0
 800caf4:	f004 f99a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+53, Y+66, 'R');
 800caf8:	f104 0035 	add.w	r0, r4, #53	; 0x35
 800cafc:	2252      	movs	r2, #82	; 0x52
 800cafe:	4629      	mov	r1, r5
 800cb00:	b280      	uxth	r0, r0
 800cb02:	f004 f993 	bl	8010e2c <TFT_DrawChar>
	if (Language_status==Ru) GUI_TextRu_umol(X+202, Y+66, deg);
 800cb06:	f898 3000 	ldrb.w	r3, [r8]
 800cb0a:	2b00      	cmp	r3, #0
 800cb0c:	d13e      	bne.n	800cb8c <GUI_Text_PPFRGB_Measure+0x4b8>
 800cb0e:	f104 00ca 	add.w	r0, r4, #202	; 0xca
 800cb12:	463a      	mov	r2, r7
 800cb14:	4629      	mov	r1, r5
 800cb16:	b280      	uxth	r0, r0
 800cb18:	f003 f9fc 	bl	800ff14 <GUI_TextRu_umol>
	else if (Language_status==En) GUI_TextEn_umol(X+200, Y+66, deg);

}
 800cb1c:	b006      	add	sp, #24
 800cb1e:	ecbd 8b06 	vpop	{d8-d10}
 800cb22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	else if (Language_status==En)
 800cb26:	2b01      	cmp	r3, #1
 800cb28:	f47f ae6e 	bne.w	800c808 <GUI_Text_PPFRGB_Measure+0x134>
		GUI_TextEn_Blue(X+34, Y);
 800cb2c:	f104 0022 	add.w	r0, r4, #34	; 0x22
 800cb30:	4629      	mov	r1, r5
 800cb32:	b280      	uxth	r0, r0
 800cb34:	f002 fada 	bl	800f0ec <GUI_TextEn_Blue>
		GUI_TextEn_umol(X+200, Y, deg);
 800cb38:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
 800cb3c:	464a      	mov	r2, r9
 800cb3e:	4629      	mov	r1, r5
 800cb40:	b280      	uxth	r0, r0
 800cb42:	f001 fd15 	bl	800e570 <GUI_TextEn_umol>
 800cb46:	e65f      	b.n	800c808 <GUI_Text_PPFRGB_Measure+0x134>
	else if (Language_status==En)
 800cb48:	2b01      	cmp	r3, #1
 800cb4a:	f47f aee1 	bne.w	800c910 <GUI_Text_PPFRGB_Measure+0x23c>
		GUI_TextEn_Green(X+17, Y+22);
 800cb4e:	f104 0011 	add.w	r0, r4, #17
 800cb52:	4631      	mov	r1, r6
 800cb54:	b280      	uxth	r0, r0
 800cb56:	f002 fa97 	bl	800f088 <GUI_TextEn_Green>
		GUI_TextEn_umol(X+200, Y+22, deg);
 800cb5a:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
 800cb5e:	464a      	mov	r2, r9
 800cb60:	4631      	mov	r1, r6
 800cb62:	b280      	uxth	r0, r0
 800cb64:	f001 fd04 	bl	800e570 <GUI_TextEn_umol>
 800cb68:	e6d2      	b.n	800c910 <GUI_Text_PPFRGB_Measure+0x23c>
	else if (Language_status==En)
 800cb6a:	2b01      	cmp	r3, #1
 800cb6c:	f47f af4c 	bne.w	800ca08 <GUI_Text_PPFRGB_Measure+0x334>
		GUI_TextEn_Red(X+37, Y+44);
 800cb70:	f104 0025 	add.w	r0, r4, #37	; 0x25
 800cb74:	4631      	mov	r1, r6
 800cb76:	b280      	uxth	r0, r0
 800cb78:	f002 fae4 	bl	800f144 <GUI_TextEn_Red>
		GUI_TextEn_umol(X+200, Y+44, deg);
 800cb7c:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
 800cb80:	464a      	mov	r2, r9
 800cb82:	4631      	mov	r1, r6
 800cb84:	b280      	uxth	r0, r0
 800cb86:	f001 fcf3 	bl	800e570 <GUI_TextEn_umol>
 800cb8a:	e73d      	b.n	800ca08 <GUI_Text_PPFRGB_Measure+0x334>
	else if (Language_status==En) GUI_TextEn_umol(X+200, Y+66, deg);
 800cb8c:	2b01      	cmp	r3, #1
 800cb8e:	d1c5      	bne.n	800cb1c <GUI_Text_PPFRGB_Measure+0x448>
 800cb90:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
 800cb94:	463a      	mov	r2, r7
 800cb96:	4629      	mov	r1, r5
 800cb98:	b280      	uxth	r0, r0
 800cb9a:	f001 fce9 	bl	800e570 <GUI_TextEn_umol>
}
 800cb9e:	e7bd      	b.n	800cb1c <GUI_Text_PPFRGB_Measure+0x448>
 800cba0:	0801f558 	.word	0x0801f558
 800cba4:	20000181 	.word	0x20000181
 800cba8:	200000f8 	.word	0x200000f8

0800cbac <GUI_Text_XYZ_Measure>:
uint8_t old_numX = 10, old_numY = 10, old_numZ = 10;
void GUI_Text_XYZ_Measure(uint16_t X, uint16_t Y, uint16_t ValueX, uint16_t ValueY, uint16_t ValueZ)
{
 800cbac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cbb0:	b087      	sub	sp, #28
	char buffer[5] = {0};
 800cbb2:	2600      	movs	r6, #0
{
 800cbb4:	4604      	mov	r4, r0
 800cbb6:	469a      	mov	sl, r3
	uint8_t	delta_pos = 180, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800cbb8:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800cbbc:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
 800cbc0:	9303      	str	r3, [sp, #12]
 800cbc2:	460d      	mov	r5, r1
 800cbc4:	4693      	mov	fp, r2
	char buffer[5] = {0};
 800cbc6:	9604      	str	r6, [sp, #16]
 800cbc8:	f88d 6014 	strb.w	r6, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800cbcc:	f004 f8be 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800cbd0:	2063      	movs	r0, #99	; 0x63
 800cbd2:	f004 f8c1 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800cbd6:	487b      	ldr	r0, [pc, #492]	; (800cdc4 <GUI_Text_XYZ_Measure+0x218>)
 800cbd8:	f004 f8b2 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", ValueX);
 800cbdc:	465a      	mov	r2, fp
 800cbde:	497a      	ldr	r1, [pc, #488]	; (800cdc8 <GUI_Text_XYZ_Measure+0x21c>)
 800cbe0:	a804      	add	r0, sp, #16
 800cbe2:	f005 fbd3 	bl	801238c <siprintf>
 800cbe6:	f04f 0804 	mov.w	r8, #4
	uint32_t dec = 10;
 800cbea:	f04f 090a 	mov.w	r9, #10
	uint8_t	delta_pos = 180, number = 0;
 800cbee:	27b4      	movs	r7, #180	; 0xb4
	
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueX/(dec)) >= 1.0)
 800cbf0:	fbbb f0f9 	udiv	r0, fp, r9
 800cbf4:	f7f3 fc96 	bl	8000524 <__aeabi_ui2d>
 800cbf8:	2200      	movs	r2, #0
 800cbfa:	4b74      	ldr	r3, [pc, #464]	; (800cdcc <GUI_Text_XYZ_Measure+0x220>)
 800cbfc:	f7f3 ff8e 	bl	8000b1c <__aeabi_dcmpge>
 800cc00:	b130      	cbz	r0, 800cc10 <GUI_Text_XYZ_Measure+0x64>
		{
			dec *= 10;
 800cc02:	230a      	movs	r3, #10
			delta_pos-=23;
 800cc04:	3f17      	subs	r7, #23
			number++;
 800cc06:	3601      	adds	r6, #1
			dec *= 10;
 800cc08:	fb03 f909 	mul.w	r9, r3, r9
			delta_pos-=23;
 800cc0c:	b2ff      	uxtb	r7, r7
			number++;
 800cc0e:	b2f6      	uxtb	r6, r6
 800cc10:	f108 38ff 	add.w	r8, r8, #4294967295
	for (uint8_t i = 1; i <= 4; i++)
 800cc14:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 800cc18:	d1ea      	bne.n	800cbf0 <GUI_Text_XYZ_Measure+0x44>
		}
	}
	
	if(number < old_numX )
 800cc1a:	4b6d      	ldr	r3, [pc, #436]	; (800cdd0 <GUI_Text_XYZ_Measure+0x224>)
 800cc1c:	781a      	ldrb	r2, [r3, #0]
 800cc1e:	42b2      	cmp	r2, r6
 800cc20:	4698      	mov	r8, r3
 800cc22:	d90d      	bls.n	800cc40 <GUI_Text_XYZ_Measure+0x94>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+24, TFT_Black_Bkgr);
 800cc24:	2163      	movs	r1, #99	; 0x63
 800cc26:	f105 0318 	add.w	r3, r5, #24
 800cc2a:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800cc2e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800cc32:	9100      	str	r1, [sp, #0]
 800cc34:	b29b      	uxth	r3, r3
 800cc36:	b292      	uxth	r2, r2
 800cc38:	4629      	mov	r1, r5
 800cc3a:	b280      	uxth	r0, r0
 800cc3c:	f003 fe7d 	bl	801093a <TFT_FillRectangle>
	} 
	old_numX = number;
	number = 0;
	
		TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800cc40:	19e0      	adds	r0, r4, r7
 800cc42:	2303      	movs	r3, #3
 800cc44:	aa04      	add	r2, sp, #16
 800cc46:	4629      	mov	r1, r5
 800cc48:	b280      	uxth	r0, r0
	old_numX = number;
 800cc4a:	f888 6000 	strb.w	r6, [r8]
		TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800cc4e:	f004 f945 	bl	8010edc <TFT_DisplayString>
	
			TFT_SetTextColor(TFT_White);
 800cc52:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cc56:	f004 f879 	bl	8010d4c <TFT_SetTextColor>
			TFT_SetBackColor(TFT_Black_Bkgr);
 800cc5a:	2063      	movs	r0, #99	; 0x63
 800cc5c:	f004 f87c 	bl	8010d58 <TFT_SetBackColor>
			TFT_SetFont(&Font26EN_arch_big);
 800cc60:	485c      	ldr	r0, [pc, #368]	; (800cdd4 <GUI_Text_XYZ_Measure+0x228>)
 800cc62:	f004 f86d 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y, 'X'-34);
 800cc66:	2236      	movs	r2, #54	; 0x36
 800cc68:	4629      	mov	r1, r5
 800cc6a:	4620      	mov	r0, r4
 800cc6c:	f004 f8de 	bl	8010e2c <TFT_DrawChar>
	
	delta_pos = 180;
	dec = 10;
	
	TFT_SetFont(&Font26EN_arch_digit);
 800cc70:	4854      	ldr	r0, [pc, #336]	; (800cdc4 <GUI_Text_XYZ_Measure+0x218>)
 800cc72:	f004 f865 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", ValueY);
 800cc76:	4652      	mov	r2, sl
 800cc78:	4953      	ldr	r1, [pc, #332]	; (800cdc8 <GUI_Text_XYZ_Measure+0x21c>)
 800cc7a:	a804      	add	r0, sp, #16
 800cc7c:	f005 fb86 	bl	801238c <siprintf>
	dec = 10;
 800cc80:	f04f 090a 	mov.w	r9, #10
	sprintf (buffer, "%d", ValueY);
 800cc84:	f04f 0804 	mov.w	r8, #4
	number = 0;
 800cc88:	2700      	movs	r7, #0
	delta_pos = 180;
 800cc8a:	26b4      	movs	r6, #180	; 0xb4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueY/(dec)) >= 1.0)
		{
			dec *= 10;
 800cc8c:	46cb      	mov	fp, r9
		if((ValueY/(dec)) >= 1.0)
 800cc8e:	fbba f0f9 	udiv	r0, sl, r9
 800cc92:	f7f3 fc47 	bl	8000524 <__aeabi_ui2d>
 800cc96:	2200      	movs	r2, #0
 800cc98:	4b4c      	ldr	r3, [pc, #304]	; (800cdcc <GUI_Text_XYZ_Measure+0x220>)
 800cc9a:	f7f3 ff3f 	bl	8000b1c <__aeabi_dcmpge>
 800cc9e:	b128      	cbz	r0, 800ccac <GUI_Text_XYZ_Measure+0x100>
			delta_pos-=23;
 800cca0:	3e17      	subs	r6, #23
			number++;
 800cca2:	3701      	adds	r7, #1
			dec *= 10;
 800cca4:	fb0b f909 	mul.w	r9, fp, r9
			delta_pos-=23;
 800cca8:	b2f6      	uxtb	r6, r6
			number++;
 800ccaa:	b2ff      	uxtb	r7, r7
 800ccac:	f108 38ff 	add.w	r8, r8, #4294967295
	for (uint8_t i = 1; i <= 4; i++)
 800ccb0:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 800ccb4:	d1eb      	bne.n	800cc8e <GUI_Text_XYZ_Measure+0xe2>
		}
	}
	
	if(number < old_numY )
 800ccb6:	4b48      	ldr	r3, [pc, #288]	; (800cdd8 <GUI_Text_XYZ_Measure+0x22c>)
 800ccb8:	781a      	ldrb	r2, [r3, #0]
 800ccba:	42ba      	cmp	r2, r7
 800ccbc:	4699      	mov	r9, r3
 800ccbe:	f105 0823 	add.w	r8, r5, #35	; 0x23
 800ccc2:	d90e      	bls.n	800cce2 <GUI_Text_XYZ_Measure+0x136>
	{
		TFT_FillRectangle(X+40, Y+35, X+197, Y+59, TFT_Black_Bkgr);
 800ccc4:	2163      	movs	r1, #99	; 0x63
 800ccc6:	f105 033b 	add.w	r3, r5, #59	; 0x3b
 800ccca:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800ccce:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800ccd2:	9100      	str	r1, [sp, #0]
 800ccd4:	b29b      	uxth	r3, r3
 800ccd6:	b292      	uxth	r2, r2
 800ccd8:	fa1f f188 	uxth.w	r1, r8
 800ccdc:	b280      	uxth	r0, r0
 800ccde:	f003 fe2c 	bl	801093a <TFT_FillRectangle>
	} 
	old_numY = number;
	number = 0;
	

			TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800cce2:	fa1f f888 	uxth.w	r8, r8
 800cce6:	19a0      	adds	r0, r4, r6
 800cce8:	2303      	movs	r3, #3
 800ccea:	4641      	mov	r1, r8
 800ccec:	aa04      	add	r2, sp, #16
 800ccee:	b280      	uxth	r0, r0
	old_numY = number;
 800ccf0:	f889 7000 	strb.w	r7, [r9]
			TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800ccf4:	f004 f8f2 	bl	8010edc <TFT_DisplayString>
	
			TFT_SetTextColor(TFT_White);
 800ccf8:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ccfc:	f004 f826 	bl	8010d4c <TFT_SetTextColor>
			TFT_SetBackColor(TFT_Black_Bkgr);
 800cd00:	2063      	movs	r0, #99	; 0x63
 800cd02:	f004 f829 	bl	8010d58 <TFT_SetBackColor>
			TFT_SetFont(&Font26EN_arch_big);
 800cd06:	4833      	ldr	r0, [pc, #204]	; (800cdd4 <GUI_Text_XYZ_Measure+0x228>)
 800cd08:	f004 f81a 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y+35, 'Y'-34);
 800cd0c:	4641      	mov	r1, r8
 800cd0e:	2237      	movs	r2, #55	; 0x37
 800cd10:	4620      	mov	r0, r4
 800cd12:	f004 f88b 	bl	8010e2c <TFT_DrawChar>
	
		delta_pos = 180;
	 dec = 10;
	
	TFT_SetFont(&Font26EN_arch_digit);
 800cd16:	482b      	ldr	r0, [pc, #172]	; (800cdc4 <GUI_Text_XYZ_Measure+0x218>)
 800cd18:	f004 f812 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", ValueZ);
 800cd1c:	9a03      	ldr	r2, [sp, #12]
 800cd1e:	492a      	ldr	r1, [pc, #168]	; (800cdc8 <GUI_Text_XYZ_Measure+0x21c>)
 800cd20:	a804      	add	r0, sp, #16
 800cd22:	f005 fb33 	bl	801238c <siprintf>
	 dec = 10;
 800cd26:	f04f 090a 	mov.w	r9, #10
	sprintf (buffer, "%d", ValueZ);
 800cd2a:	f04f 0804 	mov.w	r8, #4
	number = 0;
 800cd2e:	2700      	movs	r7, #0
		delta_pos = 180;
 800cd30:	26b4      	movs	r6, #180	; 0xb4
		for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueZ/(dec)) >= 1.0)
		{
			dec *= 10;
 800cd32:	46ca      	mov	sl, r9
		if((ValueZ/(dec)) >= 1.0)
 800cd34:	9b03      	ldr	r3, [sp, #12]
 800cd36:	fbb3 f0f9 	udiv	r0, r3, r9
 800cd3a:	f7f3 fbf3 	bl	8000524 <__aeabi_ui2d>
 800cd3e:	2200      	movs	r2, #0
 800cd40:	4b22      	ldr	r3, [pc, #136]	; (800cdcc <GUI_Text_XYZ_Measure+0x220>)
 800cd42:	f7f3 feeb 	bl	8000b1c <__aeabi_dcmpge>
 800cd46:	b128      	cbz	r0, 800cd54 <GUI_Text_XYZ_Measure+0x1a8>
			delta_pos-=23;
 800cd48:	3e17      	subs	r6, #23
			number++;
 800cd4a:	3701      	adds	r7, #1
			dec *= 10;
 800cd4c:	fb0a f909 	mul.w	r9, sl, r9
			delta_pos-=23;
 800cd50:	b2f6      	uxtb	r6, r6
			number++;
 800cd52:	b2ff      	uxtb	r7, r7
 800cd54:	f108 38ff 	add.w	r8, r8, #4294967295
		for (uint8_t i = 1; i <= 4; i++)
 800cd58:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 800cd5c:	d1ea      	bne.n	800cd34 <GUI_Text_XYZ_Measure+0x188>
		}
	}
	
	if(number < old_numZ )
 800cd5e:	4b1f      	ldr	r3, [pc, #124]	; (800cddc <GUI_Text_XYZ_Measure+0x230>)
 800cd60:	781a      	ldrb	r2, [r3, #0]
 800cd62:	42ba      	cmp	r2, r7
 800cd64:	4699      	mov	r9, r3
 800cd66:	f105 0846 	add.w	r8, r5, #70	; 0x46
 800cd6a:	d90e      	bls.n	800cd8a <GUI_Text_XYZ_Measure+0x1de>
	{
		TFT_FillRectangle(X+40, Y+70, X+197, Y+94, TFT_Black_Bkgr);
 800cd6c:	2163      	movs	r1, #99	; 0x63
 800cd6e:	f105 035e 	add.w	r3, r5, #94	; 0x5e
 800cd72:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800cd76:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800cd7a:	9100      	str	r1, [sp, #0]
 800cd7c:	b29b      	uxth	r3, r3
 800cd7e:	b292      	uxth	r2, r2
 800cd80:	fa1f f188 	uxth.w	r1, r8
 800cd84:	b280      	uxth	r0, r0
 800cd86:	f003 fdd8 	bl	801093a <TFT_FillRectangle>
	} 
	old_numZ = number;
	number = 0;
	

			TFT_DisplayString(X+delta_pos, Y+70, (uint8_t *)buffer, LEFT_MODE);
 800cd8a:	fa1f f888 	uxth.w	r8, r8
 800cd8e:	19a0      	adds	r0, r4, r6
 800cd90:	2303      	movs	r3, #3
 800cd92:	aa04      	add	r2, sp, #16
 800cd94:	4641      	mov	r1, r8
 800cd96:	b280      	uxth	r0, r0
	old_numZ = number;
 800cd98:	f889 7000 	strb.w	r7, [r9]
			TFT_DisplayString(X+delta_pos, Y+70, (uint8_t *)buffer, LEFT_MODE);
 800cd9c:	f004 f89e 	bl	8010edc <TFT_DisplayString>
	
			TFT_SetTextColor(TFT_White);
 800cda0:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cda4:	f003 ffd2 	bl	8010d4c <TFT_SetTextColor>
			TFT_SetBackColor(TFT_Black_Bkgr);
 800cda8:	2063      	movs	r0, #99	; 0x63
 800cdaa:	f003 ffd5 	bl	8010d58 <TFT_SetBackColor>
			TFT_SetFont(&Font26EN_arch_big);
 800cdae:	4809      	ldr	r0, [pc, #36]	; (800cdd4 <GUI_Text_XYZ_Measure+0x228>)
 800cdb0:	f003 ffc6 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y+70, 'Z'-34);
 800cdb4:	2238      	movs	r2, #56	; 0x38
 800cdb6:	4641      	mov	r1, r8
 800cdb8:	4620      	mov	r0, r4
 800cdba:	f004 f837 	bl	8010e2c <TFT_DrawChar>
}	
 800cdbe:	b007      	add	sp, #28
 800cdc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cdc4:	20000138 	.word	0x20000138
 800cdc8:	0801f55d 	.word	0x0801f55d
 800cdcc:	3ff00000 	.word	0x3ff00000
 800cdd0:	20000184 	.word	0x20000184
 800cdd4:	20000130 	.word	0x20000130
 800cdd8:	20000185 	.word	0x20000185
 800cddc:	20000186 	.word	0x20000186

0800cde0 <GUI_Text_xy_Measure>:

void GUI_Text_xy_Measure(uint16_t X, uint16_t Y, float Valuex, float Valuey)
{
 800cde0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cde4:	b085      	sub	sp, #20
	char buffer[5] = {0};
 800cde6:	2300      	movs	r3, #0
{
 800cde8:	4606      	mov	r6, r0
	uint8_t	delta_pos = 60;
	
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font26EN_arch_digit);
 800cdea:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 800ceb8 <GUI_Text_xy_Measure+0xd8>
{
 800cdee:	edcd 0a00 	vstr	s1, [sp]
	TFT_SetTextColor(TFT_White);
 800cdf2:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800cdf6:	460c      	mov	r4, r1
	char buffer[5] = {0};
 800cdf8:	9302      	str	r3, [sp, #8]
 800cdfa:	f88d 300c 	strb.w	r3, [sp, #12]
{
 800cdfe:	ed8d 0a01 	vstr	s0, [sp, #4]
	TFT_SetTextColor(TFT_White);
 800ce02:	f003 ffa3 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ce06:	2063      	movs	r0, #99	; 0x63
 800ce08:	f003 ffa6 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800ce0c:	4648      	mov	r0, r9
 800ce0e:	f003 ff97 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.4f", Valuex);
 800ce12:	ed9d 0a01 	vldr	s0, [sp, #4]
 800ce16:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 800cebc <GUI_Text_xy_Measure+0xdc>

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);

	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font26EN_arch_small);
 800ce1a:	4f26      	ldr	r7, [pc, #152]	; (800ceb4 <GUI_Text_xy_Measure+0xd4>)
	sprintf (buffer, "%.4f", Valuex);
 800ce1c:	ee10 0a10 	vmov	r0, s0
 800ce20:	f7f3 fba2 	bl	8000568 <__aeabi_f2d>
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800ce24:	f106 053c 	add.w	r5, r6, #60	; 0x3c
	sprintf (buffer, "%.4f", Valuex);
 800ce28:	4602      	mov	r2, r0
 800ce2a:	460b      	mov	r3, r1
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800ce2c:	b2ad      	uxth	r5, r5
	sprintf (buffer, "%.4f", Valuex);
 800ce2e:	4641      	mov	r1, r8
 800ce30:	a802      	add	r0, sp, #8
 800ce32:	f005 faab 	bl	801238c <siprintf>
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800ce36:	2303      	movs	r3, #3
 800ce38:	aa02      	add	r2, sp, #8
 800ce3a:	4621      	mov	r1, r4
 800ce3c:	4628      	mov	r0, r5
 800ce3e:	f004 f84d 	bl	8010edc <TFT_DisplayString>
	TFT_SetTextColor(TFT_White);
 800ce42:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ce46:	f003 ff81 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ce4a:	2063      	movs	r0, #99	; 0x63
 800ce4c:	f003 ff84 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_small);
 800ce50:	4638      	mov	r0, r7
 800ce52:	f003 ff75 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'x'-65);
 800ce56:	2237      	movs	r2, #55	; 0x37
 800ce58:	4621      	mov	r1, r4
 800ce5a:	4630      	mov	r0, r6
 800ce5c:	f003 ffe6 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font26EN_arch_digit);
 800ce60:	4648      	mov	r0, r9
 800ce62:	f003 ff6d 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.4f", Valuey);
 800ce66:	eddd 0a00 	vldr	s1, [sp]
 800ce6a:	ee10 0a90 	vmov	r0, s1
 800ce6e:	f7f3 fb7b 	bl	8000568 <__aeabi_f2d>

	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800ce72:	3423      	adds	r4, #35	; 0x23
	sprintf (buffer, "%.4f", Valuey);
 800ce74:	4602      	mov	r2, r0
 800ce76:	460b      	mov	r3, r1
	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800ce78:	b2a4      	uxth	r4, r4
	sprintf (buffer, "%.4f", Valuey);
 800ce7a:	4641      	mov	r1, r8
 800ce7c:	a802      	add	r0, sp, #8
 800ce7e:	f005 fa85 	bl	801238c <siprintf>
	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800ce82:	2303      	movs	r3, #3
 800ce84:	aa02      	add	r2, sp, #8
 800ce86:	4621      	mov	r1, r4
 800ce88:	4628      	mov	r0, r5
 800ce8a:	f004 f827 	bl	8010edc <TFT_DisplayString>

	TFT_SetTextColor(TFT_White);
 800ce8e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ce92:	f003 ff5b 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ce96:	2063      	movs	r0, #99	; 0x63
 800ce98:	f003 ff5e 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_small);
 800ce9c:	4638      	mov	r0, r7
 800ce9e:	f003 ff4f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+35, 'y'-65);
 800cea2:	2238      	movs	r2, #56	; 0x38
 800cea4:	4621      	mov	r1, r4
 800cea6:	4630      	mov	r0, r6
 800cea8:	f003 ffc0 	bl	8010e2c <TFT_DrawChar>
	
}	
 800ceac:	b005      	add	sp, #20
 800ceae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ceb2:	bf00      	nop
 800ceb4:	20000140 	.word	0x20000140
 800ceb8:	20000138 	.word	0x20000138
 800cebc:	0801f560 	.word	0x0801f560

0800cec0 <GUI_Text_uv_Measure>:

void GUI_Text_uv_Measure(uint16_t X, uint16_t Y, float ValueU, float ValueV)
{
 800cec0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	char buffer[5] = {0};
 800cec4:	2300      	movs	r3, #0
{
 800cec6:	4605      	mov	r5, r0
	uint8_t	delta_pos = 60;
	
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font26EN_arch_digit);
 800cec8:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 800cfac <GUI_Text_uv_Measure+0xec>
{
 800cecc:	edcd 0a00 	vstr	s1, [sp]
	TFT_SetTextColor(TFT_White);
 800ced0:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ced4:	460c      	mov	r4, r1
	char buffer[5] = {0};
 800ced6:	9302      	str	r3, [sp, #8]
 800ced8:	f88d 300c 	strb.w	r3, [sp, #12]
{
 800cedc:	ed8d 0a01 	vstr	s0, [sp, #4]
	TFT_SetTextColor(TFT_White);
 800cee0:	f003 ff34 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800cee4:	2063      	movs	r0, #99	; 0x63
 800cee6:	f003 ff37 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800ceea:	4650      	mov	r0, sl
 800ceec:	f003 ff28 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.4f", ValueU);
 800cef0:	ed9d 0a01 	vldr	s0, [sp, #4]
 800cef4:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 800cfb0 <GUI_Text_uv_Measure+0xf0>

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
	
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font26EN_arch_small);
 800cef8:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 800cfb4 <GUI_Text_uv_Measure+0xf4>
	sprintf (buffer, "%.4f", ValueU);
 800cefc:	ee10 0a10 	vmov	r0, s0
 800cf00:	f7f3 fb32 	bl	8000568 <__aeabi_f2d>
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800cf04:	f105 073c 	add.w	r7, r5, #60	; 0x3c
	sprintf (buffer, "%.4f", ValueU);
 800cf08:	4602      	mov	r2, r0
 800cf0a:	460b      	mov	r3, r1
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800cf0c:	b2bf      	uxth	r7, r7
	sprintf (buffer, "%.4f", ValueU);
 800cf0e:	4649      	mov	r1, r9
 800cf10:	a802      	add	r0, sp, #8
 800cf12:	f005 fa3b 	bl	801238c <siprintf>
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800cf16:	2303      	movs	r3, #3
 800cf18:	aa02      	add	r2, sp, #8
 800cf1a:	4621      	mov	r1, r4
 800cf1c:	4638      	mov	r0, r7
 800cf1e:	f003 ffdd 	bl	8010edc <TFT_DisplayString>
	TFT_SetTextColor(TFT_White);
 800cf22:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cf26:	f003 ff11 	bl	8010d4c <TFT_SetTextColor>
	TFT_DrawChar(X+15, Y, 'z'-64);
 800cf2a:	f105 060f 	add.w	r6, r5, #15
	TFT_SetBackColor(TFT_Black_Bkgr);
 800cf2e:	2063      	movs	r0, #99	; 0x63
 800cf30:	f003 ff12 	bl	8010d58 <TFT_SetBackColor>
	TFT_DrawChar(X+15, Y, 'z'-64);
 800cf34:	b2b6      	uxth	r6, r6
	TFT_SetFont(&Font26EN_arch_small);
 800cf36:	4640      	mov	r0, r8
 800cf38:	f003 ff02 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+15, Y, 'z'-64);
 800cf3c:	4621      	mov	r1, r4
 800cf3e:	4630      	mov	r0, r6
 800cf40:	223a      	movs	r2, #58	; 0x3a
 800cf42:	f003 ff73 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'u'-65);
 800cf46:	2234      	movs	r2, #52	; 0x34
 800cf48:	4621      	mov	r1, r4
 800cf4a:	4628      	mov	r0, r5
 800cf4c:	f003 ff6e 	bl	8010e2c <TFT_DrawChar>

	TFT_SetFont(&Font26EN_arch_digit);
 800cf50:	4650      	mov	r0, sl
 800cf52:	f003 fef5 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.4f", ValueV);
 800cf56:	eddd 0a00 	vldr	s1, [sp]
 800cf5a:	ee10 0a90 	vmov	r0, s1
 800cf5e:	f7f3 fb03 	bl	8000568 <__aeabi_f2d>

	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800cf62:	3423      	adds	r4, #35	; 0x23
 800cf64:	b2a4      	uxth	r4, r4
	sprintf (buffer, "%.4f", ValueV);
 800cf66:	4602      	mov	r2, r0
 800cf68:	460b      	mov	r3, r1
 800cf6a:	a802      	add	r0, sp, #8
 800cf6c:	4649      	mov	r1, r9
 800cf6e:	f005 fa0d 	bl	801238c <siprintf>
	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800cf72:	2303      	movs	r3, #3
 800cf74:	aa02      	add	r2, sp, #8
 800cf76:	4621      	mov	r1, r4
 800cf78:	4638      	mov	r0, r7
 800cf7a:	f003 ffaf 	bl	8010edc <TFT_DisplayString>

	TFT_SetTextColor(TFT_White);
 800cf7e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cf82:	f003 fee3 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800cf86:	2063      	movs	r0, #99	; 0x63
 800cf88:	f003 fee6 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_small);
 800cf8c:	4640      	mov	r0, r8
 800cf8e:	f003 fed7 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+15, Y+35, 'z'-64);
 800cf92:	4621      	mov	r1, r4
 800cf94:	4630      	mov	r0, r6
 800cf96:	223a      	movs	r2, #58	; 0x3a
 800cf98:	f003 ff48 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y+35, 'v'-65);
 800cf9c:	2235      	movs	r2, #53	; 0x35
 800cf9e:	4621      	mov	r1, r4
 800cfa0:	4628      	mov	r0, r5
 800cfa2:	f003 ff43 	bl	8010e2c <TFT_DrawChar>
}	
 800cfa6:	b004      	add	sp, #16
 800cfa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800cfac:	20000138 	.word	0x20000138
 800cfb0:	0801f560 	.word	0x0801f560
 800cfb4:	20000140 	.word	0x20000140

0800cfb8 <GUI_Text_CCT_Measure>:

uint8_t old_numCCT = 10;
void GUI_Text_CCT_Measure(uint16_t X, uint16_t Y, uint16_t Value)
{	
 800cfb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cfbc:	b087      	sub	sp, #28

	char buffer[9] = {0};
 800cfbe:	2600      	movs	r6, #0
{	
 800cfc0:	4605      	mov	r5, r0
	uint8_t	delta_pos = 160, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800cfc2:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	
 800cfc6:	460c      	mov	r4, r1
 800cfc8:	4692      	mov	sl, r2
	char buffer[9] = {0};
 800cfca:	9603      	str	r6, [sp, #12]
 800cfcc:	9604      	str	r6, [sp, #16]
 800cfce:	f88d 6014 	strb.w	r6, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800cfd2:	f003 febb 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800cfd6:	2063      	movs	r0, #99	; 0x63
 800cfd8:	f003 febe 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800cfdc:	4849      	ldr	r0, [pc, #292]	; (800d104 <GUI_Text_CCT_Measure+0x14c>)
 800cfde:	f003 feaf 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", Value);
 800cfe2:	4652      	mov	r2, sl
 800cfe4:	4948      	ldr	r1, [pc, #288]	; (800d108 <GUI_Text_CCT_Measure+0x150>)
 800cfe6:	a803      	add	r0, sp, #12
 800cfe8:	f005 f9d0 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800cfec:	f04f 090a 	mov.w	r9, #10
	sprintf (buffer, "%d", Value);
 800cff0:	f04f 0804 	mov.w	r8, #4
	uint8_t	delta_pos = 160, number = 0;
 800cff4:	27a0      	movs	r7, #160	; 0xa0
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
		{
			dec *= 10;
 800cff6:	46cb      	mov	fp, r9
		if((Value/(dec)) >= 1.0)
 800cff8:	fbba f0f9 	udiv	r0, sl, r9
 800cffc:	f7f3 fa92 	bl	8000524 <__aeabi_ui2d>
 800d000:	2200      	movs	r2, #0
 800d002:	4b42      	ldr	r3, [pc, #264]	; (800d10c <GUI_Text_CCT_Measure+0x154>)
 800d004:	f7f3 fd8a 	bl	8000b1c <__aeabi_dcmpge>
 800d008:	b128      	cbz	r0, 800d016 <GUI_Text_CCT_Measure+0x5e>
			delta_pos-=23;
 800d00a:	3f17      	subs	r7, #23
			number++;
 800d00c:	3601      	adds	r6, #1
			dec *= 10;
 800d00e:	fb0b f909 	mul.w	r9, fp, r9
			delta_pos-=23;
 800d012:	b2ff      	uxtb	r7, r7
			number++;
 800d014:	b2f6      	uxtb	r6, r6
 800d016:	f108 38ff 	add.w	r8, r8, #4294967295
	for (uint8_t i = 1; i <= 4; i++)
 800d01a:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 800d01e:	d1eb      	bne.n	800cff8 <GUI_Text_CCT_Measure+0x40>
		}
	}
	
	if(number < old_numCCT )
 800d020:	4b3b      	ldr	r3, [pc, #236]	; (800d110 <GUI_Text_CCT_Measure+0x158>)
 800d022:	781a      	ldrb	r2, [r3, #0]
 800d024:	42b2      	cmp	r2, r6
 800d026:	4698      	mov	r8, r3
 800d028:	d90d      	bls.n	800d046 <GUI_Text_CCT_Measure+0x8e>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d02a:	2163      	movs	r1, #99	; 0x63
 800d02c:	f104 0319 	add.w	r3, r4, #25
 800d030:	f105 02c5 	add.w	r2, r5, #197	; 0xc5
 800d034:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800d038:	9100      	str	r1, [sp, #0]
 800d03a:	b29b      	uxth	r3, r3
 800d03c:	b292      	uxth	r2, r2
 800d03e:	4621      	mov	r1, r4
 800d040:	b280      	uxth	r0, r0
 800d042:	f003 fc7a 	bl	801093a <TFT_FillRectangle>
	} 
	old_numCCT = number;
 800d046:	f888 6000 	strb.w	r6, [r8]
	
	if(Value == 0){TFT_SetFont(&Font26EN_arch_big);  TFT_DrawChar(X+100, Y+4, 'N'-33);TFT_DrawChar(X+125, Y+4, 'A'-33);TFT_DrawChar(X+150, Y+4, 'N'-33);}else{
 800d04a:	f1ba 0f00 	cmp.w	sl, #0
 800d04e:	d143      	bne.n	800d0d8 <GUI_Text_CCT_Measure+0x120>
 800d050:	4830      	ldr	r0, [pc, #192]	; (800d114 <GUI_Text_CCT_Measure+0x15c>)
 800d052:	1d26      	adds	r6, r4, #4
 800d054:	f003 fe74 	bl	8010d40 <TFT_SetFont>
 800d058:	b2b6      	uxth	r6, r6
 800d05a:	f105 0064 	add.w	r0, r5, #100	; 0x64
 800d05e:	222d      	movs	r2, #45	; 0x2d
 800d060:	4631      	mov	r1, r6
 800d062:	b280      	uxth	r0, r0
 800d064:	f003 fee2 	bl	8010e2c <TFT_DrawChar>
 800d068:	f105 007d 	add.w	r0, r5, #125	; 0x7d
 800d06c:	2220      	movs	r2, #32
 800d06e:	4631      	mov	r1, r6
 800d070:	b280      	uxth	r0, r0
 800d072:	f003 fedb 	bl	8010e2c <TFT_DrawChar>
 800d076:	f105 0096 	add.w	r0, r5, #150	; 0x96
 800d07a:	222d      	movs	r2, #45	; 0x2d
 800d07c:	4631      	mov	r1, r6
 800d07e:	b280      	uxth	r0, r0
 800d080:	f003 fed4 	bl	8010e2c <TFT_DrawChar>
	TFT_DisplayString(X+delta_pos, Y+2, (uint8_t *)buffer, LEFT_MODE);}
	
	TFT_SetTextColor(TFT_White);
 800d084:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800d088:	f003 fe60 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d08c:	2063      	movs	r0, #99	; 0x63
 800d08e:	f003 fe63 	bl	8010d58 <TFT_SetBackColor>
	if(Language_status == Ru ){
 800d092:	4b21      	ldr	r3, [pc, #132]	; (800d118 <GUI_Text_CCT_Measure+0x160>)
 800d094:	781b      	ldrb	r3, [r3, #0]
 800d096:	f105 06c8 	add.w	r6, r5, #200	; 0xc8
 800d09a:	bb33      	cbnz	r3, 800d0ea <GUI_Text_CCT_Measure+0x132>
			TFT_SetFont(&Font26RU_arch_big);
 800d09c:	481f      	ldr	r0, [pc, #124]	; (800d11c <GUI_Text_CCT_Measure+0x164>)
 800d09e:	f003 fe4f 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X, Y, ''-17);
 800d0a2:	2289      	movs	r2, #137	; 0x89
 800d0a4:	4621      	mov	r1, r4
 800d0a6:	4628      	mov	r0, r5
 800d0a8:	f003 fe5c 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+24, Y, ''-17);
 800d0ac:	f105 0018 	add.w	r0, r5, #24
 800d0b0:	2295      	movs	r2, #149	; 0x95
 800d0b2:	4621      	mov	r1, r4
 800d0b4:	b280      	uxth	r0, r0
 800d0b6:	f003 fe55 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+45, Y, ''-17);
 800d0ba:	f105 002d 	add.w	r0, r5, #45	; 0x2d
 800d0be:	2291      	movs	r2, #145	; 0x91
 800d0c0:	4621      	mov	r1, r4
 800d0c2:	b280      	uxth	r0, r0
 800d0c4:	f003 fe4e 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+200, Y, ''-17);
 800d0c8:	2289      	movs	r2, #137	; 0x89
 800d0ca:	4621      	mov	r1, r4
 800d0cc:	b2b0      	uxth	r0, r6
 800d0ce:	f003 fe49 	bl	8010d64 <TFT_DrawCharRus>
		{
			GUI_TextEn_CCT(X, Y+4);

			TFT_DrawChar(X+200, Y+4, 'K'-33);
		}	
}
 800d0d2:	b007      	add	sp, #28
 800d0d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	TFT_DisplayString(X+delta_pos, Y+2, (uint8_t *)buffer, LEFT_MODE);}
 800d0d8:	1ca1      	adds	r1, r4, #2
 800d0da:	19e8      	adds	r0, r5, r7
 800d0dc:	2303      	movs	r3, #3
 800d0de:	aa03      	add	r2, sp, #12
 800d0e0:	b289      	uxth	r1, r1
 800d0e2:	b280      	uxth	r0, r0
 800d0e4:	f003 fefa 	bl	8010edc <TFT_DisplayString>
 800d0e8:	e7cc      	b.n	800d084 <GUI_Text_CCT_Measure+0xcc>
			GUI_TextEn_CCT(X, Y+4);
 800d0ea:	3404      	adds	r4, #4
 800d0ec:	b2a4      	uxth	r4, r4
 800d0ee:	4621      	mov	r1, r4
 800d0f0:	4628      	mov	r0, r5
 800d0f2:	f001 fea3 	bl	800ee3c <GUI_TextEn_CCT>
			TFT_DrawChar(X+200, Y+4, 'K'-33);
 800d0f6:	222a      	movs	r2, #42	; 0x2a
 800d0f8:	4621      	mov	r1, r4
 800d0fa:	b2b0      	uxth	r0, r6
 800d0fc:	f003 fe96 	bl	8010e2c <TFT_DrawChar>
}
 800d100:	e7e7      	b.n	800d0d2 <GUI_Text_CCT_Measure+0x11a>
 800d102:	bf00      	nop
 800d104:	20000138 	.word	0x20000138
 800d108:	0801f55d 	.word	0x0801f55d
 800d10c:	3ff00000 	.word	0x3ff00000
 800d110:	2000017c 	.word	0x2000017c
 800d114:	20000130 	.word	0x20000130
 800d118:	200002bb 	.word	0x200002bb
 800d11c:	20000148 	.word	0x20000148

0800d120 <GUI_Text_lambdaD_Measure>:
uint8_t old_lambdaD = 10;
void GUI_Text_lambdaD_Measure(uint16_t X, uint16_t Y, float Value)
{	
 800d120:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d124:	ed2d 8b02 	vpush	{d8}
 800d128:	b086      	sub	sp, #24

	char buffer[9] = {0};
 800d12a:	2400      	movs	r4, #0
{	
 800d12c:	4605      	mov	r5, r0
	uint8_t	delta_pos = 122, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d12e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	
 800d132:	eeb0 8a40 	vmov.f32	s16, s0
 800d136:	460f      	mov	r7, r1
	char buffer[9] = {0};
 800d138:	9403      	str	r4, [sp, #12]
 800d13a:	9404      	str	r4, [sp, #16]
 800d13c:	f88d 4014 	strb.w	r4, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d140:	f003 fe04 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d144:	2063      	movs	r0, #99	; 0x63
 800d146:	f003 fe07 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d14a:	483b      	ldr	r0, [pc, #236]	; (800d238 <GUI_Text_lambdaD_Measure+0x118>)
 800d14c:	f003 fdf8 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.1f", Value);
 800d150:	ee18 0a10 	vmov	r0, s16
 800d154:	f7f3 fa08 	bl	8000568 <__aeabi_f2d>
 800d158:	4602      	mov	r2, r0
 800d15a:	460b      	mov	r3, r1
 800d15c:	a803      	add	r0, sp, #12
 800d15e:	4937      	ldr	r1, [pc, #220]	; (800d23c <GUI_Text_lambdaD_Measure+0x11c>)
 800d160:	f005 f914 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d164:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", Value);
 800d166:	2304      	movs	r3, #4
	uint8_t	delta_pos = 122, number = 0;
 800d168:	267a      	movs	r6, #122	; 0x7a

		for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800d16a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800d16e:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800d170:	ee07 2a10 	vmov	s14, r2
 800d174:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d178:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800d17c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d180:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d184:	db04      	blt.n	800d190 <GUI_Text_lambdaD_Measure+0x70>
			delta_pos-=23;
 800d186:	3e17      	subs	r6, #23
			number++;
 800d188:	3401      	adds	r4, #1
			dec *= 10;
 800d18a:	434a      	muls	r2, r1
			delta_pos-=23;
 800d18c:	b2f6      	uxtb	r6, r6
			number++;
 800d18e:	b2e4      	uxtb	r4, r4
 800d190:	3b01      	subs	r3, #1
		for (uint8_t i = 1; i <= 4; i++)
 800d192:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d196:	d1eb      	bne.n	800d170 <GUI_Text_lambdaD_Measure+0x50>
		}
	}
	
	if(number < old_lambdaD )
 800d198:	4b29      	ldr	r3, [pc, #164]	; (800d240 <GUI_Text_lambdaD_Measure+0x120>)
 800d19a:	781a      	ldrb	r2, [r3, #0]
 800d19c:	42a2      	cmp	r2, r4
 800d19e:	4698      	mov	r8, r3
 800d1a0:	d90d      	bls.n	800d1be <GUI_Text_lambdaD_Measure+0x9e>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d1a2:	2163      	movs	r1, #99	; 0x63
 800d1a4:	f107 0319 	add.w	r3, r7, #25
 800d1a8:	f105 02c5 	add.w	r2, r5, #197	; 0xc5
 800d1ac:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800d1b0:	9100      	str	r1, [sp, #0]
 800d1b2:	b29b      	uxth	r3, r3
 800d1b4:	b292      	uxth	r2, r2
 800d1b6:	4639      	mov	r1, r7
 800d1b8:	b280      	uxth	r0, r0
 800d1ba:	f003 fbbe 	bl	801093a <TFT_FillRectangle>
	} 
	old_lambdaD = number;
	
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d1be:	19a8      	adds	r0, r5, r6
 800d1c0:	2303      	movs	r3, #3
 800d1c2:	aa03      	add	r2, sp, #12
 800d1c4:	4639      	mov	r1, r7
 800d1c6:	b280      	uxth	r0, r0
	old_lambdaD = number;
 800d1c8:	f888 4000 	strb.w	r4, [r8]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d1cc:	f003 fe86 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	GUI_Text_lambda_d(X, Y+5);
 800d1d0:	1d7c      	adds	r4, r7, #5
	TFT_SetTextColor(TFT_White);
 800d1d2:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800d1d6:	f003 fdb9 	bl	8010d4c <TFT_SetTextColor>
	GUI_Text_lambda_d(X, Y+5);
 800d1da:	b2a4      	uxth	r4, r4
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d1dc:	2063      	movs	r0, #99	; 0x63
 800d1de:	f003 fdbb 	bl	8010d58 <TFT_SetBackColor>
	GUI_Text_lambda_d(X, Y+5);
 800d1e2:	4628      	mov	r0, r5
 800d1e4:	4621      	mov	r1, r4
 800d1e6:	f001 f907 	bl	800e3f8 <GUI_Text_lambda_d>
	if(Language_status == Ru ){
 800d1ea:	4b16      	ldr	r3, [pc, #88]	; (800d244 <GUI_Text_lambdaD_Measure+0x124>)
 800d1ec:	781b      	ldrb	r3, [r3, #0]
 800d1ee:	f105 06c8 	add.w	r6, r5, #200	; 0xc8
 800d1f2:	35d8      	adds	r5, #216	; 0xd8
 800d1f4:	b98b      	cbnz	r3, 800d21a <GUI_Text_lambdaD_Measure+0xfa>
			TFT_SetFont(&Font26RU_arch_small);
 800d1f6:	4814      	ldr	r0, [pc, #80]	; (800d248 <GUI_Text_lambdaD_Measure+0x128>)
 800d1f8:	f003 fda2 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X+200, Y+5, '');
 800d1fc:	22bd      	movs	r2, #189	; 0xbd
 800d1fe:	4621      	mov	r1, r4
 800d200:	b2b0      	uxth	r0, r6
 800d202:	f003 fdaf 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+216, Y+5, '');
 800d206:	22bc      	movs	r2, #188	; 0xbc
 800d208:	4621      	mov	r1, r4
 800d20a:	b2a8      	uxth	r0, r5
 800d20c:	f003 fdaa 	bl	8010d64 <TFT_DrawCharRus>
			TFT_SetFont(&Font16EN_arch_small);
			TFT_DrawChar(X+200, Y, 'n');
			TFT_DrawChar(X+216, Y, 'm');
		}	

}
 800d210:	b006      	add	sp, #24
 800d212:	ecbd 8b02 	vpop	{d8}
 800d216:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			TFT_SetFont(&Font16EN_arch_small);
 800d21a:	480c      	ldr	r0, [pc, #48]	; (800d24c <GUI_Text_lambdaD_Measure+0x12c>)
 800d21c:	f003 fd90 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X+200, Y, 'n');
 800d220:	4639      	mov	r1, r7
 800d222:	b2b0      	uxth	r0, r6
 800d224:	226e      	movs	r2, #110	; 0x6e
 800d226:	f003 fe01 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+216, Y, 'm');
 800d22a:	226d      	movs	r2, #109	; 0x6d
 800d22c:	4639      	mov	r1, r7
 800d22e:	b2a8      	uxth	r0, r5
 800d230:	f003 fdfc 	bl	8010e2c <TFT_DrawChar>
}
 800d234:	e7ec      	b.n	800d210 <GUI_Text_lambdaD_Measure+0xf0>
 800d236:	bf00      	nop
 800d238:	20000138 	.word	0x20000138
 800d23c:	0801f558 	.word	0x0801f558
 800d240:	20000179 	.word	0x20000179
 800d244:	200002bb 	.word	0x200002bb
 800d248:	20000150 	.word	0x20000150
 800d24c:	20000108 	.word	0x20000108

0800d250 <GUI_Text_lambdaC_Measure>:
uint8_t old_lambdaC = 10;
void GUI_Text_lambdaC_Measure(uint16_t X, uint16_t Y, float Value)
{	
 800d250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d254:	ed2d 8b02 	vpush	{d8}
 800d258:	b086      	sub	sp, #24

	char buffer[9] = {0};
 800d25a:	2400      	movs	r4, #0
{	
 800d25c:	4605      	mov	r5, r0
	uint8_t	delta_pos = 122, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d25e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	
 800d262:	eeb0 8a40 	vmov.f32	s16, s0
 800d266:	460f      	mov	r7, r1
	char buffer[9] = {0};
 800d268:	9403      	str	r4, [sp, #12]
 800d26a:	9404      	str	r4, [sp, #16]
 800d26c:	f88d 4014 	strb.w	r4, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d270:	f003 fd6c 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d274:	2063      	movs	r0, #99	; 0x63
 800d276:	f003 fd6f 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d27a:	483b      	ldr	r0, [pc, #236]	; (800d368 <GUI_Text_lambdaC_Measure+0x118>)
 800d27c:	f003 fd60 	bl	8010d40 <TFT_SetFont>
	
	sprintf (buffer, "%.1f", Value);
 800d280:	ee18 0a10 	vmov	r0, s16
 800d284:	f7f3 f970 	bl	8000568 <__aeabi_f2d>
 800d288:	4602      	mov	r2, r0
 800d28a:	460b      	mov	r3, r1
 800d28c:	a803      	add	r0, sp, #12
 800d28e:	4937      	ldr	r1, [pc, #220]	; (800d36c <GUI_Text_lambdaC_Measure+0x11c>)
 800d290:	f005 f87c 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d294:	220a      	movs	r2, #10
	sprintf (buffer, "%.1f", Value);
 800d296:	2304      	movs	r3, #4
	uint8_t	delta_pos = 122, number = 0;
 800d298:	267a      	movs	r6, #122	; 0x7a
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800d29a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800d29e:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800d2a0:	ee07 2a10 	vmov	s14, r2
 800d2a4:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d2a8:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800d2ac:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d2b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d2b4:	db04      	blt.n	800d2c0 <GUI_Text_lambdaC_Measure+0x70>
			delta_pos-=23;
 800d2b6:	3e17      	subs	r6, #23
			number++;
 800d2b8:	3401      	adds	r4, #1
			dec *= 10;
 800d2ba:	434a      	muls	r2, r1
			delta_pos-=23;
 800d2bc:	b2f6      	uxtb	r6, r6
			number++;
 800d2be:	b2e4      	uxtb	r4, r4
 800d2c0:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d2c2:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d2c6:	d1eb      	bne.n	800d2a0 <GUI_Text_lambdaC_Measure+0x50>
		}
	}
	
	if(number < old_lambdaC )
 800d2c8:	4b29      	ldr	r3, [pc, #164]	; (800d370 <GUI_Text_lambdaC_Measure+0x120>)
 800d2ca:	781a      	ldrb	r2, [r3, #0]
 800d2cc:	42a2      	cmp	r2, r4
 800d2ce:	4698      	mov	r8, r3
 800d2d0:	d90d      	bls.n	800d2ee <GUI_Text_lambdaC_Measure+0x9e>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d2d2:	2163      	movs	r1, #99	; 0x63
 800d2d4:	f107 0319 	add.w	r3, r7, #25
 800d2d8:	f105 02c5 	add.w	r2, r5, #197	; 0xc5
 800d2dc:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800d2e0:	9100      	str	r1, [sp, #0]
 800d2e2:	b29b      	uxth	r3, r3
 800d2e4:	b292      	uxth	r2, r2
 800d2e6:	4639      	mov	r1, r7
 800d2e8:	b280      	uxth	r0, r0
 800d2ea:	f003 fb26 	bl	801093a <TFT_FillRectangle>
	} 
	old_lambdaC = number;

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d2ee:	19a8      	adds	r0, r5, r6
 800d2f0:	2303      	movs	r3, #3
 800d2f2:	aa03      	add	r2, sp, #12
 800d2f4:	4639      	mov	r1, r7
 800d2f6:	b280      	uxth	r0, r0
	old_lambdaC = number;
 800d2f8:	f888 4000 	strb.w	r4, [r8]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d2fc:	f003 fdee 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	GUI_Text_lambda_c(X, Y+5);
 800d300:	1d7c      	adds	r4, r7, #5
	TFT_SetTextColor(TFT_White);
 800d302:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800d306:	f003 fd21 	bl	8010d4c <TFT_SetTextColor>
	GUI_Text_lambda_c(X, Y+5);
 800d30a:	b2a4      	uxth	r4, r4
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d30c:	2063      	movs	r0, #99	; 0x63
 800d30e:	f003 fd23 	bl	8010d58 <TFT_SetBackColor>
	GUI_Text_lambda_c(X, Y+5);
 800d312:	4628      	mov	r0, r5
 800d314:	4621      	mov	r1, r4
 800d316:	f001 f893 	bl	800e440 <GUI_Text_lambda_c>
	if(Language_status == Ru ){
 800d31a:	4b16      	ldr	r3, [pc, #88]	; (800d374 <GUI_Text_lambdaC_Measure+0x124>)
 800d31c:	781b      	ldrb	r3, [r3, #0]
 800d31e:	f105 06c8 	add.w	r6, r5, #200	; 0xc8
 800d322:	35d8      	adds	r5, #216	; 0xd8
 800d324:	b98b      	cbnz	r3, 800d34a <GUI_Text_lambdaC_Measure+0xfa>
			TFT_SetFont(&Font26RU_arch_small);
 800d326:	4814      	ldr	r0, [pc, #80]	; (800d378 <GUI_Text_lambdaC_Measure+0x128>)
 800d328:	f003 fd0a 	bl	8010d40 <TFT_SetFont>
			TFT_DrawCharRus(X+200, Y+5, '');
 800d32c:	22bd      	movs	r2, #189	; 0xbd
 800d32e:	4621      	mov	r1, r4
 800d330:	b2b0      	uxth	r0, r6
 800d332:	f003 fd17 	bl	8010d64 <TFT_DrawCharRus>
			TFT_DrawCharRus(X+216, Y+5, '');
 800d336:	22bc      	movs	r2, #188	; 0xbc
 800d338:	4621      	mov	r1, r4
 800d33a:	b2a8      	uxth	r0, r5
 800d33c:	f003 fd12 	bl	8010d64 <TFT_DrawCharRus>
			TFT_SetFont(&Font16EN_arch_small);
			TFT_DrawChar(X+200, Y, 'n');
			TFT_DrawChar(X+216, Y, 'm');
		}	

}
 800d340:	b006      	add	sp, #24
 800d342:	ecbd 8b02 	vpop	{d8}
 800d346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			TFT_SetFont(&Font16EN_arch_small);
 800d34a:	480c      	ldr	r0, [pc, #48]	; (800d37c <GUI_Text_lambdaC_Measure+0x12c>)
 800d34c:	f003 fcf8 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X+200, Y, 'n');
 800d350:	4639      	mov	r1, r7
 800d352:	b2b0      	uxth	r0, r6
 800d354:	226e      	movs	r2, #110	; 0x6e
 800d356:	f003 fd69 	bl	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X+216, Y, 'm');
 800d35a:	226d      	movs	r2, #109	; 0x6d
 800d35c:	4639      	mov	r1, r7
 800d35e:	b2a8      	uxth	r0, r5
 800d360:	f003 fd64 	bl	8010e2c <TFT_DrawChar>
}
 800d364:	e7ec      	b.n	800d340 <GUI_Text_lambdaC_Measure+0xf0>
 800d366:	bf00      	nop
 800d368:	20000138 	.word	0x20000138
 800d36c:	0801f558 	.word	0x0801f558
 800d370:	20000178 	.word	0x20000178
 800d374:	200002bb 	.word	0x200002bb
 800d378:	20000150 	.word	0x20000150
 800d37c:	20000108 	.word	0x20000108

0800d380 <GUI_Text_deltaE_Measure>:


uint8_t old_deltaE = 10;
void GUI_Text_deltaE_Measure(uint16_t X, uint16_t Y, float Value)
{	
 800d380:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d384:	ed2d 8b02 	vpush	{d8}
 800d388:	b087      	sub	sp, #28

	char buffer[9] = {0};
 800d38a:	2700      	movs	r7, #0
{	
 800d38c:	4604      	mov	r4, r0
	uint8_t	delta_pos = 140, sign = 0, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d38e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	
 800d392:	eeb0 8a40 	vmov.f32	s16, s0
 800d396:	460d      	mov	r5, r1
	char buffer[9] = {0};
 800d398:	9703      	str	r7, [sp, #12]
 800d39a:	9704      	str	r7, [sp, #16]
 800d39c:	f88d 7014 	strb.w	r7, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d3a0:	f003 fcd4 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d3a4:	2063      	movs	r0, #99	; 0x63
 800d3a6:	f003 fcd7 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d3aa:	483c      	ldr	r0, [pc, #240]	; (800d49c <GUI_Text_deltaE_Measure+0x11c>)
 800d3ac:	f003 fcc8 	bl	8010d40 <TFT_SetFont>
	
	if(Value < 0){Value *= -1; sign = 1;}
 800d3b0:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800d3b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d3b8:	bf48      	it	mi
 800d3ba:	eeb1 8a48 	vnegmi.f32	s16, s16
	
	sprintf (buffer, "%.2f", Value);
 800d3be:	ee18 0a10 	vmov	r0, s16
	if(Value < 0){Value *= -1; sign = 1;}
 800d3c2:	bf48      	it	mi
 800d3c4:	2701      	movmi	r7, #1
	sprintf (buffer, "%.2f", Value);
 800d3c6:	f7f3 f8cf 	bl	8000568 <__aeabi_f2d>
 800d3ca:	4602      	mov	r2, r0
 800d3cc:	460b      	mov	r3, r1
 800d3ce:	a803      	add	r0, sp, #12
 800d3d0:	4933      	ldr	r1, [pc, #204]	; (800d4a0 <GUI_Text_deltaE_Measure+0x120>)
 800d3d2:	f004 ffdb 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d3d6:	220a      	movs	r2, #10
	sprintf (buffer, "%.2f", Value);
 800d3d8:	2304      	movs	r3, #4
	uint8_t	delta_pos = 140, sign = 0, number = 0;
 800d3da:	f04f 0800 	mov.w	r8, #0
 800d3de:	268c      	movs	r6, #140	; 0x8c
	
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800d3e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800d3e4:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800d3e6:	ee07 2a10 	vmov	s14, r2
 800d3ea:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d3ee:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800d3f2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d3f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d3fa:	db06      	blt.n	800d40a <GUI_Text_deltaE_Measure+0x8a>
			delta_pos-=23;
 800d3fc:	3e17      	subs	r6, #23
			number++;
 800d3fe:	f108 0801 	add.w	r8, r8, #1
			dec *= 10;
 800d402:	434a      	muls	r2, r1
			delta_pos-=23;
 800d404:	b2f6      	uxtb	r6, r6
			number++;
 800d406:	fa5f f888 	uxtb.w	r8, r8
 800d40a:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d40c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d410:	d1e9      	bne.n	800d3e6 <GUI_Text_deltaE_Measure+0x66>
		}
	}
	
	if(number < old_deltaE )
 800d412:	4b24      	ldr	r3, [pc, #144]	; (800d4a4 <GUI_Text_deltaE_Measure+0x124>)
 800d414:	781a      	ldrb	r2, [r3, #0]
 800d416:	4542      	cmp	r2, r8
 800d418:	4699      	mov	r9, r3
 800d41a:	d90d      	bls.n	800d438 <GUI_Text_deltaE_Measure+0xb8>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d41c:	2163      	movs	r1, #99	; 0x63
 800d41e:	f105 0319 	add.w	r3, r5, #25
 800d422:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800d426:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800d42a:	9100      	str	r1, [sp, #0]
 800d42c:	b29b      	uxth	r3, r3
 800d42e:	b292      	uxth	r2, r2
 800d430:	4629      	mov	r1, r5
 800d432:	b280      	uxth	r0, r0
 800d434:	f003 fa81 	bl	801093a <TFT_FillRectangle>
	} 
	old_deltaE = number;
 800d438:	f889 8000 	strb.w	r8, [r9]
	
	if(sign){TFT_DrawChar(X+delta_pos-18, Y, '-');}
 800d43c:	b13f      	cbz	r7, 800d44e <GUI_Text_deltaE_Measure+0xce>
 800d43e:	f1a4 0012 	sub.w	r0, r4, #18
 800d442:	4430      	add	r0, r6
 800d444:	222d      	movs	r2, #45	; 0x2d
 800d446:	4629      	mov	r1, r5
 800d448:	b280      	uxth	r0, r0
 800d44a:	f003 fcef 	bl	8010e2c <TFT_DrawChar>

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d44e:	19a0      	adds	r0, r4, r6
 800d450:	2303      	movs	r3, #3
 800d452:	aa03      	add	r2, sp, #12
 800d454:	4629      	mov	r1, r5
 800d456:	b280      	uxth	r0, r0
 800d458:	f003 fd40 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetTextColor(TFT_White);
 800d45c:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800d460:	f003 fc74 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d464:	2063      	movs	r0, #99	; 0x63
 800d466:	f003 fc77 	bl	8010d58 <TFT_SetBackColor>

	TFT_SetFont(&Font16EN_arch_big);
 800d46a:	480f      	ldr	r0, [pc, #60]	; (800d4a8 <GUI_Text_deltaE_Measure+0x128>)
 800d46c:	f003 fc68 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+6, '~'+2);
 800d470:	1da9      	adds	r1, r5, #6
 800d472:	2280      	movs	r2, #128	; 0x80
 800d474:	b289      	uxth	r1, r1
 800d476:	4620      	mov	r0, r4
 800d478:	f003 fcd8 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font26EN_arch_big);
 800d47c:	480b      	ldr	r0, [pc, #44]	; (800d4ac <GUI_Text_deltaE_Measure+0x12c>)
 800d47e:	f003 fc5f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+18, Y+2, 'E'-33);
 800d482:	1ca9      	adds	r1, r5, #2
 800d484:	f104 0012 	add.w	r0, r4, #18
 800d488:	2224      	movs	r2, #36	; 0x24
 800d48a:	b289      	uxth	r1, r1
 800d48c:	b280      	uxth	r0, r0
 800d48e:	f003 fccd 	bl	8010e2c <TFT_DrawChar>

}
 800d492:	b007      	add	sp, #28
 800d494:	ecbd 8b02 	vpop	{d8}
 800d498:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d49c:	20000138 	.word	0x20000138
 800d4a0:	0801f553 	.word	0x0801f553
 800d4a4:	20000177 	.word	0x20000177
 800d4a8:	200000f8 	.word	0x200000f8
 800d4ac:	20000130 	.word	0x20000130

0800d4b0 <GUI_Text_EbEr_Measure>:
uint8_t old_num_EB = 10, old_num_ER = 10;
void GUI_Text_EbEr_Measure(uint16_t X, uint16_t Y, float ValueEB, float ValueER)
{
 800d4b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d4b4:	ed2d 8b04 	vpush	{d8-d9}
 800d4b8:	b087      	sub	sp, #28
	char buffer[9] = {0};
 800d4ba:	2600      	movs	r6, #0
{
 800d4bc:	4607      	mov	r7, r0
	uint8_t	delta_pos = 150, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d4be:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800d4c2:	eef0 8a40 	vmov.f32	s17, s0
 800d4c6:	eeb0 8a60 	vmov.f32	s16, s1
 800d4ca:	460c      	mov	r4, r1
	char buffer[9] = {0};
 800d4cc:	9603      	str	r6, [sp, #12]
 800d4ce:	9604      	str	r6, [sp, #16]
 800d4d0:	f88d 6014 	strb.w	r6, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d4d4:	f003 fc3a 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d4d8:	2063      	movs	r0, #99	; 0x63
 800d4da:	f003 fc3d 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d4de:	485a      	ldr	r0, [pc, #360]	; (800d648 <GUI_Text_EbEr_Measure+0x198>)
 800d4e0:	f003 fc2e 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.2f", ValueEB);
 800d4e4:	ee18 0a90 	vmov	r0, s17
 800d4e8:	f7f3 f83e 	bl	8000568 <__aeabi_f2d>
 800d4ec:	4602      	mov	r2, r0
 800d4ee:	460b      	mov	r3, r1
 800d4f0:	a803      	add	r0, sp, #12
 800d4f2:	4956      	ldr	r1, [pc, #344]	; (800d64c <GUI_Text_EbEr_Measure+0x19c>)
 800d4f4:	f004 ff4a 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d4f8:	f04f 080a 	mov.w	r8, #10
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueEB/(dec)) >= 1.0)
 800d4fc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	sprintf (buffer, "%.2f", ValueEB);
 800d500:	2304      	movs	r3, #4
	uint8_t	delta_pos = 150, number = 0;
 800d502:	2596      	movs	r5, #150	; 0x96
 800d504:	eeb0 9a67 	vmov.f32	s18, s15
		{
			dec *= 10;
 800d508:	4642      	mov	r2, r8
		if((ValueEB/(dec)) >= 1.0)
 800d50a:	ee07 8a10 	vmov	s14, r8
 800d50e:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d512:	ee88 7aa6 	vdiv.f32	s14, s17, s13
 800d516:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d51a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d51e:	db05      	blt.n	800d52c <GUI_Text_EbEr_Measure+0x7c>
			delta_pos-=23;
 800d520:	3d17      	subs	r5, #23
			number++;
 800d522:	3601      	adds	r6, #1
			dec *= 10;
 800d524:	fb02 f808 	mul.w	r8, r2, r8
			delta_pos-=23;
 800d528:	b2ed      	uxtb	r5, r5
			number++;
 800d52a:	b2f6      	uxtb	r6, r6
 800d52c:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d52e:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d532:	d1ea      	bne.n	800d50a <GUI_Text_EbEr_Measure+0x5a>
		}
	}
	
	if(number < old_num_EB )
 800d534:	4b46      	ldr	r3, [pc, #280]	; (800d650 <GUI_Text_EbEr_Measure+0x1a0>)
 800d536:	781a      	ldrb	r2, [r3, #0]
 800d538:	42b2      	cmp	r2, r6
 800d53a:	4699      	mov	r9, r3
 800d53c:	d90d      	bls.n	800d55a <GUI_Text_EbEr_Measure+0xaa>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d53e:	2163      	movs	r1, #99	; 0x63
 800d540:	f104 0319 	add.w	r3, r4, #25
 800d544:	f107 02c5 	add.w	r2, r7, #197	; 0xc5
 800d548:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d54c:	9100      	str	r1, [sp, #0]
 800d54e:	b29b      	uxth	r3, r3
 800d550:	b292      	uxth	r2, r2
 800d552:	4621      	mov	r1, r4
 800d554:	b280      	uxth	r0, r0
 800d556:	f003 f9f0 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_EB = number;
	number = 0;

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d55a:	1978      	adds	r0, r7, r5
 800d55c:	2303      	movs	r3, #3
 800d55e:	aa03      	add	r2, sp, #12
 800d560:	4621      	mov	r1, r4
 800d562:	b280      	uxth	r0, r0
	old_num_EB = number;
 800d564:	f889 6000 	strb.w	r6, [r9]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d568:	f003 fcb8 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%.2f", ValueER);
 800d56c:	ee18 0a10 	vmov	r0, s16
 800d570:	f7f2 fffa 	bl	8000568 <__aeabi_f2d>
 800d574:	4602      	mov	r2, r0
 800d576:	460b      	mov	r3, r1
 800d578:	a803      	add	r0, sp, #12
 800d57a:	4934      	ldr	r1, [pc, #208]	; (800d64c <GUI_Text_EbEr_Measure+0x19c>)
 800d57c:	f004 ff06 	bl	801238c <siprintf>
	number = 0;
 800d580:	2600      	movs	r6, #0
	sprintf (buffer, "%.2f", ValueER);
 800d582:	2304      	movs	r3, #4
		for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueER/(dec)) >= 1.0)
		{
			dec *= 10;
 800d584:	220a      	movs	r2, #10
		if((ValueER/(dec)) >= 1.0)
 800d586:	ee07 8a90 	vmov	s15, r8
 800d58a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800d58e:	eec8 7a07 	vdiv.f32	s15, s16, s14
 800d592:	eef4 7ac9 	vcmpe.f32	s15, s18
 800d596:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d59a:	db05      	blt.n	800d5a8 <GUI_Text_EbEr_Measure+0xf8>
			delta_pos-=23;
 800d59c:	3d17      	subs	r5, #23
			number++;
 800d59e:	3601      	adds	r6, #1
			dec *= 10;
 800d5a0:	fb02 f808 	mul.w	r8, r2, r8
			delta_pos-=23;
 800d5a4:	b2ed      	uxtb	r5, r5
			number++;
 800d5a6:	b2f6      	uxtb	r6, r6
 800d5a8:	3b01      	subs	r3, #1
		for (uint8_t i = 1; i <= 4; i++)
 800d5aa:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d5ae:	d1ea      	bne.n	800d586 <GUI_Text_EbEr_Measure+0xd6>
		}
	}
	
	if(number < old_num_ER )
 800d5b0:	4b28      	ldr	r3, [pc, #160]	; (800d654 <GUI_Text_EbEr_Measure+0x1a4>)
 800d5b2:	781a      	ldrb	r2, [r3, #0]
 800d5b4:	42b2      	cmp	r2, r6
 800d5b6:	4698      	mov	r8, r3
 800d5b8:	d911      	bls.n	800d5de <GUI_Text_EbEr_Measure+0x12e>
	{
		TFT_FillRectangle(X+40, Y+33, X+197, Y+59, TFT_Black_Bkgr);
 800d5ba:	f104 033b 	add.w	r3, r4, #59	; 0x3b
 800d5be:	f107 02c5 	add.w	r2, r7, #197	; 0xc5
 800d5c2:	f104 0121 	add.w	r1, r4, #33	; 0x21
 800d5c6:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d5ca:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800d5ce:	f8cd e000 	str.w	lr, [sp]
 800d5d2:	b29b      	uxth	r3, r3
 800d5d4:	b292      	uxth	r2, r2
 800d5d6:	b289      	uxth	r1, r1
 800d5d8:	b280      	uxth	r0, r0
 800d5da:	f003 f9ae 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_ER = number;
	number = 0;

	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800d5de:	1978      	adds	r0, r7, r5
 800d5e0:	f104 0123 	add.w	r1, r4, #35	; 0x23
 800d5e4:	2303      	movs	r3, #3
 800d5e6:	aa03      	add	r2, sp, #12
 800d5e8:	b289      	uxth	r1, r1
 800d5ea:	b280      	uxth	r0, r0
	old_num_ER = number;
 800d5ec:	f888 6000 	strb.w	r6, [r8]
	
	TFT_SetFont(&Font16EN_arch_big);
	TFT_DrawChar(X+21, Y+12, 'B');
 800d5f0:	f107 0515 	add.w	r5, r7, #21
	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800d5f4:	f003 fc72 	bl	8010edc <TFT_DisplayString>
	TFT_SetFont(&Font16EN_arch_big);
 800d5f8:	4817      	ldr	r0, [pc, #92]	; (800d658 <GUI_Text_EbEr_Measure+0x1a8>)
 800d5fa:	f003 fba1 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+21, Y+12, 'B');
 800d5fe:	b2ad      	uxth	r5, r5
 800d600:	f104 010c 	add.w	r1, r4, #12
 800d604:	4628      	mov	r0, r5
 800d606:	2242      	movs	r2, #66	; 0x42
 800d608:	b289      	uxth	r1, r1
 800d60a:	f003 fc0f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+21, Y+47, 'R');
 800d60e:	f104 012f 	add.w	r1, r4, #47	; 0x2f
 800d612:	2252      	movs	r2, #82	; 0x52
 800d614:	b289      	uxth	r1, r1
 800d616:	4628      	mov	r0, r5
 800d618:	f003 fc08 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font26EN_arch_big);
 800d61c:	480f      	ldr	r0, [pc, #60]	; (800d65c <GUI_Text_EbEr_Measure+0x1ac>)
 800d61e:	f003 fb8f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+2, 'E'-33);
 800d622:	1ca1      	adds	r1, r4, #2
 800d624:	4638      	mov	r0, r7
 800d626:	2224      	movs	r2, #36	; 0x24
 800d628:	b289      	uxth	r1, r1
 800d62a:	f003 fbff 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y+37, 'E'-33);
 800d62e:	f104 0125 	add.w	r1, r4, #37	; 0x25
 800d632:	2224      	movs	r2, #36	; 0x24
 800d634:	b289      	uxth	r1, r1
 800d636:	4638      	mov	r0, r7
 800d638:	f003 fbf8 	bl	8010e2c <TFT_DrawChar>
}
 800d63c:	b007      	add	sp, #28
 800d63e:	ecbd 8b04 	vpop	{d8-d9}
 800d642:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d646:	bf00      	nop
 800d648:	20000138 	.word	0x20000138
 800d64c:	0801f553 	.word	0x0801f553
 800d650:	20000189 	.word	0x20000189
 800d654:	2000018a 	.word	0x2000018a
 800d658:	200000f8 	.word	0x200000f8
 800d65c:	20000130 	.word	0x20000130

0800d660 <GUI_Text_LbLr_Measure>:
uint8_t old_num_LB = 10, old_num_LR = 10;
void GUI_Text_LbLr_Measure(uint16_t X, uint16_t Y, float ValueLB, float ValueLR)
{
 800d660:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d664:	ed2d 8b04 	vpush	{d8-d9}
 800d668:	b087      	sub	sp, #28
	char buffer[9] = {0};
 800d66a:	2600      	movs	r6, #0
{
 800d66c:	4607      	mov	r7, r0
	uint8_t	delta_pos = 150, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d66e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800d672:	eef0 8a40 	vmov.f32	s17, s0
 800d676:	eeb0 8a60 	vmov.f32	s16, s1
 800d67a:	460c      	mov	r4, r1
	char buffer[9] = {0};
 800d67c:	9603      	str	r6, [sp, #12]
 800d67e:	9604      	str	r6, [sp, #16]
 800d680:	f88d 6014 	strb.w	r6, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d684:	f003 fb62 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d688:	2063      	movs	r0, #99	; 0x63
 800d68a:	f003 fb65 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d68e:	485b      	ldr	r0, [pc, #364]	; (800d7fc <GUI_Text_LbLr_Measure+0x19c>)
 800d690:	f003 fb56 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.2f", ValueLB);
 800d694:	ee18 0a90 	vmov	r0, s17
 800d698:	f7f2 ff66 	bl	8000568 <__aeabi_f2d>
 800d69c:	4602      	mov	r2, r0
 800d69e:	460b      	mov	r3, r1
 800d6a0:	a803      	add	r0, sp, #12
 800d6a2:	4957      	ldr	r1, [pc, #348]	; (800d800 <GUI_Text_LbLr_Measure+0x1a0>)
 800d6a4:	f004 fe72 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d6a8:	f04f 080a 	mov.w	r8, #10
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueLB/(dec)) >= 1.0)
 800d6ac:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	sprintf (buffer, "%.2f", ValueLB);
 800d6b0:	2304      	movs	r3, #4
	uint8_t	delta_pos = 150, number = 0;
 800d6b2:	2596      	movs	r5, #150	; 0x96
 800d6b4:	eeb0 9a67 	vmov.f32	s18, s15
		{
			dec *= 10;
 800d6b8:	4642      	mov	r2, r8
		if((ValueLB/(dec)) >= 1.0)
 800d6ba:	ee07 8a10 	vmov	s14, r8
 800d6be:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d6c2:	ee88 7aa6 	vdiv.f32	s14, s17, s13
 800d6c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d6ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d6ce:	db05      	blt.n	800d6dc <GUI_Text_LbLr_Measure+0x7c>
			delta_pos-=23;
 800d6d0:	3d17      	subs	r5, #23
			number++;
 800d6d2:	3601      	adds	r6, #1
			dec *= 10;
 800d6d4:	fb02 f808 	mul.w	r8, r2, r8
			delta_pos-=23;
 800d6d8:	b2ed      	uxtb	r5, r5
			number++;
 800d6da:	b2f6      	uxtb	r6, r6
 800d6dc:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d6de:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d6e2:	d1ea      	bne.n	800d6ba <GUI_Text_LbLr_Measure+0x5a>
		}
	}
	
	if(number < old_num_LB )
 800d6e4:	4b47      	ldr	r3, [pc, #284]	; (800d804 <GUI_Text_LbLr_Measure+0x1a4>)
 800d6e6:	781a      	ldrb	r2, [r3, #0]
 800d6e8:	42b2      	cmp	r2, r6
 800d6ea:	4699      	mov	r9, r3
 800d6ec:	d90d      	bls.n	800d70a <GUI_Text_LbLr_Measure+0xaa>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d6ee:	2163      	movs	r1, #99	; 0x63
 800d6f0:	f104 0319 	add.w	r3, r4, #25
 800d6f4:	f107 02c5 	add.w	r2, r7, #197	; 0xc5
 800d6f8:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d6fc:	9100      	str	r1, [sp, #0]
 800d6fe:	b29b      	uxth	r3, r3
 800d700:	b292      	uxth	r2, r2
 800d702:	4621      	mov	r1, r4
 800d704:	b280      	uxth	r0, r0
 800d706:	f003 f918 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_LB = number;
	number = 0;

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d70a:	1978      	adds	r0, r7, r5
 800d70c:	2303      	movs	r3, #3
 800d70e:	aa03      	add	r2, sp, #12
 800d710:	4621      	mov	r1, r4
 800d712:	b280      	uxth	r0, r0
	old_num_LB = number;
 800d714:	f889 6000 	strb.w	r6, [r9]
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d718:	f003 fbe0 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%.2f", ValueLR);
 800d71c:	ee18 0a10 	vmov	r0, s16
 800d720:	f7f2 ff22 	bl	8000568 <__aeabi_f2d>
 800d724:	4602      	mov	r2, r0
 800d726:	460b      	mov	r3, r1
 800d728:	a803      	add	r0, sp, #12
 800d72a:	4935      	ldr	r1, [pc, #212]	; (800d800 <GUI_Text_LbLr_Measure+0x1a0>)
 800d72c:	f004 fe2e 	bl	801238c <siprintf>
	number = 0;
 800d730:	2600      	movs	r6, #0
	sprintf (buffer, "%.2f", ValueLR);
 800d732:	2304      	movs	r3, #4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueLR/(dec)) >= 1.0)
		{
			dec *= 10;
 800d734:	220a      	movs	r2, #10
		if((ValueLR/(dec)) >= 1.0)
 800d736:	ee07 8a90 	vmov	s15, r8
 800d73a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800d73e:	eec8 7a07 	vdiv.f32	s15, s16, s14
 800d742:	eef4 7ac9 	vcmpe.f32	s15, s18
 800d746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d74a:	db05      	blt.n	800d758 <GUI_Text_LbLr_Measure+0xf8>
			delta_pos-=23;
 800d74c:	3d17      	subs	r5, #23
			number++;
 800d74e:	3601      	adds	r6, #1
			dec *= 10;
 800d750:	fb02 f808 	mul.w	r8, r2, r8
			delta_pos-=23;
 800d754:	b2ed      	uxtb	r5, r5
			number++;
 800d756:	b2f6      	uxtb	r6, r6
 800d758:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d75a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d75e:	d1ea      	bne.n	800d736 <GUI_Text_LbLr_Measure+0xd6>
		}
	}
	
	if(number < old_num_LR )
 800d760:	4b29      	ldr	r3, [pc, #164]	; (800d808 <GUI_Text_LbLr_Measure+0x1a8>)
 800d762:	781a      	ldrb	r2, [r3, #0]
 800d764:	42b2      	cmp	r2, r6
 800d766:	4698      	mov	r8, r3
 800d768:	d911      	bls.n	800d78e <GUI_Text_LbLr_Measure+0x12e>
	{
		TFT_FillRectangle(X+40, Y+33, X+197, Y+59, TFT_Black_Bkgr);
 800d76a:	f104 033b 	add.w	r3, r4, #59	; 0x3b
 800d76e:	f107 02c5 	add.w	r2, r7, #197	; 0xc5
 800d772:	f104 0121 	add.w	r1, r4, #33	; 0x21
 800d776:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d77a:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800d77e:	f8cd e000 	str.w	lr, [sp]
 800d782:	b29b      	uxth	r3, r3
 800d784:	b292      	uxth	r2, r2
 800d786:	b289      	uxth	r1, r1
 800d788:	b280      	uxth	r0, r0
 800d78a:	f003 f8d6 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_LR = number;
	number = 0;

	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800d78e:	1978      	adds	r0, r7, r5
 800d790:	f104 0123 	add.w	r1, r4, #35	; 0x23
 800d794:	2303      	movs	r3, #3
 800d796:	aa03      	add	r2, sp, #12
 800d798:	b289      	uxth	r1, r1
 800d79a:	b280      	uxth	r0, r0
	old_num_LR = number;
 800d79c:	f888 6000 	strb.w	r6, [r8]
	TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800d7a0:	f003 fb9c 	bl	8010edc <TFT_DisplayString>
	
	TFT_SetFont(&Font26EN_arch_digit);
 800d7a4:	4815      	ldr	r0, [pc, #84]	; (800d7fc <GUI_Text_LbLr_Measure+0x19c>)
 800d7a6:	f003 facb 	bl	8010d40 <TFT_SetFont>

	
	TFT_SetFont(&Font16EN_arch_big);
	TFT_DrawChar(X+21, Y+12, 'B');
 800d7aa:	f107 0515 	add.w	r5, r7, #21
	TFT_SetFont(&Font16EN_arch_big);
 800d7ae:	4817      	ldr	r0, [pc, #92]	; (800d80c <GUI_Text_LbLr_Measure+0x1ac>)
 800d7b0:	f003 fac6 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+21, Y+12, 'B');
 800d7b4:	b2ad      	uxth	r5, r5
 800d7b6:	f104 010c 	add.w	r1, r4, #12
 800d7ba:	4628      	mov	r0, r5
 800d7bc:	2242      	movs	r2, #66	; 0x42
 800d7be:	b289      	uxth	r1, r1
 800d7c0:	f003 fb34 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+21, Y+47, 'R');
 800d7c4:	f104 012f 	add.w	r1, r4, #47	; 0x2f
 800d7c8:	2252      	movs	r2, #82	; 0x52
 800d7ca:	b289      	uxth	r1, r1
 800d7cc:	4628      	mov	r0, r5
 800d7ce:	f003 fb2d 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font26EN_arch_big);
 800d7d2:	480f      	ldr	r0, [pc, #60]	; (800d810 <GUI_Text_LbLr_Measure+0x1b0>)
 800d7d4:	f003 fab4 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+2, 'L'-33);
 800d7d8:	1ca1      	adds	r1, r4, #2
 800d7da:	4638      	mov	r0, r7
 800d7dc:	222b      	movs	r2, #43	; 0x2b
 800d7de:	b289      	uxth	r1, r1
 800d7e0:	f003 fb24 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y+37, 'L'-33);
 800d7e4:	f104 0125 	add.w	r1, r4, #37	; 0x25
 800d7e8:	222b      	movs	r2, #43	; 0x2b
 800d7ea:	b289      	uxth	r1, r1
 800d7ec:	4638      	mov	r0, r7
 800d7ee:	f003 fb1d 	bl	8010e2c <TFT_DrawChar>
}
 800d7f2:	b007      	add	sp, #28
 800d7f4:	ecbd 8b04 	vpop	{d8-d9}
 800d7f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d7fc:	20000138 	.word	0x20000138
 800d800:	0801f553 	.word	0x0801f553
 800d804:	2000018c 	.word	0x2000018c
 800d808:	2000018d 	.word	0x2000018d
 800d80c:	200000f8 	.word	0x200000f8
 800d810:	20000130 	.word	0x20000130

0800d814 <GUI_Text_S_P_Measure>:

uint8_t old_num_SP = 10;
void GUI_Text_S_P_Measure(uint16_t X, uint16_t Y, float Value)
{
 800d814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d818:	ed2d 8b02 	vpush	{d8}
 800d81c:	b086      	sub	sp, #24
	char buffer[9] = {0};
 800d81e:	2400      	movs	r4, #0
{
 800d820:	4606      	mov	r6, r0
	uint8_t	delta_pos = 100, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d822:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800d826:	eeb0 8a40 	vmov.f32	s16, s0
 800d82a:	460d      	mov	r5, r1
	char buffer[9] = {0};
 800d82c:	9403      	str	r4, [sp, #12]
 800d82e:	9404      	str	r4, [sp, #16]
 800d830:	f88d 4014 	strb.w	r4, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d834:	f003 fa8a 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d838:	2063      	movs	r0, #99	; 0x63
 800d83a:	f003 fa8d 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d83e:	4831      	ldr	r0, [pc, #196]	; (800d904 <GUI_Text_S_P_Measure+0xf0>)
 800d840:	f003 fa7e 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%.4f", Value);
 800d844:	ee18 0a10 	vmov	r0, s16
 800d848:	f7f2 fe8e 	bl	8000568 <__aeabi_f2d>
 800d84c:	4602      	mov	r2, r0
 800d84e:	460b      	mov	r3, r1
 800d850:	a803      	add	r0, sp, #12
 800d852:	492d      	ldr	r1, [pc, #180]	; (800d908 <GUI_Text_S_P_Measure+0xf4>)
 800d854:	f004 fd9a 	bl	801238c <siprintf>
	uint32_t dec = 10;
 800d858:	220a      	movs	r2, #10
	sprintf (buffer, "%.4f", Value);
 800d85a:	2304      	movs	r3, #4
	uint8_t	delta_pos = 100, number = 0;
 800d85c:	2764      	movs	r7, #100	; 0x64
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((Value/(dec)) >= 1.0)
 800d85e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		{
			dec *= 10;
 800d862:	4611      	mov	r1, r2
		if((Value/(dec)) >= 1.0)
 800d864:	ee07 2a10 	vmov	s14, r2
 800d868:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800d86c:	ee88 7a26 	vdiv.f32	s14, s16, s13
 800d870:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800d874:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d878:	db04      	blt.n	800d884 <GUI_Text_S_P_Measure+0x70>
			delta_pos-=23;
 800d87a:	3f17      	subs	r7, #23
			number++;
 800d87c:	3401      	adds	r4, #1
			dec *= 10;
 800d87e:	434a      	muls	r2, r1
			delta_pos-=23;
 800d880:	b2ff      	uxtb	r7, r7
			number++;
 800d882:	b2e4      	uxtb	r4, r4
 800d884:	3b01      	subs	r3, #1
	for (uint8_t i = 1; i <= 4; i++)
 800d886:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800d88a:	d1eb      	bne.n	800d864 <GUI_Text_S_P_Measure+0x50>
		}
	}
	
	if(number < old_num_SP )
 800d88c:	4b1f      	ldr	r3, [pc, #124]	; (800d90c <GUI_Text_S_P_Measure+0xf8>)
 800d88e:	781a      	ldrb	r2, [r3, #0]
 800d890:	42a2      	cmp	r2, r4
 800d892:	4698      	mov	r8, r3
 800d894:	d90d      	bls.n	800d8b2 <GUI_Text_S_P_Measure+0x9e>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d896:	2163      	movs	r1, #99	; 0x63
 800d898:	f105 0319 	add.w	r3, r5, #25
 800d89c:	f106 02c5 	add.w	r2, r6, #197	; 0xc5
 800d8a0:	f106 0028 	add.w	r0, r6, #40	; 0x28
 800d8a4:	9100      	str	r1, [sp, #0]
 800d8a6:	b29b      	uxth	r3, r3
 800d8a8:	b292      	uxth	r2, r2
 800d8aa:	4629      	mov	r1, r5
 800d8ac:	b280      	uxth	r0, r0
 800d8ae:	f003 f844 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_SP = number;

	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d8b2:	19f0      	adds	r0, r6, r7
 800d8b4:	2303      	movs	r3, #3
 800d8b6:	aa03      	add	r2, sp, #12
 800d8b8:	4629      	mov	r1, r5
 800d8ba:	b280      	uxth	r0, r0
	old_num_SP = number;
 800d8bc:	f888 4000 	strb.w	r4, [r8]
	
	TFT_SetFont(&Font26EN_arch_digit);
	TFT_DrawChar(X+22, Y+2, '/');
 800d8c0:	3502      	adds	r5, #2
	TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d8c2:	f003 fb0b 	bl	8010edc <TFT_DisplayString>
	TFT_SetFont(&Font26EN_arch_digit);
 800d8c6:	480f      	ldr	r0, [pc, #60]	; (800d904 <GUI_Text_S_P_Measure+0xf0>)
 800d8c8:	f003 fa3a 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+22, Y+2, '/');
 800d8cc:	b2ad      	uxth	r5, r5
 800d8ce:	f106 0016 	add.w	r0, r6, #22
 800d8d2:	4629      	mov	r1, r5
 800d8d4:	222f      	movs	r2, #47	; 0x2f
 800d8d6:	b280      	uxth	r0, r0
 800d8d8:	f003 faa8 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font26EN_arch_big);
 800d8dc:	480c      	ldr	r0, [pc, #48]	; (800d910 <GUI_Text_S_P_Measure+0xfc>)
 800d8de:	f003 fa2f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y+2, 'S'-33);
 800d8e2:	4629      	mov	r1, r5
 800d8e4:	4630      	mov	r0, r6
 800d8e6:	2232      	movs	r2, #50	; 0x32
 800d8e8:	f003 faa0 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+46, Y+2, 'P'-33);
 800d8ec:	f106 002e 	add.w	r0, r6, #46	; 0x2e
 800d8f0:	222f      	movs	r2, #47	; 0x2f
 800d8f2:	4629      	mov	r1, r5
 800d8f4:	b280      	uxth	r0, r0
 800d8f6:	f003 fa99 	bl	8010e2c <TFT_DrawChar>
}
 800d8fa:	b006      	add	sp, #24
 800d8fc:	ecbd 8b02 	vpop	{d8}
 800d900:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d904:	20000138 	.word	0x20000138
 800d908:	0801f560 	.word	0x0801f560
 800d90c:	2000018e 	.word	0x2000018e
 800d910:	20000130 	.word	0x20000130

0800d914 <GUI_Text_LAB_Measure>:

uint8_t old_num_L = 10, old_num_A = 10, old_num_B = 10;
void GUI_Text_LAB_Measure(uint16_t X, uint16_t Y, int16_t ValueL, int16_t ValueA, int16_t ValueB)
{
 800d914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d918:	b087      	sub	sp, #28
	char buffer[5] = {0};
 800d91a:	2600      	movs	r6, #0
{
 800d91c:	4604      	mov	r4, r0
 800d91e:	461f      	mov	r7, r3
	uint8_t	delta_pos = 180, sign = 0, number = 0;
	uint32_t dec = 10;
	
	TFT_SetTextColor(TFT_White);
 800d920:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800d924:	f9bd 3040 	ldrsh.w	r3, [sp, #64]	; 0x40
 800d928:	9302      	str	r3, [sp, #8]
 800d92a:	4690      	mov	r8, r2
 800d92c:	460d      	mov	r5, r1
	char buffer[5] = {0};
 800d92e:	9604      	str	r6, [sp, #16]
 800d930:	f88d 6014 	strb.w	r6, [sp, #20]
	TFT_SetTextColor(TFT_White);
 800d934:	f003 fa0a 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800d938:	2063      	movs	r0, #99	; 0x63
 800d93a:	f003 fa0d 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_digit);
 800d93e:	4894      	ldr	r0, [pc, #592]	; (800db90 <GUI_Text_LAB_Measure+0x27c>)
 800d940:	f003 f9fe 	bl	8010d40 <TFT_SetFont>
	
	if(ValueL < 0){ValueL *= -1; sign = 1;}
 800d944:	45b0      	cmp	r8, r6
 800d946:	bfbe      	ittt	lt
 800d948:	f1c8 0800 	rsblt	r8, r8, #0
 800d94c:	fa0f f888 	sxthlt.w	r8, r8
 800d950:	2301      	movlt	r3, #1
	
	sprintf (buffer, "%d", ValueL);
 800d952:	4642      	mov	r2, r8
 800d954:	498f      	ldr	r1, [pc, #572]	; (800db94 <GUI_Text_LAB_Measure+0x280>)
	uint8_t	delta_pos = 180, sign = 0, number = 0;
 800d956:	bfa8      	it	ge
 800d958:	9603      	strge	r6, [sp, #12]
	sprintf (buffer, "%d", ValueL);
 800d95a:	a804      	add	r0, sp, #16
	if(ValueL < 0){ValueL *= -1; sign = 1;}
 800d95c:	bfb8      	it	lt
 800d95e:	9303      	strlt	r3, [sp, #12]
	sprintf (buffer, "%d", ValueL);
 800d960:	f004 fd14 	bl	801238c <siprintf>
 800d964:	f04f 0a04 	mov.w	sl, #4
	uint32_t dec = 10;
 800d968:	f04f 0b0a 	mov.w	fp, #10
	uint8_t	delta_pos = 180, sign = 0, number = 0;
 800d96c:	f04f 0900 	mov.w	r9, #0
 800d970:	26b4      	movs	r6, #180	; 0xb4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueL/(dec)) >= 1.0)
 800d972:	fbb8 f0fb 	udiv	r0, r8, fp
 800d976:	f7f2 fdd5 	bl	8000524 <__aeabi_ui2d>
 800d97a:	2200      	movs	r2, #0
 800d97c:	4b86      	ldr	r3, [pc, #536]	; (800db98 <GUI_Text_LAB_Measure+0x284>)
 800d97e:	f7f3 f8cd 	bl	8000b1c <__aeabi_dcmpge>
 800d982:	b140      	cbz	r0, 800d996 <GUI_Text_LAB_Measure+0x82>
		{
			dec *= 10;
 800d984:	230a      	movs	r3, #10
			delta_pos-=23;
 800d986:	3e17      	subs	r6, #23
			number++;
 800d988:	f109 0901 	add.w	r9, r9, #1
			dec *= 10;
 800d98c:	fb03 fb0b 	mul.w	fp, r3, fp
			delta_pos-=23;
 800d990:	b2f6      	uxtb	r6, r6
			number++;
 800d992:	fa5f f989 	uxtb.w	r9, r9
 800d996:	f10a 3aff 	add.w	sl, sl, #4294967295
	for (uint8_t i = 1; i <= 4; i++)
 800d99a:	f01a 0aff 	ands.w	sl, sl, #255	; 0xff
 800d99e:	d1e8      	bne.n	800d972 <GUI_Text_LAB_Measure+0x5e>
		}
	}
	
	if(number < old_num_L )
 800d9a0:	4b7e      	ldr	r3, [pc, #504]	; (800db9c <GUI_Text_LAB_Measure+0x288>)
 800d9a2:	781a      	ldrb	r2, [r3, #0]
 800d9a4:	454a      	cmp	r2, r9
 800d9a6:	4698      	mov	r8, r3
 800d9a8:	d90d      	bls.n	800d9c6 <GUI_Text_LAB_Measure+0xb2>
	{
		TFT_FillRectangle(X+40, Y, X+197, Y+25, TFT_Black_Bkgr);
 800d9aa:	2163      	movs	r1, #99	; 0x63
 800d9ac:	f105 0319 	add.w	r3, r5, #25
 800d9b0:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800d9b4:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800d9b8:	9100      	str	r1, [sp, #0]
 800d9ba:	b29b      	uxth	r3, r3
 800d9bc:	b292      	uxth	r2, r2
 800d9be:	4629      	mov	r1, r5
 800d9c0:	b280      	uxth	r0, r0
 800d9c2:	f002 ffba 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_L = number;
	number = 0;
	
	if(sign){TFT_DrawChar(X+delta_pos-18, Y, '-'); sign = 0;}
 800d9c6:	9b03      	ldr	r3, [sp, #12]
	old_num_L = number;
 800d9c8:	f888 9000 	strb.w	r9, [r8]
	if(sign){TFT_DrawChar(X+delta_pos-18, Y, '-'); sign = 0;}
 800d9cc:	b13b      	cbz	r3, 800d9de <GUI_Text_LAB_Measure+0xca>
 800d9ce:	f1a4 0012 	sub.w	r0, r4, #18
 800d9d2:	4430      	add	r0, r6
 800d9d4:	222d      	movs	r2, #45	; 0x2d
 800d9d6:	4629      	mov	r1, r5
 800d9d8:	b280      	uxth	r0, r0
 800d9da:	f003 fa27 	bl	8010e2c <TFT_DrawChar>
	
			TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d9de:	19a0      	adds	r0, r4, r6
			TFT_DrawChar(X+17, Y, '*');
 800d9e0:	f104 0911 	add.w	r9, r4, #17
			TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d9e4:	2303      	movs	r3, #3
 800d9e6:	aa04      	add	r2, sp, #16
 800d9e8:	4629      	mov	r1, r5
 800d9ea:	b280      	uxth	r0, r0
			TFT_DrawChar(X+17, Y, '*');
 800d9ec:	fa1f f989 	uxth.w	r9, r9
			TFT_DisplayString(X+delta_pos, Y, (uint8_t *)buffer, LEFT_MODE);
 800d9f0:	f003 fa74 	bl	8010edc <TFT_DisplayString>
			TFT_DrawChar(X+17, Y, '*');
 800d9f4:	222a      	movs	r2, #42	; 0x2a
 800d9f6:	4629      	mov	r1, r5
 800d9f8:	4648      	mov	r0, r9
 800d9fa:	f003 fa17 	bl	8010e2c <TFT_DrawChar>

			TFT_SetFont(&Font26EN_arch_big);
 800d9fe:	4868      	ldr	r0, [pc, #416]	; (800dba0 <GUI_Text_LAB_Measure+0x28c>)
 800da00:	f003 f99e 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y, 'L'-33);
 800da04:	222b      	movs	r2, #43	; 0x2b
 800da06:	4629      	mov	r1, r5
 800da08:	4620      	mov	r0, r4
 800da0a:	f003 fa0f 	bl	8010e2c <TFT_DrawChar>
	
	delta_pos = 180;
	dec = 10;
			
	if(ValueA < 0){ValueA *= -1; sign = 1;}
 800da0e:	2f00      	cmp	r7, #0
 800da10:	bfbd      	ittte	lt
 800da12:	427f      	neglt	r7, r7
 800da14:	b23f      	sxthlt	r7, r7
 800da16:	2301      	movlt	r3, #1
 800da18:	2300      	movge	r3, #0
			
	TFT_SetFont(&Font26EN_arch_digit);
 800da1a:	485d      	ldr	r0, [pc, #372]	; (800db90 <GUI_Text_LAB_Measure+0x27c>)
 800da1c:	9303      	str	r3, [sp, #12]
 800da1e:	f003 f98f 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", ValueA);
 800da22:	463a      	mov	r2, r7
 800da24:	495b      	ldr	r1, [pc, #364]	; (800db94 <GUI_Text_LAB_Measure+0x280>)
 800da26:	a804      	add	r0, sp, #16
 800da28:	f004 fcb0 	bl	801238c <siprintf>
 800da2c:	f04f 0a04 	mov.w	sl, #4
	dec = 10;
 800da30:	f04f 0b0a 	mov.w	fp, #10
	number = 0;
 800da34:	f04f 0800 	mov.w	r8, #0
	delta_pos = 180;
 800da38:	26b4      	movs	r6, #180	; 0xb4
		for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueA/(dec)) >= 1.0)
 800da3a:	fbb7 f0fb 	udiv	r0, r7, fp
 800da3e:	f7f2 fd71 	bl	8000524 <__aeabi_ui2d>
 800da42:	2200      	movs	r2, #0
 800da44:	4b54      	ldr	r3, [pc, #336]	; (800db98 <GUI_Text_LAB_Measure+0x284>)
 800da46:	f7f3 f869 	bl	8000b1c <__aeabi_dcmpge>
 800da4a:	b140      	cbz	r0, 800da5e <GUI_Text_LAB_Measure+0x14a>
		{
			dec *= 10;
 800da4c:	230a      	movs	r3, #10
			delta_pos-=23;
 800da4e:	3e17      	subs	r6, #23
			number++;
 800da50:	f108 0801 	add.w	r8, r8, #1
			dec *= 10;
 800da54:	fb03 fb0b 	mul.w	fp, r3, fp
			delta_pos-=23;
 800da58:	b2f6      	uxtb	r6, r6
			number++;
 800da5a:	fa5f f888 	uxtb.w	r8, r8
 800da5e:	f10a 3aff 	add.w	sl, sl, #4294967295
		for (uint8_t i = 1; i <= 4; i++)
 800da62:	f01a 0aff 	ands.w	sl, sl, #255	; 0xff
 800da66:	d1e8      	bne.n	800da3a <GUI_Text_LAB_Measure+0x126>
		}
	}
	
	if(number < old_num_A )
 800da68:	4f4e      	ldr	r7, [pc, #312]	; (800dba4 <GUI_Text_LAB_Measure+0x290>)
 800da6a:	783b      	ldrb	r3, [r7, #0]
 800da6c:	4543      	cmp	r3, r8
 800da6e:	d911      	bls.n	800da94 <GUI_Text_LAB_Measure+0x180>
	{
		TFT_FillRectangle(X+40, Y+35, X+197, Y+62, TFT_Black_Bkgr);
 800da70:	f105 033e 	add.w	r3, r5, #62	; 0x3e
 800da74:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800da78:	f105 0123 	add.w	r1, r5, #35	; 0x23
 800da7c:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800da80:	f04f 0e63 	mov.w	lr, #99	; 0x63
 800da84:	f8cd e000 	str.w	lr, [sp]
 800da88:	b29b      	uxth	r3, r3
 800da8a:	b292      	uxth	r2, r2
 800da8c:	b289      	uxth	r1, r1
 800da8e:	b280      	uxth	r0, r0
 800da90:	f002 ff53 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_A = number;
	number = 0;
	
	if(sign){TFT_DrawChar(X+delta_pos-18, Y+35, '-'); sign = 0;}
 800da94:	9b03      	ldr	r3, [sp, #12]
	old_num_A = number;
 800da96:	f887 8000 	strb.w	r8, [r7]
 800da9a:	f105 0723 	add.w	r7, r5, #35	; 0x23
	if(sign){TFT_DrawChar(X+delta_pos-18, Y+35, '-'); sign = 0;}
 800da9e:	b13b      	cbz	r3, 800dab0 <GUI_Text_LAB_Measure+0x19c>
 800daa0:	f1a4 0012 	sub.w	r0, r4, #18
 800daa4:	4430      	add	r0, r6
 800daa6:	222d      	movs	r2, #45	; 0x2d
 800daa8:	b2b9      	uxth	r1, r7
 800daaa:	b280      	uxth	r0, r0
 800daac:	f003 f9be 	bl	8010e2c <TFT_DrawChar>
			TFT_DisplayString(X+delta_pos, Y+35, (uint8_t *)buffer, LEFT_MODE);
 800dab0:	b2bf      	uxth	r7, r7
 800dab2:	19a0      	adds	r0, r4, r6
 800dab4:	2303      	movs	r3, #3
 800dab6:	4639      	mov	r1, r7
 800dab8:	aa04      	add	r2, sp, #16
 800daba:	b280      	uxth	r0, r0
 800dabc:	f003 fa0e 	bl	8010edc <TFT_DisplayString>
			TFT_DrawChar(X+17, Y+35, '*');
 800dac0:	4639      	mov	r1, r7
 800dac2:	222a      	movs	r2, #42	; 0x2a
 800dac4:	4648      	mov	r0, r9
 800dac6:	f003 f9b1 	bl	8010e2c <TFT_DrawChar>

			TFT_SetFont(&Font26EN_arch_small);
 800daca:	4837      	ldr	r0, [pc, #220]	; (800dba8 <GUI_Text_LAB_Measure+0x294>)
 800dacc:	f003 f938 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y+35, 'a'-65);
 800dad0:	4639      	mov	r1, r7
 800dad2:	2220      	movs	r2, #32
 800dad4:	4620      	mov	r0, r4
 800dad6:	f003 f9a9 	bl	8010e2c <TFT_DrawChar>
	
		delta_pos = 180;
	 dec = 10;
	
	if(ValueB < 0){ValueB *= -1; sign = 1;}
 800dada:	9b02      	ldr	r3, [sp, #8]
	
	TFT_SetFont(&Font26EN_arch_digit);
 800dadc:	482c      	ldr	r0, [pc, #176]	; (800db90 <GUI_Text_LAB_Measure+0x27c>)
	if(ValueB < 0){ValueB *= -1; sign = 1;}
 800dade:	2b00      	cmp	r3, #0
 800dae0:	bfbe      	ittt	lt
 800dae2:	425b      	neglt	r3, r3
 800dae4:	b21b      	sxthlt	r3, r3
 800dae6:	9302      	strlt	r3, [sp, #8]
	TFT_SetFont(&Font26EN_arch_digit);
 800dae8:	f003 f92a 	bl	8010d40 <TFT_SetFont>
	sprintf (buffer, "%d", ValueB);
 800daec:	9a02      	ldr	r2, [sp, #8]
 800daee:	4929      	ldr	r1, [pc, #164]	; (800db94 <GUI_Text_LAB_Measure+0x280>)
 800daf0:	a804      	add	r0, sp, #16
 800daf2:	f004 fc4b 	bl	801238c <siprintf>
	 dec = 10;
 800daf6:	f04f 0a0a 	mov.w	sl, #10
	sprintf (buffer, "%d", ValueB);
 800dafa:	f04f 0804 	mov.w	r8, #4
	number = 0;
 800dafe:	2700      	movs	r7, #0
		delta_pos = 180;
 800db00:	26b4      	movs	r6, #180	; 0xb4
	for (uint8_t i = 1; i <= 4; i++)
	{
		if((ValueB/(dec)) >= 1.0)
		{
			dec *= 10;
 800db02:	46d3      	mov	fp, sl
		if((ValueB/(dec)) >= 1.0)
 800db04:	9b02      	ldr	r3, [sp, #8]
 800db06:	fbb3 f0fa 	udiv	r0, r3, sl
 800db0a:	f7f2 fd0b 	bl	8000524 <__aeabi_ui2d>
 800db0e:	2200      	movs	r2, #0
 800db10:	4b21      	ldr	r3, [pc, #132]	; (800db98 <GUI_Text_LAB_Measure+0x284>)
 800db12:	f7f3 f803 	bl	8000b1c <__aeabi_dcmpge>
 800db16:	b128      	cbz	r0, 800db24 <GUI_Text_LAB_Measure+0x210>
			delta_pos-=23;
 800db18:	3e17      	subs	r6, #23
			number++;
 800db1a:	3701      	adds	r7, #1
			dec *= 10;
 800db1c:	fb0b fa0a 	mul.w	sl, fp, sl
			delta_pos-=23;
 800db20:	b2f6      	uxtb	r6, r6
			number++;
 800db22:	b2ff      	uxtb	r7, r7
 800db24:	f108 38ff 	add.w	r8, r8, #4294967295
	for (uint8_t i = 1; i <= 4; i++)
 800db28:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 800db2c:	d1ea      	bne.n	800db04 <GUI_Text_LAB_Measure+0x1f0>
		}
	}
	
	if(number < old_num_B )
 800db2e:	4b1f      	ldr	r3, [pc, #124]	; (800dbac <GUI_Text_LAB_Measure+0x298>)
 800db30:	781a      	ldrb	r2, [r3, #0]
 800db32:	42ba      	cmp	r2, r7
 800db34:	469a      	mov	sl, r3
 800db36:	f105 0846 	add.w	r8, r5, #70	; 0x46
 800db3a:	d90e      	bls.n	800db5a <GUI_Text_LAB_Measure+0x246>
	{
		TFT_FillRectangle(X+40, Y+70, X+197, Y+95, TFT_Black_Bkgr);
 800db3c:	2163      	movs	r1, #99	; 0x63
 800db3e:	f105 035f 	add.w	r3, r5, #95	; 0x5f
 800db42:	f104 02c5 	add.w	r2, r4, #197	; 0xc5
 800db46:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800db4a:	9100      	str	r1, [sp, #0]
 800db4c:	b29b      	uxth	r3, r3
 800db4e:	b292      	uxth	r2, r2
 800db50:	fa1f f188 	uxth.w	r1, r8
 800db54:	b280      	uxth	r0, r0
 800db56:	f002 fef0 	bl	801093a <TFT_FillRectangle>
	} 
	old_num_B = number;
	number = 0;

//		if(sign){TFT_DrawChar(X+delta_pos-18, Y+70, '-'); sign = 0;}
			TFT_DisplayString(X+delta_pos, Y+70, (uint8_t *)buffer, LEFT_MODE);
 800db5a:	fa1f f888 	uxth.w	r8, r8
 800db5e:	19a0      	adds	r0, r4, r6
 800db60:	2303      	movs	r3, #3
 800db62:	aa04      	add	r2, sp, #16
 800db64:	4641      	mov	r1, r8
 800db66:	b280      	uxth	r0, r0
	old_num_B = number;
 800db68:	f88a 7000 	strb.w	r7, [sl]
			TFT_DisplayString(X+delta_pos, Y+70, (uint8_t *)buffer, LEFT_MODE);
 800db6c:	f003 f9b6 	bl	8010edc <TFT_DisplayString>
			TFT_DrawChar(X+17, Y+70, '*');
 800db70:	4641      	mov	r1, r8
 800db72:	222a      	movs	r2, #42	; 0x2a
 800db74:	4648      	mov	r0, r9
 800db76:	f003 f959 	bl	8010e2c <TFT_DrawChar>

			TFT_SetFont(&Font26EN_arch_small);
 800db7a:	480b      	ldr	r0, [pc, #44]	; (800dba8 <GUI_Text_LAB_Measure+0x294>)
 800db7c:	f003 f8e0 	bl	8010d40 <TFT_SetFont>
			TFT_DrawChar(X, Y+70, 'b'-65);
 800db80:	2221      	movs	r2, #33	; 0x21
 800db82:	4641      	mov	r1, r8
 800db84:	4620      	mov	r0, r4
 800db86:	f003 f951 	bl	8010e2c <TFT_DrawChar>
}	
 800db8a:	b007      	add	sp, #28
 800db8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800db90:	20000138 	.word	0x20000138
 800db94:	0801f55d 	.word	0x0801f55d
 800db98:	3ff00000 	.word	0x3ff00000
 800db9c:	2000018b 	.word	0x2000018b
 800dba0:	20000130 	.word	0x20000130
 800dba4:	20000187 	.word	0x20000187
 800dba8:	20000140 	.word	0x20000140
 800dbac:	20000188 	.word	0x20000188

0800dbb0 <GUI_Battery_Level>:


void GUI_Battery_Level(uint16_t X, uint16_t Y, double charge)
{
 800dbb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800dbb4:	b085      	sub	sp, #20
	char buffer[5] = {0};
 800dbb6:	2300      	movs	r3, #0
	
	
	TFT_FillRectangle(X+10, Y+10, X+45, Y+26, TFT_Blue_Off); // big battery rect
 800dbb8:	f100 082d 	add.w	r8, r0, #45	; 0x2d
{
 800dbbc:	460c      	mov	r4, r1
 800dbbe:	4605      	mov	r5, r0
	char buffer[5] = {0};
 800dbc0:	9302      	str	r3, [sp, #8]
 800dbc2:	f88d 300c 	strb.w	r3, [sp, #12]
	TFT_FillRectangle(X+10, Y+10, X+45, Y+26, TFT_Blue_Off); // big battery rect
 800dbc6:	fa1f f888 	uxth.w	r8, r8
 800dbca:	f101 031a 	add.w	r3, r1, #26
 800dbce:	f241 3976 	movw	r9, #4982	; 0x1376
 800dbd2:	310a      	adds	r1, #10
 800dbd4:	300a      	adds	r0, #10
 800dbd6:	b29b      	uxth	r3, r3
 800dbd8:	4642      	mov	r2, r8
 800dbda:	b289      	uxth	r1, r1
 800dbdc:	b280      	uxth	r0, r0
 800dbde:	f8cd 9000 	str.w	r9, [sp]
{
 800dbe2:	ec57 6b10 	vmov	r6, r7, d0
	TFT_FillRectangle(X+10, Y+10, X+45, Y+26, TFT_Blue_Off); // big battery rect
 800dbe6:	f002 fea8 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(X+45, Y+15, X+48, Y+20, TFT_Blue_Off); //small battery rect
 800dbea:	f104 0314 	add.w	r3, r4, #20
 800dbee:	f105 0230 	add.w	r2, r5, #48	; 0x30
 800dbf2:	f104 010f 	add.w	r1, r4, #15
 800dbf6:	b29b      	uxth	r3, r3
 800dbf8:	b292      	uxth	r2, r2
 800dbfa:	b289      	uxth	r1, r1
 800dbfc:	4640      	mov	r0, r8
 800dbfe:	f8cd 9000 	str.w	r9, [sp]
 800dc02:	f002 fe9a 	bl	801093a <TFT_FillRectangle>

		if(charge < 12)
 800dc06:	2200      	movs	r2, #0
 800dc08:	4b4c      	ldr	r3, [pc, #304]	; (800dd3c <GUI_Battery_Level+0x18c>)
 800dc0a:	4630      	mov	r0, r6
 800dc0c:	4639      	mov	r1, r7
 800dc0e:	f7f2 ff71 	bl	8000af4 <__aeabi_dcmplt>
 800dc12:	b188      	cbz	r0, 800dc38 <GUI_Battery_Level+0x88>
		{
			TFT_FillRectangle(X+15, Y+12, X+19, Y+24, TFT_Red);
 800dc14:	f104 0318 	add.w	r3, r4, #24
 800dc18:	f105 0213 	add.w	r2, r5, #19
 800dc1c:	f104 010c 	add.w	r1, r4, #12
 800dc20:	f105 000f 	add.w	r0, r5, #15
 800dc24:	f44f 4e78 	mov.w	lr, #63488	; 0xf800
 800dc28:	f8cd e000 	str.w	lr, [sp]
 800dc2c:	b29b      	uxth	r3, r3
 800dc2e:	b292      	uxth	r2, r2
 800dc30:	b289      	uxth	r1, r1
 800dc32:	b280      	uxth	r0, r0
 800dc34:	f002 fe81 	bl	801093a <TFT_FillRectangle>
		}		
		if(charge >= 12)
 800dc38:	2200      	movs	r2, #0
 800dc3a:	4b40      	ldr	r3, [pc, #256]	; (800dd3c <GUI_Battery_Level+0x18c>)
 800dc3c:	4630      	mov	r0, r6
 800dc3e:	4639      	mov	r1, r7
 800dc40:	f7f2 ff6c 	bl	8000b1c <__aeabi_dcmpge>
 800dc44:	b188      	cbz	r0, 800dc6a <GUI_Battery_Level+0xba>
		{
			TFT_FillRectangle(X+15, Y+12, X+19, Y+24, TFT_White);
 800dc46:	f104 0318 	add.w	r3, r4, #24
 800dc4a:	f105 0213 	add.w	r2, r5, #19
 800dc4e:	f104 010c 	add.w	r1, r4, #12
 800dc52:	f105 000f 	add.w	r0, r5, #15
 800dc56:	f64f 7eff 	movw	lr, #65535	; 0xffff
 800dc5a:	f8cd e000 	str.w	lr, [sp]
 800dc5e:	b29b      	uxth	r3, r3
 800dc60:	b292      	uxth	r2, r2
 800dc62:	b289      	uxth	r1, r1
 800dc64:	b280      	uxth	r0, r0
 800dc66:	f002 fe68 	bl	801093a <TFT_FillRectangle>
		}		
		if(charge >= 25)
 800dc6a:	2200      	movs	r2, #0
 800dc6c:	4b34      	ldr	r3, [pc, #208]	; (800dd40 <GUI_Battery_Level+0x190>)
 800dc6e:	4630      	mov	r0, r6
 800dc70:	4639      	mov	r1, r7
 800dc72:	f7f2 ff53 	bl	8000b1c <__aeabi_dcmpge>
 800dc76:	b188      	cbz	r0, 800dc9c <GUI_Battery_Level+0xec>
		{
			TFT_FillRectangle(X+22, Y+12, X+26, Y+24, TFT_White);
 800dc78:	f104 0318 	add.w	r3, r4, #24
 800dc7c:	f105 021a 	add.w	r2, r5, #26
 800dc80:	f104 010c 	add.w	r1, r4, #12
 800dc84:	f105 0016 	add.w	r0, r5, #22
 800dc88:	f64f 7eff 	movw	lr, #65535	; 0xffff
 800dc8c:	f8cd e000 	str.w	lr, [sp]
 800dc90:	b29b      	uxth	r3, r3
 800dc92:	b292      	uxth	r2, r2
 800dc94:	b289      	uxth	r1, r1
 800dc96:	b280      	uxth	r0, r0
 800dc98:	f002 fe4f 	bl	801093a <TFT_FillRectangle>
		}		
		if(charge >= 50)
 800dc9c:	2200      	movs	r2, #0
 800dc9e:	4b29      	ldr	r3, [pc, #164]	; (800dd44 <GUI_Battery_Level+0x194>)
 800dca0:	4630      	mov	r0, r6
 800dca2:	4639      	mov	r1, r7
 800dca4:	f7f2 ff3a 	bl	8000b1c <__aeabi_dcmpge>
 800dca8:	b188      	cbz	r0, 800dcce <GUI_Battery_Level+0x11e>
		{
			TFT_FillRectangle(X+29, Y+12, X+33, Y+24, TFT_White);
 800dcaa:	f104 0318 	add.w	r3, r4, #24
 800dcae:	f105 0221 	add.w	r2, r5, #33	; 0x21
 800dcb2:	f104 010c 	add.w	r1, r4, #12
 800dcb6:	f105 001d 	add.w	r0, r5, #29
 800dcba:	f64f 7eff 	movw	lr, #65535	; 0xffff
 800dcbe:	f8cd e000 	str.w	lr, [sp]
 800dcc2:	b29b      	uxth	r3, r3
 800dcc4:	b292      	uxth	r2, r2
 800dcc6:	b289      	uxth	r1, r1
 800dcc8:	b280      	uxth	r0, r0
 800dcca:	f002 fe36 	bl	801093a <TFT_FillRectangle>
		}
		if(charge >= 85)
 800dcce:	2200      	movs	r2, #0
 800dcd0:	4b1d      	ldr	r3, [pc, #116]	; (800dd48 <GUI_Battery_Level+0x198>)
 800dcd2:	4630      	mov	r0, r6
 800dcd4:	4639      	mov	r1, r7
 800dcd6:	f7f2 ff21 	bl	8000b1c <__aeabi_dcmpge>
 800dcda:	b188      	cbz	r0, 800dd00 <GUI_Battery_Level+0x150>
		{
			TFT_FillRectangle(X+36, Y+12, X+40, Y+24, TFT_White);
 800dcdc:	f104 0318 	add.w	r3, r4, #24
 800dce0:	f105 0228 	add.w	r2, r5, #40	; 0x28
 800dce4:	f104 010c 	add.w	r1, r4, #12
 800dce8:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800dcec:	f64f 7eff 	movw	lr, #65535	; 0xffff
 800dcf0:	f8cd e000 	str.w	lr, [sp]
 800dcf4:	b29b      	uxth	r3, r3
 800dcf6:	b292      	uxth	r2, r2
 800dcf8:	b289      	uxth	r1, r1
 800dcfa:	b280      	uxth	r0, r0
 800dcfc:	f002 fe1d 	bl	801093a <TFT_FillRectangle>
		}
		
		sprintf (buffer, "%.1f%%", charge);
 800dd00:	4632      	mov	r2, r6
 800dd02:	463b      	mov	r3, r7
 800dd04:	4911      	ldr	r1, [pc, #68]	; (800dd4c <GUI_Battery_Level+0x19c>)
 800dd06:	a802      	add	r0, sp, #8
 800dd08:	f004 fb40 	bl	801238c <siprintf>
		TFT_SetFont(&Font8);
 800dd0c:	4810      	ldr	r0, [pc, #64]	; (800dd50 <GUI_Battery_Level+0x1a0>)
 800dd0e:	f003 f817 	bl	8010d40 <TFT_SetFont>
		TFT_SetTextColor(TFT_White);
 800dd12:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800dd16:	f003 f819 	bl	8010d4c <TFT_SetTextColor>
		TFT_SetBackColor(TFT_Black_Bkgr);
 800dd1a:	2063      	movs	r0, #99	; 0x63
 800dd1c:	f003 f81c 	bl	8010d58 <TFT_SetBackColor>
		TFT_DisplayString(X+52, Y+14, (uint8_t *)buffer, LEFT_MODE);
 800dd20:	f104 010e 	add.w	r1, r4, #14
 800dd24:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800dd28:	2303      	movs	r3, #3
 800dd2a:	aa02      	add	r2, sp, #8
 800dd2c:	b289      	uxth	r1, r1
 800dd2e:	b280      	uxth	r0, r0
 800dd30:	f003 f8d4 	bl	8010edc <TFT_DisplayString>

}
 800dd34:	b005      	add	sp, #20
 800dd36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800dd3a:	bf00      	nop
 800dd3c:	40280000 	.word	0x40280000
 800dd40:	40390000 	.word	0x40390000
 800dd44:	40490000 	.word	0x40490000
 800dd48:	40554000 	.word	0x40554000
 800dd4c:	0801f54c 	.word	0x0801f54c
 800dd50:	20000160 	.word	0x20000160

0800dd54 <GUI_Text_CIE_XYZ>:
#include "stdio.h"
#include "GUI_Text_Elements_EN.h"


void GUI_Text_CIE_XYZ(uint16_t X, uint16_t Y)
{
 800dd54:	b538      	push	{r3, r4, r5, lr}
 800dd56:	4604      	mov	r4, r0
TFT_SetTextColor(TFT_White);
 800dd58:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800dd5c:	460d      	mov	r5, r1
TFT_SetTextColor(TFT_White);
 800dd5e:	f002 fff5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800dd62:	2063      	movs	r0, #99	; 0x63
 800dd64:	f002 fff8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800dd68:	4816      	ldr	r0, [pc, #88]	; (800ddc4 <GUI_Text_CIE_XYZ+0x70>)
 800dd6a:	f002 ffe9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800dd6e:	4629      	mov	r1, r5
 800dd70:	4620      	mov	r0, r4
 800dd72:	2243      	movs	r2, #67	; 0x43
 800dd74:	f003 f85a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800dd78:	f104 000d 	add.w	r0, r4, #13
 800dd7c:	4629      	mov	r1, r5
 800dd7e:	2249      	movs	r2, #73	; 0x49
 800dd80:	b280      	uxth	r0, r0
 800dd82:	f003 f853 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800dd86:	f104 001b 	add.w	r0, r4, #27
 800dd8a:	4629      	mov	r1, r5
 800dd8c:	2245      	movs	r2, #69	; 0x45
 800dd8e:	b280      	uxth	r0, r0
 800dd90:	f003 f84c 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+49, Y, 'X');
 800dd94:	f104 0031 	add.w	r0, r4, #49	; 0x31
 800dd98:	4629      	mov	r1, r5
 800dd9a:	2258      	movs	r2, #88	; 0x58
 800dd9c:	b280      	uxth	r0, r0
 800dd9e:	f003 f845 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+65, Y, 'Y');
 800dda2:	f104 0041 	add.w	r0, r4, #65	; 0x41
 800dda6:	4629      	mov	r1, r5
 800dda8:	2259      	movs	r2, #89	; 0x59
 800ddaa:	b280      	uxth	r0, r0
 800ddac:	f003 f83e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+81, Y, 'Z');
 800ddb0:	f104 0051 	add.w	r0, r4, #81	; 0x51
 800ddb4:	4629      	mov	r1, r5
 800ddb6:	225a      	movs	r2, #90	; 0x5a
 800ddb8:	b280      	uxth	r0, r0
}
 800ddba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+81, Y, 'Z');
 800ddbe:	f003 b835 	b.w	8010e2c <TFT_DrawChar>
 800ddc2:	bf00      	nop
 800ddc4:	200000f8 	.word	0x200000f8

0800ddc8 <GUI_Text_CIE_xy_1931>:
	TFT_DrawChar(X+49, Y+1, 'x');
	TFT_DrawChar(X+72, Y+1, 'y');
}

void GUI_Text_CIE_xy_1931(uint16_t X, uint16_t Y)
{
 800ddc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ddca:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font16EN_arch_big);
 800ddcc:	4f2c      	ldr	r7, [pc, #176]	; (800de80 <GUI_Text_CIE_xy_1931+0xb8>)
	TFT_SetTextColor(TFT_White);
 800ddce:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ddd2:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800ddd4:	f002 ffba 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ddd8:	2063      	movs	r0, #99	; 0x63
 800ddda:	f002 ffbd 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800ddde:	4638      	mov	r0, r7
 800dde0:	f002 ffae 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800dde4:	4629      	mov	r1, r5
 800dde6:	4620      	mov	r0, r4
 800dde8:	2243      	movs	r2, #67	; 0x43
 800ddea:	f003 f81f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800ddee:	f104 000d 	add.w	r0, r4, #13
 800ddf2:	4629      	mov	r1, r5
 800ddf4:	2249      	movs	r2, #73	; 0x49
 800ddf6:	b280      	uxth	r0, r0
 800ddf8:	f003 f818 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800ddfc:	f104 001b 	add.w	r0, r4, #27
 800de00:	4629      	mov	r1, r5
 800de02:	2245      	movs	r2, #69	; 0x45
 800de04:	b280      	uxth	r0, r0
 800de06:	f003 f811 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+58, Y, ',');
 800de0a:	f104 003a 	add.w	r0, r4, #58	; 0x3a
 800de0e:	4629      	mov	r1, r5
 800de10:	222c      	movs	r2, #44	; 0x2c
 800de12:	b280      	uxth	r0, r0
 800de14:	f003 f80a 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+49, Y+1, 'x');
 800de18:	1c6e      	adds	r6, r5, #1
	TFT_SetFont(&Font16EN_arch_small);
 800de1a:	481a      	ldr	r0, [pc, #104]	; (800de84 <GUI_Text_CIE_xy_1931+0xbc>)
 800de1c:	f002 ff90 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+49, Y+1, 'x');
 800de20:	b2b6      	uxth	r6, r6
 800de22:	f104 0031 	add.w	r0, r4, #49	; 0x31
 800de26:	4631      	mov	r1, r6
 800de28:	2278      	movs	r2, #120	; 0x78
 800de2a:	b280      	uxth	r0, r0
 800de2c:	f002 fffe 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+72, Y+1, 'y');
 800de30:	f104 0048 	add.w	r0, r4, #72	; 0x48
 800de34:	4631      	mov	r1, r6
 800de36:	2279      	movs	r2, #121	; 0x79
 800de38:	b280      	uxth	r0, r0
 800de3a:	f002 fff7 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800de3e:	4638      	mov	r0, r7
 800de40:	f002 ff7e 	bl	8010d40 <TFT_SetFont>
	
	TFT_DrawChar(X+92, Y, '1');
 800de44:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800de48:	4629      	mov	r1, r5
 800de4a:	2231      	movs	r2, #49	; 0x31
 800de4c:	b280      	uxth	r0, r0
 800de4e:	f002 ffed 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+133, Y, '1');
 800de52:	f104 0085 	add.w	r0, r4, #133	; 0x85
 800de56:	4629      	mov	r1, r5
 800de58:	2231      	movs	r2, #49	; 0x31
 800de5a:	b280      	uxth	r0, r0
 800de5c:	f002 ffe6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+105, Y, '9');
 800de60:	f104 0069 	add.w	r0, r4, #105	; 0x69
 800de64:	4629      	mov	r1, r5
 800de66:	2239      	movs	r2, #57	; 0x39
 800de68:	b280      	uxth	r0, r0
 800de6a:	f002 ffdf 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+121, Y, '3');
 800de6e:	f104 0079 	add.w	r0, r4, #121	; 0x79
 800de72:	4629      	mov	r1, r5
 800de74:	2233      	movs	r2, #51	; 0x33
 800de76:	b280      	uxth	r0, r0


}
 800de78:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	TFT_DrawChar(X+121, Y, '3');
 800de7c:	f002 bfd6 	b.w	8010e2c <TFT_DrawChar>
 800de80:	200000f8 	.word	0x200000f8
 800de84:	20000108 	.word	0x20000108

0800de88 <GUI_Text_CIE_xy_1964>:

void GUI_Text_CIE_xy_1964(uint16_t X, uint16_t Y)
{
 800de88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800de8a:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font16EN_arch_big);
 800de8c:	4f2c      	ldr	r7, [pc, #176]	; (800df40 <GUI_Text_CIE_xy_1964+0xb8>)
	TFT_SetTextColor(TFT_White);
 800de8e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800de92:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800de94:	f002 ff5a 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800de98:	2063      	movs	r0, #99	; 0x63
 800de9a:	f002 ff5d 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800de9e:	4638      	mov	r0, r7
 800dea0:	f002 ff4e 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800dea4:	4629      	mov	r1, r5
 800dea6:	4620      	mov	r0, r4
 800dea8:	2243      	movs	r2, #67	; 0x43
 800deaa:	f002 ffbf 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800deae:	f104 000d 	add.w	r0, r4, #13
 800deb2:	4629      	mov	r1, r5
 800deb4:	2249      	movs	r2, #73	; 0x49
 800deb6:	b280      	uxth	r0, r0
 800deb8:	f002 ffb8 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800debc:	f104 001b 	add.w	r0, r4, #27
 800dec0:	4629      	mov	r1, r5
 800dec2:	2245      	movs	r2, #69	; 0x45
 800dec4:	b280      	uxth	r0, r0
 800dec6:	f002 ffb1 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+58, Y, ',');
 800deca:	f104 003a 	add.w	r0, r4, #58	; 0x3a
 800dece:	4629      	mov	r1, r5
 800ded0:	222c      	movs	r2, #44	; 0x2c
 800ded2:	b280      	uxth	r0, r0
 800ded4:	f002 ffaa 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+49, Y+1, 'x');
 800ded8:	1c6e      	adds	r6, r5, #1
	TFT_SetFont(&Font16EN_arch_small);
 800deda:	481a      	ldr	r0, [pc, #104]	; (800df44 <GUI_Text_CIE_xy_1964+0xbc>)
 800dedc:	f002 ff30 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+49, Y+1, 'x');
 800dee0:	b2b6      	uxth	r6, r6
 800dee2:	f104 0031 	add.w	r0, r4, #49	; 0x31
 800dee6:	4631      	mov	r1, r6
 800dee8:	2278      	movs	r2, #120	; 0x78
 800deea:	b280      	uxth	r0, r0
 800deec:	f002 ff9e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+72, Y+1, 'y');
 800def0:	f104 0048 	add.w	r0, r4, #72	; 0x48
 800def4:	4631      	mov	r1, r6
 800def6:	2279      	movs	r2, #121	; 0x79
 800def8:	b280      	uxth	r0, r0
 800defa:	f002 ff97 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800defe:	4638      	mov	r0, r7
 800df00:	f002 ff1e 	bl	8010d40 <TFT_SetFont>
	
	TFT_DrawChar(X+92, Y, '1');
 800df04:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800df08:	4629      	mov	r1, r5
 800df0a:	2231      	movs	r2, #49	; 0x31
 800df0c:	b280      	uxth	r0, r0
 800df0e:	f002 ff8d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+105, Y, '9');
 800df12:	f104 0069 	add.w	r0, r4, #105	; 0x69
 800df16:	4629      	mov	r1, r5
 800df18:	2239      	movs	r2, #57	; 0x39
 800df1a:	b280      	uxth	r0, r0
 800df1c:	f002 ff86 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+120, Y, '6');
 800df20:	f104 0078 	add.w	r0, r4, #120	; 0x78
 800df24:	4629      	mov	r1, r5
 800df26:	2236      	movs	r2, #54	; 0x36
 800df28:	b280      	uxth	r0, r0
 800df2a:	f002 ff7f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+135, Y, '9');
 800df2e:	f104 0087 	add.w	r0, r4, #135	; 0x87
 800df32:	4629      	mov	r1, r5
 800df34:	2239      	movs	r2, #57	; 0x39
 800df36:	b280      	uxth	r0, r0
}
 800df38:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	TFT_DrawChar(X+135, Y, '9');
 800df3c:	f002 bf76 	b.w	8010e2c <TFT_DrawChar>
 800df40:	200000f8 	.word	0x200000f8
 800df44:	20000108 	.word	0x20000108

0800df48 <GUI_Text_CIE_Luv>:



void GUI_Text_CIE_Luv(uint16_t X, uint16_t Y)
{
 800df48:	b538      	push	{r3, r4, r5, lr}
 800df4a:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800df4c:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800df50:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800df52:	f002 fefb 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800df56:	2063      	movs	r0, #99	; 0x63
 800df58:	f002 fefe 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800df5c:	481f      	ldr	r0, [pc, #124]	; (800dfdc <GUI_Text_CIE_Luv+0x94>)
 800df5e:	f002 feef 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800df62:	4621      	mov	r1, r4
 800df64:	4628      	mov	r0, r5
 800df66:	2243      	movs	r2, #67	; 0x43
 800df68:	f002 ff60 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800df6c:	f105 000d 	add.w	r0, r5, #13
 800df70:	4621      	mov	r1, r4
 800df72:	2249      	movs	r2, #73	; 0x49
 800df74:	b280      	uxth	r0, r0
 800df76:	f002 ff59 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800df7a:	f105 001b 	add.w	r0, r5, #27
 800df7e:	4621      	mov	r1, r4
 800df80:	2245      	movs	r2, #69	; 0x45
 800df82:	b280      	uxth	r0, r0
 800df84:	f002 ff52 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+49, Y, 'L');
 800df88:	f105 0031 	add.w	r0, r5, #49	; 0x31
 800df8c:	4621      	mov	r1, r4
 800df8e:	224c      	movs	r2, #76	; 0x4c
 800df90:	b280      	uxth	r0, r0
 800df92:	f002 ff4b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+80, Y, '('-1);
 800df96:	f105 0050 	add.w	r0, r5, #80	; 0x50
 800df9a:	4621      	mov	r1, r4
 800df9c:	2227      	movs	r2, #39	; 0x27
 800df9e:	b280      	uxth	r0, r0
 800dfa0:	f002 ff44 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+106, Y, '('-1);
 800dfa4:	f105 006a 	add.w	r0, r5, #106	; 0x6a
 800dfa8:	4621      	mov	r1, r4
 800dfaa:	2227      	movs	r2, #39	; 0x27
 800dfac:	b280      	uxth	r0, r0
 800dfae:	f002 ff3d 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+68, Y+2, 'u');
 800dfb2:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small);
 800dfb4:	480a      	ldr	r0, [pc, #40]	; (800dfe0 <GUI_Text_CIE_Luv+0x98>)
 800dfb6:	f002 fec3 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+68, Y+2, 'u');
 800dfba:	b2a4      	uxth	r4, r4
 800dfbc:	f105 0044 	add.w	r0, r5, #68	; 0x44
 800dfc0:	4621      	mov	r1, r4
 800dfc2:	2275      	movs	r2, #117	; 0x75
 800dfc4:	b280      	uxth	r0, r0
 800dfc6:	f002 ff31 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+93, Y+2, 'v');
 800dfca:	f105 005d 	add.w	r0, r5, #93	; 0x5d
 800dfce:	4621      	mov	r1, r4
 800dfd0:	2276      	movs	r2, #118	; 0x76
 800dfd2:	b280      	uxth	r0, r0
}
 800dfd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+93, Y+2, 'v');
 800dfd8:	f002 bf28 	b.w	8010e2c <TFT_DrawChar>
 800dfdc:	200000f8 	.word	0x200000f8
 800dfe0:	20000108 	.word	0x20000108

0800dfe4 <GUI_Text_CIE_Lab>:

void GUI_Text_CIE_Lab(uint16_t X, uint16_t Y)
{
 800dfe4:	b538      	push	{r3, r4, r5, lr}
 800dfe6:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800dfe8:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800dfec:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800dfee:	f002 fead 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800dff2:	2063      	movs	r0, #99	; 0x63
 800dff4:	f002 feb0 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800dff8:	481f      	ldr	r0, [pc, #124]	; (800e078 <GUI_Text_CIE_Lab+0x94>)
 800dffa:	f002 fea1 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800dffe:	4621      	mov	r1, r4
 800e000:	4628      	mov	r0, r5
 800e002:	2243      	movs	r2, #67	; 0x43
 800e004:	f002 ff12 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800e008:	f105 000d 	add.w	r0, r5, #13
 800e00c:	4621      	mov	r1, r4
 800e00e:	2249      	movs	r2, #73	; 0x49
 800e010:	b280      	uxth	r0, r0
 800e012:	f002 ff0b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800e016:	f105 001b 	add.w	r0, r5, #27
 800e01a:	4621      	mov	r1, r4
 800e01c:	2245      	movs	r2, #69	; 0x45
 800e01e:	b280      	uxth	r0, r0
 800e020:	f002 ff04 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+49, Y, 'L');
 800e024:	f105 0031 	add.w	r0, r5, #49	; 0x31
 800e028:	4621      	mov	r1, r4
 800e02a:	224c      	movs	r2, #76	; 0x4c
 800e02c:	b280      	uxth	r0, r0
 800e02e:	f002 fefd 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+80, Y, '*');
 800e032:	f105 0050 	add.w	r0, r5, #80	; 0x50
 800e036:	4621      	mov	r1, r4
 800e038:	222a      	movs	r2, #42	; 0x2a
 800e03a:	b280      	uxth	r0, r0
 800e03c:	f002 fef6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+105, Y, '*');
 800e040:	f105 0069 	add.w	r0, r5, #105	; 0x69
 800e044:	4621      	mov	r1, r4
 800e046:	222a      	movs	r2, #42	; 0x2a
 800e048:	b280      	uxth	r0, r0
 800e04a:	f002 feef 	bl	8010e2c <TFT_DrawChar>
	
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+68, Y+2, 'a');
 800e04e:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small);
 800e050:	480a      	ldr	r0, [pc, #40]	; (800e07c <GUI_Text_CIE_Lab+0x98>)
 800e052:	f002 fe75 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+68, Y+2, 'a');
 800e056:	b2a4      	uxth	r4, r4
 800e058:	f105 0044 	add.w	r0, r5, #68	; 0x44
 800e05c:	4621      	mov	r1, r4
 800e05e:	2261      	movs	r2, #97	; 0x61
 800e060:	b280      	uxth	r0, r0
 800e062:	f002 fee3 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+93, Y+2, 'b');
 800e066:	f105 005d 	add.w	r0, r5, #93	; 0x5d
 800e06a:	4621      	mov	r1, r4
 800e06c:	2262      	movs	r2, #98	; 0x62
 800e06e:	b280      	uxth	r0, r0
}
 800e070:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+93, Y+2, 'b');
 800e074:	f002 beda 	b.w	8010e2c <TFT_DrawChar>
 800e078:	200000f8 	.word	0x200000f8
 800e07c:	20000108 	.word	0x20000108

0800e080 <GUI_Text_Bluetooth>:

void GUI_Text_Bluetooth(uint16_t X, uint16_t Y)
{
 800e080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e082:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font16EN_arch_small);
 800e084:	4e29      	ldr	r6, [pc, #164]	; (800e12c <GUI_Text_Bluetooth+0xac>)
	TFT_SetTextColor(TFT_White);
 800e086:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e08a:	460f      	mov	r7, r1
	TFT_SetTextColor(TFT_White);
 800e08c:	f002 fe5e 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e090:	2063      	movs	r0, #99	; 0x63
 800e092:	f002 fe61 	bl	8010d58 <TFT_SetBackColor>
	TFT_DrawChar(X+13, Y+2, 'l');
 800e096:	1cbd      	adds	r5, r7, #2
	TFT_SetFont(&Font16EN_arch_small);
 800e098:	4630      	mov	r0, r6
	TFT_DrawChar(X+13, Y+2, 'l');
 800e09a:	b2ad      	uxth	r5, r5
	TFT_SetFont(&Font16EN_arch_small);
 800e09c:	f002 fe50 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+13, Y+2, 'l');
 800e0a0:	f104 000d 	add.w	r0, r4, #13
 800e0a4:	4629      	mov	r1, r5
 800e0a6:	226c      	movs	r2, #108	; 0x6c
 800e0a8:	b280      	uxth	r0, r0
 800e0aa:	f002 febf 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+47, Y+2, 't');
 800e0ae:	f104 002f 	add.w	r0, r4, #47	; 0x2f
 800e0b2:	4629      	mov	r1, r5
 800e0b4:	2274      	movs	r2, #116	; 0x74
 800e0b6:	b280      	uxth	r0, r0
 800e0b8:	f002 feb8 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+81, Y+2, 't');
 800e0bc:	f104 0051 	add.w	r0, r4, #81	; 0x51
 800e0c0:	4629      	mov	r1, r5
 800e0c2:	2274      	movs	r2, #116	; 0x74
 800e0c4:	b280      	uxth	r0, r0
 800e0c6:	f002 feb1 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800e0ca:	4819      	ldr	r0, [pc, #100]	; (800e130 <GUI_Text_Bluetooth+0xb0>)
 800e0cc:	f002 fe38 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'B');
 800e0d0:	4639      	mov	r1, r7
 800e0d2:	2242      	movs	r2, #66	; 0x42
 800e0d4:	4620      	mov	r0, r4
 800e0d6:	f002 fea9 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800e0da:	4630      	mov	r0, r6
 800e0dc:	f002 fe30 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+23, Y+2, 'u');
 800e0e0:	f104 0017 	add.w	r0, r4, #23
 800e0e4:	4629      	mov	r1, r5
 800e0e6:	2275      	movs	r2, #117	; 0x75
 800e0e8:	b280      	uxth	r0, r0
 800e0ea:	f002 fe9f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+36, Y+2, 'e');
 800e0ee:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800e0f2:	4629      	mov	r1, r5
 800e0f4:	2265      	movs	r2, #101	; 0x65
 800e0f6:	b280      	uxth	r0, r0
 800e0f8:	f002 fe98 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+57, Y+2, 'o');
 800e0fc:	f104 0039 	add.w	r0, r4, #57	; 0x39
 800e100:	4629      	mov	r1, r5
 800e102:	226f      	movs	r2, #111	; 0x6f
 800e104:	b280      	uxth	r0, r0
 800e106:	f002 fe91 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+70, Y+2, 'o');
 800e10a:	f104 0046 	add.w	r0, r4, #70	; 0x46
 800e10e:	4629      	mov	r1, r5
 800e110:	226f      	movs	r2, #111	; 0x6f
 800e112:	b280      	uxth	r0, r0
 800e114:	f002 fe8a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+91, Y+2, 'h');
 800e118:	f104 005b 	add.w	r0, r4, #91	; 0x5b
 800e11c:	4629      	mov	r1, r5
 800e11e:	2268      	movs	r2, #104	; 0x68
 800e120:	b280      	uxth	r0, r0
}
 800e122:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	TFT_DrawChar(X+91, Y+2, 'h');
 800e126:	f002 be81 	b.w	8010e2c <TFT_DrawChar>
 800e12a:	bf00      	nop
 800e12c:	20000108 	.word	0x20000108
 800e130:	200000f8 	.word	0x200000f8

0800e134 <GUI_Text_A>:

void GUI_Text_A(uint16_t X, uint16_t Y)
{
 800e134:	b538      	push	{r3, r4, r5, lr}
 800e136:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e138:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e13c:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e13e:	f002 fe05 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e142:	2063      	movs	r0, #99	; 0x63
 800e144:	f002 fe08 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e148:	4804      	ldr	r0, [pc, #16]	; (800e15c <GUI_Text_A+0x28>)
 800e14a:	f002 fdf9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'A');
 800e14e:	4629      	mov	r1, r5
 800e150:	4620      	mov	r0, r4
 800e152:	2241      	movs	r2, #65	; 0x41
}
 800e154:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X, Y, 'A');
 800e158:	f002 be68 	b.w	8010e2c <TFT_DrawChar>
 800e15c:	200000f8 	.word	0x200000f8

0800e160 <GUI_Text_D65>:

void GUI_Text_D65(uint16_t X, uint16_t Y)
{
 800e160:	b538      	push	{r3, r4, r5, lr}
 800e162:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e164:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e168:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e16a:	f002 fdef 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e16e:	2063      	movs	r0, #99	; 0x63
 800e170:	f002 fdf2 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e174:	480b      	ldr	r0, [pc, #44]	; (800e1a4 <GUI_Text_D65+0x44>)
 800e176:	f002 fde3 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'D');
 800e17a:	4629      	mov	r1, r5
 800e17c:	4620      	mov	r0, r4
 800e17e:	2244      	movs	r2, #68	; 0x44
 800e180:	f002 fe54 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+15, Y, '6');
 800e184:	f104 000f 	add.w	r0, r4, #15
 800e188:	4629      	mov	r1, r5
 800e18a:	2236      	movs	r2, #54	; 0x36
 800e18c:	b280      	uxth	r0, r0
 800e18e:	f002 fe4d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+32, Y, '5');
 800e192:	f104 0020 	add.w	r0, r4, #32
 800e196:	4629      	mov	r1, r5
 800e198:	2235      	movs	r2, #53	; 0x35
 800e19a:	b280      	uxth	r0, r0
}
 800e19c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+32, Y, '5');
 800e1a0:	f002 be44 	b.w	8010e2c <TFT_DrawChar>
 800e1a4:	200000f8 	.word	0x200000f8

0800e1a8 <GUI_Text_C>:

void GUI_Text_C(uint16_t X, uint16_t Y)
{
 800e1a8:	b538      	push	{r3, r4, r5, lr}
 800e1aa:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e1ac:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e1b0:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e1b2:	f002 fdcb 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e1b6:	2063      	movs	r0, #99	; 0x63
 800e1b8:	f002 fdce 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e1bc:	4804      	ldr	r0, [pc, #16]	; (800e1d0 <GUI_Text_C+0x28>)
 800e1be:	f002 fdbf 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800e1c2:	4629      	mov	r1, r5
 800e1c4:	4620      	mov	r0, r4
 800e1c6:	2243      	movs	r2, #67	; 0x43
}
 800e1c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X, Y, 'C');
 800e1cc:	f002 be2e 	b.w	8010e2c <TFT_DrawChar>
 800e1d0:	200000f8 	.word	0x200000f8

0800e1d4 <GUI_Text_D50>:

void GUI_Text_D50(uint16_t X, uint16_t Y)
{
 800e1d4:	b538      	push	{r3, r4, r5, lr}
 800e1d6:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e1d8:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e1dc:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e1de:	f002 fdb5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e1e2:	2063      	movs	r0, #99	; 0x63
 800e1e4:	f002 fdb8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e1e8:	480b      	ldr	r0, [pc, #44]	; (800e218 <GUI_Text_D50+0x44>)
 800e1ea:	f002 fda9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'D');
 800e1ee:	4629      	mov	r1, r5
 800e1f0:	4620      	mov	r0, r4
 800e1f2:	2244      	movs	r2, #68	; 0x44
 800e1f4:	f002 fe1a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+15, Y, '5');
 800e1f8:	f104 000f 	add.w	r0, r4, #15
 800e1fc:	4629      	mov	r1, r5
 800e1fe:	2235      	movs	r2, #53	; 0x35
 800e200:	b280      	uxth	r0, r0
 800e202:	f002 fe13 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+31, Y, '0');
 800e206:	f104 001f 	add.w	r0, r4, #31
 800e20a:	4629      	mov	r1, r5
 800e20c:	2230      	movs	r2, #48	; 0x30
 800e20e:	b280      	uxth	r0, r0
}
 800e210:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+31, Y, '0');
 800e214:	f002 be0a 	b.w	8010e2c <TFT_DrawChar>
 800e218:	200000f8 	.word	0x200000f8

0800e21c <GUI_Text_D55>:

void GUI_Text_D55(uint16_t X, uint16_t Y)
{
 800e21c:	b538      	push	{r3, r4, r5, lr}
 800e21e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e220:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e224:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e226:	f002 fd91 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e22a:	2063      	movs	r0, #99	; 0x63
 800e22c:	f002 fd94 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e230:	480b      	ldr	r0, [pc, #44]	; (800e260 <GUI_Text_D55+0x44>)
 800e232:	f002 fd85 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'D');
 800e236:	4629      	mov	r1, r5
 800e238:	4620      	mov	r0, r4
 800e23a:	2244      	movs	r2, #68	; 0x44
 800e23c:	f002 fdf6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+15, Y, '5');
 800e240:	f104 000f 	add.w	r0, r4, #15
 800e244:	4629      	mov	r1, r5
 800e246:	2235      	movs	r2, #53	; 0x35
 800e248:	b280      	uxth	r0, r0
 800e24a:	f002 fdef 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+31, Y, '5');
 800e24e:	f104 001f 	add.w	r0, r4, #31
 800e252:	4629      	mov	r1, r5
 800e254:	2235      	movs	r2, #53	; 0x35
 800e256:	b280      	uxth	r0, r0
}
 800e258:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+31, Y, '5');
 800e25c:	f002 bde6 	b.w	8010e2c <TFT_DrawChar>
 800e260:	200000f8 	.word	0x200000f8

0800e264 <GUI_Text_D75>:

void GUI_Text_D75(uint16_t X, uint16_t Y)
{
 800e264:	b538      	push	{r3, r4, r5, lr}
 800e266:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e268:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e26c:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e26e:	f002 fd6d 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e272:	2063      	movs	r0, #99	; 0x63
 800e274:	f002 fd70 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e278:	480b      	ldr	r0, [pc, #44]	; (800e2a8 <GUI_Text_D75+0x44>)
 800e27a:	f002 fd61 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'D');
 800e27e:	4629      	mov	r1, r5
 800e280:	4620      	mov	r0, r4
 800e282:	2244      	movs	r2, #68	; 0x44
 800e284:	f002 fdd2 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+15, Y, '7');
 800e288:	f104 000f 	add.w	r0, r4, #15
 800e28c:	4629      	mov	r1, r5
 800e28e:	2237      	movs	r2, #55	; 0x37
 800e290:	b280      	uxth	r0, r0
 800e292:	f002 fdcb 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+31, Y, '5');
 800e296:	f104 001f 	add.w	r0, r4, #31
 800e29a:	4629      	mov	r1, r5
 800e29c:	2235      	movs	r2, #53	; 0x35
 800e29e:	b280      	uxth	r0, r0
}
 800e2a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+31, Y, '5');
 800e2a4:	f002 bdc2 	b.w	8010e2c <TFT_DrawChar>
 800e2a8:	200000f8 	.word	0x200000f8

0800e2ac <GUI_Text_CIE_xy>:


void GUI_Text_CIE_xy(uint16_t X, uint16_t Y)
{
 800e2ac:	b538      	push	{r3, r4, r5, lr}
 800e2ae:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e2b0:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e2b4:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e2b6:	f002 fd49 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e2ba:	2063      	movs	r0, #99	; 0x63
 800e2bc:	f002 fd4c 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e2c0:	4815      	ldr	r0, [pc, #84]	; (800e318 <GUI_Text_CIE_xy+0x6c>)
 800e2c2:	f002 fd3d 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800e2c6:	4621      	mov	r1, r4
 800e2c8:	4628      	mov	r0, r5
 800e2ca:	2243      	movs	r2, #67	; 0x43
 800e2cc:	f002 fdae 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'I');
 800e2d0:	f105 000d 	add.w	r0, r5, #13
 800e2d4:	4621      	mov	r1, r4
 800e2d6:	2249      	movs	r2, #73	; 0x49
 800e2d8:	b280      	uxth	r0, r0
 800e2da:	f002 fda7 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y, 'E');
 800e2de:	f105 001b 	add.w	r0, r5, #27
 800e2e2:	4621      	mov	r1, r4
 800e2e4:	2245      	movs	r2, #69	; 0x45
 800e2e6:	b280      	uxth	r0, r0
 800e2e8:	f002 fda0 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+49, Y+1, 'x');
 800e2ec:	3401      	adds	r4, #1
	TFT_SetFont(&Font16EN_arch_small);
 800e2ee:	480b      	ldr	r0, [pc, #44]	; (800e31c <GUI_Text_CIE_xy+0x70>)
 800e2f0:	f002 fd26 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+49, Y+1, 'x');
 800e2f4:	b2a4      	uxth	r4, r4
 800e2f6:	f105 0031 	add.w	r0, r5, #49	; 0x31
 800e2fa:	4621      	mov	r1, r4
 800e2fc:	2278      	movs	r2, #120	; 0x78
 800e2fe:	b280      	uxth	r0, r0
 800e300:	f002 fd94 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+61, Y+1, 'y');
 800e304:	f105 003d 	add.w	r0, r5, #61	; 0x3d
 800e308:	4621      	mov	r1, r4
 800e30a:	2279      	movs	r2, #121	; 0x79
 800e30c:	b280      	uxth	r0, r0
}
 800e30e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+61, Y+1, 'y');
 800e312:	f002 bd8b 	b.w	8010e2c <TFT_DrawChar>
 800e316:	bf00      	nop
 800e318:	200000f8 	.word	0x200000f8
 800e31c:	20000108 	.word	0x20000108

0800e320 <GUI_Text_CRI>:

void GUI_Text_CRI(uint16_t X, uint16_t Y)
{
 800e320:	b538      	push	{r3, r4, r5, lr}
 800e322:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e324:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e328:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e32a:	f002 fd0f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e32e:	2063      	movs	r0, #99	; 0x63
 800e330:	f002 fd12 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e334:	480b      	ldr	r0, [pc, #44]	; (800e364 <GUI_Text_CRI+0x44>)
 800e336:	f002 fd03 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+27, Y, 'I');
 800e33a:	f104 001b 	add.w	r0, r4, #27
 800e33e:	4629      	mov	r1, r5
 800e340:	2249      	movs	r2, #73	; 0x49
 800e342:	b280      	uxth	r0, r0
 800e344:	f002 fd72 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'C');
 800e348:	4629      	mov	r1, r5
 800e34a:	4620      	mov	r0, r4
 800e34c:	2243      	movs	r2, #67	; 0x43
 800e34e:	f002 fd6d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'R');
 800e352:	f104 000d 	add.w	r0, r4, #13
 800e356:	4629      	mov	r1, r5
 800e358:	2252      	movs	r2, #82	; 0x52
 800e35a:	b280      	uxth	r0, r0
}
 800e35c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+13, Y, 'R');
 800e360:	f002 bd64 	b.w	8010e2c <TFT_DrawChar>
 800e364:	200000f8 	.word	0x200000f8

0800e368 <GUI_Text_CQS>:

void GUI_Text_CQS(uint16_t X, uint16_t Y)
{
 800e368:	b538      	push	{r3, r4, r5, lr}
 800e36a:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e36c:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e370:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e372:	f002 fceb 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e376:	2063      	movs	r0, #99	; 0x63
 800e378:	f002 fcee 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e37c:	480b      	ldr	r0, [pc, #44]	; (800e3ac <GUI_Text_CQS+0x44>)
 800e37e:	f002 fcdf 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800e382:	4629      	mov	r1, r5
 800e384:	4620      	mov	r0, r4
 800e386:	2243      	movs	r2, #67	; 0x43
 800e388:	f002 fd50 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y, 'Q');
 800e38c:	f104 000d 	add.w	r0, r4, #13
 800e390:	4629      	mov	r1, r5
 800e392:	2251      	movs	r2, #81	; 0x51
 800e394:	b280      	uxth	r0, r0
 800e396:	f002 fd49 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+28, Y, 'S');
 800e39a:	f104 001c 	add.w	r0, r4, #28
 800e39e:	4629      	mov	r1, r5
 800e3a0:	2253      	movs	r2, #83	; 0x53
 800e3a2:	b280      	uxth	r0, r0
}
 800e3a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+28, Y, 'S');
 800e3a8:	f002 bd40 	b.w	8010e2c <TFT_DrawChar>
 800e3ac:	200000f8 	.word	0x200000f8

0800e3b0 <GUI_Text_SP>:



void GUI_Text_SP(uint16_t X, uint16_t Y)
{
 800e3b0:	b538      	push	{r3, r4, r5, lr}
 800e3b2:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e3b4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e3b8:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e3ba:	f002 fcc7 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e3be:	2063      	movs	r0, #99	; 0x63
 800e3c0:	f002 fcca 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e3c4:	480b      	ldr	r0, [pc, #44]	; (800e3f4 <GUI_Text_SP+0x44>)
 800e3c6:	f002 fcbb 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+13, Y, '/');
 800e3ca:	f104 000d 	add.w	r0, r4, #13
 800e3ce:	4629      	mov	r1, r5
 800e3d0:	222f      	movs	r2, #47	; 0x2f
 800e3d2:	b280      	uxth	r0, r0
 800e3d4:	f002 fd2a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'S');
 800e3d8:	4629      	mov	r1, r5
 800e3da:	4620      	mov	r0, r4
 800e3dc:	2253      	movs	r2, #83	; 0x53
 800e3de:	f002 fd25 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+28, Y, 'P');
 800e3e2:	f104 001c 	add.w	r0, r4, #28
 800e3e6:	4629      	mov	r1, r5
 800e3e8:	2250      	movs	r2, #80	; 0x50
 800e3ea:	b280      	uxth	r0, r0
}
 800e3ec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+28, Y, 'P');
 800e3f0:	f002 bd1c 	b.w	8010e2c <TFT_DrawChar>
 800e3f4:	200000f8 	.word	0x200000f8

0800e3f8 <GUI_Text_lambda_d>:



void GUI_Text_lambda_d(uint16_t X, uint16_t Y)
{
 800e3f8:	b538      	push	{r3, r4, r5, lr}
 800e3fa:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e3fc:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e400:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e402:	f002 fca3 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e406:	2063      	movs	r0, #99	; 0x63
 800e408:	f002 fca6 	bl	8010d58 <TFT_SetBackColor>
	
	TFT_SetFont(&Font16EN_arch_big);
 800e40c:	480a      	ldr	r0, [pc, #40]	; (800e438 <GUI_Text_lambda_d+0x40>)
 800e40e:	f002 fc97 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, '~'+1);
 800e412:	4629      	mov	r1, r5
 800e414:	227f      	movs	r2, #127	; 0x7f
 800e416:	4620      	mov	r0, r4
 800e418:	f002 fd08 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800e41c:	4807      	ldr	r0, [pc, #28]	; (800e43c <GUI_Text_lambda_d+0x44>)
 800e41e:	f002 fc8f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+15, Y+7, 'd');
 800e422:	1de9      	adds	r1, r5, #7
 800e424:	f104 000f 	add.w	r0, r4, #15
 800e428:	2264      	movs	r2, #100	; 0x64
 800e42a:	b289      	uxth	r1, r1
 800e42c:	b280      	uxth	r0, r0
}
 800e42e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+15, Y+7, 'd');
 800e432:	f002 bcfb 	b.w	8010e2c <TFT_DrawChar>
 800e436:	bf00      	nop
 800e438:	200000f8 	.word	0x200000f8
 800e43c:	20000108 	.word	0x20000108

0800e440 <GUI_Text_lambda_c>:

void GUI_Text_lambda_c(uint16_t X, uint16_t Y)
{
 800e440:	b538      	push	{r3, r4, r5, lr}
 800e442:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e444:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e448:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e44a:	f002 fc7f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e44e:	2063      	movs	r0, #99	; 0x63
 800e450:	f002 fc82 	bl	8010d58 <TFT_SetBackColor>
	
	TFT_SetFont(&Font16EN_arch_big);
 800e454:	480a      	ldr	r0, [pc, #40]	; (800e480 <GUI_Text_lambda_c+0x40>)
 800e456:	f002 fc73 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, '~'+1);
 800e45a:	4629      	mov	r1, r5
 800e45c:	227f      	movs	r2, #127	; 0x7f
 800e45e:	4620      	mov	r0, r4
 800e460:	f002 fce4 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800e464:	4807      	ldr	r0, [pc, #28]	; (800e484 <GUI_Text_lambda_c+0x44>)
 800e466:	f002 fc6b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+15, Y+7, 'c');
 800e46a:	1de9      	adds	r1, r5, #7
 800e46c:	f104 000f 	add.w	r0, r4, #15
 800e470:	2263      	movs	r2, #99	; 0x63
 800e472:	b289      	uxth	r1, r1
 800e474:	b280      	uxth	r0, r0
}
 800e476:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+15, Y+7, 'c');
 800e47a:	f002 bcd7 	b.w	8010e2c <TFT_DrawChar>
 800e47e:	bf00      	nop
 800e480:	200000f8 	.word	0x200000f8
 800e484:	20000108 	.word	0x20000108

0800e488 <GUI_Text_V_lambda>:

void GUI_Text_V_lambda(uint16_t X, uint16_t Y)
{
 800e488:	b538      	push	{r3, r4, r5, lr}
 800e48a:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e48c:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e490:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e492:	f002 fc5b 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e496:	2063      	movs	r0, #99	; 0x63
 800e498:	f002 fc5e 	bl	8010d58 <TFT_SetBackColor>
	
	TFT_SetFont(&Font16EN_arch_big);
 800e49c:	4824      	ldr	r0, [pc, #144]	; (800e530 <GUI_Text_V_lambda+0xa8>)
 800e49e:	f002 fc4f 	bl	8010d40 <TFT_SetFont>

	TFT_DrawChar(X+13, Y, '(');
 800e4a2:	f104 000d 	add.w	r0, r4, #13
 800e4a6:	4629      	mov	r1, r5
 800e4a8:	2228      	movs	r2, #40	; 0x28
 800e4aa:	b280      	uxth	r0, r0
 800e4ac:	f002 fcbe 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+40, Y, ')');
 800e4b0:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800e4b4:	4629      	mov	r1, r5
 800e4b6:	2229      	movs	r2, #41	; 0x29
 800e4b8:	b280      	uxth	r0, r0
 800e4ba:	f002 fcb7 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'V');
 800e4be:	4629      	mov	r1, r5
 800e4c0:	4620      	mov	r0, r4
 800e4c2:	2256      	movs	r2, #86	; 0x56
 800e4c4:	f002 fcb2 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+26, Y, '~'+1);
 800e4c8:	f104 001a 	add.w	r0, r4, #26
 800e4cc:	4629      	mov	r1, r5
 800e4ce:	227f      	movs	r2, #127	; 0x7f
 800e4d0:	b280      	uxth	r0, r0
 800e4d2:	f002 fcab 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+53, Y, '/');
 800e4d6:	f104 0035 	add.w	r0, r4, #53	; 0x35
 800e4da:	4629      	mov	r1, r5
 800e4dc:	222f      	movs	r2, #47	; 0x2f
 800e4de:	b280      	uxth	r0, r0
 800e4e0:	f002 fca4 	bl	8010e2c <TFT_DrawChar>
		
	TFT_DrawChar(X+80, Y, '('-1);
 800e4e4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 800e4e8:	4629      	mov	r1, r5
 800e4ea:	2227      	movs	r2, #39	; 0x27
 800e4ec:	b280      	uxth	r0, r0
 800e4ee:	f002 fc9d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+90, Y, '(');
 800e4f2:	f104 005a 	add.w	r0, r4, #90	; 0x5a
 800e4f6:	4629      	mov	r1, r5
 800e4f8:	2228      	movs	r2, #40	; 0x28
 800e4fa:	b280      	uxth	r0, r0
 800e4fc:	f002 fc96 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+117, Y, ')');
 800e500:	f104 0075 	add.w	r0, r4, #117	; 0x75
 800e504:	4629      	mov	r1, r5
 800e506:	2229      	movs	r2, #41	; 0x29
 800e508:	b280      	uxth	r0, r0
 800e50a:	f002 fc8f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+68, Y, 'V');
 800e50e:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800e512:	4629      	mov	r1, r5
 800e514:	2256      	movs	r2, #86	; 0x56
 800e516:	b280      	uxth	r0, r0
 800e518:	f002 fc88 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+103, Y, '~'+1);
 800e51c:	f104 0067 	add.w	r0, r4, #103	; 0x67
 800e520:	4629      	mov	r1, r5
 800e522:	227f      	movs	r2, #127	; 0x7f
 800e524:	b280      	uxth	r0, r0
		
}
 800e526:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+103, Y, '~'+1);
 800e52a:	f002 bc7f 	b.w	8010e2c <TFT_DrawChar>
 800e52e:	bf00      	nop
 800e530:	200000f8 	.word	0x200000f8

0800e534 <GUI_Text_deltaE>:

void GUI_Text_deltaE(uint16_t X, uint16_t Y)
{
 800e534:	b538      	push	{r3, r4, r5, lr}
 800e536:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e538:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e53c:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e53e:	f002 fc05 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e542:	2063      	movs	r0, #99	; 0x63
 800e544:	f002 fc08 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e548:	4808      	ldr	r0, [pc, #32]	; (800e56c <GUI_Text_deltaE+0x38>)
 800e54a:	f002 fbf9 	bl	8010d40 <TFT_SetFont>

	TFT_DrawChar(X, Y, '~'+2);
 800e54e:	4629      	mov	r1, r5
 800e550:	4620      	mov	r0, r4
 800e552:	2280      	movs	r2, #128	; 0x80
 800e554:	f002 fc6a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+14, Y, 'E');
 800e558:	f104 000e 	add.w	r0, r4, #14
 800e55c:	4629      	mov	r1, r5
 800e55e:	2245      	movs	r2, #69	; 0x45
 800e560:	b280      	uxth	r0, r0
}
 800e562:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+14, Y, 'E');
 800e566:	f002 bc61 	b.w	8010e2c <TFT_DrawChar>
 800e56a:	bf00      	nop
 800e56c:	200000f8 	.word	0x200000f8

0800e570 <GUI_TextEn_umol>:

void GUI_TextEn_umol(uint16_t X, uint16_t Y, uint8_t deg)
{
 800e570:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800e574:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e576:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e57a:	4616      	mov	r6, r2
 800e57c:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e57e:	f002 fbe5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e582:	2063      	movs	r0, #99	; 0x63
 800e584:	f002 fbe8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font12EN_arch_small);
 800e588:	482b      	ldr	r0, [pc, #172]	; (800e638 <GUI_TextEn_umol+0xc8>)
 800e58a:	f002 fbd9 	bl	8010d40 <TFT_SetFont>
	
	if(deg){
 800e58e:	2e00      	cmp	r6, #0
 800e590:	d050      	beq.n	800e634 <GUI_TextEn_umol+0xc4>
			TFT_DrawChar(X, Y, 'm'-65);
 800e592:	222c      	movs	r2, #44	; 0x2c
	} else
	{
			TFT_DrawChar(X, Y, 'z'-64);
 800e594:	4629      	mov	r1, r5
 800e596:	4620      	mov	r0, r4
 800e598:	f002 fc48 	bl	8010e2c <TFT_DrawChar>
	}
	TFT_DrawChar(X+8, Y, 'm'-65);
	TFT_DrawChar(X+16, Y, 'o'-65);
 800e59c:	f104 0710 	add.w	r7, r4, #16
	TFT_DrawChar(X+8, Y, 'm'-65);
 800e5a0:	f104 0008 	add.w	r0, r4, #8
 800e5a4:	4629      	mov	r1, r5
	TFT_DrawChar(X+16, Y, 'o'-65);
 800e5a6:	b2bf      	uxth	r7, r7
	TFT_DrawChar(X+8, Y, 'm'-65);
 800e5a8:	222c      	movs	r2, #44	; 0x2c
 800e5aa:	b280      	uxth	r0, r0
 800e5ac:	f002 fc3e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+16, Y, 'o'-65);
 800e5b0:	4629      	mov	r1, r5
 800e5b2:	4638      	mov	r0, r7
 800e5b4:	222e      	movs	r2, #46	; 0x2e
 800e5b6:	f002 fc39 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+22, Y, 'l'-65);
 800e5ba:	f104 0016 	add.w	r0, r4, #22
 800e5be:	4629      	mov	r1, r5
 800e5c0:	222b      	movs	r2, #43	; 0x2b
 800e5c2:	b280      	uxth	r0, r0
 800e5c4:	f002 fc32 	bl	8010e2c <TFT_DrawChar>
	
	TFT_DrawLine(X, Y+10, X+25, Y+10, TFT_White);
 800e5c8:	f105 030a 	add.w	r3, r5, #10
 800e5cc:	b29b      	uxth	r3, r3
 800e5ce:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800e5d2:	f104 0219 	add.w	r2, r4, #25
 800e5d6:	4619      	mov	r1, r3
 800e5d8:	4620      	mov	r0, r4
 800e5da:	f8cd 8000 	str.w	r8, [sp]
 800e5de:	b292      	uxth	r2, r2
	
	TFT_DrawChar(X+10, Y+11, 'z'-63);
 800e5e0:	f105 060b 	add.w	r6, r5, #11
	TFT_DrawLine(X, Y+10, X+25, Y+10, TFT_White);
 800e5e4:	f002 f94c 	bl	8010880 <TFT_DrawLine>
	TFT_DrawChar(X+10, Y+11, 'z'-63);
 800e5e8:	b2b6      	uxth	r6, r6
 800e5ea:	f104 000a 	add.w	r0, r4, #10
 800e5ee:	4631      	mov	r1, r6
 800e5f0:	223b      	movs	r2, #59	; 0x3b
 800e5f2:	b280      	uxth	r0, r0
 800e5f4:	f002 fc1a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+2, Y+11, 'm'-65);
 800e5f8:	1ca0      	adds	r0, r4, #2
 800e5fa:	4631      	mov	r1, r6
 800e5fc:	222c      	movs	r2, #44	; 0x2c
 800e5fe:	b280      	uxth	r0, r0
 800e600:	f002 fc14 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawRectangle(X+16, Y+14, X+17, Y+15, TFT_White);
 800e604:	f105 030f 	add.w	r3, r5, #15
 800e608:	f104 0211 	add.w	r2, r4, #17
 800e60c:	f105 010e 	add.w	r1, r5, #14
 800e610:	4638      	mov	r0, r7
 800e612:	f8cd 8000 	str.w	r8, [sp]
 800e616:	b29b      	uxth	r3, r3
 800e618:	b292      	uxth	r2, r2
 800e61a:	b289      	uxth	r1, r1
 800e61c:	f002 f9a5 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawChar(X+19, Y+11, 's'-65);
 800e620:	f104 0013 	add.w	r0, r4, #19
 800e624:	2232      	movs	r2, #50	; 0x32
 800e626:	4631      	mov	r1, r6
 800e628:	b280      	uxth	r0, r0
}
 800e62a:	b002      	add	sp, #8
 800e62c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TFT_DrawChar(X+19, Y+11, 's'-65);
 800e630:	f002 bbfc 	b.w	8010e2c <TFT_DrawChar>
			TFT_DrawChar(X, Y, 'z'-64);
 800e634:	223a      	movs	r2, #58	; 0x3a
 800e636:	e7ad      	b.n	800e594 <GUI_TextEn_umol+0x24>
 800e638:	200000d8 	.word	0x200000d8

0800e63c <GUI_Text_On>:

void GUI_Text_On(uint16_t X, uint16_t Y)
{
 800e63c:	b538      	push	{r3, r4, r5, lr}
 800e63e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800e640:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e644:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800e646:	f002 fb81 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e64a:	2063      	movs	r0, #99	; 0x63
 800e64c:	f002 fb84 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e650:	480a      	ldr	r0, [pc, #40]	; (800e67c <GUI_Text_On+0x40>)
 800e652:	f002 fb75 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'O');
 800e656:	4629      	mov	r1, r5
 800e658:	224f      	movs	r2, #79	; 0x4f
 800e65a:	4620      	mov	r0, r4
 800e65c:	f002 fbe6 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800e660:	4807      	ldr	r0, [pc, #28]	; (800e680 <GUI_Text_On+0x44>)
 800e662:	f002 fb6d 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+16, Y+2, 'n');
 800e666:	1ca9      	adds	r1, r5, #2
 800e668:	f104 0010 	add.w	r0, r4, #16
 800e66c:	226e      	movs	r2, #110	; 0x6e
 800e66e:	b289      	uxth	r1, r1
 800e670:	b280      	uxth	r0, r0
	
}
 800e672:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+16, Y+2, 'n');
 800e676:	f002 bbd9 	b.w	8010e2c <TFT_DrawChar>
 800e67a:	bf00      	nop
 800e67c:	200000f8 	.word	0x200000f8
 800e680:	20000108 	.word	0x20000108

0800e684 <GUI_Text_Off>:

void GUI_Text_Off(uint16_t X, uint16_t Y)
{
 800e684:	b570      	push	{r4, r5, r6, lr}
 800e686:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e688:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e68c:	460e      	mov	r6, r1
	TFT_SetTextColor(TFT_White);
 800e68e:	f002 fb5d 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e692:	2063      	movs	r0, #99	; 0x63
 800e694:	f002 fb60 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_small);
	TFT_DrawChar(X+13, Y+2, 'f');
 800e698:	1cb4      	adds	r4, r6, #2
	TFT_SetFont(&Font16EN_arch_small);
 800e69a:	480e      	ldr	r0, [pc, #56]	; (800e6d4 <GUI_Text_Off+0x50>)
 800e69c:	f002 fb50 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+13, Y+2, 'f');
 800e6a0:	b2a4      	uxth	r4, r4
 800e6a2:	f105 000d 	add.w	r0, r5, #13
 800e6a6:	4621      	mov	r1, r4
 800e6a8:	2266      	movs	r2, #102	; 0x66
 800e6aa:	b280      	uxth	r0, r0
 800e6ac:	f002 fbbe 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+23, Y+2, 'f');
 800e6b0:	f105 0017 	add.w	r0, r5, #23
 800e6b4:	4621      	mov	r1, r4
 800e6b6:	2266      	movs	r2, #102	; 0x66
 800e6b8:	b280      	uxth	r0, r0
 800e6ba:	f002 fbb7 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800e6be:	4806      	ldr	r0, [pc, #24]	; (800e6d8 <GUI_Text_Off+0x54>)
 800e6c0:	f002 fb3e 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'O');
 800e6c4:	4631      	mov	r1, r6
 800e6c6:	4628      	mov	r0, r5
 800e6c8:	224f      	movs	r2, #79	; 0x4f
}
 800e6ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TFT_DrawChar(X, Y, 'O');
 800e6ce:	f002 bbad 	b.w	8010e2c <TFT_DrawChar>
 800e6d2:	bf00      	nop
 800e6d4:	20000108 	.word	0x20000108
 800e6d8:	200000f8 	.word	0x200000f8

0800e6dc <GUI_Text_EbEr>:

void GUI_Text_EbEr(uint16_t X, uint16_t Y)
{
 800e6dc:	b538      	push	{r3, r4, r5, lr}
 800e6de:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e6e0:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e6e4:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e6e6:	f002 fb31 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e6ea:	2063      	movs	r0, #99	; 0x63
 800e6ec:	f002 fb34 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e6f0:	4815      	ldr	r0, [pc, #84]	; (800e748 <GUI_Text_EbEr+0x6c>)
 800e6f2:	f002 fb25 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+19, Y+2, ',');
 800e6f6:	1ca1      	adds	r1, r4, #2
 800e6f8:	f105 0013 	add.w	r0, r5, #19
 800e6fc:	222c      	movs	r2, #44	; 0x2c
 800e6fe:	b289      	uxth	r1, r1
 800e700:	b280      	uxth	r0, r0
 800e702:	f002 fb93 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'E');
 800e706:	4621      	mov	r1, r4
 800e708:	4628      	mov	r0, r5
 800e70a:	2245      	movs	r2, #69	; 0x45
 800e70c:	f002 fb8e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+32, Y, 'E');
 800e710:	f105 0020 	add.w	r0, r5, #32
 800e714:	4621      	mov	r1, r4
 800e716:	2245      	movs	r2, #69	; 0x45
 800e718:	b280      	uxth	r0, r0
 800e71a:	f002 fb87 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font8);
	TFT_DrawChar(X+18, Y+12, 'B');
 800e71e:	340c      	adds	r4, #12
	TFT_SetFont(&Font8);
 800e720:	480a      	ldr	r0, [pc, #40]	; (800e74c <GUI_Text_EbEr+0x70>)
 800e722:	f002 fb0d 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+18, Y+12, 'B');
 800e726:	b2a4      	uxth	r4, r4
 800e728:	f105 0012 	add.w	r0, r5, #18
 800e72c:	4621      	mov	r1, r4
 800e72e:	2242      	movs	r2, #66	; 0x42
 800e730:	b280      	uxth	r0, r0
 800e732:	f002 fb7b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+50, Y+12, 'R');
 800e736:	f105 0032 	add.w	r0, r5, #50	; 0x32
 800e73a:	4621      	mov	r1, r4
 800e73c:	2252      	movs	r2, #82	; 0x52
 800e73e:	b280      	uxth	r0, r0
}
 800e740:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+50, Y+12, 'R');
 800e744:	f002 bb72 	b.w	8010e2c <TFT_DrawChar>
 800e748:	200000f8 	.word	0x200000f8
 800e74c:	20000160 	.word	0x20000160

0800e750 <GUI_Text_LbLr>:

void GUI_Text_LbLr(uint16_t X, uint16_t Y)
{
 800e750:	b538      	push	{r3, r4, r5, lr}
 800e752:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e754:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e758:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e75a:	f002 faf7 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e75e:	2063      	movs	r0, #99	; 0x63
 800e760:	f002 fafa 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800e764:	4815      	ldr	r0, [pc, #84]	; (800e7bc <GUI_Text_LbLr+0x6c>)
 800e766:	f002 faeb 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+19, Y+2, ',');
 800e76a:	1ca1      	adds	r1, r4, #2
 800e76c:	f105 0013 	add.w	r0, r5, #19
 800e770:	222c      	movs	r2, #44	; 0x2c
 800e772:	b289      	uxth	r1, r1
 800e774:	b280      	uxth	r0, r0
 800e776:	f002 fb59 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'L');
 800e77a:	4621      	mov	r1, r4
 800e77c:	4628      	mov	r0, r5
 800e77e:	224c      	movs	r2, #76	; 0x4c
 800e780:	f002 fb54 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+30, Y, 'L');
 800e784:	f105 001e 	add.w	r0, r5, #30
 800e788:	4621      	mov	r1, r4
 800e78a:	224c      	movs	r2, #76	; 0x4c
 800e78c:	b280      	uxth	r0, r0
 800e78e:	f002 fb4d 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font8);
	TFT_DrawChar(X+18, Y+12, 'B');
 800e792:	340c      	adds	r4, #12
	TFT_SetFont(&Font8);
 800e794:	480a      	ldr	r0, [pc, #40]	; (800e7c0 <GUI_Text_LbLr+0x70>)
 800e796:	f002 fad3 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+18, Y+12, 'B');
 800e79a:	b2a4      	uxth	r4, r4
 800e79c:	f105 0012 	add.w	r0, r5, #18
 800e7a0:	4621      	mov	r1, r4
 800e7a2:	2242      	movs	r2, #66	; 0x42
 800e7a4:	b280      	uxth	r0, r0
 800e7a6:	f002 fb41 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+48, Y+12, 'R');
 800e7aa:	f105 0030 	add.w	r0, r5, #48	; 0x30
 800e7ae:	4621      	mov	r1, r4
 800e7b0:	2252      	movs	r2, #82	; 0x52
 800e7b2:	b280      	uxth	r0, r0
}
 800e7b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+48, Y+12, 'R');
 800e7b8:	f002 bb38 	b.w	8010e2c <TFT_DrawChar>
 800e7bc:	200000f8 	.word	0x200000f8
 800e7c0:	20000160 	.word	0x20000160

0800e7c4 <GUI_TextEn_Language>:
///////////////////////////////////////////////////////////////////////
void GUI_TextEn_Language(uint16_t X, uint16_t Y)
{	/* Print word 'Language' */
 800e7c4:	b538      	push	{r3, r4, r5, lr}
 800e7c6:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e7c8:	f64f 70ff 	movw	r0, #65535	; 0xffff
{	/* Print word 'Language' */
 800e7cc:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e7ce:	f002 fabd 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e7d2:	2063      	movs	r0, #99	; 0x63
 800e7d4:	f002 fac0 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800e7d8:	481f      	ldr	r0, [pc, #124]	; (800e858 <GUI_TextEn_Language+0x94>)
 800e7da:	f002 fab1 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'L');
 800e7de:	4621      	mov	r1, r4
 800e7e0:	224c      	movs	r2, #76	; 0x4c
 800e7e2:	4628      	mov	r0, r5
 800e7e4:	f002 fb22 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+14, Y+2, 'a');
 800e7e8:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800e7ea:	481c      	ldr	r0, [pc, #112]	; (800e85c <GUI_TextEn_Language+0x98>)
	TFT_DrawChar(X+14, Y+2, 'a');
 800e7ec:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800e7ee:	f002 faa7 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+14, Y+2, 'a');
 800e7f2:	f105 000e 	add.w	r0, r5, #14
 800e7f6:	4621      	mov	r1, r4
 800e7f8:	2261      	movs	r2, #97	; 0x61
 800e7fa:	b280      	uxth	r0, r0
 800e7fc:	f002 fb16 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+26, Y+2, 'n');
 800e800:	f105 001a 	add.w	r0, r5, #26
 800e804:	4621      	mov	r1, r4
 800e806:	226e      	movs	r2, #110	; 0x6e
 800e808:	b280      	uxth	r0, r0
 800e80a:	f002 fb0f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+39, Y+2, 'g');
 800e80e:	f105 0027 	add.w	r0, r5, #39	; 0x27
 800e812:	4621      	mov	r1, r4
 800e814:	2267      	movs	r2, #103	; 0x67
 800e816:	b280      	uxth	r0, r0
 800e818:	f002 fb08 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+65, Y+2, 'a');
 800e81c:	f105 0041 	add.w	r0, r5, #65	; 0x41
 800e820:	4621      	mov	r1, r4
 800e822:	2261      	movs	r2, #97	; 0x61
 800e824:	b280      	uxth	r0, r0
 800e826:	f002 fb01 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+52, Y+2, 'u');
 800e82a:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800e82e:	4621      	mov	r1, r4
 800e830:	2275      	movs	r2, #117	; 0x75
 800e832:	b280      	uxth	r0, r0
 800e834:	f002 fafa 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+77, Y+2, 'g');
 800e838:	f105 004d 	add.w	r0, r5, #77	; 0x4d
 800e83c:	4621      	mov	r1, r4
 800e83e:	2267      	movs	r2, #103	; 0x67
 800e840:	b280      	uxth	r0, r0
 800e842:	f002 faf3 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+90, Y+2, 'e');
 800e846:	f105 005a 	add.w	r0, r5, #90	; 0x5a
 800e84a:	4621      	mov	r1, r4
 800e84c:	2265      	movs	r2, #101	; 0x65
 800e84e:	b280      	uxth	r0, r0
}
 800e850:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+90, Y+2, 'e');
 800e854:	f002 baea 	b.w	8010e2c <TFT_DrawChar>
 800e858:	20000100 	.word	0x20000100
 800e85c:	20000110 	.word	0x20000110

0800e860 <GUI_TextEn_English>:
void GUI_TextEn_English(uint16_t X, uint16_t Y)
{
 800e860:	b538      	push	{r3, r4, r5, lr}
 800e862:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e864:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e868:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e86a:	f002 fa6f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e86e:	2063      	movs	r0, #99	; 0x63
 800e870:	f002 fa72 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800e874:	481c      	ldr	r0, [pc, #112]	; (800e8e8 <GUI_TextEn_English+0x88>)
 800e876:	f002 fa63 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'E');
 800e87a:	4621      	mov	r1, r4
 800e87c:	2245      	movs	r2, #69	; 0x45
 800e87e:	4628      	mov	r0, r5
 800e880:	f002 fad4 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+16, Y+2, 'n');
 800e884:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800e886:	4819      	ldr	r0, [pc, #100]	; (800e8ec <GUI_TextEn_English+0x8c>)
	TFT_DrawChar(X+16, Y+2, 'n');
 800e888:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800e88a:	f002 fa59 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+16, Y+2, 'n');
 800e88e:	f105 0010 	add.w	r0, r5, #16
 800e892:	4621      	mov	r1, r4
 800e894:	226e      	movs	r2, #110	; 0x6e
 800e896:	b280      	uxth	r0, r0
 800e898:	f002 fac8 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+29, Y+2, 'g');
 800e89c:	f105 001d 	add.w	r0, r5, #29
 800e8a0:	4621      	mov	r1, r4
 800e8a2:	2267      	movs	r2, #103	; 0x67
 800e8a4:	b280      	uxth	r0, r0
 800e8a6:	f002 fac1 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+42, Y+2, 'l');
 800e8aa:	f105 002a 	add.w	r0, r5, #42	; 0x2a
 800e8ae:	4621      	mov	r1, r4
 800e8b0:	226c      	movs	r2, #108	; 0x6c
 800e8b2:	b280      	uxth	r0, r0
 800e8b4:	f002 faba 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+47, Y+2, 'i');
 800e8b8:	f105 002f 	add.w	r0, r5, #47	; 0x2f
 800e8bc:	4621      	mov	r1, r4
 800e8be:	2269      	movs	r2, #105	; 0x69
 800e8c0:	b280      	uxth	r0, r0
 800e8c2:	f002 fab3 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+53, Y+2, 's');
 800e8c6:	f105 0035 	add.w	r0, r5, #53	; 0x35
 800e8ca:	4621      	mov	r1, r4
 800e8cc:	2273      	movs	r2, #115	; 0x73
 800e8ce:	b280      	uxth	r0, r0
 800e8d0:	f002 faac 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+65, Y+2, 'h');
 800e8d4:	f105 0041 	add.w	r0, r5, #65	; 0x41
 800e8d8:	4621      	mov	r1, r4
 800e8da:	2268      	movs	r2, #104	; 0x68
 800e8dc:	b280      	uxth	r0, r0
	

}
 800e8de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+65, Y+2, 'h');
 800e8e2:	f002 baa3 	b.w	8010e2c <TFT_DrawChar>
 800e8e6:	bf00      	nop
 800e8e8:	20000100 	.word	0x20000100
 800e8ec:	20000110 	.word	0x20000110

0800e8f0 <GUI_TextEn_Info>:
void GUI_TextEn_Info(uint16_t X, uint16_t Y)
{
 800e8f0:	b538      	push	{r3, r4, r5, lr}
 800e8f2:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e8f4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e8f8:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e8fa:	f002 fa27 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e8fe:	2063      	movs	r0, #99	; 0x63
 800e900:	f002 fa2a 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800e904:	4811      	ldr	r0, [pc, #68]	; (800e94c <GUI_TextEn_Info+0x5c>)
 800e906:	f002 fa1b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'I');
 800e90a:	4621      	mov	r1, r4
 800e90c:	2249      	movs	r2, #73	; 0x49
 800e90e:	4628      	mov	r0, r5
 800e910:	f002 fa8c 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+18, Y+2, 'f');
 800e914:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800e916:	480e      	ldr	r0, [pc, #56]	; (800e950 <GUI_TextEn_Info+0x60>)
 800e918:	f002 fa12 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+18, Y+2, 'f');
 800e91c:	b2a4      	uxth	r4, r4
 800e91e:	f105 0012 	add.w	r0, r5, #18
 800e922:	4621      	mov	r1, r4
 800e924:	2266      	movs	r2, #102	; 0x66
 800e926:	b280      	uxth	r0, r0
 800e928:	f002 fa80 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+8, Y+2, 'n');
 800e92c:	f105 0008 	add.w	r0, r5, #8
 800e930:	4621      	mov	r1, r4
 800e932:	226e      	movs	r2, #110	; 0x6e
 800e934:	b280      	uxth	r0, r0
 800e936:	f002 fa79 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+29, Y+2, 'o');
 800e93a:	f105 001d 	add.w	r0, r5, #29
 800e93e:	4621      	mov	r1, r4
 800e940:	226f      	movs	r2, #111	; 0x6f
 800e942:	b280      	uxth	r0, r0
}
 800e944:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+29, Y+2, 'o');
 800e948:	f002 ba70 	b.w	8010e2c <TFT_DrawChar>
 800e94c:	20000100 	.word	0x20000100
 800e950:	20000110 	.word	0x20000110

0800e954 <GUI_TextEn_Radiance>:
void GUI_TextEn_Radiance(uint16_t X, uint16_t Y)
{
 800e954:	b538      	push	{r3, r4, r5, lr}
 800e956:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e958:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e95c:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e95e:	f002 f9f5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e962:	2063      	movs	r0, #99	; 0x63
 800e964:	f002 f9f8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800e968:	481f      	ldr	r0, [pc, #124]	; (800e9e8 <GUI_TextEn_Radiance+0x94>)
 800e96a:	f002 f9e9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'R');
 800e96e:	4621      	mov	r1, r4
 800e970:	2252      	movs	r2, #82	; 0x52
 800e972:	4628      	mov	r0, r5
 800e974:	f002 fa5a 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+16, Y+2, 'a');
 800e978:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800e97a:	481c      	ldr	r0, [pc, #112]	; (800e9ec <GUI_TextEn_Radiance+0x98>)
	TFT_DrawChar(X+16, Y+2, 'a');
 800e97c:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800e97e:	f002 f9df 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+16, Y+2, 'a');
 800e982:	f105 0010 	add.w	r0, r5, #16
 800e986:	4621      	mov	r1, r4
 800e988:	2261      	movs	r2, #97	; 0x61
 800e98a:	b280      	uxth	r0, r0
 800e98c:	f002 fa4e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+28, Y+2, 'd');
 800e990:	f105 001c 	add.w	r0, r5, #28
 800e994:	4621      	mov	r1, r4
 800e996:	2264      	movs	r2, #100	; 0x64
 800e998:	b280      	uxth	r0, r0
 800e99a:	f002 fa47 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+41, Y+2, 'i');
 800e99e:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800e9a2:	4621      	mov	r1, r4
 800e9a4:	2269      	movs	r2, #105	; 0x69
 800e9a6:	b280      	uxth	r0, r0
 800e9a8:	f002 fa40 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+46, Y+2, 'a');
 800e9ac:	f105 002e 	add.w	r0, r5, #46	; 0x2e
 800e9b0:	4621      	mov	r1, r4
 800e9b2:	2261      	movs	r2, #97	; 0x61
 800e9b4:	b280      	uxth	r0, r0
 800e9b6:	f002 fa39 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+58, Y+2, 'n');
 800e9ba:	f105 003a 	add.w	r0, r5, #58	; 0x3a
 800e9be:	4621      	mov	r1, r4
 800e9c0:	226e      	movs	r2, #110	; 0x6e
 800e9c2:	b280      	uxth	r0, r0
 800e9c4:	f002 fa32 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+71, Y+2, 'c');
 800e9c8:	f105 0047 	add.w	r0, r5, #71	; 0x47
 800e9cc:	4621      	mov	r1, r4
 800e9ce:	2263      	movs	r2, #99	; 0x63
 800e9d0:	b280      	uxth	r0, r0
 800e9d2:	f002 fa2b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+83, Y+2, 'e');
 800e9d6:	f105 0053 	add.w	r0, r5, #83	; 0x53
 800e9da:	4621      	mov	r1, r4
 800e9dc:	2265      	movs	r2, #101	; 0x65
 800e9de:	b280      	uxth	r0, r0
}
 800e9e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+83, Y+2, 'e');
 800e9e4:	f002 ba22 	b.w	8010e2c <TFT_DrawChar>
 800e9e8:	20000100 	.word	0x20000100
 800e9ec:	20000110 	.word	0x20000110

0800e9f0 <GUI_TextEn_Irradiance>:
void GUI_TextEn_Irradiance(uint16_t X, uint16_t Y)
{
 800e9f0:	b538      	push	{r3, r4, r5, lr}
 800e9f2:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800e9f4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800e9f8:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800e9fa:	f002 f9a7 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800e9fe:	2063      	movs	r0, #99	; 0x63
 800ea00:	f002 f9aa 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800ea04:	4826      	ldr	r0, [pc, #152]	; (800eaa0 <GUI_TextEn_Irradiance+0xb0>)
 800ea06:	f002 f99b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'I');
 800ea0a:	4621      	mov	r1, r4
 800ea0c:	2249      	movs	r2, #73	; 0x49
 800ea0e:	4628      	mov	r0, r5
 800ea10:	f002 fa0c 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+9, Y+2, 'r');
 800ea14:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800ea16:	4823      	ldr	r0, [pc, #140]	; (800eaa4 <GUI_TextEn_Irradiance+0xb4>)
	TFT_DrawChar(X+9, Y+2, 'r');
 800ea18:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800ea1a:	f002 f991 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+9, Y+2, 'r');
 800ea1e:	f105 0009 	add.w	r0, r5, #9
 800ea22:	4621      	mov	r1, r4
 800ea24:	2272      	movs	r2, #114	; 0x72
 800ea26:	b280      	uxth	r0, r0
 800ea28:	f002 fa00 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+21, Y+2, 'r');
 800ea2c:	f105 0015 	add.w	r0, r5, #21
 800ea30:	4621      	mov	r1, r4
 800ea32:	2272      	movs	r2, #114	; 0x72
 800ea34:	b280      	uxth	r0, r0
 800ea36:	f002 f9f9 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+32, Y+2, 'a');
 800ea3a:	f105 0020 	add.w	r0, r5, #32
 800ea3e:	4621      	mov	r1, r4
 800ea40:	2261      	movs	r2, #97	; 0x61
 800ea42:	b280      	uxth	r0, r0
 800ea44:	f002 f9f2 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+44, Y+2, 'd');
 800ea48:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800ea4c:	4621      	mov	r1, r4
 800ea4e:	2264      	movs	r2, #100	; 0x64
 800ea50:	b280      	uxth	r0, r0
 800ea52:	f002 f9eb 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+57, Y+2, 'i');
 800ea56:	f105 0039 	add.w	r0, r5, #57	; 0x39
 800ea5a:	4621      	mov	r1, r4
 800ea5c:	2269      	movs	r2, #105	; 0x69
 800ea5e:	b280      	uxth	r0, r0
 800ea60:	f002 f9e4 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+62, Y+2, 'a');
 800ea64:	f105 003e 	add.w	r0, r5, #62	; 0x3e
 800ea68:	4621      	mov	r1, r4
 800ea6a:	2261      	movs	r2, #97	; 0x61
 800ea6c:	b280      	uxth	r0, r0
 800ea6e:	f002 f9dd 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+74, Y+2, 'n');
 800ea72:	f105 004a 	add.w	r0, r5, #74	; 0x4a
 800ea76:	4621      	mov	r1, r4
 800ea78:	226e      	movs	r2, #110	; 0x6e
 800ea7a:	b280      	uxth	r0, r0
 800ea7c:	f002 f9d6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+87, Y+2, 'c');
 800ea80:	f105 0057 	add.w	r0, r5, #87	; 0x57
 800ea84:	4621      	mov	r1, r4
 800ea86:	2263      	movs	r2, #99	; 0x63
 800ea88:	b280      	uxth	r0, r0
 800ea8a:	f002 f9cf 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+99, Y+2, 'e');
 800ea8e:	f105 0063 	add.w	r0, r5, #99	; 0x63
 800ea92:	4621      	mov	r1, r4
 800ea94:	2265      	movs	r2, #101	; 0x65
 800ea96:	b280      	uxth	r0, r0
}
 800ea98:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+99, Y+2, 'e');
 800ea9c:	f002 b9c6 	b.w	8010e2c <TFT_DrawChar>
 800eaa0:	20000100 	.word	0x20000100
 800eaa4:	20000110 	.word	0x20000110

0800eaa8 <GUI_TextEn_Luminance>:
void GUI_TextEn_Luminance(uint16_t X, uint16_t Y)
{
 800eaa8:	b538      	push	{r3, r4, r5, lr}
 800eaaa:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800eaac:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800eab0:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800eab2:	f002 f94b 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800eab6:	2063      	movs	r0, #99	; 0x63
 800eab8:	f002 f94e 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800eabc:	4823      	ldr	r0, [pc, #140]	; (800eb4c <GUI_TextEn_Luminance+0xa4>)
 800eabe:	f002 f93f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'L');
 800eac2:	4621      	mov	r1, r4
 800eac4:	224c      	movs	r2, #76	; 0x4c
 800eac6:	4628      	mov	r0, r5
 800eac8:	f002 f9b0 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+13, Y+2, 'u');
 800eacc:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800eace:	4820      	ldr	r0, [pc, #128]	; (800eb50 <GUI_TextEn_Luminance+0xa8>)
	TFT_DrawChar(X+13, Y+2, 'u');
 800ead0:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800ead2:	f002 f935 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+13, Y+2, 'u');
 800ead6:	f105 000d 	add.w	r0, r5, #13
 800eada:	4621      	mov	r1, r4
 800eadc:	2275      	movs	r2, #117	; 0x75
 800eade:	b280      	uxth	r0, r0
 800eae0:	f002 f9a4 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y+2, 'm');
 800eae4:	f105 001b 	add.w	r0, r5, #27
 800eae8:	4621      	mov	r1, r4
 800eaea:	226d      	movs	r2, #109	; 0x6d
 800eaec:	b280      	uxth	r0, r0
 800eaee:	f002 f99d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+41, Y+2, 'i');
 800eaf2:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800eaf6:	4621      	mov	r1, r4
 800eaf8:	2269      	movs	r2, #105	; 0x69
 800eafa:	b280      	uxth	r0, r0
 800eafc:	f002 f996 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+59, Y+2, 'a');
 800eb00:	f105 003b 	add.w	r0, r5, #59	; 0x3b
 800eb04:	4621      	mov	r1, r4
 800eb06:	2261      	movs	r2, #97	; 0x61
 800eb08:	b280      	uxth	r0, r0
 800eb0a:	f002 f98f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+46, Y+2, 'n');
 800eb0e:	f105 002e 	add.w	r0, r5, #46	; 0x2e
 800eb12:	4621      	mov	r1, r4
 800eb14:	226e      	movs	r2, #110	; 0x6e
 800eb16:	b280      	uxth	r0, r0
 800eb18:	f002 f988 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+71, Y+2, 'n');
 800eb1c:	f105 0047 	add.w	r0, r5, #71	; 0x47
 800eb20:	4621      	mov	r1, r4
 800eb22:	226e      	movs	r2, #110	; 0x6e
 800eb24:	b280      	uxth	r0, r0
 800eb26:	f002 f981 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+84, Y+2, 'c');
 800eb2a:	f105 0054 	add.w	r0, r5, #84	; 0x54
 800eb2e:	4621      	mov	r1, r4
 800eb30:	2263      	movs	r2, #99	; 0x63
 800eb32:	b280      	uxth	r0, r0
 800eb34:	f002 f97a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+96, Y+2, 'e');
 800eb38:	f105 0060 	add.w	r0, r5, #96	; 0x60
 800eb3c:	4621      	mov	r1, r4
 800eb3e:	2265      	movs	r2, #101	; 0x65
 800eb40:	b280      	uxth	r0, r0
}
 800eb42:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+96, Y+2, 'e');
 800eb46:	f002 b971 	b.w	8010e2c <TFT_DrawChar>
 800eb4a:	bf00      	nop
 800eb4c:	20000100 	.word	0x20000100
 800eb50:	20000110 	.word	0x20000110

0800eb54 <GUI_TextEn_Illuminance>:

void GUI_TextEn_Illuminance(uint16_t X, uint16_t Y)
{
 800eb54:	b538      	push	{r3, r4, r5, lr}
 800eb56:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800eb58:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800eb5c:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800eb5e:	f002 f8f5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800eb62:	2063      	movs	r0, #99	; 0x63
 800eb64:	f002 f8f8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800eb68:	482a      	ldr	r0, [pc, #168]	; (800ec14 <GUI_TextEn_Illuminance+0xc0>)
 800eb6a:	f002 f8e9 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'I');
 800eb6e:	4621      	mov	r1, r4
 800eb70:	2249      	movs	r2, #73	; 0x49
 800eb72:	4628      	mov	r0, r5
 800eb74:	f002 f95a 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+8, Y+2, 'l');
 800eb78:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800eb7a:	4827      	ldr	r0, [pc, #156]	; (800ec18 <GUI_TextEn_Illuminance+0xc4>)
	TFT_DrawChar(X+8, Y+2, 'l');
 800eb7c:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800eb7e:	f002 f8df 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+8, Y+2, 'l');
 800eb82:	f105 0008 	add.w	r0, r5, #8
 800eb86:	4621      	mov	r1, r4
 800eb88:	226c      	movs	r2, #108	; 0x6c
 800eb8a:	b280      	uxth	r0, r0
 800eb8c:	f002 f94e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+13, Y+2, 'l');
 800eb90:	f105 000d 	add.w	r0, r5, #13
 800eb94:	4621      	mov	r1, r4
 800eb96:	226c      	movs	r2, #108	; 0x6c
 800eb98:	b280      	uxth	r0, r0
 800eb9a:	f002 f947 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+18, Y+2, 'u');
 800eb9e:	f105 0012 	add.w	r0, r5, #18
 800eba2:	4621      	mov	r1, r4
 800eba4:	2275      	movs	r2, #117	; 0x75
 800eba6:	b280      	uxth	r0, r0
 800eba8:	f002 f940 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+32, Y+2, 'm');
 800ebac:	f105 0020 	add.w	r0, r5, #32
 800ebb0:	4621      	mov	r1, r4
 800ebb2:	226d      	movs	r2, #109	; 0x6d
 800ebb4:	b280      	uxth	r0, r0
 800ebb6:	f002 f939 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+46, Y+2, 'i');
 800ebba:	f105 002e 	add.w	r0, r5, #46	; 0x2e
 800ebbe:	4621      	mov	r1, r4
 800ebc0:	2269      	movs	r2, #105	; 0x69
 800ebc2:	b280      	uxth	r0, r0
 800ebc4:	f002 f932 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+64, Y+2, 'a');
 800ebc8:	f105 0040 	add.w	r0, r5, #64	; 0x40
 800ebcc:	4621      	mov	r1, r4
 800ebce:	2261      	movs	r2, #97	; 0x61
 800ebd0:	b280      	uxth	r0, r0
 800ebd2:	f002 f92b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+51, Y+2, 'n');
 800ebd6:	f105 0033 	add.w	r0, r5, #51	; 0x33
 800ebda:	4621      	mov	r1, r4
 800ebdc:	226e      	movs	r2, #110	; 0x6e
 800ebde:	b280      	uxth	r0, r0
 800ebe0:	f002 f924 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+76, Y+2, 'n');
 800ebe4:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 800ebe8:	4621      	mov	r1, r4
 800ebea:	226e      	movs	r2, #110	; 0x6e
 800ebec:	b280      	uxth	r0, r0
 800ebee:	f002 f91d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+89, Y+2, 'c');
 800ebf2:	f105 0059 	add.w	r0, r5, #89	; 0x59
 800ebf6:	4621      	mov	r1, r4
 800ebf8:	2263      	movs	r2, #99	; 0x63
 800ebfa:	b280      	uxth	r0, r0
 800ebfc:	f002 f916 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+101, Y+2, 'e');
 800ec00:	f105 0065 	add.w	r0, r5, #101	; 0x65
 800ec04:	4621      	mov	r1, r4
 800ec06:	2265      	movs	r2, #101	; 0x65
 800ec08:	b280      	uxth	r0, r0
}
 800ec0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+101, Y+2, 'e');
 800ec0e:	f002 b90d 	b.w	8010e2c <TFT_DrawChar>
 800ec12:	bf00      	nop
 800ec14:	20000100 	.word	0x20000100
 800ec18:	20000110 	.word	0x20000110

0800ec1c <GUI_TextEn_Mode>:
void GUI_TextEn_Mode(uint16_t X, uint16_t Y)
{
 800ec1c:	b538      	push	{r3, r4, r5, lr}
 800ec1e:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800ec20:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ec24:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800ec26:	f002 f891 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ec2a:	2063      	movs	r0, #99	; 0x63
 800ec2c:	f002 f894 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800ec30:	4811      	ldr	r0, [pc, #68]	; (800ec78 <GUI_TextEn_Mode+0x5c>)
 800ec32:	f002 f885 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'M');
 800ec36:	4621      	mov	r1, r4
 800ec38:	224d      	movs	r2, #77	; 0x4d
 800ec3a:	4628      	mov	r0, r5
 800ec3c:	f002 f8f6 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+19, Y+2, 'o');
 800ec40:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800ec42:	480e      	ldr	r0, [pc, #56]	; (800ec7c <GUI_TextEn_Mode+0x60>)
 800ec44:	f002 f87c 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+19, Y+2, 'o');
 800ec48:	b2a4      	uxth	r4, r4
 800ec4a:	f105 0013 	add.w	r0, r5, #19
 800ec4e:	4621      	mov	r1, r4
 800ec50:	226f      	movs	r2, #111	; 0x6f
 800ec52:	b280      	uxth	r0, r0
 800ec54:	f002 f8ea 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+30, Y+2, 'd');
 800ec58:	f105 001e 	add.w	r0, r5, #30
 800ec5c:	4621      	mov	r1, r4
 800ec5e:	2264      	movs	r2, #100	; 0x64
 800ec60:	b280      	uxth	r0, r0
 800ec62:	f002 f8e3 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+43, Y+2, 'e');
 800ec66:	f105 002b 	add.w	r0, r5, #43	; 0x2b
 800ec6a:	4621      	mov	r1, r4
 800ec6c:	2265      	movs	r2, #101	; 0x65
 800ec6e:	b280      	uxth	r0, r0
}
 800ec70:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+43, Y+2, 'e');
 800ec74:	f002 b8da 	b.w	8010e2c <TFT_DrawChar>
 800ec78:	20000100 	.word	0x20000100
 800ec7c:	20000110 	.word	0x20000110

0800ec80 <GUI_TextEn_PPFD>:
	TFT_DrawChar(X+85, Y+2, 't');
	TFT_DrawChar(X+92, Y+2, 'h');
}
*/
void GUI_TextEn_PPFD(uint16_t X, uint16_t Y)
{
 800ec80:	b538      	push	{r3, r4, r5, lr}
 800ec82:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800ec84:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ec88:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800ec8a:	f002 f85f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ec8e:	2063      	movs	r0, #99	; 0x63
 800ec90:	f002 f862 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800ec94:	480f      	ldr	r0, [pc, #60]	; (800ecd4 <GUI_TextEn_PPFD+0x54>)
 800ec96:	f002 f853 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+48, Y, 'D');
 800ec9a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800ec9e:	4629      	mov	r1, r5
 800eca0:	2244      	movs	r2, #68	; 0x44
 800eca2:	b280      	uxth	r0, r0
 800eca4:	f002 f8c2 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+31, Y, 'F');
 800eca8:	f104 001f 	add.w	r0, r4, #31
 800ecac:	4629      	mov	r1, r5
 800ecae:	2246      	movs	r2, #70	; 0x46
 800ecb0:	b280      	uxth	r0, r0
 800ecb2:	f002 f8bb 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+16, Y, 'P');
 800ecb6:	f104 0010 	add.w	r0, r4, #16
 800ecba:	4629      	mov	r1, r5
 800ecbc:	2250      	movs	r2, #80	; 0x50
 800ecbe:	b280      	uxth	r0, r0
 800ecc0:	f002 f8b4 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'P');
 800ecc4:	4629      	mov	r1, r5
 800ecc6:	4620      	mov	r0, r4
 800ecc8:	2250      	movs	r2, #80	; 0x50
}
 800ecca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X, Y, 'P');
 800ecce:	f002 b8ad 	b.w	8010e2c <TFT_DrawChar>
 800ecd2:	bf00      	nop
 800ecd4:	20000100 	.word	0x20000100

0800ecd8 <GUI_TextEn_PARwavebands>:
	TFT_DrawChar(X+31, Y, 'L');
	TFT_DrawChar(X+16, Y, 'P');
	TFT_DrawChar(X, Y, 'P');
}
void GUI_TextEn_PARwavebands(uint16_t X, uint16_t Y)
{
 800ecd8:	b538      	push	{r3, r4, r5, lr}
 800ecda:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800ecdc:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ece0:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800ece2:	f002 f833 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ece6:	2063      	movs	r0, #99	; 0x63
 800ece8:	f002 f836 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800ecec:	482d      	ldr	r0, [pc, #180]	; (800eda4 <GUI_TextEn_PARwavebands+0xcc>)
 800ecee:	f002 f827 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+32, Y, 'R');
 800ecf2:	f105 0020 	add.w	r0, r5, #32
 800ecf6:	4621      	mov	r1, r4
 800ecf8:	2252      	movs	r2, #82	; 0x52
 800ecfa:	b280      	uxth	r0, r0
 800ecfc:	f002 f896 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+16, Y, 'A');
 800ed00:	f105 0010 	add.w	r0, r5, #16
 800ed04:	4621      	mov	r1, r4
 800ed06:	2241      	movs	r2, #65	; 0x41
 800ed08:	b280      	uxth	r0, r0
 800ed0a:	f002 f88f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'P');
 800ed0e:	4621      	mov	r1, r4
 800ed10:	2250      	movs	r2, #80	; 0x50
 800ed12:	4628      	mov	r0, r5
 800ed14:	f002 f88a 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small_A);
	TFT_DrawChar(X+75, Y+2, 'a');
 800ed18:	3402      	adds	r4, #2
	TFT_SetFont(&Font16EN_arch_small_A);
 800ed1a:	4823      	ldr	r0, [pc, #140]	; (800eda8 <GUI_TextEn_PARwavebands+0xd0>)
	TFT_DrawChar(X+75, Y+2, 'a');
 800ed1c:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16EN_arch_small_A);
 800ed1e:	f002 f80f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+75, Y+2, 'a');
 800ed22:	f105 004b 	add.w	r0, r5, #75	; 0x4b
 800ed26:	4621      	mov	r1, r4
 800ed28:	2261      	movs	r2, #97	; 0x61
 800ed2a:	b280      	uxth	r0, r0
 800ed2c:	f002 f87e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+60, Y+2, 'w');
 800ed30:	f105 003c 	add.w	r0, r5, #60	; 0x3c
 800ed34:	4621      	mov	r1, r4
 800ed36:	2277      	movs	r2, #119	; 0x77
 800ed38:	b280      	uxth	r0, r0
 800ed3a:	f002 f877 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+101, Y+2, 'e');
 800ed3e:	f105 0065 	add.w	r0, r5, #101	; 0x65
 800ed42:	4621      	mov	r1, r4
 800ed44:	2265      	movs	r2, #101	; 0x65
 800ed46:	b280      	uxth	r0, r0
 800ed48:	f002 f870 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+87, Y+2, 'v');
 800ed4c:	f105 0057 	add.w	r0, r5, #87	; 0x57
 800ed50:	4621      	mov	r1, r4
 800ed52:	2276      	movs	r2, #118	; 0x76
 800ed54:	b280      	uxth	r0, r0
 800ed56:	f002 f869 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+126, Y+2, 'a');
 800ed5a:	f105 007e 	add.w	r0, r5, #126	; 0x7e
 800ed5e:	4621      	mov	r1, r4
 800ed60:	2261      	movs	r2, #97	; 0x61
 800ed62:	b280      	uxth	r0, r0
 800ed64:	f002 f862 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+113, Y+2, 'b');
 800ed68:	f105 0071 	add.w	r0, r5, #113	; 0x71
 800ed6c:	4621      	mov	r1, r4
 800ed6e:	2262      	movs	r2, #98	; 0x62
 800ed70:	b280      	uxth	r0, r0
 800ed72:	f002 f85b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+138, Y+2, 'n');
 800ed76:	f105 008a 	add.w	r0, r5, #138	; 0x8a
 800ed7a:	4621      	mov	r1, r4
 800ed7c:	226e      	movs	r2, #110	; 0x6e
 800ed7e:	b280      	uxth	r0, r0
 800ed80:	f002 f854 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+151, Y+2, 'd');
 800ed84:	f105 0097 	add.w	r0, r5, #151	; 0x97
 800ed88:	4621      	mov	r1, r4
 800ed8a:	2264      	movs	r2, #100	; 0x64
 800ed8c:	b280      	uxth	r0, r0
 800ed8e:	f002 f84d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+165, Y+2, 's');
 800ed92:	f105 00a5 	add.w	r0, r5, #165	; 0xa5
 800ed96:	4621      	mov	r1, r4
 800ed98:	2273      	movs	r2, #115	; 0x73
 800ed9a:	b280      	uxth	r0, r0
}
 800ed9c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+165, Y+2, 's');
 800eda0:	f002 b844 	b.w	8010e2c <TFT_DrawChar>
 800eda4:	20000100 	.word	0x20000100
 800eda8:	20000110 	.word	0x20000110

0800edac <GUI_TextEn_B_G_R_FR>:
void GUI_TextEn_B_G_R_FR(uint16_t X, uint16_t Y)
{
 800edac:	b538      	push	{r3, r4, r5, lr}
 800edae:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800edb0:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800edb4:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800edb6:	f001 ffc9 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800edba:	2063      	movs	r0, #99	; 0x63
 800edbc:	f001 ffcc 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big_A);
 800edc0:	481d      	ldr	r0, [pc, #116]	; (800ee38 <GUI_TextEn_B_G_R_FR+0x8c>)
 800edc2:	f001 ffbd 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+15, Y, '-');
 800edc6:	f104 000f 	add.w	r0, r4, #15
 800edca:	4629      	mov	r1, r5
 800edcc:	222d      	movs	r2, #45	; 0x2d
 800edce:	b280      	uxth	r0, r0
 800edd0:	f002 f82c 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y, 'B');
 800edd4:	4629      	mov	r1, r5
 800edd6:	4620      	mov	r0, r4
 800edd8:	2242      	movs	r2, #66	; 0x42
 800edda:	f002 f827 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+44, Y, '-');
 800edde:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800ede2:	4629      	mov	r1, r5
 800ede4:	222d      	movs	r2, #45	; 0x2d
 800ede6:	b280      	uxth	r0, r0
 800ede8:	f002 f820 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+29, Y, 'G');
 800edec:	f104 001d 	add.w	r0, r4, #29
 800edf0:	4629      	mov	r1, r5
 800edf2:	2247      	movs	r2, #71	; 0x47
 800edf4:	b280      	uxth	r0, r0
 800edf6:	f002 f819 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+74, Y, '-');
 800edfa:	f104 004a 	add.w	r0, r4, #74	; 0x4a
 800edfe:	4629      	mov	r1, r5
 800ee00:	222d      	movs	r2, #45	; 0x2d
 800ee02:	b280      	uxth	r0, r0
 800ee04:	f002 f812 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+59, Y, 'R');	
 800ee08:	f104 003b 	add.w	r0, r4, #59	; 0x3b
 800ee0c:	4629      	mov	r1, r5
 800ee0e:	2252      	movs	r2, #82	; 0x52
 800ee10:	b280      	uxth	r0, r0
 800ee12:	f002 f80b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+87, Y, 'F');
 800ee16:	f104 0057 	add.w	r0, r4, #87	; 0x57
 800ee1a:	4629      	mov	r1, r5
 800ee1c:	2246      	movs	r2, #70	; 0x46
 800ee1e:	b280      	uxth	r0, r0
 800ee20:	f002 f804 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+103, Y, 'R');
 800ee24:	f104 0067 	add.w	r0, r4, #103	; 0x67
 800ee28:	4629      	mov	r1, r5
 800ee2a:	2252      	movs	r2, #82	; 0x52
 800ee2c:	b280      	uxth	r0, r0
}
 800ee2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+103, Y, 'R');
 800ee32:	f001 bffb 	b.w	8010e2c <TFT_DrawChar>
 800ee36:	bf00      	nop
 800ee38:	20000100 	.word	0x20000100

0800ee3c <GUI_TextEn_CCT>:
	TFT_DrawChar(X, Y, 'L');
	TFT_SetFont(&Font11EN_arch_big);
	TFT_DrawChar(X+17, Y+7, 'R');
}
void GUI_TextEn_CCT(uint16_t X, uint16_t Y)
{
 800ee3c:	b538      	push	{r3, r4, r5, lr}
 800ee3e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800ee40:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ee44:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800ee46:	f001 ff81 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ee4a:	2063      	movs	r0, #99	; 0x63
 800ee4c:	f001 ff84 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font26EN_arch_big);
 800ee50:	480b      	ldr	r0, [pc, #44]	; (800ee80 <GUI_TextEn_CCT+0x44>)
 800ee52:	f001 ff75 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C'-33);
 800ee56:	4629      	mov	r1, r5
 800ee58:	4620      	mov	r0, r4
 800ee5a:	2222      	movs	r2, #34	; 0x22
 800ee5c:	f001 ffe6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+23, Y, 'C'-33);
 800ee60:	f104 0017 	add.w	r0, r4, #23
 800ee64:	4629      	mov	r1, r5
 800ee66:	2222      	movs	r2, #34	; 0x22
 800ee68:	b280      	uxth	r0, r0
 800ee6a:	f001 ffdf 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+46, Y, 'T'-33);
 800ee6e:	f104 002e 	add.w	r0, r4, #46	; 0x2e
 800ee72:	4629      	mov	r1, r5
 800ee74:	2233      	movs	r2, #51	; 0x33
 800ee76:	b280      	uxth	r0, r0
}
 800ee78:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+46, Y, 'T'-33);
 800ee7c:	f001 bfd6 	b.w	8010e2c <TFT_DrawChar>
 800ee80:	20000130 	.word	0x20000130

0800ee84 <GUI_TextEn_W_m2>:

/* Measure dimensions */
void GUI_TextEn_W_m2(uint16_t X, uint16_t Y)
{
 800ee84:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800ee86:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800ee88:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ee8c:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800ee8e:	f001 ff5d 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ee92:	2063      	movs	r0, #99	; 0x63
 800ee94:	f001 ff60 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font9EN_arch_big);
 800ee98:	4815      	ldr	r0, [pc, #84]	; (800eef0 <GUI_TextEn_W_m2+0x6c>)
 800ee9a:	f001 ff51 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+3, Y, 'W');
 800ee9e:	1ce8      	adds	r0, r5, #3
 800eea0:	4621      	mov	r1, r4
 800eea2:	2257      	movs	r2, #87	; 0x57
 800eea4:	b280      	uxth	r0, r0
 800eea6:	f001 ffc1 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+1, Y+17, 'm');
 800eeaa:	f104 0111 	add.w	r1, r4, #17
 800eeae:	1c68      	adds	r0, r5, #1
 800eeb0:	226d      	movs	r2, #109	; 0x6d
 800eeb2:	b289      	uxth	r1, r1
 800eeb4:	b280      	uxth	r0, r0
 800eeb6:	f001 ffb9 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font6EN_arch_big);
 800eeba:	480e      	ldr	r0, [pc, #56]	; (800eef4 <GUI_TextEn_W_m2+0x70>)
 800eebc:	f001 ff40 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+11, Y+16, '2');	
 800eec0:	f104 0110 	add.w	r1, r4, #16
 800eec4:	f105 000b 	add.w	r0, r5, #11
 800eec8:	2232      	movs	r2, #50	; 0x32
 800eeca:	b289      	uxth	r1, r1
 800eecc:	b280      	uxth	r0, r0
 800eece:	f001 ffad 	bl	8010e2c <TFT_DrawChar>
  TFT_DrawLine(X, Y+14, X+17, Y+14, TFT_White);
 800eed2:	f104 030e 	add.w	r3, r4, #14
 800eed6:	b29b      	uxth	r3, r3
 800eed8:	f105 0211 	add.w	r2, r5, #17
 800eedc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800eee0:	9100      	str	r1, [sp, #0]
 800eee2:	b292      	uxth	r2, r2
 800eee4:	4619      	mov	r1, r3
 800eee6:	4628      	mov	r0, r5
 800eee8:	f001 fcca 	bl	8010880 <TFT_DrawLine>
}
 800eeec:	b003      	add	sp, #12
 800eeee:	bd30      	pop	{r4, r5, pc}
 800eef0:	20000168 	.word	0x20000168
 800eef4:	20000158 	.word	0x20000158

0800eef8 <GUI_TextEn_W_m2_sr>:
void GUI_TextEn_W_m2_sr(uint16_t X, uint16_t Y)
{
 800eef8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800eefa:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800eefc:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ef00:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800ef02:	f001 ff23 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ef06:	2063      	movs	r0, #99	; 0x63
 800ef08:	f001 ff26 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font9EN_arch_big);
 800ef0c:	4824      	ldr	r0, [pc, #144]	; (800efa0 <GUI_TextEn_W_m2_sr+0xa8>)
 800ef0e:	f001 ff17 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+12, Y, 'W');
 800ef12:	f105 000c 	add.w	r0, r5, #12
 800ef16:	4621      	mov	r1, r4
 800ef18:	2257      	movs	r2, #87	; 0x57
 800ef1a:	b280      	uxth	r0, r0
	TFT_DrawChar(X+20, Y+17, 'm');
 800ef1c:	f104 0611 	add.w	r6, r4, #17
	TFT_DrawChar(X+12, Y, 'W');
 800ef20:	f001 ff84 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+20, Y+17, 'm');
 800ef24:	b2b6      	uxth	r6, r6
 800ef26:	f105 0014 	add.w	r0, r5, #20
 800ef2a:	4631      	mov	r1, r6
 800ef2c:	226d      	movs	r2, #109	; 0x6d
 800ef2e:	b280      	uxth	r0, r0
 800ef30:	f001 ff7c 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X, Y+17, 's');
 800ef34:	4631      	mov	r1, r6
 800ef36:	4628      	mov	r0, r5
 800ef38:	2273      	movs	r2, #115	; 0x73
 800ef3a:	f001 ff77 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+7, Y+17, 'r');
 800ef3e:	1de8      	adds	r0, r5, #7
 800ef40:	4631      	mov	r1, r6
 800ef42:	2272      	movs	r2, #114	; 0x72
 800ef44:	b280      	uxth	r0, r0
 800ef46:	f001 ff71 	bl	8010e2c <TFT_DrawChar>
	TFT_FillRectangle(X+17,Y+23,X+18,Y+24,TFT_White);
 800ef4a:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800ef4e:	f104 0318 	add.w	r3, r4, #24
 800ef52:	f105 0212 	add.w	r2, r5, #18
 800ef56:	f104 0117 	add.w	r1, r4, #23
 800ef5a:	f105 0011 	add.w	r0, r5, #17
 800ef5e:	b29b      	uxth	r3, r3
 800ef60:	b292      	uxth	r2, r2
 800ef62:	b289      	uxth	r1, r1
 800ef64:	9600      	str	r6, [sp, #0]
 800ef66:	b280      	uxth	r0, r0
 800ef68:	f001 fce7 	bl	801093a <TFT_FillRectangle>
	TFT_SetFont(&Font6EN_arch_big);
 800ef6c:	480d      	ldr	r0, [pc, #52]	; (800efa4 <GUI_TextEn_W_m2_sr+0xac>)
 800ef6e:	f001 fee7 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+30, Y+16, '2');	
 800ef72:	f104 0110 	add.w	r1, r4, #16
 800ef76:	f105 001e 	add.w	r0, r5, #30
 800ef7a:	2232      	movs	r2, #50	; 0x32
 800ef7c:	b289      	uxth	r1, r1
 800ef7e:	b280      	uxth	r0, r0
 800ef80:	f001 ff54 	bl	8010e2c <TFT_DrawChar>
  TFT_DrawLine(X, Y+14, X+36, Y+14, TFT_White);
 800ef84:	f104 030e 	add.w	r3, r4, #14
 800ef88:	b29b      	uxth	r3, r3
 800ef8a:	f105 0224 	add.w	r2, r5, #36	; 0x24
 800ef8e:	9600      	str	r6, [sp, #0]
 800ef90:	b292      	uxth	r2, r2
 800ef92:	4619      	mov	r1, r3
 800ef94:	4628      	mov	r0, r5
 800ef96:	f001 fc73 	bl	8010880 <TFT_DrawLine>
}
 800ef9a:	b002      	add	sp, #8
 800ef9c:	bd70      	pop	{r4, r5, r6, pc}
 800ef9e:	bf00      	nop
 800efa0:	20000168 	.word	0x20000168
 800efa4:	20000158 	.word	0x20000158

0800efa8 <GUI_TextEn_cd_m2>:
void GUI_TextEn_cd_m2(uint16_t X, uint16_t Y, uint8_t deg)
{
 800efa8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800efac:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800efae:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800efb2:	460d      	mov	r5, r1
 800efb4:	4616      	mov	r6, r2
	TFT_SetTextColor(TFT_White);
 800efb6:	f001 fec9 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800efba:	2063      	movs	r0, #99	; 0x63
 800efbc:	f001 fecc 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font9EN_arch_big);
 800efc0:	482f      	ldr	r0, [pc, #188]	; (800f080 <GUI_TextEn_cd_m2+0xd8>)
 800efc2:	f001 febd 	bl	8010d40 <TFT_SetFont>
	
	if (deg==1)
 800efc6:	2e01      	cmp	r6, #1
 800efc8:	f105 0911 	add.w	r9, r5, #17
 800efcc:	f105 0810 	add.w	r8, r5, #16
 800efd0:	f105 060e 	add.w	r6, r5, #14
 800efd4:	d131      	bne.n	800f03a <GUI_TextEn_cd_m2+0x92>
	{
		TFT_DrawChar(X, Y, 'k');
 800efd6:	226b      	movs	r2, #107	; 0x6b
 800efd8:	4629      	mov	r1, r5
 800efda:	4620      	mov	r0, r4
 800efdc:	f001 ff26 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+7, Y, 'c');
 800efe0:	1de0      	adds	r0, r4, #7
 800efe2:	2263      	movs	r2, #99	; 0x63
 800efe4:	4629      	mov	r1, r5
 800efe6:	b280      	uxth	r0, r0
 800efe8:	f001 ff20 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+14, Y, 'd');
 800efec:	f104 000e 	add.w	r0, r4, #14
 800eff0:	2264      	movs	r2, #100	; 0x64
 800eff2:	4629      	mov	r1, r5
 800eff4:	b280      	uxth	r0, r0
 800eff6:	f001 ff19 	bl	8010e2c <TFT_DrawChar>
		
		TFT_DrawChar(X+5, Y+17, 'm');
 800effa:	1d60      	adds	r0, r4, #5
 800effc:	226d      	movs	r2, #109	; 0x6d
 800effe:	fa1f f189 	uxth.w	r1, r9
 800f002:	b280      	uxth	r0, r0
 800f004:	f001 ff12 	bl	8010e2c <TFT_DrawChar>
		TFT_SetFont(&Font6EN_arch_big);
 800f008:	481e      	ldr	r0, [pc, #120]	; (800f084 <GUI_TextEn_cd_m2+0xdc>)
 800f00a:	f001 fe99 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+15, Y+16, '2');	
 800f00e:	f104 000f 	add.w	r0, r4, #15
 800f012:	2232      	movs	r2, #50	; 0x32
 800f014:	fa1f f188 	uxth.w	r1, r8
 800f018:	b280      	uxth	r0, r0
 800f01a:	f001 ff07 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawLine(X, Y+14, X+22, Y+14, TFT_White);
 800f01e:	b2b3      	uxth	r3, r6
 800f020:	f104 0216 	add.w	r2, r4, #22
		TFT_DrawChar(X+9, Y, 'd');
		
		TFT_DrawChar(X+2, Y+17, 'm');
		TFT_SetFont(&Font6EN_arch_big);
		TFT_DrawChar(X+12, Y+16, '2');	
		TFT_DrawLine(X, Y+14, X+19, Y+14, TFT_White);
 800f024:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800f028:	9100      	str	r1, [sp, #0]
 800f02a:	b292      	uxth	r2, r2
 800f02c:	4619      	mov	r1, r3
 800f02e:	4620      	mov	r0, r4
 800f030:	f001 fc26 	bl	8010880 <TFT_DrawLine>
	}
}
 800f034:	b003      	add	sp, #12
 800f036:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		TFT_DrawChar(X+2, Y, 'c');
 800f03a:	1ca7      	adds	r7, r4, #2
 800f03c:	b2bf      	uxth	r7, r7
 800f03e:	2263      	movs	r2, #99	; 0x63
 800f040:	4629      	mov	r1, r5
 800f042:	4638      	mov	r0, r7
 800f044:	f001 fef2 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+9, Y, 'd');
 800f048:	f104 0009 	add.w	r0, r4, #9
 800f04c:	2264      	movs	r2, #100	; 0x64
 800f04e:	4629      	mov	r1, r5
 800f050:	b280      	uxth	r0, r0
 800f052:	f001 feeb 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+2, Y+17, 'm');
 800f056:	226d      	movs	r2, #109	; 0x6d
 800f058:	fa1f f189 	uxth.w	r1, r9
 800f05c:	4638      	mov	r0, r7
 800f05e:	f001 fee5 	bl	8010e2c <TFT_DrawChar>
		TFT_SetFont(&Font6EN_arch_big);
 800f062:	4808      	ldr	r0, [pc, #32]	; (800f084 <GUI_TextEn_cd_m2+0xdc>)
 800f064:	f001 fe6c 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+12, Y+16, '2');	
 800f068:	f104 000c 	add.w	r0, r4, #12
 800f06c:	2232      	movs	r2, #50	; 0x32
 800f06e:	fa1f f188 	uxth.w	r1, r8
 800f072:	b280      	uxth	r0, r0
 800f074:	f001 feda 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawLine(X, Y+14, X+19, Y+14, TFT_White);
 800f078:	b2b3      	uxth	r3, r6
 800f07a:	f104 0213 	add.w	r2, r4, #19
 800f07e:	e7d1      	b.n	800f024 <GUI_TextEn_cd_m2+0x7c>
 800f080:	20000168 	.word	0x20000168
 800f084:	20000158 	.word	0x20000158

0800f088 <GUI_TextEn_Green>:
	TFT_DrawChar(X+23, Y+16, '2');

  TFT_DrawLine(X, Y+14, X+30, Y+14, TFT_White);	
}
void GUI_TextEn_Green(uint16_t X, uint16_t Y)
{
 800f088:	b538      	push	{r3, r4, r5, lr}
 800f08a:	4605      	mov	r5, r0
 800f08c:	460c      	mov	r4, r1
		TFT_SetFont(&Font16EN_arch_big);
 800f08e:	4815      	ldr	r0, [pc, #84]	; (800f0e4 <GUI_TextEn_Green+0x5c>)
 800f090:	f001 fe56 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X, Y, 'G');
 800f094:	4621      	mov	r1, r4
 800f096:	2247      	movs	r2, #71	; 0x47
 800f098:	4628      	mov	r0, r5
 800f09a:	f001 fec7 	bl	8010e2c <TFT_DrawChar>
		TFT_SetFont(&Font16EN_arch_small);
		TFT_DrawChar(X+15, Y+2, 'r');
 800f09e:	3402      	adds	r4, #2
		TFT_SetFont(&Font16EN_arch_small);
 800f0a0:	4811      	ldr	r0, [pc, #68]	; (800f0e8 <GUI_TextEn_Green+0x60>)
 800f0a2:	f001 fe4d 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+15, Y+2, 'r');
 800f0a6:	b2a4      	uxth	r4, r4
 800f0a8:	f105 000f 	add.w	r0, r5, #15
 800f0ac:	4621      	mov	r1, r4
 800f0ae:	2272      	movs	r2, #114	; 0x72
 800f0b0:	b280      	uxth	r0, r0
 800f0b2:	f001 febb 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+26, Y+2, 'e');
 800f0b6:	f105 001a 	add.w	r0, r5, #26
 800f0ba:	4621      	mov	r1, r4
 800f0bc:	2265      	movs	r2, #101	; 0x65
 800f0be:	b280      	uxth	r0, r0
 800f0c0:	f001 feb4 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+38, Y+2, 'e');
 800f0c4:	f105 0026 	add.w	r0, r5, #38	; 0x26
 800f0c8:	4621      	mov	r1, r4
 800f0ca:	2265      	movs	r2, #101	; 0x65
 800f0cc:	b280      	uxth	r0, r0
 800f0ce:	f001 fead 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+50, Y+2, 'n');
 800f0d2:	f105 0032 	add.w	r0, r5, #50	; 0x32
 800f0d6:	4621      	mov	r1, r4
 800f0d8:	226e      	movs	r2, #110	; 0x6e
 800f0da:	b280      	uxth	r0, r0
}
 800f0dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		TFT_DrawChar(X+50, Y+2, 'n');
 800f0e0:	f001 bea4 	b.w	8010e2c <TFT_DrawChar>
 800f0e4:	200000f8 	.word	0x200000f8
 800f0e8:	20000108 	.word	0x20000108

0800f0ec <GUI_TextEn_Blue>:
void GUI_TextEn_Blue(uint16_t X, uint16_t Y)
{
 800f0ec:	b538      	push	{r3, r4, r5, lr}
 800f0ee:	4605      	mov	r5, r0
 800f0f0:	460c      	mov	r4, r1
		TFT_SetFont(&Font16EN_arch_big);
 800f0f2:	4812      	ldr	r0, [pc, #72]	; (800f13c <GUI_TextEn_Blue+0x50>)
 800f0f4:	f001 fe24 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X, Y, 'B');
 800f0f8:	4621      	mov	r1, r4
 800f0fa:	2242      	movs	r2, #66	; 0x42
 800f0fc:	4628      	mov	r0, r5
 800f0fe:	f001 fe95 	bl	8010e2c <TFT_DrawChar>
		TFT_SetFont(&Font16EN_arch_small_A);
		TFT_DrawChar(X+15, Y+2, 'l');
 800f102:	3402      	adds	r4, #2
		TFT_SetFont(&Font16EN_arch_small_A);
 800f104:	480e      	ldr	r0, [pc, #56]	; (800f140 <GUI_TextEn_Blue+0x54>)
 800f106:	f001 fe1b 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+15, Y+2, 'l');
 800f10a:	b2a4      	uxth	r4, r4
 800f10c:	f105 000f 	add.w	r0, r5, #15
 800f110:	4621      	mov	r1, r4
 800f112:	226c      	movs	r2, #108	; 0x6c
 800f114:	b280      	uxth	r0, r0
 800f116:	f001 fe89 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+20, Y+2, 'u');
 800f11a:	f105 0014 	add.w	r0, r5, #20
 800f11e:	4621      	mov	r1, r4
 800f120:	2275      	movs	r2, #117	; 0x75
 800f122:	b280      	uxth	r0, r0
 800f124:	f001 fe82 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+33, Y+2, 'e');
 800f128:	f105 0021 	add.w	r0, r5, #33	; 0x21
 800f12c:	4621      	mov	r1, r4
 800f12e:	2265      	movs	r2, #101	; 0x65
 800f130:	b280      	uxth	r0, r0
}
 800f132:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		TFT_DrawChar(X+33, Y+2, 'e');
 800f136:	f001 be79 	b.w	8010e2c <TFT_DrawChar>
 800f13a:	bf00      	nop
 800f13c:	200000f8 	.word	0x200000f8
 800f140:	20000110 	.word	0x20000110

0800f144 <GUI_TextEn_Red>:
void GUI_TextEn_Red(uint16_t X, uint16_t Y)
{
 800f144:	b538      	push	{r3, r4, r5, lr}
 800f146:	4605      	mov	r5, r0
 800f148:	460c      	mov	r4, r1
		TFT_SetFont(&Font16EN_arch_big);
 800f14a:	480e      	ldr	r0, [pc, #56]	; (800f184 <GUI_TextEn_Red+0x40>)
 800f14c:	f001 fdf8 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X, Y, 'R');
 800f150:	4621      	mov	r1, r4
 800f152:	2252      	movs	r2, #82	; 0x52
 800f154:	4628      	mov	r0, r5
 800f156:	f001 fe69 	bl	8010e2c <TFT_DrawChar>
		TFT_SetFont(&Font16EN_arch_small);
		TFT_DrawChar(X+16, Y+2, 'e');
 800f15a:	3402      	adds	r4, #2
		TFT_SetFont(&Font16EN_arch_small);
 800f15c:	480a      	ldr	r0, [pc, #40]	; (800f188 <GUI_TextEn_Red+0x44>)
 800f15e:	f001 fdef 	bl	8010d40 <TFT_SetFont>
		TFT_DrawChar(X+16, Y+2, 'e');
 800f162:	b2a4      	uxth	r4, r4
 800f164:	f105 0010 	add.w	r0, r5, #16
 800f168:	4621      	mov	r1, r4
 800f16a:	2265      	movs	r2, #101	; 0x65
 800f16c:	b280      	uxth	r0, r0
 800f16e:	f001 fe5d 	bl	8010e2c <TFT_DrawChar>
		TFT_DrawChar(X+29, Y+2, 'd');
 800f172:	f105 001d 	add.w	r0, r5, #29
 800f176:	4621      	mov	r1, r4
 800f178:	2264      	movs	r2, #100	; 0x64
 800f17a:	b280      	uxth	r0, r0
}
 800f17c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		TFT_DrawChar(X+29, Y+2, 'd');
 800f180:	f001 be54 	b.w	8010e2c <TFT_DrawChar>
 800f184:	200000f8 	.word	0x200000f8
 800f188:	20000108 	.word	0x20000108

0800f18c <GUI_TextEn_Info_Callibration>:

void GUI_TextEn_Info_Callibration(uint16_t X, uint16_t Y, uint8_t date, uint8_t month, uint16_t year)
{
 800f18c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800f18e:	461e      	mov	r6, r3
	char buffer[5] = {0};
	
	X = 70;
	Y = 100;
	
	TFT_SetTextColor(TFT_White);
 800f190:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800f194:	2300      	movs	r3, #0
 800f196:	9300      	str	r3, [sp, #0]
 800f198:	f88d 3004 	strb.w	r3, [sp, #4]
{
 800f19c:	4614      	mov	r4, r2
	TFT_SetTextColor(TFT_White);
 800f19e:	f001 fdd5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f1a2:	2063      	movs	r0, #99	; 0x63
 800f1a4:	f001 fdd8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800f1a8:	4834      	ldr	r0, [pc, #208]	; (800f27c <GUI_TextEn_Info_Callibration+0xf0>)
	TFT_DrawChar(X+89, Y+2, 't');
	TFT_DrawChar(X+97, Y+2, 'i');
	TFT_DrawChar(X+108, Y+2, 'o');
	TFT_DrawChar(X+120, Y+2, 'n');
	
	sprintf (buffer, "%02u",  date);
 800f1aa:	4d35      	ldr	r5, [pc, #212]	; (800f280 <GUI_TextEn_Info_Callibration+0xf4>)
	TFT_SetFont(&Font16EN_arch_big);
 800f1ac:	f001 fdc8 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'C');
 800f1b0:	2243      	movs	r2, #67	; 0x43
 800f1b2:	2164      	movs	r1, #100	; 0x64
 800f1b4:	2046      	movs	r0, #70	; 0x46
 800f1b6:	f001 fe39 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800f1ba:	4832      	ldr	r0, [pc, #200]	; (800f284 <GUI_TextEn_Info_Callibration+0xf8>)
 800f1bc:	f001 fdc0 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+16, Y+2, 'a');
 800f1c0:	2261      	movs	r2, #97	; 0x61
 800f1c2:	2166      	movs	r1, #102	; 0x66
 800f1c4:	2056      	movs	r0, #86	; 0x56
 800f1c6:	f001 fe31 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+29, Y+2, 'l');
 800f1ca:	226c      	movs	r2, #108	; 0x6c
 800f1cc:	2166      	movs	r1, #102	; 0x66
 800f1ce:	2063      	movs	r0, #99	; 0x63
 800f1d0:	f001 fe2c 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+38, Y+2, 'i');
 800f1d4:	2269      	movs	r2, #105	; 0x69
 800f1d6:	2166      	movs	r1, #102	; 0x66
 800f1d8:	206c      	movs	r0, #108	; 0x6c
 800f1da:	f001 fe27 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+50, Y+2, 'b');
 800f1de:	2262      	movs	r2, #98	; 0x62
 800f1e0:	2166      	movs	r1, #102	; 0x66
 800f1e2:	2078      	movs	r0, #120	; 0x78
 800f1e4:	f001 fe22 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+63, Y+2, 'r');
 800f1e8:	2272      	movs	r2, #114	; 0x72
 800f1ea:	2166      	movs	r1, #102	; 0x66
 800f1ec:	2085      	movs	r0, #133	; 0x85
 800f1ee:	f001 fe1d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+76, Y+2, 'a');
 800f1f2:	2261      	movs	r2, #97	; 0x61
 800f1f4:	2166      	movs	r1, #102	; 0x66
 800f1f6:	2092      	movs	r0, #146	; 0x92
 800f1f8:	f001 fe18 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+89, Y+2, 't');
 800f1fc:	2274      	movs	r2, #116	; 0x74
 800f1fe:	2166      	movs	r1, #102	; 0x66
 800f200:	209f      	movs	r0, #159	; 0x9f
 800f202:	f001 fe13 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+97, Y+2, 'i');
 800f206:	2269      	movs	r2, #105	; 0x69
 800f208:	2166      	movs	r1, #102	; 0x66
 800f20a:	20a7      	movs	r0, #167	; 0xa7
 800f20c:	f001 fe0e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+108, Y+2, 'o');
 800f210:	226f      	movs	r2, #111	; 0x6f
 800f212:	2166      	movs	r1, #102	; 0x66
 800f214:	20b2      	movs	r0, #178	; 0xb2
 800f216:	f001 fe09 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+120, Y+2, 'n');
 800f21a:	226e      	movs	r2, #110	; 0x6e
 800f21c:	2166      	movs	r1, #102	; 0x66
 800f21e:	20be      	movs	r0, #190	; 0xbe
 800f220:	f001 fe04 	bl	8010e2c <TFT_DrawChar>
	sprintf (buffer, "%02u",  date);
 800f224:	4622      	mov	r2, r4
 800f226:	4629      	mov	r1, r5
 800f228:	4668      	mov	r0, sp
 800f22a:	f003 f8af 	bl	801238c <siprintf>
	TFT_SetFont(&Font26EN_arch_digit);
 800f22e:	4816      	ldr	r0, [pc, #88]	; (800f288 <GUI_TextEn_Info_Callibration+0xfc>)
 800f230:	f001 fd86 	bl	8010d40 <TFT_SetFont>
	buffer[2] = '.';
 800f234:	242e      	movs	r4, #46	; 0x2e
	TFT_DisplayString(30, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f236:	2303      	movs	r3, #3
 800f238:	466a      	mov	r2, sp
 800f23a:	2182      	movs	r1, #130	; 0x82
 800f23c:	201e      	movs	r0, #30
	buffer[2] = '.';
 800f23e:	f88d 4002 	strb.w	r4, [sp, #2]
	TFT_DisplayString(30, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f242:	f001 fe4b 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%02u",  month);
 800f246:	4632      	mov	r2, r6
 800f248:	4629      	mov	r1, r5
 800f24a:	4668      	mov	r0, sp
 800f24c:	f003 f89e 	bl	801238c <siprintf>
	buffer[2] = '.';
	TFT_DisplayString(30+60, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f250:	2303      	movs	r3, #3
 800f252:	466a      	mov	r2, sp
 800f254:	2182      	movs	r1, #130	; 0x82
 800f256:	205a      	movs	r0, #90	; 0x5a
	buffer[2] = '.';
 800f258:	f88d 4002 	strb.w	r4, [sp, #2]
	TFT_DisplayString(30+60, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f25c:	f001 fe3e 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%4u",  year);
 800f260:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 800f264:	4909      	ldr	r1, [pc, #36]	; (800f28c <GUI_TextEn_Info_Callibration+0x100>)
 800f266:	4668      	mov	r0, sp
 800f268:	f003 f890 	bl	801238c <siprintf>
	TFT_DisplayString(30+125, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f26c:	2303      	movs	r3, #3
 800f26e:	466a      	mov	r2, sp
 800f270:	2182      	movs	r1, #130	; 0x82
 800f272:	209b      	movs	r0, #155	; 0x9b
 800f274:	f001 fe32 	bl	8010edc <TFT_DisplayString>
}
 800f278:	b002      	add	sp, #8
 800f27a:	bd70      	pop	{r4, r5, r6, pc}
 800f27c:	200000f8 	.word	0x200000f8
 800f280:	0801f565 	.word	0x0801f565
 800f284:	20000108 	.word	0x20000108
 800f288:	20000138 	.word	0x20000138
 800f28c:	0801f56a 	.word	0x0801f56a

0800f290 <GUI_TextEn_Info_Serial>:

void GUI_TextEn_Info_Serial(uint16_t X, uint16_t Y, uint16_t Part, uint16_t Number)
{
 800f290:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800f292:	461c      	mov	r4, r3
	char buffer[5] = {0};
	
	X = 60;
	Y = 200;
	
	TFT_SetTextColor(TFT_White);
 800f294:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800f298:	2300      	movs	r3, #0
 800f29a:	9300      	str	r3, [sp, #0]
 800f29c:	f88d 3004 	strb.w	r3, [sp, #4]
{
 800f2a0:	4615      	mov	r5, r2
	TFT_SetTextColor(TFT_White);
 800f2a2:	f001 fd53 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f2a6:	2063      	movs	r0, #99	; 0x63
 800f2a8:	f001 fd56 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800f2ac:	482e      	ldr	r0, [pc, #184]	; (800f368 <GUI_TextEn_Info_Serial+0xd8>)
 800f2ae:	f001 fd47 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'S');
 800f2b2:	2253      	movs	r2, #83	; 0x53
 800f2b4:	21c8      	movs	r1, #200	; 0xc8
 800f2b6:	203c      	movs	r0, #60	; 0x3c
 800f2b8:	f001 fdb8 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800f2bc:	482b      	ldr	r0, [pc, #172]	; (800f36c <GUI_TextEn_Info_Serial+0xdc>)
 800f2be:	f001 fd3f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+17, Y+2, 'e');
 800f2c2:	2265      	movs	r2, #101	; 0x65
 800f2c4:	21ca      	movs	r1, #202	; 0xca
 800f2c6:	204d      	movs	r0, #77	; 0x4d
 800f2c8:	f001 fdb0 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+30, Y+2, 'r');
 800f2cc:	2272      	movs	r2, #114	; 0x72
 800f2ce:	21ca      	movs	r1, #202	; 0xca
 800f2d0:	205a      	movs	r0, #90	; 0x5a
 800f2d2:	f001 fdab 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+42, Y+2, 'i');
 800f2d6:	2269      	movs	r2, #105	; 0x69
 800f2d8:	21ca      	movs	r1, #202	; 0xca
 800f2da:	2066      	movs	r0, #102	; 0x66
 800f2dc:	f001 fda6 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+54, Y+2, 'a');
 800f2e0:	2261      	movs	r2, #97	; 0x61
 800f2e2:	21ca      	movs	r1, #202	; 0xca
 800f2e4:	2072      	movs	r0, #114	; 0x72
 800f2e6:	f001 fda1 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+67, Y+2, 'l');
 800f2ea:	226c      	movs	r2, #108	; 0x6c
 800f2ec:	21ca      	movs	r1, #202	; 0xca
 800f2ee:	207f      	movs	r0, #127	; 0x7f
 800f2f0:	f001 fd9c 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+89, Y+2, 'n');
 800f2f4:	226e      	movs	r2, #110	; 0x6e
 800f2f6:	21ca      	movs	r1, #202	; 0xca
 800f2f8:	2095      	movs	r0, #149	; 0x95
 800f2fa:	f001 fd97 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+102, Y+2, 'u');
 800f2fe:	2275      	movs	r2, #117	; 0x75
 800f300:	21ca      	movs	r1, #202	; 0xca
 800f302:	20a2      	movs	r0, #162	; 0xa2
 800f304:	f001 fd92 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+115, Y+2, 'm');
 800f308:	226d      	movs	r2, #109	; 0x6d
 800f30a:	21ca      	movs	r1, #202	; 0xca
 800f30c:	20af      	movs	r0, #175	; 0xaf
 800f30e:	f001 fd8d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+128, Y+2, 'b');
 800f312:	2262      	movs	r2, #98	; 0x62
 800f314:	21ca      	movs	r1, #202	; 0xca
 800f316:	20bc      	movs	r0, #188	; 0xbc
 800f318:	f001 fd88 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+141, Y+2, 'e');
 800f31c:	2265      	movs	r2, #101	; 0x65
 800f31e:	21ca      	movs	r1, #202	; 0xca
 800f320:	20c9      	movs	r0, #201	; 0xc9
 800f322:	f001 fd83 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+154, Y+2, 'r');
 800f326:	2272      	movs	r2, #114	; 0x72
 800f328:	21ca      	movs	r1, #202	; 0xca
 800f32a:	20d6      	movs	r0, #214	; 0xd6
 800f32c:	f001 fd7e 	bl	8010e2c <TFT_DrawChar>

	
	sprintf (buffer, "%u",  Part);
 800f330:	462a      	mov	r2, r5
 800f332:	490f      	ldr	r1, [pc, #60]	; (800f370 <GUI_TextEn_Info_Serial+0xe0>)
 800f334:	4668      	mov	r0, sp
 800f336:	f003 f829 	bl	801238c <siprintf>
	TFT_SetFont(&Font26EN_arch_digit);
 800f33a:	480e      	ldr	r0, [pc, #56]	; (800f374 <GUI_TextEn_Info_Serial+0xe4>)
 800f33c:	f001 fd00 	bl	8010d40 <TFT_SetFont>
	TFT_DisplayString(40, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f340:	2303      	movs	r3, #3
 800f342:	466a      	mov	r2, sp
 800f344:	21e6      	movs	r1, #230	; 0xe6
 800f346:	2028      	movs	r0, #40	; 0x28
 800f348:	f001 fdc8 	bl	8010edc <TFT_DisplayString>
	sprintf (buffer, "%04u",  Number);
 800f34c:	4622      	mov	r2, r4
 800f34e:	490a      	ldr	r1, [pc, #40]	; (800f378 <GUI_TextEn_Info_Serial+0xe8>)
 800f350:	4668      	mov	r0, sp
 800f352:	f003 f81b 	bl	801238c <siprintf>
	TFT_DisplayString(135, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800f356:	2303      	movs	r3, #3
 800f358:	466a      	mov	r2, sp
 800f35a:	21e6      	movs	r1, #230	; 0xe6
 800f35c:	2087      	movs	r0, #135	; 0x87
 800f35e:	f001 fdbd 	bl	8010edc <TFT_DisplayString>
}
 800f362:	b003      	add	sp, #12
 800f364:	bd30      	pop	{r4, r5, pc}
 800f366:	bf00      	nop
 800f368:	200000f8 	.word	0x200000f8
 800f36c:	20000108 	.word	0x20000108
 800f370:	0801f56e 	.word	0x0801f56e
 800f374:	20000138 	.word	0x20000138
 800f378:	0801f571 	.word	0x0801f571

0800f37c <GUI_TextEn_Info_Ver>:

void GUI_TextEn_Info_Ver(uint16_t X, uint16_t Y, float Version)
{
 800f37c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char buffer[5] = {0};
 800f37e:	2300      	movs	r3, #0
	
	X = 20;
	Y = 350;
	
	TFT_SetTextColor(TFT_White);
 800f380:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800f384:	9302      	str	r3, [sp, #8]
 800f386:	f88d 300c 	strb.w	r3, [sp, #12]
{
 800f38a:	ed8d 0a01 	vstr	s0, [sp, #4]
	TFT_SetTextColor(TFT_White);
 800f38e:	f001 fcdd 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f392:	2063      	movs	r0, #99	; 0x63
 800f394:	f001 fce0 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800f398:	482e      	ldr	r0, [pc, #184]	; (800f454 <GUI_TextEn_Info_Ver+0xd8>)
	TFT_DrawChar(X+55, Y+2, 'w');
	TFT_DrawChar(X+70, Y+2, 'a');
	TFT_DrawChar(X+86, Y+2, 'r');
	TFT_DrawChar(X+99, Y+2, 'e');
	
	TFT_SetFont(&Font16);
 800f39a:	4c2f      	ldr	r4, [pc, #188]	; (800f458 <GUI_TextEn_Info_Ver+0xdc>)
	TFT_SetFont(&Font16EN_arch_big);
 800f39c:	f001 fcd0 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, Y, 'F');
 800f3a0:	2246      	movs	r2, #70	; 0x46
 800f3a2:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800f3a6:	2014      	movs	r0, #20
 800f3a8:	f001 fd40 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800f3ac:	482b      	ldr	r0, [pc, #172]	; (800f45c <GUI_TextEn_Info_Ver+0xe0>)
 800f3ae:	f001 fcc7 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+16, Y+2, 'i');
 800f3b2:	2269      	movs	r2, #105	; 0x69
 800f3b4:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3b8:	2024      	movs	r0, #36	; 0x24
 800f3ba:	f001 fd37 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+27, Y+2, 'r');
 800f3be:	2272      	movs	r2, #114	; 0x72
 800f3c0:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3c4:	202f      	movs	r0, #47	; 0x2f
 800f3c6:	f001 fd31 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+40, Y+2, 'm');
 800f3ca:	226d      	movs	r2, #109	; 0x6d
 800f3cc:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3d0:	203c      	movs	r0, #60	; 0x3c
 800f3d2:	f001 fd2b 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+55, Y+2, 'w');
 800f3d6:	2277      	movs	r2, #119	; 0x77
 800f3d8:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3dc:	204b      	movs	r0, #75	; 0x4b
 800f3de:	f001 fd25 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+70, Y+2, 'a');
 800f3e2:	2261      	movs	r2, #97	; 0x61
 800f3e4:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3e8:	205a      	movs	r0, #90	; 0x5a
 800f3ea:	f001 fd1f 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+86, Y+2, 'r');
 800f3ee:	2272      	movs	r2, #114	; 0x72
 800f3f0:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f3f4:	206a      	movs	r0, #106	; 0x6a
 800f3f6:	f001 fd19 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+99, Y+2, 'e');
 800f3fa:	2265      	movs	r2, #101	; 0x65
 800f3fc:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800f400:	2077      	movs	r0, #119	; 0x77
 800f402:	f001 fd13 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16);
 800f406:	4620      	mov	r0, r4
 800f408:	f001 fc9a 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+152, Y, '.');
 800f40c:	222e      	movs	r2, #46	; 0x2e
 800f40e:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800f412:	20ac      	movs	r0, #172	; 0xac
 800f414:	f001 fd0a 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+142, Y, 'v');
 800f418:	2276      	movs	r2, #118	; 0x76
 800f41a:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800f41e:	20a2      	movs	r0, #162	; 0xa2
 800f420:	f001 fd04 	bl	8010e2c <TFT_DrawChar>
	
	sprintf (buffer, "%.1f",  Version);
 800f424:	ed9d 0a01 	vldr	s0, [sp, #4]
 800f428:	ee10 0a10 	vmov	r0, s0
 800f42c:	f7f1 f89c 	bl	8000568 <__aeabi_f2d>
 800f430:	4602      	mov	r2, r0
 800f432:	460b      	mov	r3, r1
 800f434:	a802      	add	r0, sp, #8
 800f436:	490a      	ldr	r1, [pc, #40]	; (800f460 <GUI_TextEn_Info_Ver+0xe4>)
 800f438:	f002 ffa8 	bl	801238c <siprintf>
	TFT_SetFont(&Font16);
 800f43c:	4620      	mov	r0, r4
 800f43e:	f001 fc7f 	bl	8010d40 <TFT_SetFont>
	TFT_DisplayString(X+172, Y, (uint8_t *)buffer, LEFT_MODE);
 800f442:	2303      	movs	r3, #3
 800f444:	aa02      	add	r2, sp, #8
 800f446:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800f44a:	20c0      	movs	r0, #192	; 0xc0
 800f44c:	f001 fd46 	bl	8010edc <TFT_DisplayString>
 800f450:	b004      	add	sp, #16
 800f452:	bd10      	pop	{r4, pc}
 800f454:	200000f8 	.word	0x200000f8
 800f458:	200000f0 	.word	0x200000f0
 800f45c:	20000108 	.word	0x20000108
 800f460:	0801f558 	.word	0x0801f558

0800f464 <GUI_TitleString_Name>:
#include "stdio.h"
#include "GUI_Text_Elements_RU.h"

void GUI_TitleString_Name(uint16_t X, uint16_t Y)
{
 800f464:	b570      	push	{r4, r5, r6, lr}
 800f466:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	
	TFT_SetFont(&Font16EN_arch_big);
 800f468:	4e36      	ldr	r6, [pc, #216]	; (800f544 <GUI_TitleString_Name+0xe0>)
	TFT_SetTextColor(TFT_White);
 800f46a:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f46e:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800f470:	f001 fc6c 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f474:	2063      	movs	r0, #99	; 0x63
 800f476:	f001 fc6f 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_big);
 800f47a:	4630      	mov	r0, r6
 800f47c:	f001 fc60 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, 		Y, 'T');
 800f480:	4629      	mov	r1, r5
 800f482:	4620      	mov	r0, r4
 800f484:	2254      	movs	r2, #84	; 0x54
 800f486:	f001 fcd1 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+15, 	Y, 'K');
 800f48a:	f104 000f 	add.w	r0, r4, #15
 800f48e:	4629      	mov	r1, r5
 800f490:	224b      	movs	r2, #75	; 0x4b
 800f492:	b280      	uxth	r0, r0
 800f494:	f001 fcca 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+30, 	Y, 'A');
 800f498:	f104 001e 	add.w	r0, r4, #30
 800f49c:	4629      	mov	r1, r5
 800f49e:	2241      	movs	r2, #65	; 0x41
 800f4a0:	b280      	uxth	r0, r0
 800f4a2:	f001 fcc3 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+45, 	Y, '-');
 800f4a6:	f104 002d 	add.w	r0, r4, #45	; 0x2d
 800f4aa:	4629      	mov	r1, r5
 800f4ac:	222d      	movs	r2, #45	; 0x2d
 800f4ae:	b280      	uxth	r0, r0
 800f4b0:	f001 fcbc 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+60, 	Y, 'S');
 800f4b4:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 800f4b8:	4629      	mov	r1, r5
 800f4ba:	2253      	movs	r2, #83	; 0x53
 800f4bc:	b280      	uxth	r0, r0
 800f4be:	f001 fcb5 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_small);
 800f4c2:	4821      	ldr	r0, [pc, #132]	; (800f548 <GUI_TitleString_Name+0xe4>)
 800f4c4:	f001 fc3c 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+75, 	Y, 'p');
 800f4c8:	f104 004b 	add.w	r0, r4, #75	; 0x4b
 800f4cc:	4629      	mov	r1, r5
 800f4ce:	2270      	movs	r2, #112	; 0x70
 800f4d0:	b280      	uxth	r0, r0
 800f4d2:	f001 fcab 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+88, 	Y, 'e');
 800f4d6:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800f4da:	4629      	mov	r1, r5
 800f4dc:	2265      	movs	r2, #101	; 0x65
 800f4de:	b280      	uxth	r0, r0
 800f4e0:	f001 fca4 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+99, 	Y, 'c');
 800f4e4:	f104 0063 	add.w	r0, r4, #99	; 0x63
 800f4e8:	4629      	mov	r1, r5
 800f4ea:	2263      	movs	r2, #99	; 0x63
 800f4ec:	b280      	uxth	r0, r0
 800f4ee:	f001 fc9d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+109, 	Y, 't');
 800f4f2:	f104 006d 	add.w	r0, r4, #109	; 0x6d
 800f4f6:	4629      	mov	r1, r5
 800f4f8:	2274      	movs	r2, #116	; 0x74
 800f4fa:	b280      	uxth	r0, r0
 800f4fc:	f001 fc96 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+120, 	Y, 'r');
 800f500:	f104 0078 	add.w	r0, r4, #120	; 0x78
 800f504:	4629      	mov	r1, r5
 800f506:	2272      	movs	r2, #114	; 0x72
 800f508:	b280      	uxth	r0, r0
 800f50a:	f001 fc8f 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800f50e:	4630      	mov	r0, r6
 800f510:	f001 fc16 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+135, 	Y, '(');
 800f514:	f104 0087 	add.w	r0, r4, #135	; 0x87
 800f518:	4629      	mov	r1, r5
 800f51a:	2228      	movs	r2, #40	; 0x28
 800f51c:	b280      	uxth	r0, r0
 800f51e:	f001 fc85 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+150, 	Y, 'M');
 800f522:	f104 0096 	add.w	r0, r4, #150	; 0x96
 800f526:	4629      	mov	r1, r5
 800f528:	224d      	movs	r2, #77	; 0x4d
 800f52a:	b280      	uxth	r0, r0
 800f52c:	f001 fc7e 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+166, 	Y, ')');
 800f530:	f104 00a6 	add.w	r0, r4, #166	; 0xa6
 800f534:	4629      	mov	r1, r5
 800f536:	2229      	movs	r2, #41	; 0x29
 800f538:	b280      	uxth	r0, r0
}
 800f53a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TFT_DrawChar(X+166, 	Y, ')');
 800f53e:	f001 bc75 	b.w	8010e2c <TFT_DrawChar>
 800f542:	bf00      	nop
 800f544:	200000f8 	.word	0x200000f8
 800f548:	20000108 	.word	0x20000108

0800f54c <GUI_TitleString_Version>:

void GUI_TitleString_Version(uint16_t X, uint16_t Y)
{
 800f54c:	b538      	push	{r3, r4, r5, lr}
 800f54e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800f550:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f554:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800f556:	f001 fbf9 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f55a:	2063      	movs	r0, #99	; 0x63
 800f55c:	f001 fbfc 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16EN_arch_small);
 800f560:	4814      	ldr	r0, [pc, #80]	; (800f5b4 <GUI_TitleString_Version+0x68>)
 800f562:	f001 fbed 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X, 		Y, 'v');
 800f566:	4629      	mov	r1, r5
 800f568:	2276      	movs	r2, #118	; 0x76
 800f56a:	4620      	mov	r0, r4
 800f56c:	f001 fc5e 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16EN_arch_big);
 800f570:	4811      	ldr	r0, [pc, #68]	; (800f5b8 <GUI_TitleString_Version+0x6c>)
 800f572:	f001 fbe5 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+13, 		Y, '.');
 800f576:	f104 000d 	add.w	r0, r4, #13
 800f57a:	4629      	mov	r1, r5
 800f57c:	222e      	movs	r2, #46	; 0x2e
 800f57e:	b280      	uxth	r0, r0
 800f580:	f001 fc54 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+24, 		Y, '1');
 800f584:	f104 0018 	add.w	r0, r4, #24
 800f588:	4629      	mov	r1, r5
 800f58a:	2231      	movs	r2, #49	; 0x31
 800f58c:	b280      	uxth	r0, r0
 800f58e:	f001 fc4d 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+35, 		Y, '.');
 800f592:	f104 0023 	add.w	r0, r4, #35	; 0x23
 800f596:	4629      	mov	r1, r5
 800f598:	222e      	movs	r2, #46	; 0x2e
 800f59a:	b280      	uxth	r0, r0
 800f59c:	f001 fc46 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+45, 		Y, '0');
 800f5a0:	f104 002d 	add.w	r0, r4, #45	; 0x2d
 800f5a4:	4629      	mov	r1, r5
 800f5a6:	2230      	movs	r2, #48	; 0x30
 800f5a8:	b280      	uxth	r0, r0
}
 800f5aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+45, 		Y, '0');
 800f5ae:	f001 bc3d 	b.w	8010e2c <TFT_DrawChar>
 800f5b2:	bf00      	nop
 800f5b4:	20000108 	.word	0x20000108
 800f5b8:	200000f8 	.word	0x200000f8

0800f5bc <GUI_TextRu_Language>:

void GUI_TextRu_Language(uint16_t X, uint16_t Y)
{
 800f5bc:	b538      	push	{r3, r4, r5, lr}
 800f5be:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800f5c0:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f5c4:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800f5c6:	f001 fbc1 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f5ca:	2063      	movs	r0, #99	; 0x63
 800f5cc:	f001 fbc4 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f5d0:	4811      	ldr	r0, [pc, #68]	; (800f618 <GUI_TextRu_Language+0x5c>)
 800f5d2:	f001 fbb5 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f5d6:	4621      	mov	r1, r4
 800f5d8:	22af      	movs	r2, #175	; 0xaf
 800f5da:	4628      	mov	r0, r5
 800f5dc:	f001 fbc2 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800f5e0:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f5e2:	480e      	ldr	r0, [pc, #56]	; (800f61c <GUI_TextRu_Language+0x60>)
 800f5e4:	f001 fbac 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f5e8:	b2a4      	uxth	r4, r4
 800f5ea:	f105 000f 	add.w	r0, r5, #15
 800f5ee:	4621      	mov	r1, r4
 800f5f0:	22b7      	movs	r2, #183	; 0xb7
 800f5f2:	b280      	uxth	r0, r0
 800f5f4:	f001 fbb6 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 800f5f8:	f105 001c 	add.w	r0, r5, #28
 800f5fc:	4621      	mov	r1, r4
 800f5fe:	228b      	movs	r2, #139	; 0x8b
 800f600:	b280      	uxth	r0, r0
 800f602:	f001 fbaf 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+41, Y+5, '');
 800f606:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800f60a:	4621      	mov	r1, r4
 800f60c:	22ba      	movs	r2, #186	; 0xba
 800f60e:	b280      	uxth	r0, r0
}
 800f610:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+41, Y+5, '');
 800f614:	f001 bba6 	b.w	8010d64 <TFT_DrawCharRus>
 800f618:	20000118 	.word	0x20000118
 800f61c:	20000120 	.word	0x20000120

0800f620 <GUI_TextRu_Russian>:

void GUI_TextRu_Russian(uint16_t X, uint16_t Y)
{
 800f620:	b538      	push	{r3, r4, r5, lr}
 800f622:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800f624:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f628:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800f62a:	f001 fb8f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f62e:	2063      	movs	r0, #99	; 0x63
 800f630:	f001 fb92 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f634:	481c      	ldr	r0, [pc, #112]	; (800f6a8 <GUI_TextRu_Russian+0x88>)
 800f636:	f001 fb83 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f63a:	4621      	mov	r1, r4
 800f63c:	22a0      	movs	r2, #160	; 0xa0
 800f63e:	4628      	mov	r0, r5
 800f640:	f001 fb90 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800f644:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f646:	4819      	ldr	r0, [pc, #100]	; (800f6ac <GUI_TextRu_Russian+0x8c>)
	TFT_DrawCharRus(X+15, Y+5, '');
 800f648:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 800f64a:	f001 fb79 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f64e:	f105 000f 	add.w	r0, r5, #15
 800f652:	4621      	mov	r1, r4
 800f654:	2283      	movs	r2, #131	; 0x83
 800f656:	b280      	uxth	r0, r0
 800f658:	f001 fb84 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 800f65c:	f105 001c 	add.w	r0, r5, #28
 800f660:	4621      	mov	r1, r4
 800f662:	2281      	movs	r2, #129	; 0x81
 800f664:	b280      	uxth	r0, r0
 800f666:	f001 fb7d 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+40, Y+5, '');
 800f66a:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800f66e:	4621      	mov	r1, r4
 800f670:	2281      	movs	r2, #129	; 0x81
 800f672:	b280      	uxth	r0, r0
 800f674:	f001 fb76 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+52, Y+5, '');
 800f678:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800f67c:	4621      	mov	r1, r4
 800f67e:	22ba      	movs	r2, #186	; 0xba
 800f680:	b280      	uxth	r0, r0
 800f682:	f001 fb6f 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+64, Y+5, '');
 800f686:	f105 0040 	add.w	r0, r5, #64	; 0x40
 800f68a:	4621      	mov	r1, r4
 800f68c:	22b8      	movs	r2, #184	; 0xb8
 800f68e:	b280      	uxth	r0, r0
 800f690:	f001 fb68 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+77, Y+5, '');
 800f694:	f105 004d 	add.w	r0, r5, #77	; 0x4d
 800f698:	4621      	mov	r1, r4
 800f69a:	22b9      	movs	r2, #185	; 0xb9
 800f69c:	b280      	uxth	r0, r0
}
 800f69e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+77, Y+5, '');
 800f6a2:	f001 bb5f 	b.w	8010d64 <TFT_DrawCharRus>
 800f6a6:	bf00      	nop
 800f6a8:	20000118 	.word	0x20000118
 800f6ac:	20000120 	.word	0x20000120

0800f6b0 <GUI_TextRu_Info>:



void GUI_TextRu_Info(uint16_t X, uint16_t Y)
{
 800f6b0:	b538      	push	{r3, r4, r5, lr}
 800f6b2:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800f6b4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f6b8:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800f6ba:	f001 fb47 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f6be:	2063      	movs	r0, #99	; 0x63
 800f6c0:	f001 fb4a 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f6c4:	4849      	ldr	r0, [pc, #292]	; (800f7ec <GUI_TextRu_Info+0x13c>)
 800f6c6:	f001 fb3b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f6ca:	4621      	mov	r1, r4
 800f6cc:	2298      	movs	r2, #152	; 0x98
 800f6ce:	4628      	mov	r0, r5
 800f6d0:	f001 fb48 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800f6d4:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f6d6:	4846      	ldr	r0, [pc, #280]	; (800f7f0 <GUI_TextRu_Info+0x140>)
	TFT_DrawCharRus(X+15, Y+5, '');
 800f6d8:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 800f6da:	f001 fb31 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f6de:	f105 000f 	add.w	r0, r5, #15
 800f6e2:	4621      	mov	r1, r4
 800f6e4:	22bd      	movs	r2, #189	; 0xbd
 800f6e6:	b280      	uxth	r0, r0
 800f6e8:	f001 fb3c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 800f6ec:	f105 001c 	add.w	r0, r5, #28
 800f6f0:	4621      	mov	r1, r4
 800f6f2:	2284      	movs	r2, #132	; 0x84
 800f6f4:	b280      	uxth	r0, r0
 800f6f6:	f001 fb35 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+41, Y+5, '');
 800f6fa:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800f6fe:	4621      	mov	r1, r4
 800f700:	22be      	movs	r2, #190	; 0xbe
 800f702:	b280      	uxth	r0, r0
 800f704:	f001 fb2e 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+53, Y+5, '');
 800f708:	f105 0035 	add.w	r0, r5, #53	; 0x35
 800f70c:	4621      	mov	r1, r4
 800f70e:	2280      	movs	r2, #128	; 0x80
 800f710:	b280      	uxth	r0, r0
 800f712:	f001 fb27 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+65, Y+5, '');
 800f716:	f105 0041 	add.w	r0, r5, #65	; 0x41
 800f71a:	4621      	mov	r1, r4
 800f71c:	22bc      	movs	r2, #188	; 0xbc
 800f71e:	b280      	uxth	r0, r0
 800f720:	f001 fb20 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+78, Y+5, '');
 800f724:	f105 004e 	add.w	r0, r5, #78	; 0x4e
 800f728:	4621      	mov	r1, r4
 800f72a:	22b0      	movs	r2, #176	; 0xb0
 800f72c:	b280      	uxth	r0, r0
 800f72e:	f001 fb19 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+90, Y+5, '');
 800f732:	f105 005a 	add.w	r0, r5, #90	; 0x5a
 800f736:	4621      	mov	r1, r4
 800f738:	2286      	movs	r2, #134	; 0x86
 800f73a:	b280      	uxth	r0, r0
 800f73c:	f001 fb12 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+102, Y+5, '');
 800f740:	f105 0066 	add.w	r0, r5, #102	; 0x66
 800f744:	4621      	mov	r1, r4
 800f746:	22b8      	movs	r2, #184	; 0xb8
 800f748:	b280      	uxth	r0, r0
 800f74a:	f001 fb0b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+114, Y+5, '');
 800f74e:	f105 0072 	add.w	r0, r5, #114	; 0x72
 800f752:	4621      	mov	r1, r4
 800f754:	228f      	movs	r2, #143	; 0x8f
 800f756:	b280      	uxth	r0, r0
 800f758:	f001 fb04 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+126, Y+5, 0x01);
 800f75c:	f105 007e 	add.w	r0, r5, #126	; 0x7e
 800f760:	4621      	mov	r1, r4
 800f762:	2201      	movs	r2, #1
 800f764:	b280      	uxth	r0, r0
 800f766:	f001 fafd 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+138, Y+5, '');
 800f76a:	f105 008a 	add.w	r0, r5, #138	; 0x8a
 800f76e:	4621      	mov	r1, r4
 800f770:	22be      	movs	r2, #190	; 0xbe
 800f772:	b280      	uxth	r0, r0
 800f774:	f001 faf6 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+150, Y+5, 0x01);
 800f778:	f105 0096 	add.w	r0, r5, #150	; 0x96
 800f77c:	4621      	mov	r1, r4
 800f77e:	2201      	movs	r2, #1
 800f780:	b280      	uxth	r0, r0
 800f782:	f001 faef 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+162, Y+5, '');
 800f786:	f105 00a2 	add.w	r0, r5, #162	; 0xa2
 800f78a:	4621      	mov	r1, r4
 800f78c:	22bf      	movs	r2, #191	; 0xbf
 800f78e:	b280      	uxth	r0, r0
 800f790:	f001 fae8 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+174, Y+5, '');
 800f794:	f105 00ae 	add.w	r0, r5, #174	; 0xae
 800f798:	4621      	mov	r1, r4
 800f79a:	2280      	movs	r2, #128	; 0x80
 800f79c:	b280      	uxth	r0, r0
 800f79e:	f001 fae1 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+186, Y+5, '');
 800f7a2:	f105 00ba 	add.w	r0, r5, #186	; 0xba
 800f7a6:	4621      	mov	r1, r4
 800f7a8:	22b8      	movs	r2, #184	; 0xb8
 800f7aa:	b280      	uxth	r0, r0
 800f7ac:	f001 fada 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+198, Y+5, '');
 800f7b0:	f105 00c6 	add.w	r0, r5, #198	; 0xc6
 800f7b4:	4621      	mov	r1, r4
 800f7b6:	22b1      	movs	r2, #177	; 0xb1
 800f7b8:	b280      	uxth	r0, r0
 800f7ba:	f001 fad3 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+210, Y+5, '');
 800f7be:	f105 00d2 	add.w	r0, r5, #210	; 0xd2
 800f7c2:	4621      	mov	r1, r4
 800f7c4:	22be      	movs	r2, #190	; 0xbe
 800f7c6:	b280      	uxth	r0, r0
 800f7c8:	f001 facc 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+222, Y+5, '');
 800f7cc:	f105 00de 	add.w	r0, r5, #222	; 0xde
 800f7d0:	4621      	mov	r1, r4
 800f7d2:	2280      	movs	r2, #128	; 0x80
 800f7d4:	b280      	uxth	r0, r0
 800f7d6:	f001 fac5 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+234, Y+5, '');
 800f7da:	f105 00ea 	add.w	r0, r5, #234	; 0xea
 800f7de:	4621      	mov	r1, r4
 800f7e0:	22b5      	movs	r2, #181	; 0xb5
 800f7e2:	b280      	uxth	r0, r0
}
 800f7e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+234, Y+5, '');
 800f7e8:	f001 babc 	b.w	8010d64 <TFT_DrawCharRus>
 800f7ec:	20000118 	.word	0x20000118
 800f7f0:	20000120 	.word	0x20000120

0800f7f4 <GUI_TextRu_Mode>:

void GUI_TextRu_Mode(uint16_t X, uint16_t Y)
{
 800f7f4:	b538      	push	{r3, r4, r5, lr}
 800f7f6:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800f7f8:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f7fc:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800f7fe:	f001 faa5 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f802:	2063      	movs	r0, #99	; 0x63
 800f804:	f001 faa8 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f808:	4815      	ldr	r0, [pc, #84]	; (800f860 <GUI_TextRu_Mode+0x6c>)
 800f80a:	f001 fa99 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f80e:	4621      	mov	r1, r4
 800f810:	22a0      	movs	r2, #160	; 0xa0
 800f812:	4628      	mov	r0, r5
 800f814:	f001 faa6 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800f818:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f81a:	4812      	ldr	r0, [pc, #72]	; (800f864 <GUI_TextRu_Mode+0x70>)
 800f81c:	f001 fa90 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f820:	b2a4      	uxth	r4, r4
 800f822:	f105 000f 	add.w	r0, r5, #15
 800f826:	4621      	mov	r1, r4
 800f828:	22b5      	movs	r2, #181	; 0xb5
 800f82a:	b280      	uxth	r0, r0
 800f82c:	f001 fa9a 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 800f830:	f105 001c 	add.w	r0, r5, #28
 800f834:	4621      	mov	r1, r4
 800f836:	22b6      	movs	r2, #182	; 0xb6
 800f838:	b280      	uxth	r0, r0
 800f83a:	f001 fa93 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+41, Y+5, '');
 800f83e:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800f842:	4621      	mov	r1, r4
 800f844:	22b8      	movs	r2, #184	; 0xb8
 800f846:	b280      	uxth	r0, r0
 800f848:	f001 fa8c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+54, Y+5, '');
 800f84c:	f105 0036 	add.w	r0, r5, #54	; 0x36
 800f850:	4621      	mov	r1, r4
 800f852:	22bc      	movs	r2, #188	; 0xbc
 800f854:	b280      	uxth	r0, r0
}
 800f856:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+54, Y+5, '');
 800f85a:	f001 ba83 	b.w	8010d64 <TFT_DrawCharRus>
 800f85e:	bf00      	nop
 800f860:	20000118 	.word	0x20000118
 800f864:	20000120 	.word	0x20000120

0800f868 <GUI_TextRu_Illuminance>:

void GUI_TextRu_Illuminance(uint16_t X, uint16_t Y)
{
 800f868:	b538      	push	{r3, r4, r5, lr}
 800f86a:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800f86c:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f870:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800f872:	f001 fa6b 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f876:	2063      	movs	r0, #99	; 0x63
 800f878:	f001 fa6e 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f87c:	482d      	ldr	r0, [pc, #180]	; (800f934 <GUI_TextRu_Illuminance+0xcc>)
 800f87e:	f001 fa5f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f882:	4621      	mov	r1, r4
 800f884:	229e      	movs	r2, #158	; 0x9e
 800f886:	4628      	mov	r0, r5
 800f888:	f001 fa6c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800f88c:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f88e:	482a      	ldr	r0, [pc, #168]	; (800f938 <GUI_TextRu_Illuminance+0xd0>)
	TFT_DrawCharRus(X+15, Y+5, '');
 800f890:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 800f892:	f001 fa55 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f896:	f105 000f 	add.w	r0, r5, #15
 800f89a:	4621      	mov	r1, r4
 800f89c:	2281      	movs	r2, #129	; 0x81
 800f89e:	b280      	uxth	r0, r0
 800f8a0:	f001 fa60 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+26, Y+5, '');
 800f8a4:	f105 001a 	add.w	r0, r5, #26
 800f8a8:	4621      	mov	r1, r4
 800f8aa:	22b2      	movs	r2, #178	; 0xb2
 800f8ac:	b280      	uxth	r0, r0
 800f8ae:	f001 fa59 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+38, Y+5, '');
 800f8b2:	f105 0026 	add.w	r0, r5, #38	; 0x26
 800f8b6:	4621      	mov	r1, r4
 800f8b8:	22b5      	movs	r2, #181	; 0xb5
 800f8ba:	b280      	uxth	r0, r0
 800f8bc:	f001 fa52 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+50, Y+5, '');
 800f8c0:	f105 0032 	add.w	r0, r5, #50	; 0x32
 800f8c4:	4621      	mov	r1, r4
 800f8c6:	2289      	movs	r2, #137	; 0x89
 800f8c8:	b280      	uxth	r0, r0
 800f8ca:	f001 fa4b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+62, Y+5, '');
 800f8ce:	f105 003e 	add.w	r0, r5, #62	; 0x3e
 800f8d2:	4621      	mov	r1, r4
 800f8d4:	22b5      	movs	r2, #181	; 0xb5
 800f8d6:	b280      	uxth	r0, r0
 800f8d8:	f001 fa44 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+73, Y+5, '');
 800f8dc:	f105 0049 	add.w	r0, r5, #73	; 0x49
 800f8e0:	4621      	mov	r1, r4
 800f8e2:	22bd      	movs	r2, #189	; 0xbd
 800f8e4:	b280      	uxth	r0, r0
 800f8e6:	f001 fa3d 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+85, Y+5, '');
 800f8ea:	f105 0055 	add.w	r0, r5, #85	; 0x55
 800f8ee:	4621      	mov	r1, r4
 800f8f0:	22bd      	movs	r2, #189	; 0xbd
 800f8f2:	b280      	uxth	r0, r0
 800f8f4:	f001 fa36 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+97, Y+5, '');
 800f8f8:	f105 0061 	add.w	r0, r5, #97	; 0x61
 800f8fc:	4621      	mov	r1, r4
 800f8fe:	22be      	movs	r2, #190	; 0xbe
 800f900:	b280      	uxth	r0, r0
 800f902:	f001 fa2f 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+109, Y+5, '');
 800f906:	f105 006d 	add.w	r0, r5, #109	; 0x6d
 800f90a:	4621      	mov	r1, r4
 800f90c:	2281      	movs	r2, #129	; 0x81
 800f90e:	b280      	uxth	r0, r0
 800f910:	f001 fa28 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+118, Y+5, '');
 800f914:	f105 0076 	add.w	r0, r5, #118	; 0x76
 800f918:	4621      	mov	r1, r4
 800f91a:	2282      	movs	r2, #130	; 0x82
 800f91c:	b280      	uxth	r0, r0
 800f91e:	f001 fa21 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+130, Y+5, '');
 800f922:	f105 0082 	add.w	r0, r5, #130	; 0x82
 800f926:	4621      	mov	r1, r4
 800f928:	228c      	movs	r2, #140	; 0x8c
 800f92a:	b280      	uxth	r0, r0
}
 800f92c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+130, Y+5, '');
 800f930:	f001 ba18 	b.w	8010d64 <TFT_DrawCharRus>
 800f934:	20000118 	.word	0x20000118
 800f938:	20000120 	.word	0x20000120

0800f93c <GUI_TextRu_PPF>:

void GUI_TextRu_PPF(uint16_t X, uint16_t Y)
{
 800f93c:	b538      	push	{r3, r4, r5, lr}
 800f93e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800f940:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f944:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800f946:	f001 fa01 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f94a:	2063      	movs	r0, #99	; 0x63
 800f94c:	f001 fa04 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f950:	480b      	ldr	r0, [pc, #44]	; (800f980 <GUI_TextRu_PPF+0x44>)
 800f952:	f001 f9f5 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f956:	4629      	mov	r1, r5
 800f958:	4620      	mov	r0, r4
 800f95a:	22a4      	movs	r2, #164	; 0xa4
 800f95c:	f001 fa02 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+17, Y, '');
 800f960:	f104 0011 	add.w	r0, r4, #17
 800f964:	4629      	mov	r1, r5
 800f966:	2290      	movs	r2, #144	; 0x90
 800f968:	b280      	uxth	r0, r0
 800f96a:	f001 f9fb 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+32, Y, '');
 800f96e:	f104 0020 	add.w	r0, r4, #32
 800f972:	4629      	mov	r1, r5
 800f974:	22a0      	movs	r2, #160	; 0xa0
 800f976:	b280      	uxth	r0, r0
}
 800f978:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+32, Y, '');
 800f97c:	f001 b9f2 	b.w	8010d64 <TFT_DrawCharRus>
 800f980:	20000118 	.word	0x20000118

0800f984 <GUI_TextRu_PPF_RGB>:

void GUI_TextRu_PPF_RGB(uint16_t X, uint16_t Y)
{
 800f984:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f988:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
	TFT_SetBackColor(TFT_Black_Bkgr);
	TFT_SetFont(&Font16RU_arch_big);
 800f98a:	f8df 910c 	ldr.w	r9, [pc, #268]	; 800fa98 <GUI_TextRu_PPF_RGB+0x114>
	TFT_DrawCharRus(X, Y, '');
	TFT_SetFont(&Font16RU_arch_small);
 800f98e:	f8df 810c 	ldr.w	r8, [pc, #268]	; 800fa9c <GUI_TextRu_PPF_RGB+0x118>
	TFT_DrawCharRus(X+15, Y+5, '');
	TFT_DrawCharRus(X+27, Y+5, '');
	TFT_SetFont(&Font16EN_arch_big);
 800f992:	4f40      	ldr	r7, [pc, #256]	; (800fa94 <GUI_TextRu_PPF_RGB+0x110>)
	TFT_SetTextColor(TFT_White);
 800f994:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800f998:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800f99a:	f001 f9d7 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800f99e:	2063      	movs	r0, #99	; 0x63
 800f9a0:	f001 f9da 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800f9a4:	4648      	mov	r0, r9
 800f9a6:	f001 f9cb 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800f9aa:	4629      	mov	r1, r5
 800f9ac:	22a1      	movs	r2, #161	; 0xa1
 800f9ae:	4620      	mov	r0, r4
 800f9b0:	f001 f9d8 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f9b4:	1d6e      	adds	r6, r5, #5
	TFT_SetFont(&Font16RU_arch_small);
 800f9b6:	4640      	mov	r0, r8
	TFT_DrawCharRus(X+15, Y+5, '');
 800f9b8:	b2b6      	uxth	r6, r6
	TFT_SetFont(&Font16RU_arch_small);
 800f9ba:	f001 f9c1 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800f9be:	f104 000f 	add.w	r0, r4, #15
 800f9c2:	4631      	mov	r1, r6
 800f9c4:	22b8      	movs	r2, #184	; 0xb8
 800f9c6:	b280      	uxth	r0, r0
 800f9c8:	f001 f9cc 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+27, Y+5, '');
 800f9cc:	f104 001b 	add.w	r0, r4, #27
 800f9d0:	4631      	mov	r1, r6
 800f9d2:	22bd      	movs	r2, #189	; 0xbd
 800f9d4:	b280      	uxth	r0, r0
 800f9d6:	f001 f9c5 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16EN_arch_big);
 800f9da:	4638      	mov	r0, r7
 800f9dc:	f001 f9b0 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+40, Y, '-');
 800f9e0:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800f9e4:	4629      	mov	r1, r5
 800f9e6:	222d      	movs	r2, #45	; 0x2d
 800f9e8:	b280      	uxth	r0, r0
 800f9ea:	f001 fa1f 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16RU_arch_big);
 800f9ee:	4648      	mov	r0, r9
 800f9f0:	f001 f9a6 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+55, Y, '');
 800f9f4:	f104 0037 	add.w	r0, r4, #55	; 0x37
 800f9f8:	4629      	mov	r1, r5
 800f9fa:	2297      	movs	r2, #151	; 0x97
 800f9fc:	b280      	uxth	r0, r0
 800f9fe:	f001 f9b1 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
 800fa02:	4640      	mov	r0, r8
 800fa04:	f001 f99c 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+70, Y+5, '');
 800fa08:	f104 0046 	add.w	r0, r4, #70	; 0x46
 800fa0c:	4631      	mov	r1, r6
 800fa0e:	22b5      	movs	r2, #181	; 0xb5
 800fa10:	b280      	uxth	r0, r0
 800fa12:	f001 f9a7 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+82, Y+5, '');
 800fa16:	f104 0052 	add.w	r0, r4, #82	; 0x52
 800fa1a:	4631      	mov	r1, r6
 800fa1c:	22bb      	movs	r2, #187	; 0xbb
 800fa1e:	b280      	uxth	r0, r0
 800fa20:	f001 f9a0 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16EN_arch_big);
 800fa24:	4638      	mov	r0, r7
 800fa26:	f001 f98b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+94, Y, '-');
 800fa2a:	f104 005e 	add.w	r0, r4, #94	; 0x5e
 800fa2e:	4629      	mov	r1, r5
 800fa30:	222d      	movs	r2, #45	; 0x2d
 800fa32:	b280      	uxth	r0, r0
 800fa34:	f001 f9fa 	bl	8010e2c <TFT_DrawChar>
	TFT_SetFont(&Font16RU_arch_big);
 800fa38:	4648      	mov	r0, r9
 800fa3a:	f001 f981 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+109, Y, '');
 800fa3e:	f104 006d 	add.w	r0, r4, #109	; 0x6d
 800fa42:	4629      	mov	r1, r5
 800fa44:	229a      	movs	r2, #154	; 0x9a
 800fa46:	b280      	uxth	r0, r0
 800fa48:	f001 f98c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
 800fa4c:	4640      	mov	r0, r8
 800fa4e:	f001 f977 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+124, Y+5, '');
 800fa52:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 800fa56:	4631      	mov	r1, r6
 800fa58:	2280      	movs	r2, #128	; 0x80
 800fa5a:	b280      	uxth	r0, r0
 800fa5c:	f001 f982 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16EN_arch_big);
 800fa60:	4638      	mov	r0, r7
 800fa62:	f001 f96d 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+136, Y, '-');
 800fa66:	f104 0088 	add.w	r0, r4, #136	; 0x88
 800fa6a:	4629      	mov	r1, r5
 800fa6c:	222d      	movs	r2, #45	; 0x2d
 800fa6e:	b280      	uxth	r0, r0
 800fa70:	f001 f9dc 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+152, Y, 'F');
 800fa74:	f104 0098 	add.w	r0, r4, #152	; 0x98
 800fa78:	4629      	mov	r1, r5
 800fa7a:	2246      	movs	r2, #70	; 0x46
 800fa7c:	b280      	uxth	r0, r0
 800fa7e:	f001 f9d5 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+167, Y, 'R');
 800fa82:	f104 00a7 	add.w	r0, r4, #167	; 0xa7
 800fa86:	4629      	mov	r1, r5
 800fa88:	2252      	movs	r2, #82	; 0x52
 800fa8a:	b280      	uxth	r0, r0
}
 800fa8c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	TFT_DrawChar(X+167, Y, 'R');
 800fa90:	f001 b9cc 	b.w	8010e2c <TFT_DrawChar>
 800fa94:	200000f8 	.word	0x200000f8
 800fa98:	20000118 	.word	0x20000118
 800fa9c:	20000120 	.word	0x20000120

0800faa0 <GUI_TextRu_PPF_bands>:
void GUI_TextRu_PPF_bands(uint16_t X, uint16_t Y)
{
 800faa0:	b538      	push	{r3, r4, r5, lr}
 800faa2:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800faa4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800faa8:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800faaa:	f001 f94f 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800faae:	2063      	movs	r0, #99	; 0x63
 800fab0:	f001 f952 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fab4:	482d      	ldr	r0, [pc, #180]	; (800fb6c <GUI_TextRu_PPF_bands+0xcc>)
 800fab6:	f001 f943 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800faba:	4621      	mov	r1, r4
 800fabc:	4628      	mov	r0, r5
 800fabe:	22a4      	movs	r2, #164	; 0xa4
 800fac0:	f001 f950 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+17, Y, '');
 800fac4:	f105 0011 	add.w	r0, r5, #17
 800fac8:	4621      	mov	r1, r4
 800faca:	2290      	movs	r2, #144	; 0x90
 800facc:	b280      	uxth	r0, r0
 800face:	f001 f949 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+32, Y, '');
 800fad2:	f105 0020 	add.w	r0, r5, #32
 800fad6:	4621      	mov	r1, r4
 800fad8:	22a0      	movs	r2, #160	; 0xa0
 800fada:	b280      	uxth	r0, r0
 800fadc:	f001 f942 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+57, Y+2, '');
 800fae0:	3402      	adds	r4, #2
	TFT_SetFont(&Font16RU_arch_small);
 800fae2:	4823      	ldr	r0, [pc, #140]	; (800fb70 <GUI_TextRu_PPF_bands+0xd0>)
	TFT_DrawCharRus(X+57, Y+2, '');
 800fae4:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 800fae6:	f001 f92b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+57, Y+2, '');
 800faea:	f105 0039 	add.w	r0, r5, #57	; 0x39
 800faee:	4621      	mov	r1, r4
 800faf0:	22b4      	movs	r2, #180	; 0xb4
 800faf2:	b280      	uxth	r0, r0
 800faf4:	f001 f936 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+70, Y+2, '');
 800faf8:	f105 0046 	add.w	r0, r5, #70	; 0x46
 800fafc:	4621      	mov	r1, r4
 800fafe:	22b8      	movs	r2, #184	; 0xb8
 800fb00:	b280      	uxth	r0, r0
 800fb02:	f001 f92f 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+83, Y+2, '');
 800fb06:	f105 0053 	add.w	r0, r5, #83	; 0x53
 800fb0a:	4621      	mov	r1, r4
 800fb0c:	22b0      	movs	r2, #176	; 0xb0
 800fb0e:	b280      	uxth	r0, r0
 800fb10:	f001 f928 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+96, Y+2, '');
 800fb14:	f105 0060 	add.w	r0, r5, #96	; 0x60
 800fb18:	4621      	mov	r1, r4
 800fb1a:	22bf      	movs	r2, #191	; 0xbf
 800fb1c:	b280      	uxth	r0, r0
 800fb1e:	f001 f921 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+109, Y+2, '');
 800fb22:	f105 006d 	add.w	r0, r5, #109	; 0x6d
 800fb26:	4621      	mov	r1, r4
 800fb28:	22b0      	movs	r2, #176	; 0xb0
 800fb2a:	b280      	uxth	r0, r0
 800fb2c:	f001 f91a 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+122, Y+2, '');
 800fb30:	f105 007a 	add.w	r0, r5, #122	; 0x7a
 800fb34:	4621      	mov	r1, r4
 800fb36:	22b7      	movs	r2, #183	; 0xb7
 800fb38:	b280      	uxth	r0, r0
 800fb3a:	f001 f913 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+135, Y+2, '');
 800fb3e:	f105 0087 	add.w	r0, r5, #135	; 0x87
 800fb42:	4621      	mov	r1, r4
 800fb44:	22be      	movs	r2, #190	; 0xbe
 800fb46:	b280      	uxth	r0, r0
 800fb48:	f001 f90c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+148, Y+2, '');
 800fb4c:	f105 0094 	add.w	r0, r5, #148	; 0x94
 800fb50:	4621      	mov	r1, r4
 800fb52:	22bd      	movs	r2, #189	; 0xbd
 800fb54:	b280      	uxth	r0, r0
 800fb56:	f001 f905 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+162, Y+2, '');
 800fb5a:	f105 00a2 	add.w	r0, r5, #162	; 0xa2
 800fb5e:	4621      	mov	r1, r4
 800fb60:	228b      	movs	r2, #139	; 0x8b
 800fb62:	b280      	uxth	r0, r0
}
 800fb64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+162, Y+2, '');
 800fb68:	f001 b8fc 	b.w	8010d64 <TFT_DrawCharRus>
 800fb6c:	20000118 	.word	0x20000118
 800fb70:	20000120 	.word	0x20000120

0800fb74 <GUI_TextRu_Info_Callibration>:

void GUI_TextRu_Info_Callibration(uint16_t X, uint16_t Y, uint8_t date, uint8_t month, uint16_t year)
{
 800fb74:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800fb76:	461e      	mov	r6, r3
	char buffer[5] = {0};
	
	X = 70;
	Y = 100;
	
	TFT_SetTextColor(TFT_White);
 800fb78:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800fb7c:	2300      	movs	r3, #0
 800fb7e:	9300      	str	r3, [sp, #0]
 800fb80:	f88d 3004 	strb.w	r3, [sp, #4]
{
 800fb84:	4614      	mov	r4, r2
	TFT_SetTextColor(TFT_White);
 800fb86:	f001 f8e1 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fb8a:	2063      	movs	r0, #99	; 0x63
 800fb8c:	f001 f8e4 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fb90:	4832      	ldr	r0, [pc, #200]	; (800fc5c <GUI_TextRu_Info_Callibration+0xe8>)
	TFT_DrawCharRus(X+82, Y+2, '');
	TFT_DrawCharRus(X+95, Y+2, '');
	TFT_DrawCharRus(X+108, Y+2, '');
	TFT_DrawCharRus(X+118, Y+2, '');
	
	sprintf (buffer, "%02u",  date);
 800fb92:	4d33      	ldr	r5, [pc, #204]	; (800fc60 <GUI_TextRu_Info_Callibration+0xec>)
	TFT_SetFont(&Font16RU_arch_big);
 800fb94:	f001 f8d4 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y-4, '');
 800fb98:	229a      	movs	r2, #154	; 0x9a
 800fb9a:	2160      	movs	r1, #96	; 0x60
 800fb9c:	2046      	movs	r0, #70	; 0x46
 800fb9e:	f001 f8e1 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
 800fba2:	4830      	ldr	r0, [pc, #192]	; (800fc64 <GUI_TextRu_Info_Callibration+0xf0>)
 800fba4:	f001 f8cc 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+17, Y+2, '');
 800fba8:	22b0      	movs	r2, #176	; 0xb0
 800fbaa:	2166      	movs	r1, #102	; 0x66
 800fbac:	2057      	movs	r0, #87	; 0x57
 800fbae:	f001 f8d9 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+30, Y+2, '');
 800fbb2:	22bb      	movs	r2, #187	; 0xbb
 800fbb4:	2166      	movs	r1, #102	; 0x66
 800fbb6:	2064      	movs	r0, #100	; 0x64
 800fbb8:	f001 f8d4 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+43, Y+2, '');
 800fbbc:	22b8      	movs	r2, #184	; 0xb8
 800fbbe:	2166      	movs	r1, #102	; 0x66
 800fbc0:	2071      	movs	r0, #113	; 0x71
 800fbc2:	f001 f8cf 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+56, Y+2, '');
 800fbc6:	22b1      	movs	r2, #177	; 0xb1
 800fbc8:	2166      	movs	r1, #102	; 0x66
 800fbca:	207e      	movs	r0, #126	; 0x7e
 800fbcc:	f001 f8ca 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+69, Y+2, '');
 800fbd0:	2280      	movs	r2, #128	; 0x80
 800fbd2:	2166      	movs	r1, #102	; 0x66
 800fbd4:	208b      	movs	r0, #139	; 0x8b
 800fbd6:	f001 f8c5 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+82, Y+2, '');
 800fbda:	22be      	movs	r2, #190	; 0xbe
 800fbdc:	2166      	movs	r1, #102	; 0x66
 800fbde:	2098      	movs	r0, #152	; 0x98
 800fbe0:	f001 f8c0 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+95, Y+2, '');
 800fbe4:	22b2      	movs	r2, #178	; 0xb2
 800fbe6:	2166      	movs	r1, #102	; 0x66
 800fbe8:	20a5      	movs	r0, #165	; 0xa5
 800fbea:	f001 f8bb 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+108, Y+2, '');
 800fbee:	22ba      	movs	r2, #186	; 0xba
 800fbf0:	2166      	movs	r1, #102	; 0x66
 800fbf2:	20b2      	movs	r0, #178	; 0xb2
 800fbf4:	f001 f8b6 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+118, Y+2, '');
 800fbf8:	22b0      	movs	r2, #176	; 0xb0
 800fbfa:	2166      	movs	r1, #102	; 0x66
 800fbfc:	20bc      	movs	r0, #188	; 0xbc
 800fbfe:	f001 f8b1 	bl	8010d64 <TFT_DrawCharRus>
	sprintf (buffer, "%02u",  date);
 800fc02:	4622      	mov	r2, r4
 800fc04:	4629      	mov	r1, r5
 800fc06:	4668      	mov	r0, sp
 800fc08:	f002 fbc0 	bl	801238c <siprintf>
	TFT_SetFont(&Font26EN_arch_digit);
 800fc0c:	4816      	ldr	r0, [pc, #88]	; (800fc68 <GUI_TextRu_Info_Callibration+0xf4>)
 800fc0e:	f001 f897 	bl	8010d40 <TFT_SetFont>
	buffer[2] = '.';
 800fc12:	242e      	movs	r4, #46	; 0x2e
	TFT_DisplayString(30, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fc14:	2303      	movs	r3, #3
 800fc16:	466a      	mov	r2, sp
 800fc18:	2182      	movs	r1, #130	; 0x82
 800fc1a:	201e      	movs	r0, #30
	buffer[2] = '.';
 800fc1c:	f88d 4002 	strb.w	r4, [sp, #2]
	TFT_DisplayString(30, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fc20:	f001 f95c 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%02u",  month);
 800fc24:	4632      	mov	r2, r6
 800fc26:	4629      	mov	r1, r5
 800fc28:	4668      	mov	r0, sp
 800fc2a:	f002 fbaf 	bl	801238c <siprintf>
	buffer[2] = '.';
	TFT_DisplayString(30+60, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fc2e:	2303      	movs	r3, #3
 800fc30:	466a      	mov	r2, sp
 800fc32:	2182      	movs	r1, #130	; 0x82
 800fc34:	205a      	movs	r0, #90	; 0x5a
	buffer[2] = '.';
 800fc36:	f88d 4002 	strb.w	r4, [sp, #2]
	TFT_DisplayString(30+60, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fc3a:	f001 f94f 	bl	8010edc <TFT_DisplayString>
	
	sprintf (buffer, "%4u",  year);
 800fc3e:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 800fc42:	490a      	ldr	r1, [pc, #40]	; (800fc6c <GUI_TextRu_Info_Callibration+0xf8>)
 800fc44:	4668      	mov	r0, sp
 800fc46:	f002 fba1 	bl	801238c <siprintf>
	TFT_DisplayString(30+125, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fc4a:	2303      	movs	r3, #3
 800fc4c:	466a      	mov	r2, sp
 800fc4e:	2182      	movs	r1, #130	; 0x82
 800fc50:	209b      	movs	r0, #155	; 0x9b
 800fc52:	f001 f943 	bl	8010edc <TFT_DisplayString>
}
 800fc56:	b002      	add	sp, #8
 800fc58:	bd70      	pop	{r4, r5, r6, pc}
 800fc5a:	bf00      	nop
 800fc5c:	20000118 	.word	0x20000118
 800fc60:	0801f565 	.word	0x0801f565
 800fc64:	20000120 	.word	0x20000120
 800fc68:	20000138 	.word	0x20000138
 800fc6c:	0801f56a 	.word	0x0801f56a

0800fc70 <GUI_TextRu_WriteSD>:

void GUI_TextRu_WriteSD(uint16_t X, uint16_t Y)
{
 800fc70:	b538      	push	{r3, r4, r5, lr}
 800fc72:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800fc74:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800fc78:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800fc7a:	f001 f867 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fc7e:	2063      	movs	r0, #99	; 0x63
 800fc80:	f001 f86a 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fc84:	4818      	ldr	r0, [pc, #96]	; (800fce8 <GUI_TextRu_WriteSD+0x78>)
 800fc86:	f001 f85b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800fc8a:	4621      	mov	r1, r4
 800fc8c:	2297      	movs	r2, #151	; 0x97
 800fc8e:	4628      	mov	r0, r5
 800fc90:	f001 f868 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+15, Y+5, '');
 800fc94:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 800fc96:	4815      	ldr	r0, [pc, #84]	; (800fcec <GUI_TextRu_WriteSD+0x7c>)
	TFT_DrawCharRus(X+15, Y+5, '');
 800fc98:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 800fc9a:	f001 f851 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+15, Y+5, '');
 800fc9e:	f105 000f 	add.w	r0, r5, #15
 800fca2:	4621      	mov	r1, r4
 800fca4:	22b0      	movs	r2, #176	; 0xb0
 800fca6:	b280      	uxth	r0, r0
 800fca8:	f001 f85c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 800fcac:	f105 001c 	add.w	r0, r5, #28
 800fcb0:	4621      	mov	r1, r4
 800fcb2:	22bf      	movs	r2, #191	; 0xbf
 800fcb4:	b280      	uxth	r0, r0
 800fcb6:	f001 f855 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+41, Y+5, '');
 800fcba:	f105 0029 	add.w	r0, r5, #41	; 0x29
 800fcbe:	4621      	mov	r1, r4
 800fcc0:	22b8      	movs	r2, #184	; 0xb8
 800fcc2:	b280      	uxth	r0, r0
 800fcc4:	f001 f84e 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+53, Y+5, '');
 800fcc8:	f105 0035 	add.w	r0, r5, #53	; 0x35
 800fccc:	4621      	mov	r1, r4
 800fcce:	2281      	movs	r2, #129	; 0x81
 800fcd0:	b280      	uxth	r0, r0
 800fcd2:	f001 f847 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+65, Y+5, '');
 800fcd6:	f105 0041 	add.w	r0, r5, #65	; 0x41
 800fcda:	4621      	mov	r1, r4
 800fcdc:	228c      	movs	r2, #140	; 0x8c
 800fcde:	b280      	uxth	r0, r0
}
 800fce0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+65, Y+5, '');
 800fce4:	f001 b83e 	b.w	8010d64 <TFT_DrawCharRus>
 800fce8:	20000118 	.word	0x20000118
 800fcec:	20000120 	.word	0x20000120

0800fcf0 <GUI_TextRu_Info_Serial>:

void GUI_TextRu_Info_Serial(uint16_t X, uint16_t Y, uint16_t Part, uint16_t Number)
{
 800fcf0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800fcf2:	461c      	mov	r4, r3
	char buffer[5] = {0};
	
	X = 60;
	Y = 200;
	
	TFT_SetTextColor(TFT_White);
 800fcf4:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800fcf8:	2300      	movs	r3, #0
 800fcfa:	9300      	str	r3, [sp, #0]
 800fcfc:	f88d 3004 	strb.w	r3, [sp, #4]
{
 800fd00:	4615      	mov	r5, r2
	TFT_SetTextColor(TFT_White);
 800fd02:	f001 f823 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fd06:	2063      	movs	r0, #99	; 0x63
 800fd08:	f001 f826 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fd0c:	4830      	ldr	r0, [pc, #192]	; (800fdd0 <GUI_TextRu_Info_Serial+0xe0>)
 800fd0e:	f001 f817 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y-4, '');
 800fd12:	22a1      	movs	r2, #161	; 0xa1
 800fd14:	21c4      	movs	r1, #196	; 0xc4
 800fd16:	203c      	movs	r0, #60	; 0x3c
 800fd18:	f001 f824 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
 800fd1c:	482d      	ldr	r0, [pc, #180]	; (800fdd4 <GUI_TextRu_Info_Serial+0xe4>)
 800fd1e:	f001 f80f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+17, Y+2, '');
 800fd22:	22b5      	movs	r2, #181	; 0xb5
 800fd24:	21ca      	movs	r1, #202	; 0xca
 800fd26:	204d      	movs	r0, #77	; 0x4d
 800fd28:	f001 f81c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+30, Y+2, '');
 800fd2c:	2280      	movs	r2, #128	; 0x80
 800fd2e:	21ca      	movs	r1, #202	; 0xca
 800fd30:	205a      	movs	r0, #90	; 0x5a
 800fd32:	f001 f817 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+43, Y+2, '');
 800fd36:	22b8      	movs	r2, #184	; 0xb8
 800fd38:	21ca      	movs	r1, #202	; 0xca
 800fd3a:	2067      	movs	r0, #103	; 0x67
 800fd3c:	f001 f812 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+56, Y+2, '');
 800fd40:	22b9      	movs	r2, #185	; 0xb9
 800fd42:	21ca      	movs	r1, #202	; 0xca
 800fd44:	2074      	movs	r0, #116	; 0x74
 800fd46:	f001 f80d 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+69, Y+2, '');
 800fd4a:	22bd      	movs	r2, #189	; 0xbd
 800fd4c:	21ca      	movs	r1, #202	; 0xca
 800fd4e:	2081      	movs	r0, #129	; 0x81
 800fd50:	f001 f808 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+82, Y+2, '');
 800fd54:	228b      	movs	r2, #139	; 0x8b
 800fd56:	21ca      	movs	r1, #202	; 0xca
 800fd58:	208e      	movs	r0, #142	; 0x8e
 800fd5a:	f001 f803 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+95, Y+2, '');
 800fd5e:	22b9      	movs	r2, #185	; 0xb9
 800fd60:	21ca      	movs	r1, #202	; 0xca
 800fd62:	209b      	movs	r0, #155	; 0x9b
 800fd64:	f000 fffe 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+115, Y+2, '');
 800fd68:	22bd      	movs	r2, #189	; 0xbd
 800fd6a:	21ca      	movs	r1, #202	; 0xca
 800fd6c:	20af      	movs	r0, #175	; 0xaf
 800fd6e:	f000 fff9 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+128, Y+2, '');
 800fd72:	22be      	movs	r2, #190	; 0xbe
 800fd74:	21ca      	movs	r1, #202	; 0xca
 800fd76:	20bc      	movs	r0, #188	; 0xbc
 800fd78:	f000 fff4 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+141, Y+2, '');
 800fd7c:	22bc      	movs	r2, #188	; 0xbc
 800fd7e:	21ca      	movs	r1, #202	; 0xca
 800fd80:	20c9      	movs	r0, #201	; 0xc9
 800fd82:	f000 ffef 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+154, Y+2, '');
 800fd86:	22b5      	movs	r2, #181	; 0xb5
 800fd88:	21ca      	movs	r1, #202	; 0xca
 800fd8a:	20d6      	movs	r0, #214	; 0xd6
 800fd8c:	f000 ffea 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+165, Y+2, '');
 800fd90:	2280      	movs	r2, #128	; 0x80
 800fd92:	21ca      	movs	r1, #202	; 0xca
 800fd94:	20e1      	movs	r0, #225	; 0xe1
 800fd96:	f000 ffe5 	bl	8010d64 <TFT_DrawCharRus>

	sprintf (buffer, "%u",  Part);
 800fd9a:	462a      	mov	r2, r5
 800fd9c:	490e      	ldr	r1, [pc, #56]	; (800fdd8 <GUI_TextRu_Info_Serial+0xe8>)
 800fd9e:	4668      	mov	r0, sp
 800fda0:	f002 faf4 	bl	801238c <siprintf>
	TFT_SetFont(&Font26EN_arch_digit);
 800fda4:	480d      	ldr	r0, [pc, #52]	; (800fddc <GUI_TextRu_Info_Serial+0xec>)
 800fda6:	f000 ffcb 	bl	8010d40 <TFT_SetFont>
	TFT_DisplayString(40, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fdaa:	2303      	movs	r3, #3
 800fdac:	466a      	mov	r2, sp
 800fdae:	21e6      	movs	r1, #230	; 0xe6
 800fdb0:	2028      	movs	r0, #40	; 0x28
 800fdb2:	f001 f893 	bl	8010edc <TFT_DisplayString>
	sprintf (buffer, "%04u",  Number);
 800fdb6:	4622      	mov	r2, r4
 800fdb8:	4909      	ldr	r1, [pc, #36]	; (800fde0 <GUI_TextRu_Info_Serial+0xf0>)
 800fdba:	4668      	mov	r0, sp
 800fdbc:	f002 fae6 	bl	801238c <siprintf>
	TFT_DisplayString(135, Y+30, (uint8_t *)buffer, LEFT_MODE);
 800fdc0:	2303      	movs	r3, #3
 800fdc2:	466a      	mov	r2, sp
 800fdc4:	21e6      	movs	r1, #230	; 0xe6
 800fdc6:	2087      	movs	r0, #135	; 0x87
 800fdc8:	f001 f888 	bl	8010edc <TFT_DisplayString>
}
 800fdcc:	b003      	add	sp, #12
 800fdce:	bd30      	pop	{r4, r5, pc}
 800fdd0:	20000118 	.word	0x20000118
 800fdd4:	20000120 	.word	0x20000120
 800fdd8:	0801f56e 	.word	0x0801f56e
 800fddc:	20000138 	.word	0x20000138
 800fde0:	0801f571 	.word	0x0801f571

0800fde4 <GUI_TextRu_Info_Ver>:

void GUI_TextRu_Info_Ver(uint16_t X, uint16_t Y, float Version)
{
 800fde4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char buffer[5] = {0};
 800fde6:	2300      	movs	r3, #0
	
	X = 120;
	Y = 350;
	
	TFT_SetTextColor(TFT_White);
 800fde8:	f64f 70ff 	movw	r0, #65535	; 0xffff
	char buffer[5] = {0};
 800fdec:	9302      	str	r3, [sp, #8]
 800fdee:	f88d 300c 	strb.w	r3, [sp, #12]
{
 800fdf2:	ed8d 0a01 	vstr	s0, [sp, #4]
	TFT_SetTextColor(TFT_White);
 800fdf6:	f000 ffa9 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fdfa:	2063      	movs	r0, #99	; 0x63
 800fdfc:	f000 ffac 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fe00:	481b      	ldr	r0, [pc, #108]	; (800fe70 <GUI_TextRu_Info_Ver+0x8c>)
	TFT_DrawCharRus(X, Y-1, '');
	TFT_DrawCharRus(X+18, Y-1, '');
	
	TFT_SetFont(&Font16);
 800fe02:	4c1c      	ldr	r4, [pc, #112]	; (800fe74 <GUI_TextRu_Info_Ver+0x90>)
	TFT_SetFont(&Font16RU_arch_big);
 800fe04:	f000 ff9c 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y-1, '');
 800fe08:	229f      	movs	r2, #159	; 0x9f
 800fe0a:	f240 115d 	movw	r1, #349	; 0x15d
 800fe0e:	2078      	movs	r0, #120	; 0x78
 800fe10:	f000 ffa8 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+18, Y-1, '');
 800fe14:	229e      	movs	r2, #158	; 0x9e
 800fe16:	f240 115d 	movw	r1, #349	; 0x15d
 800fe1a:	208a      	movs	r0, #138	; 0x8a
 800fe1c:	f000 ffa2 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16);
 800fe20:	4620      	mov	r0, r4
 800fe22:	f000 ff8d 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+52, Y, '.');
 800fe26:	222e      	movs	r2, #46	; 0x2e
 800fe28:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800fe2c:	20ac      	movs	r0, #172	; 0xac
 800fe2e:	f000 fffd 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+42, Y, 'v');
 800fe32:	2276      	movs	r2, #118	; 0x76
 800fe34:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800fe38:	20a2      	movs	r0, #162	; 0xa2
 800fe3a:	f000 fff7 	bl	8010e2c <TFT_DrawChar>
	
	sprintf (buffer, "%.1f",  Version);
 800fe3e:	ed9d 0a01 	vldr	s0, [sp, #4]
 800fe42:	ee10 0a10 	vmov	r0, s0
 800fe46:	f7f0 fb8f 	bl	8000568 <__aeabi_f2d>
 800fe4a:	4602      	mov	r2, r0
 800fe4c:	460b      	mov	r3, r1
 800fe4e:	a802      	add	r0, sp, #8
 800fe50:	4909      	ldr	r1, [pc, #36]	; (800fe78 <GUI_TextRu_Info_Ver+0x94>)
 800fe52:	f002 fa9b 	bl	801238c <siprintf>
	TFT_SetFont(&Font16);
 800fe56:	4620      	mov	r0, r4
 800fe58:	f000 ff72 	bl	8010d40 <TFT_SetFont>
	TFT_DisplayString(185, Y, (uint8_t *)buffer, LEFT_MODE);
 800fe5c:	2303      	movs	r3, #3
 800fe5e:	aa02      	add	r2, sp, #8
 800fe60:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800fe64:	20b9      	movs	r0, #185	; 0xb9
 800fe66:	f001 f839 	bl	8010edc <TFT_DisplayString>
}
 800fe6a:	b004      	add	sp, #16
 800fe6c:	bd10      	pop	{r4, pc}
 800fe6e:	bf00      	nop
 800fe70:	20000118 	.word	0x20000118
 800fe74:	200000f0 	.word	0x200000f0
 800fe78:	0801f558 	.word	0x0801f558

0800fe7c <GUI_TextRu_CCT>:

void GUI_TextRu_CCT(uint16_t X, uint16_t Y)
{
 800fe7c:	b538      	push	{r3, r4, r5, lr}
 800fe7e:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800fe80:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800fe84:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800fe86:	f000 ff61 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fe8a:	2063      	movs	r0, #99	; 0x63
 800fe8c:	f000 ff64 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 800fe90:	481e      	ldr	r0, [pc, #120]	; (800ff0c <GUI_TextRu_CCT+0x90>)
 800fe92:	f000 ff55 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 800fe96:	4629      	mov	r1, r5
 800fe98:	4620      	mov	r0, r4
 800fe9a:	229a      	movs	r2, #154	; 0x9a
 800fe9c:	f000 ff62 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+17, Y, '');
 800fea0:	f104 0011 	add.w	r0, r4, #17
 800fea4:	4629      	mov	r1, r5
 800fea6:	22a6      	movs	r2, #166	; 0xa6
 800fea8:	b280      	uxth	r0, r0
 800feaa:	f000 ff5b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+33, Y, '');
 800feae:	f104 0021 	add.w	r0, r4, #33	; 0x21
 800feb2:	4629      	mov	r1, r5
 800feb4:	22a2      	movs	r2, #162	; 0xa2
 800feb6:	b280      	uxth	r0, r0
 800feb8:	f000 ff54 	bl	8010d64 <TFT_DrawCharRus>

	TFT_SetFont(&Font16EN_arch_big);
 800febc:	4814      	ldr	r0, [pc, #80]	; (800ff10 <GUI_TextRu_CCT+0x94>)
 800febe:	f000 ff3f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+49, Y, '(');
 800fec2:	f104 0031 	add.w	r0, r4, #49	; 0x31
 800fec6:	4629      	mov	r1, r5
 800fec8:	2228      	movs	r2, #40	; 0x28
 800feca:	b280      	uxth	r0, r0
 800fecc:	f000 ffae 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+104, Y, ')');
 800fed0:	f104 0068 	add.w	r0, r4, #104	; 0x68
 800fed4:	4629      	mov	r1, r5
 800fed6:	2229      	movs	r2, #41	; 0x29
 800fed8:	b280      	uxth	r0, r0
 800feda:	f000 ffa7 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+63, Y, 'C');
 800fede:	f104 003f 	add.w	r0, r4, #63	; 0x3f
 800fee2:	4629      	mov	r1, r5
 800fee4:	2243      	movs	r2, #67	; 0x43
 800fee6:	b280      	uxth	r0, r0
 800fee8:	f000 ffa0 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+76, Y, 'C');
 800feec:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 800fef0:	4629      	mov	r1, r5
 800fef2:	2243      	movs	r2, #67	; 0x43
 800fef4:	b280      	uxth	r0, r0
 800fef6:	f000 ff99 	bl	8010e2c <TFT_DrawChar>
	TFT_DrawChar(X+91, Y, 'T');
 800fefa:	f104 005b 	add.w	r0, r4, #91	; 0x5b
 800fefe:	4629      	mov	r1, r5
 800ff00:	2254      	movs	r2, #84	; 0x54
 800ff02:	b280      	uxth	r0, r0
}
 800ff04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawChar(X+91, Y, 'T');
 800ff08:	f000 bf90 	b.w	8010e2c <TFT_DrawChar>
 800ff0c:	20000118 	.word	0x20000118
 800ff10:	200000f8 	.word	0x200000f8

0800ff14 <GUI_TextRu_umol>:

void GUI_TextRu_umol(uint16_t X, uint16_t Y, uint8_t deg)
{
 800ff14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800ff18:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 800ff1a:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800ff1e:	4616      	mov	r6, r2
 800ff20:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 800ff22:	f000 ff13 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800ff26:	2063      	movs	r0, #99	; 0x63
 800ff28:	f000 ff16 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font12RU_arch_small);
 800ff2c:	482f      	ldr	r0, [pc, #188]	; (800ffec <GUI_TextRu_umol+0xd8>)
 800ff2e:	f000 ff07 	bl	8010d40 <TFT_SetFont>
	
	if(deg){
 800ff32:	2e00      	cmp	r6, #0
 800ff34:	d057      	beq.n	800ffe6 <GUI_TextRu_umol+0xd2>
		TFT_DrawCharRus(X, Y, '');
 800ff36:	22bc      	movs	r2, #188	; 0xbc
	} else{
		TFT_DrawCharRus(X, Y, ''+1);
 800ff38:	4629      	mov	r1, r5
 800ff3a:	4620      	mov	r0, r4
 800ff3c:	f000 ff12 	bl	8010d64 <TFT_DrawCharRus>
	}

	TFT_DrawCharRus(X+8, Y, '');
 800ff40:	f104 0008 	add.w	r0, r4, #8
 800ff44:	4629      	mov	r1, r5
 800ff46:	22bc      	movs	r2, #188	; 0xbc
 800ff48:	b280      	uxth	r0, r0
 800ff4a:	f000 ff0b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+16, Y, '');
	TFT_DrawCharRus(X+22, Y, '');
 800ff4e:	f104 0716 	add.w	r7, r4, #22
	TFT_DrawCharRus(X+16, Y, '');
 800ff52:	f104 0010 	add.w	r0, r4, #16
 800ff56:	4629      	mov	r1, r5
	TFT_DrawCharRus(X+22, Y, '');
 800ff58:	b2bf      	uxth	r7, r7
	TFT_DrawCharRus(X+16, Y, '');
 800ff5a:	22be      	movs	r2, #190	; 0xbe
 800ff5c:	b280      	uxth	r0, r0
 800ff5e:	f000 ff01 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+22, Y, '');
 800ff62:	4629      	mov	r1, r5
 800ff64:	4638      	mov	r0, r7
 800ff66:	22bb      	movs	r2, #187	; 0xbb
 800ff68:	f000 fefc 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y, '');
 800ff6c:	f104 001c 	add.w	r0, r4, #28
 800ff70:	4629      	mov	r1, r5
 800ff72:	228c      	movs	r2, #140	; 0x8c
 800ff74:	b280      	uxth	r0, r0
 800ff76:	f000 fef5 	bl	8010d64 <TFT_DrawCharRus>
	
	TFT_DrawLine(X, Y+10, X+35, Y+10, TFT_White);
 800ff7a:	f105 030a 	add.w	r3, r5, #10
 800ff7e:	b29b      	uxth	r3, r3
 800ff80:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800ff84:	f104 0223 	add.w	r2, r4, #35	; 0x23
 800ff88:	4619      	mov	r1, r3
 800ff8a:	4620      	mov	r0, r4
 800ff8c:	f8cd 8000 	str.w	r8, [sp]
 800ff90:	b292      	uxth	r2, r2
	
	TFT_DrawCharRus(X+13, Y+11, ''+2);
 800ff92:	f105 060b 	add.w	r6, r5, #11
	TFT_DrawLine(X, Y+10, X+35, Y+10, TFT_White);
 800ff96:	f000 fc73 	bl	8010880 <TFT_DrawLine>
	TFT_DrawCharRus(X+13, Y+11, ''+2);
 800ff9a:	b2b6      	uxth	r6, r6
 800ff9c:	f104 000d 	add.w	r0, r4, #13
 800ffa0:	4631      	mov	r1, r6
 800ffa2:	2291      	movs	r2, #145	; 0x91
 800ffa4:	b280      	uxth	r0, r0
 800ffa6:	f000 fedd 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+5, Y+11, '');
 800ffaa:	1d60      	adds	r0, r4, #5
 800ffac:	4631      	mov	r1, r6
 800ffae:	22bc      	movs	r2, #188	; 0xbc
 800ffb0:	b280      	uxth	r0, r0
 800ffb2:	f000 fed7 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawRectangle(X+19, Y+14, X+20, Y+15, TFT_White);
 800ffb6:	f105 030f 	add.w	r3, r5, #15
 800ffba:	f104 0214 	add.w	r2, r4, #20
 800ffbe:	f105 010e 	add.w	r1, r5, #14
 800ffc2:	f104 0013 	add.w	r0, r4, #19
 800ffc6:	f8cd 8000 	str.w	r8, [sp]
 800ffca:	b29b      	uxth	r3, r3
 800ffcc:	b292      	uxth	r2, r2
 800ffce:	b289      	uxth	r1, r1
 800ffd0:	b280      	uxth	r0, r0
 800ffd2:	f000 fcca 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawCharRus(X+22, Y+11, '');
 800ffd6:	2281      	movs	r2, #129	; 0x81
 800ffd8:	4631      	mov	r1, r6
 800ffda:	4638      	mov	r0, r7
}
 800ffdc:	b002      	add	sp, #8
 800ffde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TFT_DrawCharRus(X+22, Y+11, '');
 800ffe2:	f000 bebf 	b.w	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X, Y, ''+1);
 800ffe6:	2290      	movs	r2, #144	; 0x90
 800ffe8:	e7a6      	b.n	800ff38 <GUI_TextRu_umol+0x24>
 800ffea:	bf00      	nop
 800ffec:	200000e8 	.word	0x200000e8

0800fff0 <GUI_TextRu_W_m2>:
	TFT_DrawCharRus(X+39, Y+12, '');
	
}

void GUI_TextRu_W_m2(uint16_t X, uint16_t Y)
{
 800fff0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800fff2:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 800fff4:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 800fff8:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 800fffa:	f000 fea7 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 800fffe:	2063      	movs	r0, #99	; 0x63
 8010000:	f000 feaa 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font12RU_arch_big);
 8010004:	4819      	ldr	r0, [pc, #100]	; (801006c <GUI_TextRu_W_m2+0x7c>)
 8010006:	f000 fe9b 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+3, Y, ''-17);
 801000a:	1ce8      	adds	r0, r5, #3
 801000c:	4621      	mov	r1, r4
 801000e:	2281      	movs	r2, #129	; 0x81
 8010010:	b280      	uxth	r0, r0
 8010012:	f000 fea7 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font12RU_arch_small);
 8010016:	4816      	ldr	r0, [pc, #88]	; (8010070 <GUI_TextRu_W_m2+0x80>)
 8010018:	f000 fe92 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+13, Y+2, '');
 801001c:	1ca1      	adds	r1, r4, #2
 801001e:	f105 000d 	add.w	r0, r5, #13
 8010022:	2282      	movs	r2, #130	; 0x82
 8010024:	b289      	uxth	r1, r1
 8010026:	b280      	uxth	r0, r0
 8010028:	f000 fe9c 	bl	8010d64 <TFT_DrawCharRus>
	
	TFT_DrawLine(X, Y+10, X+20, Y+10, TFT_White);
 801002c:	f104 030a 	add.w	r3, r4, #10
 8010030:	b29b      	uxth	r3, r3
 8010032:	f105 0214 	add.w	r2, r5, #20
 8010036:	f64f 71ff 	movw	r1, #65535	; 0xffff
 801003a:	9100      	str	r1, [sp, #0]
 801003c:	4628      	mov	r0, r5
 801003e:	4619      	mov	r1, r3
 8010040:	b292      	uxth	r2, r2
	
	TFT_DrawCharRus(X+12, Y+12, ''+2);
 8010042:	340c      	adds	r4, #12
	TFT_DrawLine(X, Y+10, X+20, Y+10, TFT_White);
 8010044:	f000 fc1c 	bl	8010880 <TFT_DrawLine>
	TFT_DrawCharRus(X+12, Y+12, ''+2);
 8010048:	b2a4      	uxth	r4, r4
 801004a:	f105 000c 	add.w	r0, r5, #12
 801004e:	4621      	mov	r1, r4
 8010050:	2291      	movs	r2, #145	; 0x91
 8010052:	b280      	uxth	r0, r0
 8010054:	f000 fe86 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+4, Y+12, '');
 8010058:	1d28      	adds	r0, r5, #4
 801005a:	22bc      	movs	r2, #188	; 0xbc
 801005c:	4621      	mov	r1, r4
 801005e:	b280      	uxth	r0, r0
}
 8010060:	b003      	add	sp, #12
 8010062:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	TFT_DrawCharRus(X+4, Y+12, '');
 8010066:	f000 be7d 	b.w	8010d64 <TFT_DrawCharRus>
 801006a:	bf00      	nop
 801006c:	200000e0 	.word	0x200000e0
 8010070:	200000e8 	.word	0x200000e8

08010074 <GUI_TextRu_W_m2_sr>:

void GUI_TextRu_W_m2_sr(uint16_t X, uint16_t Y)
{
 8010074:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8010078:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 801007a:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 801007e:	460d      	mov	r5, r1
	TFT_SetTextColor(TFT_White);
 8010080:	f000 fe64 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 8010084:	2063      	movs	r0, #99	; 0x63
 8010086:	f000 fe67 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font12RU_arch_big);
 801008a:	4829      	ldr	r0, [pc, #164]	; (8010130 <GUI_TextRu_W_m2_sr+0xbc>)
 801008c:	f000 fe58 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+8, Y, ''-17);
 8010090:	f104 0008 	add.w	r0, r4, #8
 8010094:	4629      	mov	r1, r5
 8010096:	2281      	movs	r2, #129	; 0x81
 8010098:	b280      	uxth	r0, r0
 801009a:	f000 fe63 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font12RU_arch_small);
	TFT_DrawCharRus(X+18, Y+2, '');
 801009e:	f104 0712 	add.w	r7, r4, #18
	TFT_SetFont(&Font12RU_arch_small);
 80100a2:	4824      	ldr	r0, [pc, #144]	; (8010134 <GUI_TextRu_W_m2_sr+0xc0>)
 80100a4:	f000 fe4c 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+18, Y+2, '');
 80100a8:	b2bf      	uxth	r7, r7
 80100aa:	1ca9      	adds	r1, r5, #2
 80100ac:	4638      	mov	r0, r7
 80100ae:	2282      	movs	r2, #130	; 0x82
 80100b0:	b289      	uxth	r1, r1
 80100b2:	f000 fe57 	bl	8010d64 <TFT_DrawCharRus>
	
	TFT_DrawLine(X, Y+10, X+35, Y+10, TFT_White);
 80100b6:	f105 030a 	add.w	r3, r5, #10
 80100ba:	b29b      	uxth	r3, r3
 80100bc:	f64f 78ff 	movw	r8, #65535	; 0xffff
 80100c0:	f104 0223 	add.w	r2, r4, #35	; 0x23
 80100c4:	4619      	mov	r1, r3
 80100c6:	4620      	mov	r0, r4
 80100c8:	f8cd 8000 	str.w	r8, [sp]
 80100cc:	b292      	uxth	r2, r2
	
	TFT_DrawCharRus(X+10, Y+12, ''+2);
 80100ce:	f105 060c 	add.w	r6, r5, #12
	TFT_DrawLine(X, Y+10, X+35, Y+10, TFT_White);
 80100d2:	f000 fbd5 	bl	8010880 <TFT_DrawLine>
	TFT_DrawCharRus(X+10, Y+12, ''+2);
 80100d6:	b2b6      	uxth	r6, r6
 80100d8:	f104 000a 	add.w	r0, r4, #10
 80100dc:	4631      	mov	r1, r6
 80100de:	2291      	movs	r2, #145	; 0x91
 80100e0:	b280      	uxth	r0, r0
 80100e2:	f000 fe3f 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+2, Y+12, '');
 80100e6:	1ca0      	adds	r0, r4, #2
 80100e8:	4631      	mov	r1, r6
 80100ea:	22bc      	movs	r2, #188	; 0xbc
 80100ec:	b280      	uxth	r0, r0
 80100ee:	f000 fe39 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawRectangle(X+17, Y+16, X+18, Y+15, TFT_White);
 80100f2:	f105 030f 	add.w	r3, r5, #15
 80100f6:	f105 0110 	add.w	r1, r5, #16
 80100fa:	f104 0011 	add.w	r0, r4, #17
 80100fe:	b29b      	uxth	r3, r3
 8010100:	463a      	mov	r2, r7
 8010102:	f8cd 8000 	str.w	r8, [sp]
 8010106:	b289      	uxth	r1, r1
 8010108:	b280      	uxth	r0, r0
 801010a:	f000 fc2e 	bl	801096a <TFT_DrawRectangle>
	TFT_DrawCharRus(X+21, Y+12, '');
 801010e:	f104 0015 	add.w	r0, r4, #21
 8010112:	4631      	mov	r1, r6
 8010114:	2281      	movs	r2, #129	; 0x81
 8010116:	b280      	uxth	r0, r0
 8010118:	f000 fe24 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+12, '');
 801011c:	f104 001c 	add.w	r0, r4, #28
 8010120:	2280      	movs	r2, #128	; 0x80
 8010122:	4631      	mov	r1, r6
 8010124:	b280      	uxth	r0, r0
}
 8010126:	b002      	add	sp, #8
 8010128:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TFT_DrawCharRus(X+28, Y+12, '');
 801012c:	f000 be1a 	b.w	8010d64 <TFT_DrawCharRus>
 8010130:	200000e0 	.word	0x200000e0
 8010134:	200000e8 	.word	0x200000e8

08010138 <GUI_TextRu_Cd_m2>:

void GUI_TextRu_Cd_m2(uint16_t X, uint16_t Y, uint8_t deg)
{
 8010138:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 801013c:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 801013e:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 8010142:	460e      	mov	r6, r1
 8010144:	4692      	mov	sl, r2
	TFT_SetTextColor(TFT_White);
 8010146:	f000 fe01 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 801014a:	2063      	movs	r0, #99	; 0x63
 801014c:	f000 fe04 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font12RU_arch_small);
 8010150:	482f      	ldr	r0, [pc, #188]	; (8010210 <GUI_TextRu_Cd_m2+0xd8>)
 8010152:	f000 fdf5 	bl	8010d40 <TFT_SetFont>
 8010156:	f104 0008 	add.w	r0, r4, #8
 801015a:	f104 0810 	add.w	r8, r4, #16
 801015e:	f106 070a 	add.w	r7, r6, #10
 8010162:	f104 0906 	add.w	r9, r4, #6
 8010166:	f106 050c 	add.w	r5, r6, #12
	
	if(deg){
		TFT_DrawCharRus(X+8, Y, '');
 801016a:	22ba      	movs	r2, #186	; 0xba
 801016c:	4631      	mov	r1, r6
 801016e:	b280      	uxth	r0, r0
	if(deg){
 8010170:	f1ba 0f00 	cmp.w	sl, #0
 8010174:	d02c      	beq.n	80101d0 <GUI_TextRu_Cd_m2+0x98>
		TFT_DrawCharRus(X+8, Y, '');
 8010176:	f000 fdf5 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+16, Y, '');
 801017a:	22ba      	movs	r2, #186	; 0xba
 801017c:	4631      	mov	r1, r6
 801017e:	fa1f f088 	uxth.w	r0, r8
 8010182:	f000 fdef 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+24, Y, '');
 8010186:	f104 0018 	add.w	r0, r4, #24
 801018a:	22b4      	movs	r2, #180	; 0xb4
 801018c:	4631      	mov	r1, r6
 801018e:	b280      	uxth	r0, r0
 8010190:	f000 fde8 	bl	8010d64 <TFT_DrawCharRus>
		
		TFT_DrawLine(X+6, Y+10, X+31, Y+10, TFT_White);
 8010194:	b2bb      	uxth	r3, r7
 8010196:	f64f 71ff 	movw	r1, #65535	; 0xffff
 801019a:	f104 021f 	add.w	r2, r4, #31
 801019e:	9100      	str	r1, [sp, #0]
 80101a0:	b292      	uxth	r2, r2
 80101a2:	4619      	mov	r1, r3
 80101a4:	fa1f f089 	uxth.w	r0, r9
 80101a8:	f000 fb6a 	bl	8010880 <TFT_DrawLine>
		
		TFT_DrawCharRus(X+20, Y+12, ''+2);
 80101ac:	b2ad      	uxth	r5, r5
 80101ae:	f104 0014 	add.w	r0, r4, #20
 80101b2:	b280      	uxth	r0, r0
 80101b4:	2291      	movs	r2, #145	; 0x91
 80101b6:	4629      	mov	r1, r5
 80101b8:	f000 fdd4 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+12, Y+12, '');}
 80101bc:	f104 000c 	add.w	r0, r4, #12
		TFT_DrawCharRus(X+16, Y, '');
		
		TFT_DrawLine(X+6, Y+10, X+23, Y+10, TFT_White);
		
		TFT_DrawCharRus(X+17, Y+12, ''+2);
		TFT_DrawCharRus(X+9, Y+12, '');}
 80101c0:	22bc      	movs	r2, #188	; 0xbc
 80101c2:	4629      	mov	r1, r5
 80101c4:	b280      	uxth	r0, r0
		
}
 80101c6:	b002      	add	sp, #8
 80101c8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		TFT_DrawCharRus(X+9, Y+12, '');}
 80101cc:	f000 bdca 	b.w	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+8, Y, '');
 80101d0:	f000 fdc8 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+16, Y, '');
 80101d4:	22b4      	movs	r2, #180	; 0xb4
 80101d6:	4631      	mov	r1, r6
 80101d8:	fa1f f088 	uxth.w	r0, r8
 80101dc:	f000 fdc2 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawLine(X+6, Y+10, X+23, Y+10, TFT_White);
 80101e0:	b2bb      	uxth	r3, r7
 80101e2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80101e6:	f104 0217 	add.w	r2, r4, #23
 80101ea:	9100      	str	r1, [sp, #0]
 80101ec:	b292      	uxth	r2, r2
 80101ee:	4619      	mov	r1, r3
 80101f0:	fa1f f089 	uxth.w	r0, r9
 80101f4:	f000 fb44 	bl	8010880 <TFT_DrawLine>
		TFT_DrawCharRus(X+17, Y+12, ''+2);
 80101f8:	b2ad      	uxth	r5, r5
 80101fa:	f104 0011 	add.w	r0, r4, #17
 80101fe:	b280      	uxth	r0, r0
 8010200:	2291      	movs	r2, #145	; 0x91
 8010202:	4629      	mov	r1, r5
 8010204:	f000 fdae 	bl	8010d64 <TFT_DrawCharRus>
		TFT_DrawCharRus(X+9, Y+12, '');}
 8010208:	f104 0009 	add.w	r0, r4, #9
 801020c:	e7d8      	b.n	80101c0 <GUI_TextRu_Cd_m2+0x88>
 801020e:	bf00      	nop
 8010210:	200000e8 	.word	0x200000e8

08010214 <GUI_TextRu_Irradiance>:

void GUI_TextRu_Irradiance(uint16_t X, uint16_t Y)
{
 8010214:	b538      	push	{r3, r4, r5, lr}
 8010216:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 8010218:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 801021c:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 801021e:	f000 fd95 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 8010222:	2063      	movs	r0, #99	; 0x63
 8010224:	f000 fd98 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 8010228:	482d      	ldr	r0, [pc, #180]	; (80102e0 <GUI_TextRu_Irradiance+0xcc>)
 801022a:	f000 fd89 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 801022e:	4621      	mov	r1, r4
 8010230:	229e      	movs	r2, #158	; 0x9e
 8010232:	4628      	mov	r0, r5
 8010234:	f000 fd96 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+16, Y+5, '');
 8010238:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 801023a:	482a      	ldr	r0, [pc, #168]	; (80102e4 <GUI_TextRu_Irradiance+0xd0>)
	TFT_DrawCharRus(X+16, Y+5, '');
 801023c:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 801023e:	f000 fd7f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+16, Y+5, '');
 8010242:	f105 0010 	add.w	r0, r5, #16
 8010246:	4621      	mov	r1, r4
 8010248:	22b1      	movs	r2, #177	; 0xb1
 801024a:	b280      	uxth	r0, r0
 801024c:	f000 fd8a 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+27, Y+5, '');
 8010250:	f105 001b 	add.w	r0, r5, #27
 8010254:	4621      	mov	r1, r4
 8010256:	22bb      	movs	r2, #187	; 0xbb
 8010258:	b280      	uxth	r0, r0
 801025a:	f000 fd83 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+39, Y+5, '');
 801025e:	f105 0027 	add.w	r0, r5, #39	; 0x27
 8010262:	4621      	mov	r1, r4
 8010264:	2283      	movs	r2, #131	; 0x83
 8010266:	b280      	uxth	r0, r0
 8010268:	f000 fd7c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+51, Y+5, '');
 801026c:	f105 0033 	add.w	r0, r5, #51	; 0x33
 8010270:	4621      	mov	r1, r4
 8010272:	2287      	movs	r2, #135	; 0x87
 8010274:	b280      	uxth	r0, r0
 8010276:	f000 fd75 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+63, Y+5, '');
 801027a:	f105 003f 	add.w	r0, r5, #63	; 0x3f
 801027e:	4621      	mov	r1, r4
 8010280:	22b5      	movs	r2, #181	; 0xb5
 8010282:	b280      	uxth	r0, r0
 8010284:	f000 fd6e 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+74, Y+5, '');
 8010288:	f105 004a 	add.w	r0, r5, #74	; 0x4a
 801028c:	4621      	mov	r1, r4
 801028e:	22bd      	movs	r2, #189	; 0xbd
 8010290:	b280      	uxth	r0, r0
 8010292:	f000 fd67 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+86, Y+5, '');
 8010296:	f105 0056 	add.w	r0, r5, #86	; 0x56
 801029a:	4621      	mov	r1, r4
 801029c:	22bd      	movs	r2, #189	; 0xbd
 801029e:	b280      	uxth	r0, r0
 80102a0:	f000 fd60 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+98, Y+5, '');
 80102a4:	f105 0062 	add.w	r0, r5, #98	; 0x62
 80102a8:	4621      	mov	r1, r4
 80102aa:	22be      	movs	r2, #190	; 0xbe
 80102ac:	b280      	uxth	r0, r0
 80102ae:	f000 fd59 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+110, Y+5, '');
 80102b2:	f105 006e 	add.w	r0, r5, #110	; 0x6e
 80102b6:	4621      	mov	r1, r4
 80102b8:	2281      	movs	r2, #129	; 0x81
 80102ba:	b280      	uxth	r0, r0
 80102bc:	f000 fd52 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+119, Y+5, '');
 80102c0:	f105 0077 	add.w	r0, r5, #119	; 0x77
 80102c4:	4621      	mov	r1, r4
 80102c6:	2282      	movs	r2, #130	; 0x82
 80102c8:	b280      	uxth	r0, r0
 80102ca:	f000 fd4b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+131, Y+5, '');
 80102ce:	f105 0083 	add.w	r0, r5, #131	; 0x83
 80102d2:	4621      	mov	r1, r4
 80102d4:	228c      	movs	r2, #140	; 0x8c
 80102d6:	b280      	uxth	r0, r0
}
 80102d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+131, Y+5, '');
 80102dc:	f000 bd42 	b.w	8010d64 <TFT_DrawCharRus>
 80102e0:	20000118 	.word	0x20000118
 80102e4:	20000120 	.word	0x20000120

080102e8 <GUI_TextRu_Luminance>:

void GUI_TextRu_Luminance(uint16_t X, uint16_t Y)
{
 80102e8:	b538      	push	{r3, r4, r5, lr}
 80102ea:	4605      	mov	r5, r0
	TFT_SetTextColor(TFT_White);
 80102ec:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 80102f0:	460c      	mov	r4, r1
	TFT_SetTextColor(TFT_White);
 80102f2:	f000 fd2b 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 80102f6:	2063      	movs	r0, #99	; 0x63
 80102f8:	f000 fd2e 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
 80102fc:	481c      	ldr	r0, [pc, #112]	; (8010370 <GUI_TextRu_Luminance+0x88>)
 80102fe:	f000 fd1f 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 8010302:	4621      	mov	r1, r4
 8010304:	22af      	movs	r2, #175	; 0xaf
 8010306:	4628      	mov	r0, r5
 8010308:	f000 fd2c 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16RU_arch_small);
	TFT_DrawCharRus(X+16, Y+5, '');
 801030c:	3405      	adds	r4, #5
	TFT_SetFont(&Font16RU_arch_small);
 801030e:	4819      	ldr	r0, [pc, #100]	; (8010374 <GUI_TextRu_Luminance+0x8c>)
	TFT_DrawCharRus(X+16, Y+5, '');
 8010310:	b2a4      	uxth	r4, r4
	TFT_SetFont(&Font16RU_arch_small);
 8010312:	f000 fd15 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+16, Y+5, '');
 8010316:	f105 0010 	add.w	r0, r5, #16
 801031a:	4621      	mov	r1, r4
 801031c:	2280      	movs	r2, #128	; 0x80
 801031e:	b280      	uxth	r0, r0
 8010320:	f000 fd20 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+28, Y+5, '');
 8010324:	f105 001c 	add.w	r0, r5, #28
 8010328:	4621      	mov	r1, r4
 801032a:	22ba      	movs	r2, #186	; 0xba
 801032c:	b280      	uxth	r0, r0
 801032e:	f000 fd19 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+40, Y+5, '');
 8010332:	f105 0028 	add.w	r0, r5, #40	; 0x28
 8010336:	4621      	mov	r1, r4
 8010338:	22be      	movs	r2, #190	; 0xbe
 801033a:	b280      	uxth	r0, r0
 801033c:	f000 fd12 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+52, Y+5, '');
 8010340:	f105 0034 	add.w	r0, r5, #52	; 0x34
 8010344:	4621      	mov	r1, r4
 8010346:	2281      	movs	r2, #129	; 0x81
 8010348:	b280      	uxth	r0, r0
 801034a:	f000 fd0b 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+63, Y+5, '');
 801034e:	f105 003f 	add.w	r0, r5, #63	; 0x3f
 8010352:	4621      	mov	r1, r4
 8010354:	2282      	movs	r2, #130	; 0x82
 8010356:	b280      	uxth	r0, r0
 8010358:	f000 fd04 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+74, Y+5, '');
 801035c:	f105 004a 	add.w	r0, r5, #74	; 0x4a
 8010360:	4621      	mov	r1, r4
 8010362:	228c      	movs	r2, #140	; 0x8c
 8010364:	b280      	uxth	r0, r0
}
 8010366:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	TFT_DrawCharRus(X+74, Y+5, '');
 801036a:	f000 bcfb 	b.w	8010d64 <TFT_DrawCharRus>
 801036e:	bf00      	nop
 8010370:	20000118 	.word	0x20000118
 8010374:	20000120 	.word	0x20000120

08010378 <GUI_TextRu_Radiance>:

void GUI_TextRu_Radiance(uint16_t X, uint16_t Y)
{
 8010378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801037a:	4604      	mov	r4, r0
	TFT_SetTextColor(TFT_White);
 801037c:	f64f 70ff 	movw	r0, #65535	; 0xffff
{
 8010380:	460e      	mov	r6, r1
	TFT_SetTextColor(TFT_White);
 8010382:	f000 fce3 	bl	8010d4c <TFT_SetTextColor>
	TFT_SetBackColor(TFT_Black_Bkgr);
 8010386:	2063      	movs	r0, #99	; 0x63
 8010388:	f000 fce6 	bl	8010d58 <TFT_SetBackColor>
	TFT_SetFont(&Font16RU_arch_big);
	TFT_DrawCharRus(X, Y, '');
	TFT_SetFont(&Font16RU_arch_small);
 801038c:	4f31      	ldr	r7, [pc, #196]	; (8010454 <GUI_TextRu_Radiance+0xdc>)
	TFT_SetFont(&Font16RU_arch_big);
 801038e:	4832      	ldr	r0, [pc, #200]	; (8010458 <GUI_TextRu_Radiance+0xe0>)
 8010390:	f000 fcd6 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X, Y, '');
 8010394:	4631      	mov	r1, r6
 8010396:	22ad      	movs	r2, #173	; 0xad
 8010398:	4620      	mov	r0, r4
 801039a:	f000 fce3 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+16, Y+5, '');
 801039e:	1d75      	adds	r5, r6, #5
	TFT_SetFont(&Font16RU_arch_small);
 80103a0:	4638      	mov	r0, r7
	TFT_DrawCharRus(X+16, Y+5, '');
 80103a2:	b2ad      	uxth	r5, r5
	TFT_SetFont(&Font16RU_arch_small);
 80103a4:	f000 fccc 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+16, Y+5, '');
 80103a8:	f104 0010 	add.w	r0, r4, #16
 80103ac:	4629      	mov	r1, r5
 80103ae:	22bd      	movs	r2, #189	; 0xbd
 80103b0:	b280      	uxth	r0, r0
 80103b2:	f000 fcd7 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+29, Y+5, '');
 80103b6:	f104 001d 	add.w	r0, r4, #29
 80103ba:	4629      	mov	r1, r5
 80103bc:	22b5      	movs	r2, #181	; 0xb5
 80103be:	b280      	uxth	r0, r0
 80103c0:	f000 fcd0 	bl	8010d64 <TFT_DrawCharRus>
	TFT_SetFont(&Font16EN_arch_big);
 80103c4:	4825      	ldr	r0, [pc, #148]	; (801045c <GUI_TextRu_Radiance+0xe4>)
 80103c6:	f000 fcbb 	bl	8010d40 <TFT_SetFont>
	TFT_DrawChar(X+46, 		Y, '.');
 80103ca:	f104 002e 	add.w	r0, r4, #46	; 0x2e
 80103ce:	4631      	mov	r1, r6
 80103d0:	222e      	movs	r2, #46	; 0x2e
 80103d2:	b280      	uxth	r0, r0
 80103d4:	f000 fd2a 	bl	8010e2c <TFT_DrawChar>

	TFT_SetFont(&Font16RU_arch_small);
 80103d8:	4638      	mov	r0, r7
 80103da:	f000 fcb1 	bl	8010d40 <TFT_SetFont>
	TFT_DrawCharRus(X+41, Y+5, '');
 80103de:	f104 0029 	add.w	r0, r4, #41	; 0x29
 80103e2:	4629      	mov	r1, r5
 80103e4:	2280      	movs	r2, #128	; 0x80
 80103e6:	b280      	uxth	r0, r0
 80103e8:	f000 fcbc 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+61, Y+5, '');
 80103ec:	f104 003d 	add.w	r0, r4, #61	; 0x3d
 80103f0:	4629      	mov	r1, r5
 80103f2:	228f      	movs	r2, #143	; 0x8f
 80103f4:	b280      	uxth	r0, r0
 80103f6:	f000 fcb5 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+73, Y+5, '');
 80103fa:	f104 0049 	add.w	r0, r4, #73	; 0x49
 80103fe:	4629      	mov	r1, r5
 8010400:	2280      	movs	r2, #128	; 0x80
 8010402:	b280      	uxth	r0, r0
 8010404:	f000 fcae 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+85, Y+5, '');
 8010408:	f104 0055 	add.w	r0, r4, #85	; 0x55
 801040c:	4629      	mov	r1, r5
 801040e:	22ba      	movs	r2, #186	; 0xba
 8010410:	b280      	uxth	r0, r0
 8010412:	f000 fca7 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+97, Y+5, '');
 8010416:	f104 0061 	add.w	r0, r4, #97	; 0x61
 801041a:	4629      	mov	r1, r5
 801041c:	22be      	movs	r2, #190	; 0xbe
 801041e:	b280      	uxth	r0, r0
 8010420:	f000 fca0 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+109, Y+5, '');
 8010424:	f104 006d 	add.w	r0, r4, #109	; 0x6d
 8010428:	4629      	mov	r1, r5
 801042a:	2281      	movs	r2, #129	; 0x81
 801042c:	b280      	uxth	r0, r0
 801042e:	f000 fc99 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+120, Y+5, '');
 8010432:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8010436:	4629      	mov	r1, r5
 8010438:	2282      	movs	r2, #130	; 0x82
 801043a:	b280      	uxth	r0, r0
 801043c:	f000 fc92 	bl	8010d64 <TFT_DrawCharRus>
	TFT_DrawCharRus(X+131, Y+5, '');
 8010440:	f104 0083 	add.w	r0, r4, #131	; 0x83
 8010444:	4629      	mov	r1, r5
 8010446:	228c      	movs	r2, #140	; 0x8c
 8010448:	b280      	uxth	r0, r0

}
 801044a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	TFT_DrawCharRus(X+131, Y+5, '');
 801044e:	f000 bc89 	b.w	8010d64 <TFT_DrawCharRus>
 8010452:	bf00      	nop
 8010454:	20000120 	.word	0x20000120
 8010458:	20000118 	.word	0x20000118
 801045c:	200000f8 	.word	0x200000f8

08010460 <Rabs_calc_Factor2_Settings_change>:
#include "Rabs_math.h"

float Rabs_calc_Factor2_Settings_change(float Kt, float P)
{
	return Kt * P;
}
 8010460:	ee20 0a20 	vmul.f32	s0, s0, s1
 8010464:	4770      	bx	lr
	...

08010468 <TS_IO_Read>:
{

  }

uint8_t TS_IO_Read(uint8_t DeviceAddr, uint8_t Reg)
{
 8010468:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t read_value = 0;
 801046a:	aa06      	add	r2, sp, #24
 801046c:	2300      	movs	r3, #0
 801046e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  HAL_I2C_Mem_Read(&hi2c1, DeviceAddr, Reg, I2C_MEMADD_SIZE_8BIT, &read_value, 1, 0x100);
 8010472:	f44f 7380 	mov.w	r3, #256	; 0x100
 8010476:	9302      	str	r3, [sp, #8]
 8010478:	2301      	movs	r3, #1
 801047a:	e88d 000c 	stmia.w	sp, {r2, r3}
 801047e:	460a      	mov	r2, r1
 8010480:	4601      	mov	r1, r0
 8010482:	4804      	ldr	r0, [pc, #16]	; (8010494 <TS_IO_Read+0x2c>)
 8010484:	f7f1 ff5e 	bl	8002344 <HAL_I2C_Mem_Read>

  return read_value;
}
 8010488:	f89d 0017 	ldrb.w	r0, [sp, #23]
 801048c:	b007      	add	sp, #28
 801048e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010492:	bf00      	nop
 8010494:	200859dc 	.word	0x200859dc

08010498 <TS_ReadID>:
  HAL_I2C_Mem_Write(&hi2c1, DeviceAddr, (uint8_t)Reg, I2C_MEMADD_SIZE_8BIT, &Value, 1, 0x100);
  if(status != HAL_OK) Error();
}

uint8_t TS_ReadID(uint8_t DeviceAddr)
{
 8010498:	b537      	push	{r0, r1, r2, r4, r5, lr}
  volatile uint8_t ucReadId = 0;
 801049a:	2300      	movs	r3, #0
{
 801049c:	4605      	mov	r5, r0
  volatile uint8_t ucReadId = 0;
 801049e:	f88d 3007 	strb.w	r3, [sp, #7]
 80104a2:	2403      	movs	r4, #3
  uint8_t nbReadAttempts = 0;
  int8_t bFoundDevice = 0;

  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
  {
    ucReadId = TS_IO_Read(DeviceAddr, ID_G_CIPHER);
 80104a4:	21a3      	movs	r1, #163	; 0xa3
 80104a6:	4628      	mov	r0, r5
 80104a8:	f7ff ffde 	bl	8010468 <TS_IO_Read>
 80104ac:	f88d 0007 	strb.w	r0, [sp, #7]
    if(ucReadId == CHIP_ID)
 80104b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80104b4:	3c01      	subs	r4, #1
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 80104b6:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    if(ucReadId == CHIP_ID)
 80104ba:	b2db      	uxtb	r3, r3
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 80104bc:	d001      	beq.n	80104c2 <TS_ReadID+0x2a>
 80104be:	2b0a      	cmp	r3, #10
 80104c0:	d1f0      	bne.n	80104a4 <TS_ReadID+0xc>
    {
      bFoundDevice = 1;
    }
  }
  return (ucReadId);
 80104c2:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 80104c6:	b003      	add	sp, #12
 80104c8:	bd30      	pop	{r4, r5, pc}

080104ca <Touch_Ini>:

void Touch_Ini(void)
{
 80104ca:	b508      	push	{r3, lr}
	if(TS_ReadID(TS_I2C_ADDRESS) != CHIP_ID) Error();
 80104cc:	2070      	movs	r0, #112	; 0x70
 80104ce:	f7ff ffe3 	bl	8010498 <TS_ReadID>
  HAL_Delay(200);
 80104d2:	20c8      	movs	r0, #200	; 0xc8
}
 80104d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_Delay(200);
 80104d8:	f7f0 bd6a 	b.w	8000fb0 <HAL_Delay>

080104dc <TS_Get_XY1>:

void TS_Get_XY1(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)
{
 80104dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static uint16_t coord = 0x0000;
	uint16_t temp;
  coord = (TS_IO_Read(DeviceAddr, TOUCH1_XH) << 8) & 0x0F00;
 80104de:	b2c5      	uxtb	r5, r0
{
 80104e0:	460e      	mov	r6, r1
  coord = (TS_IO_Read(DeviceAddr, TOUCH1_XH) << 8) & 0x0F00;
 80104e2:	4628      	mov	r0, r5
 80104e4:	2103      	movs	r1, #3
{
 80104e6:	4617      	mov	r7, r2
  coord = (TS_IO_Read(DeviceAddr, TOUCH1_XH) << 8) & 0x0F00;
 80104e8:	f7ff ffbe 	bl	8010468 <TS_IO_Read>
 80104ec:	4c11      	ldr	r4, [pc, #68]	; (8010534 <TS_Get_XY1+0x58>)
 80104ee:	0200      	lsls	r0, r0, #8
 80104f0:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
 80104f4:	8020      	strh	r0, [r4, #0]
	coord |= TS_IO_Read(DeviceAddr, TOUCH1_XL);
 80104f6:	2104      	movs	r1, #4
 80104f8:	4628      	mov	r0, r5
 80104fa:	f7ff ffb5 	bl	8010468 <TS_IO_Read>
 80104fe:	8823      	ldrh	r3, [r4, #0]
 8010500:	4318      	orrs	r0, r3
	
	if (Orientation90)
	{
		temp = coord;
		*Y = X_SIZE_Touch - coord;
 8010502:	4b0d      	ldr	r3, [pc, #52]	; (8010538 <TS_Get_XY1+0x5c>)
 8010504:	881b      	ldrh	r3, [r3, #0]
	coord |= TS_IO_Read(DeviceAddr, TOUCH1_XL);
 8010506:	b280      	uxth	r0, r0
 8010508:	8020      	strh	r0, [r4, #0]
		*Y = X_SIZE_Touch - coord;
 801050a:	1a18      	subs	r0, r3, r0
 801050c:	8038      	strh	r0, [r7, #0]
	}
	else{
		*X = coord;
	}
	
  coord = (TS_IO_Read(DeviceAddr, TOUCH1_YH) << 8) & 0x0F00;
 801050e:	2105      	movs	r1, #5
 8010510:	4628      	mov	r0, r5
 8010512:	f7ff ffa9 	bl	8010468 <TS_IO_Read>
 8010516:	0200      	lsls	r0, r0, #8
 8010518:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
 801051c:	8020      	strh	r0, [r4, #0]
	coord |= TS_IO_Read(DeviceAddr, TOUCH1_YL);
 801051e:	2106      	movs	r1, #6
 8010520:	4628      	mov	r0, r5
 8010522:	f7ff ffa1 	bl	8010468 <TS_IO_Read>
 8010526:	8823      	ldrh	r3, [r4, #0]
 8010528:	4318      	orrs	r0, r3
 801052a:	b280      	uxth	r0, r0
 801052c:	8020      	strh	r0, [r4, #0]
	
		if (Orientation90)
	{
		*X = coord;
 801052e:	8030      	strh	r0, [r6, #0]
 8010530:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010532:	bf00      	nop
 8010534:	200002fe 	.word	0x200002fe
 8010538:	20000192 	.word	0x20000192

0801053c <TFT_FillScreen_DMA>:
		*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(i*2))=(uint16_t) color;
	}
}

void TFT_FillScreen_DMA(uint16_t color)
{
 801053c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  hdma2d.Init.Mode = DMA2D_R2M;
 801053e:	4c10      	ldr	r4, [pc, #64]	; (8010580 <TFT_FillScreen_DMA+0x44>)
 8010540:	f44f 3340 	mov.w	r3, #196608	; 0x30000
{
 8010544:	4606      	mov	r6, r0
  hdma2d.Init.Mode = DMA2D_R2M;
 8010546:	6063      	str	r3, [r4, #4]
  hdma2d.Init.OutputOffset = 0;
	hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
 8010548:	2502      	movs	r5, #2
  hdma2d.Init.OutputOffset = 0;
 801054a:	2300      	movs	r3, #0

  if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 801054c:	4620      	mov	r0, r4
  hdma2d.Init.OutputOffset = 0;
 801054e:	60e3      	str	r3, [r4, #12]
	hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
 8010550:	60a5      	str	r5, [r4, #8]
  if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8010552:	f7f1 fa7f 	bl	8001a54 <HAL_DMA2D_Init>
 8010556:	b980      	cbnz	r0, 801057a <TFT_FillScreen_DMA+0x3e>
  {
    if (HAL_DMA2D_Start(&hdma2d, color, hltdc.LayerCfg[0].FBStartAdress,
 8010558:	4a0a      	ldr	r2, [pc, #40]	; (8010584 <TFT_FillScreen_DMA+0x48>)
 801055a:	6e53      	ldr	r3, [r2, #100]	; 0x64
 801055c:	9300      	str	r3, [sp, #0]
 801055e:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8010560:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8010562:	4631      	mov	r1, r6
 8010564:	4620      	mov	r0, r4
 8010566:	f7f1 fabf 	bl	8001ae8 <HAL_DMA2D_Start>
 801056a:	b930      	cbnz	r0, 801057a <TFT_FillScreen_DMA+0x3e>
    hltdc.LayerCfg[0].ImageWidth, hltdc.LayerCfg[0].ImageHeight) == HAL_OK)
    {
      HAL_DMA2D_PollForTransfer(&hdma2d, 2);
 801056c:	4629      	mov	r1, r5
 801056e:	4620      	mov	r0, r4
    }
  }
}
 8010570:	b002      	add	sp, #8
 8010572:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_DMA2D_PollForTransfer(&hdma2d, 2);
 8010576:	f7f1 bad0 	b.w	8001b1a <HAL_DMA2D_PollForTransfer>
}
 801057a:	b002      	add	sp, #8
 801057c:	bd70      	pop	{r4, r5, r6, pc}
 801057e:	bf00      	nop
 8010580:	20085cac 	.word	0x20085cac
 8010584:	20085b20 	.word	0x20085b20

08010588 <TFT_DrawPixel>:


//----------------------------------------
void TFT_DrawPixel(uint16_t Xpos, uint16_t Ypos, uint16_t color)
{
 8010588:	b510      	push	{r4, lr}

//	tmp = Xpos;
//	Xpos = Ypos;
//	Ypos = X_SIZE - 1 - tmp;
////////////////////////////////////////////rotate -90
	if(TFT_direction == 0x00){
 801058a:	4b14      	ldr	r3, [pc, #80]	; (80105dc <TFT_DrawPixel+0x54>)
 801058c:	781c      	ldrb	r4, [r3, #0]
 801058e:	b97c      	cbnz	r4, 80105b0 <TFT_DrawPixel+0x28>
	tmp = Xpos;
	Xpos = Ypos;
	Ypos = Y_SIZE - 1 - tmp;
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Pixels - Xpos - Ypos*hltdc.LayerCfg[0].ImageWidth))) = (uint16_t) color;}
 8010590:	4b13      	ldr	r3, [pc, #76]	; (80105e0 <TFT_DrawPixel+0x58>)
 8010592:	681b      	ldr	r3, [r3, #0]
 8010594:	1a5b      	subs	r3, r3, r1
	Ypos = Y_SIZE - 1 - tmp;
 8010596:	4913      	ldr	r1, [pc, #76]	; (80105e4 <TFT_DrawPixel+0x5c>)
 8010598:	8809      	ldrh	r1, [r1, #0]
 801059a:	3901      	subs	r1, #1
 801059c:	1a09      	subs	r1, r1, r0
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Pixels - Xpos - Ypos*hltdc.LayerCfg[0].ImageWidth))) = (uint16_t) color;}
 801059e:	4812      	ldr	r0, [pc, #72]	; (80105e8 <TFT_DrawPixel+0x60>)
 80105a0:	6e04      	ldr	r4, [r0, #96]	; 0x60
 80105a2:	b289      	uxth	r1, r1
 80105a4:	fb04 3111 	mls	r1, r4, r1, r3
 80105a8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
	else	if (TFT_direction == 0x01){
//////////////////////////////////////////// 0 - no rotate
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Ypos*hltdc.LayerCfg[0].ImageWidth+Xpos)))=(uint16_t) color;
	}else	if (TFT_direction == 0x02){
////////////////////////////////////////////rotate -180
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Pixels - Xpos - Ypos*hltdc.LayerCfg[0].ImageWidth))) = (uint16_t) color;
 80105aa:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]
 80105ae:	bd10      	pop	{r4, pc}
	else	if (TFT_direction == 0x01){
 80105b0:	781c      	ldrb	r4, [r3, #0]
 80105b2:	2c01      	cmp	r4, #1
 80105b4:	d105      	bne.n	80105c2 <TFT_DrawPixel+0x3a>
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Ypos*hltdc.LayerCfg[0].ImageWidth+Xpos)))=(uint16_t) color;
 80105b6:	4c0c      	ldr	r4, [pc, #48]	; (80105e8 <TFT_DrawPixel+0x60>)
 80105b8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80105ba:	fb03 0101 	mla	r1, r3, r1, r0
 80105be:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80105c0:	e7f3      	b.n	80105aa <TFT_DrawPixel+0x22>
	}else	if (TFT_direction == 0x02){
 80105c2:	781b      	ldrb	r3, [r3, #0]
 80105c4:	2b02      	cmp	r3, #2
 80105c6:	d1f2      	bne.n	80105ae <TFT_DrawPixel+0x26>
	*(__IO uint16_t*)(hltdc.LayerCfg[0].FBStartAdress+(2*(Pixels - Xpos - Ypos*hltdc.LayerCfg[0].ImageWidth))) = (uint16_t) color;
 80105c8:	4b05      	ldr	r3, [pc, #20]	; (80105e0 <TFT_DrawPixel+0x58>)
 80105ca:	681b      	ldr	r3, [r3, #0]
 80105cc:	1a18      	subs	r0, r3, r0
 80105ce:	4b06      	ldr	r3, [pc, #24]	; (80105e8 <TFT_DrawPixel+0x60>)
 80105d0:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 80105d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80105d4:	fb04 0111 	mls	r1, r4, r1, r0
 80105d8:	e7e7      	b.n	80105aa <TFT_DrawPixel+0x22>
 80105da:	bf00      	nop
 80105dc:	20000300 	.word	0x20000300
 80105e0:	20000194 	.word	0x20000194
 80105e4:	2000019a 	.word	0x2000019a
 80105e8:	20085b20 	.word	0x20085b20

080105ec <TFT_DrawCircleCorner>:
{
 80105ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80105f0:	469a      	mov	sl, r3
	int16_t f = 1 - r;
 80105f2:	b293      	uxth	r3, r2
 80105f4:	f1c3 0401 	rsb	r4, r3, #1
	int16_t ddF_y = -2 * r;
 80105f8:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
{
 80105fc:	b085      	sub	sp, #20
	int16_t ddF_y = -2 * r;
 80105fe:	005b      	lsls	r3, r3, #1
 8010600:	b21b      	sxth	r3, r3
 8010602:	9301      	str	r3, [sp, #4]
    while (x < y) {
 8010604:	2300      	movs	r3, #0
 8010606:	9300      	str	r3, [sp, #0]
        if (corner & 0x01) {	
 8010608:	f00a 0301 	and.w	r3, sl, #1
{
 801060c:	4689      	mov	r9, r1
 801060e:	4616      	mov	r6, r2
	int16_t f = 1 - r;
 8010610:	b224      	sxth	r4, r4
        if (corner & 0x01) {	
 8010612:	9302      	str	r3, [sp, #8]
			TFT_DrawPixel(x0 - y, y0 - x, color);
 8010614:	b287      	uxth	r7, r0
    while (x < y) {
 8010616:	f9bd 3000 	ldrsh.w	r3, [sp]
 801061a:	42b3      	cmp	r3, r6
 801061c:	db02      	blt.n	8010624 <TFT_DrawCircleCorner+0x38>
}
 801061e:	b005      	add	sp, #20
 8010620:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (f >= 0) {
 8010624:	2c00      	cmp	r4, #0
 8010626:	db08      	blt.n	801063a <TFT_DrawCircleCorner+0x4e>
            ddF_y += 2;
 8010628:	9b01      	ldr	r3, [sp, #4]
 801062a:	3302      	adds	r3, #2
 801062c:	b29b      	uxth	r3, r3
            y--;
 801062e:	3e01      	subs	r6, #1
            ddF_y += 2;
 8010630:	b21a      	sxth	r2, r3
            f += ddF_y;
 8010632:	441c      	add	r4, r3
            y--;
 8010634:	b236      	sxth	r6, r6
            ddF_y += 2;
 8010636:	9201      	str	r2, [sp, #4]
            f += ddF_y;
 8010638:	b224      	sxth	r4, r4
 801063a:	f8bd 5000 	ldrh.w	r5, [sp]
        if (corner & 0x01) {	
 801063e:	9b02      	ldr	r3, [sp, #8]
        f += ddF_x;
 8010640:	eb04 0445 	add.w	r4, r4, r5, lsl #1
 8010644:	3403      	adds	r4, #3
 8010646:	b224      	sxth	r4, r4
        if (corner & 0x01) {	
 8010648:	b1e3      	cbz	r3, 8010684 <TFT_DrawCircleCorner+0x98>
			TFT_DrawPixel(x0 - y, y0 - x, color);
 801064a:	fa1f f889 	uxth.w	r8, r9
 801064e:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 8010652:	9303      	str	r3, [sp, #12]
 8010654:	fa1f fb86 	uxth.w	fp, r6
 8010658:	f108 3eff 	add.w	lr, r8, #4294967295
 801065c:	ebae 0e05 	sub.w	lr, lr, r5
 8010660:	eba7 000b 	sub.w	r0, r7, fp
 8010664:	461a      	mov	r2, r3
 8010666:	fa1f f18e 	uxth.w	r1, lr
 801066a:	b280      	uxth	r0, r0
 801066c:	f7ff ff8c 	bl	8010588 <TFT_DrawPixel>
			TFT_DrawPixel(x0 - x, y0 - y, color);
 8010670:	1e78      	subs	r0, r7, #1
 8010672:	9b03      	ldr	r3, [sp, #12]
 8010674:	eba8 010b 	sub.w	r1, r8, fp
 8010678:	1b40      	subs	r0, r0, r5
 801067a:	461a      	mov	r2, r3
 801067c:	b289      	uxth	r1, r1
 801067e:	b280      	uxth	r0, r0
 8010680:	f7ff ff82 	bl	8010588 <TFT_DrawPixel>
        if (corner & 0x02) {	
 8010684:	f01a 0f02 	tst.w	sl, #2
 8010688:	d01a      	beq.n	80106c0 <TFT_DrawCircleCorner+0xd4>
			TFT_DrawPixel(x0 + x, y0 - y, color);
 801068a:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 801068e:	9303      	str	r3, [sp, #12]
 8010690:	fa1f f889 	uxth.w	r8, r9
 8010694:	fa1f fb86 	uxth.w	fp, r6
 8010698:	1c78      	adds	r0, r7, #1
 801069a:	eba8 010b 	sub.w	r1, r8, fp
 801069e:	4428      	add	r0, r5
 80106a0:	461a      	mov	r2, r3
 80106a2:	b289      	uxth	r1, r1
 80106a4:	b280      	uxth	r0, r0
 80106a6:	f7ff ff6f 	bl	8010588 <TFT_DrawPixel>
			TFT_DrawPixel(x0 + y, y0 - x, color);
 80106aa:	f108 31ff 	add.w	r1, r8, #4294967295
 80106ae:	9b03      	ldr	r3, [sp, #12]
 80106b0:	1b49      	subs	r1, r1, r5
 80106b2:	eb07 000b 	add.w	r0, r7, fp
 80106b6:	461a      	mov	r2, r3
 80106b8:	b289      	uxth	r1, r1
 80106ba:	b280      	uxth	r0, r0
 80106bc:	f7ff ff64 	bl	8010588 <TFT_DrawPixel>
		if (corner & 0x04) {	
 80106c0:	f01a 0f04 	tst.w	sl, #4
 80106c4:	d01a      	beq.n	80106fc <TFT_DrawCircleCorner+0x110>
			TFT_DrawPixel(x0 + x, y0 + y, color);
 80106c6:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 80106ca:	9303      	str	r3, [sp, #12]
 80106cc:	fa1f f889 	uxth.w	r8, r9
 80106d0:	fa1f fb86 	uxth.w	fp, r6
 80106d4:	1c78      	adds	r0, r7, #1
 80106d6:	eb08 010b 	add.w	r1, r8, fp
 80106da:	4428      	add	r0, r5
 80106dc:	461a      	mov	r2, r3
 80106de:	b289      	uxth	r1, r1
 80106e0:	b280      	uxth	r0, r0
 80106e2:	f7ff ff51 	bl	8010588 <TFT_DrawPixel>
			TFT_DrawPixel(x0 + y, y0 + x, color);
 80106e6:	f108 0101 	add.w	r1, r8, #1
 80106ea:	9b03      	ldr	r3, [sp, #12]
 80106ec:	4429      	add	r1, r5
 80106ee:	eb07 000b 	add.w	r0, r7, fp
 80106f2:	461a      	mov	r2, r3
 80106f4:	b289      	uxth	r1, r1
 80106f6:	b280      	uxth	r0, r0
 80106f8:	f7ff ff46 	bl	8010588 <TFT_DrawPixel>
        if (corner & 0x08) {	
 80106fc:	f01a 0f08 	tst.w	sl, #8
 8010700:	d01a      	beq.n	8010738 <TFT_DrawCircleCorner+0x14c>
			TFT_DrawPixel(x0 - x, y0 + y, color);
 8010702:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 8010706:	9303      	str	r3, [sp, #12]
 8010708:	fa1f fb89 	uxth.w	fp, r9
 801070c:	fa1f f886 	uxth.w	r8, r6
 8010710:	1e78      	subs	r0, r7, #1
 8010712:	eb0b 0108 	add.w	r1, fp, r8
 8010716:	1b40      	subs	r0, r0, r5
 8010718:	461a      	mov	r2, r3
 801071a:	b289      	uxth	r1, r1
 801071c:	b280      	uxth	r0, r0
 801071e:	f7ff ff33 	bl	8010588 <TFT_DrawPixel>
			TFT_DrawPixel(x0 - y, y0 + x, color);
 8010722:	f10b 0101 	add.w	r1, fp, #1
 8010726:	9b03      	ldr	r3, [sp, #12]
 8010728:	4429      	add	r1, r5
 801072a:	eba7 0008 	sub.w	r0, r7, r8
 801072e:	461a      	mov	r2, r3
 8010730:	b289      	uxth	r1, r1
 8010732:	b280      	uxth	r0, r0
 8010734:	f7ff ff28 	bl	8010588 <TFT_DrawPixel>
 8010738:	9b00      	ldr	r3, [sp, #0]
 801073a:	3301      	adds	r3, #1
 801073c:	9300      	str	r3, [sp, #0]
 801073e:	e76a      	b.n	8010616 <TFT_DrawCircleCorner+0x2a>

08010740 <TFT_DrawCircle>:
{
 8010740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int16_t f = 1 - r;
 8010744:	b295      	uxth	r5, r2
{
 8010746:	b089      	sub	sp, #36	; 0x24
 8010748:	4690      	mov	r8, r2
	int16_t f = 1 - r;
 801074a:	f1c5 0201 	rsb	r2, r5, #1
 801074e:	b212      	sxth	r2, r2
 8010750:	9201      	str	r2, [sp, #4]
	int16_t ddF_y = -2 * r;
 8010752:	ebc5 32c5 	rsb	r2, r5, r5, lsl #15
    TFT_DrawPixel(x0, y0 + r, color);
 8010756:	b28f      	uxth	r7, r1
	int16_t ddF_y = -2 * r;
 8010758:	0052      	lsls	r2, r2, #1
    TFT_DrawPixel(x0, y0 + r, color);
 801075a:	b29c      	uxth	r4, r3
 801075c:	b286      	uxth	r6, r0
	int16_t ddF_y = -2 * r;
 801075e:	b212      	sxth	r2, r2
    TFT_DrawPixel(x0, y0 + r, color);
 8010760:	19e9      	adds	r1, r5, r7
	int16_t ddF_y = -2 * r;
 8010762:	9203      	str	r2, [sp, #12]
    TFT_DrawPixel(x0, y0 + r, color);
 8010764:	b289      	uxth	r1, r1
 8010766:	4622      	mov	r2, r4
 8010768:	4630      	mov	r0, r6
 801076a:	f7ff ff0d 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0, y0 - r, color);
 801076e:	1b79      	subs	r1, r7, r5
 8010770:	4622      	mov	r2, r4
 8010772:	b289      	uxth	r1, r1
 8010774:	4630      	mov	r0, r6
 8010776:	f7ff ff07 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0 + r, y0, color);
 801077a:	19a8      	adds	r0, r5, r6
 801077c:	4622      	mov	r2, r4
 801077e:	4639      	mov	r1, r7
 8010780:	b280      	uxth	r0, r0
 8010782:	f7ff ff01 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0 - r, y0, color);
 8010786:	1b70      	subs	r0, r6, r5
 8010788:	4622      	mov	r2, r4
 801078a:	4639      	mov	r1, r7
 801078c:	b280      	uxth	r0, r0
 801078e:	f7ff fefb 	bl	8010588 <TFT_DrawPixel>
    while (x < y) {
 8010792:	2300      	movs	r3, #0
 8010794:	9302      	str	r3, [sp, #8]
 8010796:	1c73      	adds	r3, r6, #1
 8010798:	9304      	str	r3, [sp, #16]
 801079a:	1e73      	subs	r3, r6, #1
 801079c:	9305      	str	r3, [sp, #20]
 801079e:	1c7b      	adds	r3, r7, #1
 80107a0:	9306      	str	r3, [sp, #24]
 80107a2:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 80107a6:	4543      	cmp	r3, r8
 80107a8:	db02      	blt.n	80107b0 <TFT_DrawCircle+0x70>
}
 80107aa:	b009      	add	sp, #36	; 0x24
 80107ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (f >= 0) {
 80107b0:	9b01      	ldr	r3, [sp, #4]
 80107b2:	2b00      	cmp	r3, #0
 80107b4:	db0c      	blt.n	80107d0 <TFT_DrawCircle+0x90>
            ddF_y += 2;
 80107b6:	9b03      	ldr	r3, [sp, #12]
 80107b8:	3302      	adds	r3, #2
 80107ba:	b29b      	uxth	r3, r3
 80107bc:	b21a      	sxth	r2, r3
 80107be:	9203      	str	r2, [sp, #12]
            f += ddF_y;
 80107c0:	9a01      	ldr	r2, [sp, #4]
 80107c2:	4413      	add	r3, r2
            y--;
 80107c4:	f108 38ff 	add.w	r8, r8, #4294967295
            f += ddF_y;
 80107c8:	b21b      	sxth	r3, r3
            y--;
 80107ca:	fa0f f888 	sxth.w	r8, r8
            f += ddF_y;
 80107ce:	9301      	str	r3, [sp, #4]
 80107d0:	f8bd 9008 	ldrh.w	r9, [sp, #8]
        f += ddF_x;
 80107d4:	9b01      	ldr	r3, [sp, #4]
 80107d6:	eb03 0349 	add.w	r3, r3, r9, lsl #1
 80107da:	3303      	adds	r3, #3
 80107dc:	b21b      	sxth	r3, r3
 80107de:	9301      	str	r3, [sp, #4]
 80107e0:	9b04      	ldr	r3, [sp, #16]
        TFT_DrawPixel(x0 + x, y0 + y, color);
 80107e2:	fa1f f588 	uxth.w	r5, r8
 80107e6:	444b      	add	r3, r9
 80107e8:	eb07 0b05 	add.w	fp, r7, r5
 80107ec:	b29b      	uxth	r3, r3
 80107ee:	fa1f fb8b 	uxth.w	fp, fp
 80107f2:	4659      	mov	r1, fp
 80107f4:	4618      	mov	r0, r3
 80107f6:	4622      	mov	r2, r4
 80107f8:	9307      	str	r3, [sp, #28]
 80107fa:	f7ff fec5 	bl	8010588 <TFT_DrawPixel>
 80107fe:	9b05      	ldr	r3, [sp, #20]
 8010800:	eba3 0a09 	sub.w	sl, r3, r9
 8010804:	fa1f fa8a 	uxth.w	sl, sl
        TFT_DrawPixel(x0 - x, y0 + y, color);
 8010808:	4659      	mov	r1, fp
 801080a:	4650      	mov	r0, sl
 801080c:	4622      	mov	r2, r4
 801080e:	f7ff febb 	bl	8010588 <TFT_DrawPixel>
        TFT_DrawPixel(x0 + x, y0 - y, color);
 8010812:	eba7 0b05 	sub.w	fp, r7, r5
 8010816:	9b07      	ldr	r3, [sp, #28]
 8010818:	fa1f fb8b 	uxth.w	fp, fp
 801081c:	4618      	mov	r0, r3
 801081e:	4659      	mov	r1, fp
 8010820:	4622      	mov	r2, r4
 8010822:	f7ff feb1 	bl	8010588 <TFT_DrawPixel>
        TFT_DrawPixel(x0 - x, y0 - y, color);
 8010826:	4659      	mov	r1, fp
 8010828:	4650      	mov	r0, sl
 801082a:	4622      	mov	r2, r4
 801082c:	f7ff feac 	bl	8010588 <TFT_DrawPixel>
 8010830:	9b06      	ldr	r3, [sp, #24]
        TFT_DrawPixel(x0 + y, y0 + x, color);
 8010832:	eb06 0a05 	add.w	sl, r6, r5
 8010836:	eb09 0b03 	add.w	fp, r9, r3
 801083a:	fa1f fa8a 	uxth.w	sl, sl
 801083e:	fa1f fb8b 	uxth.w	fp, fp
        TFT_DrawPixel(x0 - y, y0 + x, color);
 8010842:	1b75      	subs	r5, r6, r5
        TFT_DrawPixel(x0 + y, y0 + x, color);
 8010844:	4622      	mov	r2, r4
 8010846:	4659      	mov	r1, fp
 8010848:	4650      	mov	r0, sl
        TFT_DrawPixel(x0 - y, y0 + x, color);
 801084a:	b2ad      	uxth	r5, r5
        TFT_DrawPixel(x0 + y, y0 + x, color);
 801084c:	f7ff fe9c 	bl	8010588 <TFT_DrawPixel>
        TFT_DrawPixel(x0 - y, y0 + x, color);
 8010850:	4622      	mov	r2, r4
 8010852:	4659      	mov	r1, fp
 8010854:	4628      	mov	r0, r5
 8010856:	f7ff fe97 	bl	8010588 <TFT_DrawPixel>
 801085a:	1e7b      	subs	r3, r7, #1
 801085c:	eba3 0909 	sub.w	r9, r3, r9
 8010860:	fa1f f989 	uxth.w	r9, r9
        TFT_DrawPixel(x0 + y, y0 - x, color);
 8010864:	4622      	mov	r2, r4
 8010866:	4649      	mov	r1, r9
 8010868:	4650      	mov	r0, sl
 801086a:	f7ff fe8d 	bl	8010588 <TFT_DrawPixel>
        TFT_DrawPixel(x0 - y, y0 - x, color);
 801086e:	4622      	mov	r2, r4
 8010870:	4649      	mov	r1, r9
 8010872:	4628      	mov	r0, r5
 8010874:	f7ff fe88 	bl	8010588 <TFT_DrawPixel>
 8010878:	9b02      	ldr	r3, [sp, #8]
 801087a:	3301      	adds	r3, #1
 801087c:	9302      	str	r3, [sp, #8]
 801087e:	e790      	b.n	80107a2 <TFT_DrawCircle+0x62>

08010880 <TFT_DrawLine>:
extern uint32_t graph_data_old[1500];
extern uint8_t flag_spectral;
int16_t prev_x=0, prev_y=0; 
//----------------------------------------
void TFT_DrawLine(uint16_t x0, uint16_t y0,	uint16_t x1, uint16_t y1, uint16_t color)
{
 8010880:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010884:	b085      	sub	sp, #20
 8010886:	469a      	mov	sl, r3
	int16_t dx, dy, sx, sy, err, e2;
	
	dx = (x0 < x1) ? (x1 - x0) : (x0 - x1); 
 8010888:	4290      	cmp	r0, r2
{
 801088a:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 801088e:	9301      	str	r3, [sp, #4]
 8010890:	4607      	mov	r7, r0
 8010892:	460e      	mov	r6, r1
 8010894:	4693      	mov	fp, r2
	dx = (x0 < x1) ? (x1 - x0) : (x0 - x1); 
 8010896:	d211      	bcs.n	80108bc <TFT_DrawLine+0x3c>
 8010898:	eba2 0800 	sub.w	r8, r2, r0
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 801089c:	4551      	cmp	r1, sl
	dx = (x0 < x1) ? (x1 - x0) : (x0 - x1); 
 801089e:	fa0f f888 	sxth.w	r8, r8
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 80108a2:	d341      	bcc.n	8010928 <TFT_DrawLine+0xa8>
	sx = (x0 < x1) ? 1 : -1; 
 80108a4:	455f      	cmp	r7, fp
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 80108a6:	eba6 050a 	sub.w	r5, r6, sl
 80108aa:	b22d      	sxth	r5, r5
	sx = (x0 < x1) ? 1 : -1; 
 80108ac:	bf2c      	ite	cs
 80108ae:	f04f 39ff 	movcs.w	r9, #4294967295
 80108b2:	f04f 0901 	movcc.w	r9, #1
	sy = (y0 < y1) ? 1 : -1; 
 80108b6:	f04f 33ff 	mov.w	r3, #4294967295
 80108ba:	e00b      	b.n	80108d4 <TFT_DrawLine+0x54>
	dx = (x0 < x1) ? (x1 - x0) : (x0 - x1); 
 80108bc:	eba0 0802 	sub.w	r8, r0, r2
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 80108c0:	4551      	cmp	r1, sl
	dx = (x0 < x1) ? (x1 - x0) : (x0 - x1); 
 80108c2:	fa0f f888 	sxth.w	r8, r8
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 80108c6:	d2ed      	bcs.n	80108a4 <TFT_DrawLine+0x24>
 80108c8:	ebaa 0501 	sub.w	r5, sl, r1
 80108cc:	b22d      	sxth	r5, r5
	sx = (x0 < x1) ? 1 : -1; 
 80108ce:	f04f 39ff 	mov.w	r9, #4294967295
	sy = (y0 < y1) ? 1 : -1; 
 80108d2:	2301      	movs	r3, #1
	err = ((dx > dy) ? dx : -dy) / 2; 
 80108d4:	45a8      	cmp	r8, r5
 80108d6:	f04f 0402 	mov.w	r4, #2
 80108da:	dd20      	ble.n	801091e <TFT_DrawLine+0x9e>
 80108dc:	fb98 f4f4 	sdiv	r4, r8, r4

		if (x0 == x1 && y0 == y1) {
			break;
		}
		e2 = err; 
		if (e2 > -dx) {
 80108e0:	f1c8 0200 	rsb	r2, r8, #0
 80108e4:	9202      	str	r2, [sp, #8]
		TFT_DrawPixel(x0, y0, color); 
 80108e6:	9a01      	ldr	r2, [sp, #4]
 80108e8:	9303      	str	r3, [sp, #12]
 80108ea:	4631      	mov	r1, r6
 80108ec:	4638      	mov	r0, r7
 80108ee:	f7ff fe4b 	bl	8010588 <TFT_DrawPixel>
		if (x0 == x1 && y0 == y1) {
 80108f2:	455f      	cmp	r7, fp
 80108f4:	9b03      	ldr	r3, [sp, #12]
 80108f6:	d101      	bne.n	80108fc <TFT_DrawLine+0x7c>
 80108f8:	4556      	cmp	r6, sl
 80108fa:	d01b      	beq.n	8010934 <TFT_DrawLine+0xb4>
		if (e2 > -dx) {
 80108fc:	9a02      	ldr	r2, [sp, #8]
 80108fe:	4294      	cmp	r4, r2
			err -= dy;
 8010900:	bfc1      	itttt	gt
 8010902:	1b62      	subgt	r2, r4, r5
			x0 += sx;
 8010904:	444f      	addgt	r7, r9
			err -= dy;
 8010906:	b212      	sxthgt	r2, r2
			x0 += sx;
 8010908:	b2bf      	uxthgt	r7, r7
 801090a:	bfd8      	it	le
 801090c:	4622      	movle	r2, r4
		} 
		if (e2 < dy) {
 801090e:	42ac      	cmp	r4, r5
 8010910:	da03      	bge.n	801091a <TFT_DrawLine+0x9a>
			err += dx;
 8010912:	4442      	add	r2, r8
			y0 += sy;
 8010914:	441e      	add	r6, r3
			err += dx;
 8010916:	b212      	sxth	r2, r2
			y0 += sy;
 8010918:	b2b6      	uxth	r6, r6
	sy = (y0 < y1) ? 1 : -1; 
 801091a:	4614      	mov	r4, r2
 801091c:	e7e3      	b.n	80108e6 <TFT_DrawLine+0x66>
	err = ((dx > dy) ? dx : -dy) / 2; 
 801091e:	fb95 f4f4 	sdiv	r4, r5, r4
 8010922:	4264      	negs	r4, r4
 8010924:	b224      	sxth	r4, r4
 8010926:	e7db      	b.n	80108e0 <TFT_DrawLine+0x60>
	dy = (y0 < y1) ? (y1 - y0) : (y0 - y1); 
 8010928:	ebaa 0501 	sub.w	r5, sl, r1
 801092c:	b22d      	sxth	r5, r5
	sx = (x0 < x1) ? 1 : -1; 
 801092e:	f04f 0901 	mov.w	r9, #1
 8010932:	e7ce      	b.n	80108d2 <TFT_DrawLine+0x52>
		} 
	}
}
 8010934:	b005      	add	sp, #20
 8010936:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801093a <TFT_FillRectangle>:
{
 801093a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
		TFT_DrawLine(x0, y0, x1, y0, color);
 801093e:	f8bd 8020 	ldrh.w	r8, [sp, #32]
{
 8010942:	4606      	mov	r6, r0
 8010944:	460c      	mov	r4, r1
 8010946:	4617      	mov	r7, r2
 8010948:	461d      	mov	r5, r3
	for (; y0 <= y1; y0++) {
 801094a:	42ac      	cmp	r4, r5
 801094c:	d902      	bls.n	8010954 <TFT_FillRectangle+0x1a>
}
 801094e:	b002      	add	sp, #8
 8010950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		TFT_DrawLine(x0, y0, x1, y0, color);
 8010954:	4623      	mov	r3, r4
 8010956:	4621      	mov	r1, r4
 8010958:	f8cd 8000 	str.w	r8, [sp]
 801095c:	463a      	mov	r2, r7
 801095e:	4630      	mov	r0, r6
	for (; y0 <= y1; y0++) {
 8010960:	3401      	adds	r4, #1
		TFT_DrawLine(x0, y0, x1, y0, color);
 8010962:	f7ff ff8d 	bl	8010880 <TFT_DrawLine>
	for (; y0 <= y1; y0++) {
 8010966:	b2a4      	uxth	r4, r4
 8010968:	e7ef      	b.n	801094a <TFT_FillRectangle+0x10>

0801096a <TFT_DrawRectangle>:
{
 801096a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	TFT_DrawLine(x0, y0, x1, y0, color); /* Top */
 801096e:	f8bd 4020 	ldrh.w	r4, [sp, #32]
 8010972:	9400      	str	r4, [sp, #0]
{
 8010974:	461f      	mov	r7, r3
 8010976:	4605      	mov	r5, r0
 8010978:	4688      	mov	r8, r1
	TFT_DrawLine(x0, y0, x1, y0, color); /* Top */
 801097a:	460b      	mov	r3, r1
{
 801097c:	4616      	mov	r6, r2
	TFT_DrawLine(x0, y0, x1, y0, color); /* Top */
 801097e:	f7ff ff7f 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(x0, y0, x0, y1, color);	/* Left */
 8010982:	463b      	mov	r3, r7
 8010984:	462a      	mov	r2, r5
 8010986:	4641      	mov	r1, r8
 8010988:	4628      	mov	r0, r5
 801098a:	9400      	str	r4, [sp, #0]
 801098c:	f7ff ff78 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(x1, y0, x1, y1, color);	/* Right */
 8010990:	463b      	mov	r3, r7
 8010992:	4632      	mov	r2, r6
 8010994:	4641      	mov	r1, r8
 8010996:	4630      	mov	r0, r6
 8010998:	9400      	str	r4, [sp, #0]
 801099a:	f7ff ff71 	bl	8010880 <TFT_DrawLine>
	TFT_DrawLine(x0, y1, x1, y1, color);	/* Bottom */
 801099e:	463b      	mov	r3, r7
 80109a0:	4632      	mov	r2, r6
 80109a2:	4639      	mov	r1, r7
 80109a4:	4628      	mov	r0, r5
 80109a6:	9408      	str	r4, [sp, #32]
}
 80109a8:	b002      	add	sp, #8
 80109aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TFT_DrawLine(x0, y1, x1, y1, color);	/* Bottom */
 80109ae:	f7ff bf67 	b.w	8010880 <TFT_DrawLine>

080109b2 <TFT_DrawFilledCircle>:
{
 80109b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int16_t f = 1 - r;
 80109b6:	b297      	uxth	r7, r2
{
 80109b8:	4691      	mov	r9, r2
	int16_t ddF_y = -2 * r;
 80109ba:	ebc7 32c7 	rsb	r2, r7, r7, lsl #15
{
 80109be:	b089      	sub	sp, #36	; 0x24
    TFT_DrawPixel(x0, y0 + r, color);
 80109c0:	b28d      	uxth	r5, r1
	int16_t ddF_y = -2 * r;
 80109c2:	0052      	lsls	r2, r2, #1
    TFT_DrawPixel(x0, y0 + r, color);
 80109c4:	b29e      	uxth	r6, r3
 80109c6:	fa1f f880 	uxth.w	r8, r0
	int16_t ddF_y = -2 * r;
 80109ca:	b212      	sxth	r2, r2
    TFT_DrawPixel(x0, y0 + r, color);
 80109cc:	1979      	adds	r1, r7, r5
	int16_t ddF_y = -2 * r;
 80109ce:	9203      	str	r2, [sp, #12]
    TFT_DrawPixel(x0, y0 + r, color);
 80109d0:	b289      	uxth	r1, r1
 80109d2:	4632      	mov	r2, r6
 80109d4:	4640      	mov	r0, r8
 80109d6:	f7ff fdd7 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0 + r, y0, color);
 80109da:	eb07 0a08 	add.w	sl, r7, r8
    TFT_DrawPixel(x0, y0 - r, color);
 80109de:	1be9      	subs	r1, r5, r7
	int16_t f = 1 - r;
 80109e0:	f1c7 0401 	rsb	r4, r7, #1
    TFT_DrawPixel(x0, y0 - r, color);
 80109e4:	4632      	mov	r2, r6
 80109e6:	b289      	uxth	r1, r1
 80109e8:	4640      	mov	r0, r8
    TFT_DrawPixel(x0 + r, y0, color);
 80109ea:	fa1f fa8a 	uxth.w	sl, sl
    TFT_DrawPixel(x0 - r, y0, color);
 80109ee:	eba8 0707 	sub.w	r7, r8, r7
    TFT_DrawPixel(x0, y0 - r, color);
 80109f2:	f7ff fdc9 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0 - r, y0, color);
 80109f6:	b2bf      	uxth	r7, r7
    TFT_DrawPixel(x0 + r, y0, color);
 80109f8:	4632      	mov	r2, r6
 80109fa:	4629      	mov	r1, r5
 80109fc:	4650      	mov	r0, sl
 80109fe:	f7ff fdc3 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawPixel(x0 - r, y0, color);
 8010a02:	4632      	mov	r2, r6
 8010a04:	4629      	mov	r1, r5
 8010a06:	4638      	mov	r0, r7
 8010a08:	f7ff fdbe 	bl	8010588 <TFT_DrawPixel>
    TFT_DrawLine(x0 - r, y0, x0 + r, y0, color);
 8010a0c:	462b      	mov	r3, r5
 8010a0e:	9600      	str	r6, [sp, #0]
 8010a10:	4652      	mov	r2, sl
 8010a12:	4629      	mov	r1, r5
 8010a14:	4638      	mov	r0, r7
 8010a16:	f7ff ff33 	bl	8010880 <TFT_DrawLine>
    while (x < y) {
 8010a1a:	2300      	movs	r3, #0
 8010a1c:	9302      	str	r3, [sp, #8]
 8010a1e:	f108 33ff 	add.w	r3, r8, #4294967295
 8010a22:	9305      	str	r3, [sp, #20]
 8010a24:	f108 0301 	add.w	r3, r8, #1
 8010a28:	9306      	str	r3, [sp, #24]
 8010a2a:	1c6b      	adds	r3, r5, #1
	int16_t f = 1 - r;
 8010a2c:	b224      	sxth	r4, r4
 8010a2e:	9307      	str	r3, [sp, #28]
    while (x < y) {
 8010a30:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 8010a34:	454b      	cmp	r3, r9
 8010a36:	db02      	blt.n	8010a3e <TFT_DrawFilledCircle+0x8c>
}
 8010a38:	b009      	add	sp, #36	; 0x24
 8010a3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (f >= 0) {
 8010a3e:	2c00      	cmp	r4, #0
 8010a40:	db0a      	blt.n	8010a58 <TFT_DrawFilledCircle+0xa6>
            ddF_y += 2;
 8010a42:	9b03      	ldr	r3, [sp, #12]
 8010a44:	3302      	adds	r3, #2
 8010a46:	b29b      	uxth	r3, r3
            y--;
 8010a48:	f109 39ff 	add.w	r9, r9, #4294967295
            ddF_y += 2;
 8010a4c:	b21a      	sxth	r2, r3
            f += ddF_y;
 8010a4e:	441c      	add	r4, r3
            y--;
 8010a50:	fa0f f989 	sxth.w	r9, r9
            ddF_y += 2;
 8010a54:	9203      	str	r2, [sp, #12]
            f += ddF_y;
 8010a56:	b224      	sxth	r4, r4
 8010a58:	f8bd a008 	ldrh.w	sl, [sp, #8]
 8010a5c:	9b05      	ldr	r3, [sp, #20]
 8010a5e:	9a06      	ldr	r2, [sp, #24]
        TFT_DrawLine(x0 - x, y0 + y, x0 + x, y0 + y, color);
 8010a60:	9600      	str	r6, [sp, #0]
 8010a62:	fa1f f789 	uxth.w	r7, r9
 8010a66:	eba3 0b0a 	sub.w	fp, r3, sl
 8010a6a:	19eb      	adds	r3, r5, r7
 8010a6c:	fa1f fb8b 	uxth.w	fp, fp
 8010a70:	b29b      	uxth	r3, r3
 8010a72:	4452      	add	r2, sl
 8010a74:	b292      	uxth	r2, r2
 8010a76:	4619      	mov	r1, r3
 8010a78:	4658      	mov	r0, fp
 8010a7a:	9204      	str	r2, [sp, #16]
 8010a7c:	f7ff ff00 	bl	8010880 <TFT_DrawLine>
        TFT_DrawLine(x0 + x, y0 - y, x0 - x, y0 - y, color);
 8010a80:	1beb      	subs	r3, r5, r7
 8010a82:	b29b      	uxth	r3, r3
 8010a84:	465a      	mov	r2, fp
 8010a86:	4619      	mov	r1, r3
 8010a88:	9804      	ldr	r0, [sp, #16]
 8010a8a:	9600      	str	r6, [sp, #0]
 8010a8c:	f7ff fef8 	bl	8010880 <TFT_DrawLine>
 8010a90:	9b07      	ldr	r3, [sp, #28]
        TFT_DrawLine(x0 + y, y0 + x, x0 - y, y0 + x, color);
 8010a92:	9600      	str	r6, [sp, #0]
 8010a94:	eb08 0b07 	add.w	fp, r8, r7
 8010a98:	4453      	add	r3, sl
 8010a9a:	eba8 0707 	sub.w	r7, r8, r7
 8010a9e:	b29b      	uxth	r3, r3
 8010aa0:	fa1f fb8b 	uxth.w	fp, fp
 8010aa4:	b2bf      	uxth	r7, r7
 8010aa6:	4619      	mov	r1, r3
 8010aa8:	463a      	mov	r2, r7
 8010aaa:	4658      	mov	r0, fp
 8010aac:	f7ff fee8 	bl	8010880 <TFT_DrawLine>
 8010ab0:	1e6b      	subs	r3, r5, #1
 8010ab2:	eba3 030a 	sub.w	r3, r3, sl
 8010ab6:	b29b      	uxth	r3, r3
        TFT_DrawLine(x0 + y, y0 - x, x0 - y, y0 - x, color);
 8010ab8:	4619      	mov	r1, r3
 8010aba:	9600      	str	r6, [sp, #0]
 8010abc:	463a      	mov	r2, r7
 8010abe:	4658      	mov	r0, fp
 8010ac0:	f7ff fede 	bl	8010880 <TFT_DrawLine>
 8010ac4:	9b02      	ldr	r3, [sp, #8]
        f += ddF_x;
 8010ac6:	eb04 044a 	add.w	r4, r4, sl, lsl #1
 8010aca:	3403      	adds	r4, #3
 8010acc:	3301      	adds	r3, #1
 8010ace:	b224      	sxth	r4, r4
 8010ad0:	9302      	str	r3, [sp, #8]
 8010ad2:	e7ad      	b.n	8010a30 <TFT_DrawFilledCircle+0x7e>

08010ad4 <TFT_DrawFilledCircleCorner>:
{
 8010ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010ad8:	4699      	mov	r9, r3
	int16_t f = 1 - r;
 8010ada:	b293      	uxth	r3, r2
 8010adc:	f1c3 0601 	rsb	r6, r3, #1
	int16_t ddF_y = -2 * r;
 8010ae0:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
{
 8010ae4:	b087      	sub	sp, #28
	int16_t ddF_y = -2 * r;
 8010ae6:	005b      	lsls	r3, r3, #1
 8010ae8:	b21b      	sxth	r3, r3
 8010aea:	9304      	str	r3, [sp, #16]
    while (x < y) {
 8010aec:	2300      	movs	r3, #0
 8010aee:	9302      	str	r3, [sp, #8]
        if (corner & 0x01) {
 8010af0:	f009 0301 	and.w	r3, r9, #1
{
 8010af4:	9103      	str	r1, [sp, #12]
 8010af6:	4617      	mov	r7, r2
	int16_t f = 1 - r;
 8010af8:	b236      	sxth	r6, r6
        if (corner & 0x01) {
 8010afa:	9305      	str	r3, [sp, #20]
			TFT_DrawLine(x0, y0 - y, x0 - x, y0 - y, color);
 8010afc:	b284      	uxth	r4, r0
    while (x < y) {
 8010afe:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 8010b02:	42bb      	cmp	r3, r7
 8010b04:	db02      	blt.n	8010b0c <TFT_DrawFilledCircleCorner+0x38>
}
 8010b06:	b007      	add	sp, #28
 8010b08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (f >= 0) {
 8010b0c:	2e00      	cmp	r6, #0
 8010b0e:	db08      	blt.n	8010b22 <TFT_DrawFilledCircleCorner+0x4e>
            ddF_y += 2;
 8010b10:	9b04      	ldr	r3, [sp, #16]
 8010b12:	3302      	adds	r3, #2
 8010b14:	b29b      	uxth	r3, r3
            y--;
 8010b16:	3f01      	subs	r7, #1
            ddF_y += 2;
 8010b18:	b21a      	sxth	r2, r3
            f += ddF_y;
 8010b1a:	441e      	add	r6, r3
            y--;
 8010b1c:	b23f      	sxth	r7, r7
            ddF_y += 2;
 8010b1e:	9204      	str	r2, [sp, #16]
            f += ddF_y;
 8010b20:	b236      	sxth	r6, r6
 8010b22:	f8bd 5008 	ldrh.w	r5, [sp, #8]
        if (corner & 0x01) {
 8010b26:	9b05      	ldr	r3, [sp, #20]
        f += ddF_x;
 8010b28:	eb06 0645 	add.w	r6, r6, r5, lsl #1
 8010b2c:	3603      	adds	r6, #3
 8010b2e:	b236      	sxth	r6, r6
        if (corner & 0x01) {
 8010b30:	b1f3      	cbz	r3, 8010b70 <TFT_DrawFilledCircleCorner+0x9c>
			TFT_DrawLine(x0, y0 - y, x0 - x, y0 - y, color);
 8010b32:	f8bd 800c 	ldrh.w	r8, [sp, #12]
 8010b36:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 8010b3a:	f8cd b000 	str.w	fp, [sp]
 8010b3e:	fa1f fa87 	uxth.w	sl, r7
 8010b42:	eba8 030a 	sub.w	r3, r8, sl
 8010b46:	1e62      	subs	r2, r4, #1
 8010b48:	b29b      	uxth	r3, r3
 8010b4a:	1b52      	subs	r2, r2, r5
 8010b4c:	4619      	mov	r1, r3
 8010b4e:	b292      	uxth	r2, r2
 8010b50:	4620      	mov	r0, r4
 8010b52:	f7ff fe95 	bl	8010880 <TFT_DrawLine>
 8010b56:	f108 33ff 	add.w	r3, r8, #4294967295
 8010b5a:	1b5b      	subs	r3, r3, r5
 8010b5c:	b29b      	uxth	r3, r3
			TFT_DrawLine(x0, y0 - x, x0 - y, y0 - x, color);
 8010b5e:	eba4 020a 	sub.w	r2, r4, sl
 8010b62:	f8cd b000 	str.w	fp, [sp]
 8010b66:	b292      	uxth	r2, r2
 8010b68:	4619      	mov	r1, r3
 8010b6a:	4620      	mov	r0, r4
 8010b6c:	f7ff fe88 	bl	8010880 <TFT_DrawLine>
        if (corner & 0x02) {	
 8010b70:	f019 0f02 	tst.w	r9, #2
 8010b74:	d01e      	beq.n	8010bb4 <TFT_DrawFilledCircleCorner+0xe0>
			TFT_DrawLine(x0 + x, y0 - y, x0, y0 - y, color);
 8010b76:	f8bd 800c 	ldrh.w	r8, [sp, #12]
 8010b7a:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 8010b7e:	f8cd b000 	str.w	fp, [sp]
 8010b82:	fa1f fa87 	uxth.w	sl, r7
 8010b86:	eba8 030a 	sub.w	r3, r8, sl
 8010b8a:	1c60      	adds	r0, r4, #1
 8010b8c:	b29b      	uxth	r3, r3
 8010b8e:	4428      	add	r0, r5
 8010b90:	4619      	mov	r1, r3
 8010b92:	4622      	mov	r2, r4
 8010b94:	b280      	uxth	r0, r0
 8010b96:	f7ff fe73 	bl	8010880 <TFT_DrawLine>
 8010b9a:	f108 33ff 	add.w	r3, r8, #4294967295
 8010b9e:	1b5b      	subs	r3, r3, r5
 8010ba0:	b29b      	uxth	r3, r3
			TFT_DrawLine(x0 + y, y0 - x, x0, y0 - x, color);
 8010ba2:	eb04 000a 	add.w	r0, r4, sl
 8010ba6:	f8cd b000 	str.w	fp, [sp]
 8010baa:	4622      	mov	r2, r4
 8010bac:	4619      	mov	r1, r3
 8010bae:	b280      	uxth	r0, r0
 8010bb0:	f7ff fe66 	bl	8010880 <TFT_DrawLine>
		if (corner & 0x04) {
 8010bb4:	f019 0f04 	tst.w	r9, #4
 8010bb8:	d01e      	beq.n	8010bf8 <TFT_DrawFilledCircleCorner+0x124>
			TFT_DrawLine(x0, y0 + y, x0 + x, y0 + y, color);
 8010bba:	f8bd 800c 	ldrh.w	r8, [sp, #12]
 8010bbe:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 8010bc2:	f8cd b000 	str.w	fp, [sp]
 8010bc6:	fa1f fa87 	uxth.w	sl, r7
 8010bca:	eb08 030a 	add.w	r3, r8, sl
 8010bce:	1c62      	adds	r2, r4, #1
 8010bd0:	b29b      	uxth	r3, r3
 8010bd2:	442a      	add	r2, r5
 8010bd4:	4619      	mov	r1, r3
 8010bd6:	b292      	uxth	r2, r2
 8010bd8:	4620      	mov	r0, r4
 8010bda:	f7ff fe51 	bl	8010880 <TFT_DrawLine>
 8010bde:	f108 0301 	add.w	r3, r8, #1
 8010be2:	442b      	add	r3, r5
 8010be4:	b29b      	uxth	r3, r3
			TFT_DrawLine(x0 + y, y0 + x, x0, y0 + x, color);
 8010be6:	eb04 000a 	add.w	r0, r4, sl
 8010bea:	f8cd b000 	str.w	fp, [sp]
 8010bee:	4622      	mov	r2, r4
 8010bf0:	4619      	mov	r1, r3
 8010bf2:	b280      	uxth	r0, r0
 8010bf4:	f7ff fe44 	bl	8010880 <TFT_DrawLine>
        if (corner & 0x08) {
 8010bf8:	f019 0f08 	tst.w	r9, #8
 8010bfc:	d01e      	beq.n	8010c3c <TFT_DrawFilledCircleCorner+0x168>
			TFT_DrawLine(x0 - x, y0 + y, x0, y0 + y, color);
 8010bfe:	f8bd 800c 	ldrh.w	r8, [sp, #12]
 8010c02:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 8010c06:	f8cd b000 	str.w	fp, [sp]
 8010c0a:	fa1f fa87 	uxth.w	sl, r7
 8010c0e:	eb08 030a 	add.w	r3, r8, sl
 8010c12:	1e60      	subs	r0, r4, #1
 8010c14:	b29b      	uxth	r3, r3
 8010c16:	1b40      	subs	r0, r0, r5
 8010c18:	4619      	mov	r1, r3
 8010c1a:	4622      	mov	r2, r4
 8010c1c:	b280      	uxth	r0, r0
 8010c1e:	f7ff fe2f 	bl	8010880 <TFT_DrawLine>
 8010c22:	f108 0301 	add.w	r3, r8, #1
 8010c26:	442b      	add	r3, r5
 8010c28:	b29b      	uxth	r3, r3
			TFT_DrawLine(x0, y0 + x, x0 - y, y0 + x, color);
 8010c2a:	eba4 020a 	sub.w	r2, r4, sl
 8010c2e:	f8cd b000 	str.w	fp, [sp]
 8010c32:	b292      	uxth	r2, r2
 8010c34:	4619      	mov	r1, r3
 8010c36:	4620      	mov	r0, r4
 8010c38:	f7ff fe22 	bl	8010880 <TFT_DrawLine>
 8010c3c:	9b02      	ldr	r3, [sp, #8]
 8010c3e:	3301      	adds	r3, #1
 8010c40:	9302      	str	r3, [sp, #8]
 8010c42:	e75c      	b.n	8010afe <TFT_DrawFilledCircleCorner+0x2a>

08010c44 <TFT_DrawFilledRoundedRectangle>:
{
 8010c44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (x1 == x0 || y1 == y0) {
 8010c48:	4282      	cmp	r2, r0
{
 8010c4a:	4683      	mov	fp, r0
 8010c4c:	460d      	mov	r5, r1
 8010c4e:	4692      	mov	sl, r2
 8010c50:	461c      	mov	r4, r3
 8010c52:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
 8010c56:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
	if (x1 == x0 || y1 == y0) {
 8010c5a:	d06d      	beq.n	8010d38 <TFT_DrawFilledRoundedRectangle+0xf4>
 8010c5c:	428b      	cmp	r3, r1
 8010c5e:	d06b      	beq.n	8010d38 <TFT_DrawFilledRoundedRectangle+0xf4>
	if (r == 0) {
 8010c60:	b91e      	cbnz	r6, 8010c6a <TFT_DrawFilledRoundedRectangle+0x26>
		TFT_FillRectangle(x0, y0, x1, y1, color);
 8010c62:	f8cd 8000 	str.w	r8, [sp]
 8010c66:	f7ff fe68 	bl	801093a <TFT_FillRectangle>
	if (x0 > x1) {
 8010c6a:	45da      	cmp	sl, fp
 8010c6c:	bf3e      	ittt	cc
 8010c6e:	465b      	movcc	r3, fp
 8010c70:	46d3      	movcc	fp, sl
 8010c72:	469a      	movcc	sl, r3
	if (y0 > y1) {
 8010c74:	42ac      	cmp	r4, r5
 8010c76:	bf38      	it	cc
 8010c78:	462b      	movcc	r3, r5
	if (r > ((x1 - x0) / 2)) {
 8010c7a:	ebaa 010b 	sub.w	r1, sl, fp
	if (y0 > y1) {
 8010c7e:	bf3c      	itt	cc
 8010c80:	4625      	movcc	r5, r4
 8010c82:	461c      	movcc	r4, r3
	if (r > ((x1 - x0) / 2)) {
 8010c84:	2302      	movs	r3, #2
 8010c86:	fb91 f1f3 	sdiv	r1, r1, r3
 8010c8a:	428e      	cmp	r6, r1
		r = (x1 - x0) / 2;
 8010c8c:	bfc8      	it	gt
 8010c8e:	b28e      	uxthgt	r6, r1
 8010c90:	461a      	mov	r2, r3
	if (r > ((y1 - y0) / 2)) {
 8010c92:	1b63      	subs	r3, r4, r5
 8010c94:	fb93 f3f2 	sdiv	r3, r3, r2
 8010c98:	429e      	cmp	r6, r3
		r = (y1 - y0) / 2;
 8010c9a:	bfc8      	it	gt
 8010c9c:	b29e      	uxthgt	r6, r3
	TFT_FillRectangle(x0 + r, y0, x1 - r, y1, color);
 8010c9e:	eb0b 0706 	add.w	r7, fp, r6
 8010ca2:	ebaa 0906 	sub.w	r9, sl, r6
 8010ca6:	b2bf      	uxth	r7, r7
 8010ca8:	fa1f f989 	uxth.w	r9, r9
 8010cac:	4623      	mov	r3, r4
 8010cae:	4629      	mov	r1, r5
	TFT_FillRectangle(x0, y0 + r, x0 + r, y1 - r, color);
 8010cb0:	1ba4      	subs	r4, r4, r6
 8010cb2:	4435      	add	r5, r6
	TFT_FillRectangle(x0 + r, y0, x1 - r, y1, color);
 8010cb4:	464a      	mov	r2, r9
 8010cb6:	4638      	mov	r0, r7
	TFT_FillRectangle(x0, y0 + r, x0 + r, y1 - r, color);
 8010cb8:	b2ad      	uxth	r5, r5
 8010cba:	b2a4      	uxth	r4, r4
	TFT_FillRectangle(x0 + r, y0, x1 - r, y1, color);
 8010cbc:	f8cd 8000 	str.w	r8, [sp]
 8010cc0:	f7ff fe3b 	bl	801093a <TFT_FillRectangle>
	TFT_FillRectangle(x0, y0 + r, x0 + r, y1 - r, color);
 8010cc4:	4623      	mov	r3, r4
 8010cc6:	463a      	mov	r2, r7
 8010cc8:	4629      	mov	r1, r5
 8010cca:	4658      	mov	r0, fp
 8010ccc:	f8cd 8000 	str.w	r8, [sp]
 8010cd0:	f7ff fe33 	bl	801093a <TFT_FillRectangle>
	TFT_DrawFilledCircleCorner(x0 + r, y0 + r, r, 0x01, color);
 8010cd4:	b236      	sxth	r6, r6
	TFT_FillRectangle(x1 - r, y0 + r, x1, y1 - r, color);
 8010cd6:	4623      	mov	r3, r4
 8010cd8:	4652      	mov	r2, sl
 8010cda:	4629      	mov	r1, r5
 8010cdc:	4648      	mov	r0, r9
	TFT_DrawFilledCircleCorner(x0 + r, y0 + r, r, 0x01, color);
 8010cde:	b23f      	sxth	r7, r7
 8010ce0:	b22d      	sxth	r5, r5
	TFT_FillRectangle(x1 - r, y0 + r, x1, y1 - r, color);
 8010ce2:	f8cd 8000 	str.w	r8, [sp]
 8010ce6:	f7ff fe28 	bl	801093a <TFT_FillRectangle>
	TFT_DrawFilledCircleCorner(x1 - r, y0 + r, r, 0x02, color);
 8010cea:	fa0f f989 	sxth.w	r9, r9
	TFT_DrawFilledCircleCorner(x0 + r, y0 + r, r, 0x01, color);
 8010cee:	4632      	mov	r2, r6
 8010cf0:	4629      	mov	r1, r5
 8010cf2:	4638      	mov	r0, r7
 8010cf4:	f8cd 8000 	str.w	r8, [sp]
 8010cf8:	2301      	movs	r3, #1
	TFT_DrawFilledCircleCorner(x1 - r, y1 - r - 1, r, 0x04, color);
 8010cfa:	3c01      	subs	r4, #1
	TFT_DrawFilledCircleCorner(x0 + r, y0 + r, r, 0x01, color);
 8010cfc:	f7ff feea 	bl	8010ad4 <TFT_DrawFilledCircleCorner>
	TFT_DrawFilledCircleCorner(x1 - r, y1 - r - 1, r, 0x04, color);
 8010d00:	b224      	sxth	r4, r4
	TFT_DrawFilledCircleCorner(x1 - r, y0 + r, r, 0x02, color);
 8010d02:	4632      	mov	r2, r6
 8010d04:	4629      	mov	r1, r5
 8010d06:	4648      	mov	r0, r9
 8010d08:	f8cd 8000 	str.w	r8, [sp]
 8010d0c:	2302      	movs	r3, #2
 8010d0e:	f7ff fee1 	bl	8010ad4 <TFT_DrawFilledCircleCorner>
	TFT_DrawFilledCircleCorner(x1 - r, y1 - r - 1, r, 0x04, color);
 8010d12:	4632      	mov	r2, r6
 8010d14:	4621      	mov	r1, r4
 8010d16:	4648      	mov	r0, r9
 8010d18:	f8cd 8000 	str.w	r8, [sp]
 8010d1c:	2304      	movs	r3, #4
 8010d1e:	f7ff fed9 	bl	8010ad4 <TFT_DrawFilledCircleCorner>
	TFT_DrawFilledCircleCorner(x0 + r, y1 - r - 1, r, 0x08, color);
 8010d22:	2308      	movs	r3, #8
 8010d24:	4632      	mov	r2, r6
 8010d26:	4621      	mov	r1, r4
 8010d28:	4638      	mov	r0, r7
 8010d2a:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
}
 8010d2e:	b003      	add	sp, #12
 8010d30:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	TFT_DrawFilledCircleCorner(x0 + r, y1 - r - 1, r, 0x08, color);
 8010d34:	f7ff bece 	b.w	8010ad4 <TFT_DrawFilledCircleCorner>
}
 8010d38:	b003      	add	sp, #12
 8010d3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08010d40 <TFT_SetFont>:

//----------------------------------------

void TFT_SetFont(sFONT *fonts)
{
  lcdprop.pFont=fonts;
 8010d40:	4b01      	ldr	r3, [pc, #4]	; (8010d48 <TFT_SetFont+0x8>)
 8010d42:	6098      	str	r0, [r3, #8]
 8010d44:	4770      	bx	lr
 8010d46:	bf00      	nop
 8010d48:	200856b0 	.word	0x200856b0

08010d4c <TFT_SetTextColor>:

//----------------------------------------

void TFT_SetTextColor(uint32_t color)
{
  lcdprop.TextColor=color;
 8010d4c:	4b01      	ldr	r3, [pc, #4]	; (8010d54 <TFT_SetTextColor+0x8>)
 8010d4e:	6018      	str	r0, [r3, #0]
 8010d50:	4770      	bx	lr
 8010d52:	bf00      	nop
 8010d54:	200856b0 	.word	0x200856b0

08010d58 <TFT_SetBackColor>:

//----------------------------------------

void TFT_SetBackColor(uint32_t color)
{
  lcdprop.BackColor=color;
 8010d58:	4b01      	ldr	r3, [pc, #4]	; (8010d60 <TFT_SetBackColor+0x8>)
 8010d5a:	6058      	str	r0, [r3, #4]
 8010d5c:	4770      	bx	lr
 8010d5e:	bf00      	nop
 8010d60:	200856b0 	.word	0x200856b0

08010d64 <TFT_DrawCharRus>:

//----------------------------------------
	//--------------------------------------------------------------

void TFT_DrawCharRus(uint16_t x, uint16_t y, const uint8_t c)
{
 8010d64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010d68:	b085      	sub	sp, #20
  uint32_t i = 0, j = 0;
  uint16_t height, width;
  uint8_t offset;
  uint8_t *pchar;
  uint32_t line;
	if(c == 0x01)
 8010d6a:	2a01      	cmp	r2, #1
{
 8010d6c:	9001      	str	r0, [sp, #4]
 8010d6e:	9102      	str	r1, [sp, #8]
 8010d70:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 8010e28 <TFT_DrawCharRus+0xc4>
 8010d74:	482b      	ldr	r0, [pc, #172]	; (8010e24 <TFT_DrawCharRus+0xc0>)
	if(c == 0x01)
 8010d76:	d11f      	bne.n	8010db8 <TFT_DrawCharRus+0x54>
	{
		ch = &lcdprop.pFont->table[0];
 8010d78:	6882      	ldr	r2, [r0, #8]
 8010d7a:	6812      	ldr	r2, [r2, #0]
	}
	else
	{
		ch = &lcdprop.pFont->table[(c-0x7F) * lcdprop.pFont->Height * ((lcdprop.pFont->Width + 7) / 8)];
 8010d7c:	f8cb 2000 	str.w	r2, [fp]
	}
	
	height = lcdprop.pFont->Height;
 8010d80:	6882      	ldr	r2, [r0, #8]
	width = lcdprop.pFont->Width;
 8010d82:	f8b2 a004 	ldrh.w	sl, [r2, #4]
	height = lcdprop.pFont->Height;
 8010d86:	88d3      	ldrh	r3, [r2, #6]
 8010d88:	9300      	str	r3, [sp, #0]
	offset = 8 *((width + 7)/8) - width ;
 8010d8a:	f10a 0507 	add.w	r5, sl, #7
 8010d8e:	10ed      	asrs	r5, r5, #3
 8010d90:	ebca 01c5 	rsb	r1, sl, r5, lsl #3
				line = (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
			break;
		}
		for (j = 0; j < width; j++)
		{
				if(line & (1 << (width- j + offset- 1)))
 8010d94:	f10a 32ff 	add.w	r2, sl, #4294967295
	for(i = 0; i < height; i++)
 8010d98:	2600      	movs	r6, #0
				if(line & (1 << (width- j + offset- 1)))
 8010d9a:	fa52 f381 	uxtab	r3, r2, r1
	for(i = 0; i < height; i++)
 8010d9e:	46b0      	mov	r8, r6
				if(line & (1 << (width- j + offset- 1)))
 8010da0:	9303      	str	r3, [sp, #12]
 8010da2:	9b02      	ldr	r3, [sp, #8]
 8010da4:	eb03 0908 	add.w	r9, r3, r8
	for(i = 0; i < height; i++)
 8010da8:	9b00      	ldr	r3, [sp, #0]
 8010daa:	4598      	cmp	r8, r3
 8010dac:	fa1f f989 	uxth.w	r9, r9
 8010db0:	d30e      	bcc.n	8010dd0 <TFT_DrawCharRus+0x6c>
				TFT_DrawPixel((x + j), y, lcdprop.BackColor);
			}
		}
		y++;
	}
}
 8010db2:	b005      	add	sp, #20
 8010db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ch = &lcdprop.pFont->table[(c-0x7F) * lcdprop.pFont->Height * ((lcdprop.pFont->Width + 7) / 8)];
 8010db8:	6884      	ldr	r4, [r0, #8]
 8010dba:	f1a2 017f 	sub.w	r1, r2, #127	; 0x7f
 8010dbe:	88e2      	ldrh	r2, [r4, #6]
 8010dc0:	434a      	muls	r2, r1
 8010dc2:	88a1      	ldrh	r1, [r4, #4]
 8010dc4:	6824      	ldr	r4, [r4, #0]
 8010dc6:	3107      	adds	r1, #7
 8010dc8:	10c9      	asrs	r1, r1, #3
 8010dca:	fb01 4202 	mla	r2, r1, r2, r4
 8010dce:	e7d5      	b.n	8010d7c <TFT_DrawCharRus+0x18>
		pchar = ((uint8_t *)ch + (width + 7)/8 * i);
 8010dd0:	f8db 2000 	ldr.w	r2, [fp]
		switch((width + 7)/8)
 8010dd4:	2d01      	cmp	r5, #1
		pchar = ((uint8_t *)ch + (width + 7)/8 * i);
 8010dd6:	eb02 0106 	add.w	r1, r2, r6
 8010dda:	5d94      	ldrb	r4, [r2, r6]
		switch((width + 7)/8)
 8010ddc:	d00a      	beq.n	8010df4 <TFT_DrawCharRus+0x90>
 8010dde:	784a      	ldrb	r2, [r1, #1]
 8010de0:	2d02      	cmp	r5, #2
				line = (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
 8010de2:	bf1d      	ittte	ne
 8010de4:	0212      	lslne	r2, r2, #8
 8010de6:	ea42 4404 	orrne.w	r4, r2, r4, lsl #16
 8010dea:	788a      	ldrbne	r2, [r1, #2]
				line = (pchar[0]<< 8) | pchar[1];
 8010dec:	ea42 2404 	orreq.w	r4, r2, r4, lsl #8
				line = (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
 8010df0:	bf18      	it	ne
 8010df2:	4314      	orrne	r4, r2
		for (j = 0; j < width; j++)
 8010df4:	2700      	movs	r7, #0
 8010df6:	4557      	cmp	r7, sl
 8010df8:	d303      	bcc.n	8010e02 <TFT_DrawCharRus+0x9e>
	for(i = 0; i < height; i++)
 8010dfa:	f108 0801 	add.w	r8, r8, #1
 8010dfe:	442e      	add	r6, r5
 8010e00:	e7cf      	b.n	8010da2 <TFT_DrawCharRus+0x3e>
				if(line & (1 << (width- j + offset- 1)))
 8010e02:	9b03      	ldr	r3, [sp, #12]
 8010e04:	1bd9      	subs	r1, r3, r7
 8010e06:	9b01      	ldr	r3, [sp, #4]
 8010e08:	2201      	movs	r2, #1
 8010e0a:	408a      	lsls	r2, r1
 8010e0c:	19d8      	adds	r0, r3, r7
				TFT_DrawPixel((x + j), y, lcdprop.TextColor);
 8010e0e:	4b05      	ldr	r3, [pc, #20]	; (8010e24 <TFT_DrawCharRus+0xc0>)
				if(line & (1 << (width- j + offset- 1)))
 8010e10:	4222      	tst	r2, r4
				TFT_DrawPixel((x + j), y, lcdprop.TextColor);
 8010e12:	bf14      	ite	ne
 8010e14:	881a      	ldrhne	r2, [r3, #0]
				TFT_DrawPixel((x + j), y, lcdprop.BackColor);
 8010e16:	889a      	ldrheq	r2, [r3, #4]
 8010e18:	4649      	mov	r1, r9
 8010e1a:	b280      	uxth	r0, r0
 8010e1c:	f7ff fbb4 	bl	8010588 <TFT_DrawPixel>
		for (j = 0; j < width; j++)
 8010e20:	3701      	adds	r7, #1
 8010e22:	e7e8      	b.n	8010df6 <TFT_DrawCharRus+0x92>
 8010e24:	200856b0 	.word	0x200856b0
 8010e28:	200856bc 	.word	0x200856bc

08010e2c <TFT_DrawChar>:
		i++;
	}
}

void TFT_DrawChar(uint16_t x, uint16_t y, const uint8_t c)
{
 8010e2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t i=0, j=0;
	uint16_t height, width;
	uint8_t offset;
	uint8_t *pchar;
	uint32_t line;
	ch = &lcdprop.pFont->table[(c-' ') * lcdprop.pFont->Height *
 8010e30:	4b28      	ldr	r3, [pc, #160]	; (8010ed4 <TFT_DrawChar+0xa8>)
{
 8010e32:	b085      	sub	sp, #20
 8010e34:	e88d 0003 	stmia.w	sp, {r0, r1}
	ch = &lcdprop.pFont->table[(c-' ') * lcdprop.pFont->Height *
 8010e38:	6899      	ldr	r1, [r3, #8]
 8010e3a:	4827      	ldr	r0, [pc, #156]	; (8010ed8 <TFT_DrawChar+0xac>)
		((lcdprop.pFont->Width +7) / 8)];
 8010e3c:	f8b1 a004 	ldrh.w	sl, [r1, #4]
	ch = &lcdprop.pFont->table[(c-' ') * lcdprop.pFont->Height *
 8010e40:	f8b1 b006 	ldrh.w	fp, [r1, #6]
 8010e44:	6809      	ldr	r1, [r1, #0]
 8010e46:	9002      	str	r0, [sp, #8]
		((lcdprop.pFont->Width +7) / 8)];
 8010e48:	f10a 0507 	add.w	r5, sl, #7
	ch = &lcdprop.pFont->table[(c-' ') * lcdprop.pFont->Height *
 8010e4c:	3a20      	subs	r2, #32
		((lcdprop.pFont->Width +7) / 8)];
 8010e4e:	10ed      	asrs	r5, r5, #3
	ch = &lcdprop.pFont->table[(c-' ') * lcdprop.pFont->Height *
 8010e50:	fb0b f202 	mul.w	r2, fp, r2
 8010e54:	fb05 1202 	mla	r2, r5, r2, r1
 8010e58:	6002      	str	r2, [r0, #0]
	height = lcdprop.pFont->Height;
	width = lcdprop.pFont->Width;
	offset = 8 * ((width + 7)/8) - width;
 8010e5a:	ebca 01c5 	rsb	r1, sl, r5, lsl #3
			line = (pchar[0]<<16) | (pchar[1]<<8) | pchar[2];
			break;
		}
		for(j = 0;j < width; j++)
		{
			if(line & (1 << (width - j + offset -1)))
 8010e5e:	f10a 32ff 	add.w	r2, sl, #4294967295
	for(i = 0;i < height; i++)
 8010e62:	2600      	movs	r6, #0
			if(line & (1 << (width - j + offset -1)))
 8010e64:	fa52 f381 	uxtab	r3, r2, r1
	for(i = 0;i < height; i++)
 8010e68:	46b0      	mov	r8, r6
			if(line & (1 << (width - j + offset -1)))
 8010e6a:	9303      	str	r3, [sp, #12]
 8010e6c:	9b01      	ldr	r3, [sp, #4]
	for(i = 0;i < height; i++)
 8010e6e:	45d8      	cmp	r8, fp
 8010e70:	eb03 0908 	add.w	r9, r3, r8
 8010e74:	fa1f f989 	uxth.w	r9, r9
 8010e78:	d302      	bcc.n	8010e80 <TFT_DrawChar+0x54>
				TFT_DrawPixel((x+j), y, lcdprop.BackColor);
			}
		}
		y++;
	}
}
 8010e7a:	b005      	add	sp, #20
 8010e7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		pchar = ((uint8_t *)ch + (width + 7)/8 * i);
 8010e80:	9b02      	ldr	r3, [sp, #8]
 8010e82:	681a      	ldr	r2, [r3, #0]
		switch((width + 7)/8)
 8010e84:	2d01      	cmp	r5, #1
		pchar = ((uint8_t *)ch + (width + 7)/8 * i);
 8010e86:	eb02 0106 	add.w	r1, r2, r6
 8010e8a:	5d94      	ldrb	r4, [r2, r6]
		switch((width + 7)/8)
 8010e8c:	d00a      	beq.n	8010ea4 <TFT_DrawChar+0x78>
 8010e8e:	784a      	ldrb	r2, [r1, #1]
 8010e90:	2d02      	cmp	r5, #2
			line = (pchar[0]<<16) | (pchar[1]<<8) | pchar[2];
 8010e92:	bf1d      	ittte	ne
 8010e94:	0212      	lslne	r2, r2, #8
 8010e96:	ea42 4404 	orrne.w	r4, r2, r4, lsl #16
 8010e9a:	788a      	ldrbne	r2, [r1, #2]
			line = (pchar[0]<<8) | pchar[1];
 8010e9c:	ea42 2404 	orreq.w	r4, r2, r4, lsl #8
			line = (pchar[0]<<16) | (pchar[1]<<8) | pchar[2];
 8010ea0:	bf18      	it	ne
 8010ea2:	4314      	orrne	r4, r2
		for(j = 0;j < width; j++)
 8010ea4:	2700      	movs	r7, #0
 8010ea6:	4557      	cmp	r7, sl
 8010ea8:	d303      	bcc.n	8010eb2 <TFT_DrawChar+0x86>
	for(i = 0;i < height; i++)
 8010eaa:	f108 0801 	add.w	r8, r8, #1
 8010eae:	442e      	add	r6, r5
 8010eb0:	e7dc      	b.n	8010e6c <TFT_DrawChar+0x40>
			if(line & (1 << (width - j + offset -1)))
 8010eb2:	9b03      	ldr	r3, [sp, #12]
 8010eb4:	1bd9      	subs	r1, r3, r7
 8010eb6:	9b00      	ldr	r3, [sp, #0]
 8010eb8:	2201      	movs	r2, #1
 8010eba:	408a      	lsls	r2, r1
 8010ebc:	19d8      	adds	r0, r3, r7
				TFT_DrawPixel((x+j), y, lcdprop.TextColor);
 8010ebe:	4b05      	ldr	r3, [pc, #20]	; (8010ed4 <TFT_DrawChar+0xa8>)
			if(line & (1 << (width - j + offset -1)))
 8010ec0:	4222      	tst	r2, r4
				TFT_DrawPixel((x+j), y, lcdprop.TextColor);
 8010ec2:	bf14      	ite	ne
 8010ec4:	881a      	ldrhne	r2, [r3, #0]
				TFT_DrawPixel((x+j), y, lcdprop.BackColor);
 8010ec6:	889a      	ldrheq	r2, [r3, #4]
 8010ec8:	4649      	mov	r1, r9
 8010eca:	b280      	uxth	r0, r0
 8010ecc:	f7ff fb5c 	bl	8010588 <TFT_DrawPixel>
		for(j = 0;j < width; j++)
 8010ed0:	3701      	adds	r7, #1
 8010ed2:	e7e8      	b.n	8010ea6 <TFT_DrawChar+0x7a>
 8010ed4:	200856b0 	.word	0x200856b0
 8010ed8:	200856bc 	.word	0x200856bc

08010edc <TFT_DisplayString>:
//----------------------------------------
void TFT_DisplayString(uint16_t Xpos, uint16_t Ypos, const uint8_t *Text,	Text_AlignModeTypdef Mode)
{
 8010edc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010ee0:	460e      	mov	r6, r1
 8010ee2:	4604      	mov	r4, r0
 8010ee4:	4615      	mov	r5, r2
	uint16_t ref_column = 1, i = 0;
	uint32_t size = 0, xsize = 0;
	const uint8_t *ptr = Text;
 8010ee6:	4611      	mov	r1, r2
 8010ee8:	eba1 0e05 	sub.w	lr, r1, r5
	
	while(*ptr++) size++ ;
 8010eec:	f811 2b01 	ldrb.w	r2, [r1], #1
 8010ef0:	2a00      	cmp	r2, #0
 8010ef2:	d1f9      	bne.n	8010ee8 <TFT_DisplayString+0xc>
	xsize = (X_SIZE/lcdprop.pFont->Width);
 8010ef4:	4f1b      	ldr	r7, [pc, #108]	; (8010f64 <TFT_DisplayString+0x88>)
 8010ef6:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8010f68 <TFT_DisplayString+0x8c>
 8010efa:	68ba      	ldr	r2, [r7, #8]
 8010efc:	f8b8 1000 	ldrh.w	r1, [r8]
 8010f00:	8890      	ldrh	r0, [r2, #4]
 8010f02:	fbb1 f2f0 	udiv	r2, r1, r0
	switch (Mode)
 8010f06:	2b01      	cmp	r3, #1
 8010f08:	d017      	beq.n	8010f3a <TFT_DisplayString+0x5e>
 8010f0a:	2b02      	cmp	r3, #2
 8010f0c:	d01c      	beq.n	8010f48 <TFT_DisplayString+0x6c>
		{
			ref_column = Xpos;
			break;
		}
	}
	if((ref_column < 1) || (ref_column >= 0x8000))
 8010f0e:	b223      	sxth	r3, r4
	{
		ref_column = 1;
 8010f10:	2b00      	cmp	r3, #0
 8010f12:	bfd8      	it	le
 8010f14:	2401      	movle	r4, #1
 8010f16:	46a9      	mov	r9, r5
	}
	
	while ((*Text != 0) & (((X_SIZE - (i*lcdprop.pFont->Width)) & 0xFFFF) >=
 8010f18:	68b9      	ldr	r1, [r7, #8]
 8010f1a:	f8b8 0000 	ldrh.w	r0, [r8]
 8010f1e:	8889      	ldrh	r1, [r1, #4]
 8010f20:	eba9 0305 	sub.w	r3, r9, r5
 8010f24:	b29b      	uxth	r3, r3
 8010f26:	fb01 0313 	mls	r3, r1, r3, r0
 8010f2a:	b29b      	uxth	r3, r3
 8010f2c:	4299      	cmp	r1, r3
 8010f2e:	f819 2b01 	ldrb.w	r2, [r9], #1
 8010f32:	dc00      	bgt.n	8010f36 <TFT_DisplayString+0x5a>
 8010f34:	b96a      	cbnz	r2, 8010f52 <TFT_DisplayString+0x76>
 8010f36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			ref_column = Xpos + ((xsize-size) * lcdprop.pFont->Width) / 2;
 8010f3a:	eba2 020e 	sub.w	r2, r2, lr
 8010f3e:	4342      	muls	r2, r0
 8010f40:	eb04 0452 	add.w	r4, r4, r2, lsr #1
			ref_column = Xpos + ((xsize-size) * lcdprop.pFont->Width);
 8010f44:	b2a4      	uxth	r4, r4
			break;
 8010f46:	e7e2      	b.n	8010f0e <TFT_DisplayString+0x32>
			ref_column = Xpos + ((xsize-size) * lcdprop.pFont->Width);
 8010f48:	eba2 020e 	sub.w	r2, r2, lr
 8010f4c:	fb12 4400 	smlabb	r4, r2, r0, r4
 8010f50:	e7f8      	b.n	8010f44 <TFT_DisplayString+0x68>
			lcdprop.pFont->Width))
	{
		TFT_DrawChar(ref_column, Ypos, *Text);
 8010f52:	4620      	mov	r0, r4
 8010f54:	4631      	mov	r1, r6
 8010f56:	f7ff ff69 	bl	8010e2c <TFT_DrawChar>
		ref_column += lcdprop.pFont->Width;
 8010f5a:	68bb      	ldr	r3, [r7, #8]
 8010f5c:	889b      	ldrh	r3, [r3, #4]
 8010f5e:	441c      	add	r4, r3
 8010f60:	b2a4      	uxth	r4, r4
 8010f62:	e7d9      	b.n	8010f18 <TFT_DisplayString+0x3c>
 8010f64:	200856b0 	.word	0x200856b0
 8010f68:	20000198 	.word	0x20000198
 8010f6c:	00000000 	.word	0x00000000

08010f70 <Get_Battery_Level>:

//void auto_exposure(void);
//void exposure_display(uint16_t X, uint16_t Y);

double Get_Battery_Level()
{
 8010f70:	b538      	push	{r3, r4, r5, lr}
	HAL_ADC_Start(&hadc1);
 8010f72:	4c13      	ldr	r4, [pc, #76]	; (8010fc0 <Get_Battery_Level+0x50>)
	HAL_ADC_PollForConversion(&hadc1, 2);
	adcResult = HAL_ADC_GetValue(&hadc1);
 8010f74:	4d13      	ldr	r5, [pc, #76]	; (8010fc4 <Get_Battery_Level+0x54>)
	HAL_ADC_Start(&hadc1);
 8010f76:	4620      	mov	r0, r4
 8010f78:	f7f0 fc24 	bl	80017c4 <HAL_ADC_Start>
	HAL_ADC_PollForConversion(&hadc1, 2);
 8010f7c:	2102      	movs	r1, #2
 8010f7e:	4620      	mov	r0, r4
 8010f80:	f7f0 f91a 	bl	80011b8 <HAL_ADC_PollForConversion>
	adcResult = HAL_ADC_GetValue(&hadc1);
 8010f84:	4620      	mov	r0, r4
 8010f86:	f7f0 f965 	bl	8001254 <HAL_ADC_GetValue>
 8010f8a:	7028      	strb	r0, [r5, #0]
	HAL_ADC_Stop(&hadc1);
 8010f8c:	4620      	mov	r0, r4
 8010f8e:	f7f0 fc98 	bl	80018c2 <HAL_ADC_Stop>
	return percentage_charge = 100.0*adcResult/190;
 8010f92:	7828      	ldrb	r0, [r5, #0]
 8010f94:	f7ef fad6 	bl	8000544 <__aeabi_i2d>
 8010f98:	2200      	movs	r2, #0
 8010f9a:	4b0b      	ldr	r3, [pc, #44]	; (8010fc8 <Get_Battery_Level+0x58>)
 8010f9c:	f7ef fb38 	bl	8000610 <__aeabi_dmul>
 8010fa0:	a305      	add	r3, pc, #20	; (adr r3, 8010fb8 <Get_Battery_Level+0x48>)
 8010fa2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010fa6:	f7ef fc5d 	bl	8000864 <__aeabi_ddiv>
 8010faa:	4b08      	ldr	r3, [pc, #32]	; (8010fcc <Get_Battery_Level+0x5c>)
}
 8010fac:	ec41 0b10 	vmov	d0, r0, r1
	return percentage_charge = 100.0*adcResult/190;
 8010fb0:	e9c3 0100 	strd	r0, r1, [r3]
}
 8010fb4:	bd38      	pop	{r3, r4, r5, pc}
 8010fb6:	bf00      	nop
 8010fb8:	00000000 	.word	0x00000000
 8010fbc:	4067c000 	.word	0x4067c000
 8010fc0:	20085bdc 	.word	0x20085bdc
 8010fc4:	20084b1a 	.word	0x20084b1a
 8010fc8:	40590000 	.word	0x40590000
 8010fcc:	200002f0 	.word	0x200002f0

08010fd0 <SystemClock_Config>:

}


void SystemClock_Config(void)
{
 8010fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Configure the main internal regulator output voltage
    */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK)
 8010fd2:	2000      	movs	r0, #0
{
 8010fd4:	b0bf      	sub	sp, #252	; 0xfc
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK)
 8010fd6:	f7f2 f8bf 	bl	8003158 <HAL_PWREx_ControlVoltageScaling>
 8010fda:	b100      	cbz	r0, 8010fde <SystemClock_Config+0xe>
 8010fdc:	e7fe      	b.n	8010fdc <SystemClock_Config+0xc>

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8010fde:	f44f 7380 	mov.w	r3, #256	; 0x100
 8010fe2:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.HSICalibrationValue = 64;
 8010fe4:	2340      	movs	r3, #64	; 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8010fe6:	2402      	movs	r4, #2
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
 8010fe8:	2503      	movs	r5, #3
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8010fea:	f44f 3680 	mov.w	r6, #65536	; 0x10000
  RCC_OscInitStruct.HSICalibrationValue = 64;
 8010fee:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 30;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV5;
 8010ff0:	2705      	movs	r7, #5
  RCC_OscInitStruct.PLL.PLLN = 30;
 8010ff2:	231e      	movs	r3, #30
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8010ff4:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
 8010ff6:	9506      	str	r5, [sp, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8010ff8:	9607      	str	r6, [sp, #28]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8010ffa:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8010ffc:	9511      	str	r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 2;
 8010ffe:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 30;
 8011000:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV5;
 8011002:	9714      	str	r7, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8011004:	9415      	str	r4, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8011006:	9416      	str	r4, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8011008:	f7f2 f99c 	bl	8003344 <HAL_RCC_OscConfig>
 801100c:	b100      	cbz	r0, 8011010 <SystemClock_Config+0x40>
 801100e:	e7fe      	b.n	801100e <SystemClock_Config+0x3e>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8011010:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8011012:	9003      	str	r0, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8011014:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8011016:	9005      	str	r0, [sp, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8011018:	4639      	mov	r1, r7
 801101a:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 801101c:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 801101e:	9502      	str	r5, [sp, #8]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8011020:	f7f2 fbe2 	bl	80037e8 <HAL_RCC_ClockConfig>
 8011024:	b100      	cbz	r0, 8011028 <SystemClock_Config+0x58>
 8011026:	e7fe      	b.n	8011026 <SystemClock_Config+0x56>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1|RCC_PERIPHCLK_USB|RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_SDMMC1;
 8011028:	4b1e      	ldr	r3, [pc, #120]	; (80110a4 <SystemClock_Config+0xd4>)
 801102a:	9317      	str	r3, [sp, #92]	; 0x5c
  PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_HSI;
 801102c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8011030:	932b      	str	r3, [sp, #172]	; 0xac
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 8011032:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8011036:	9334      	str	r3, [sp, #208]	; 0xd0
	PeriphClkInit.LtdcClockSelection = RCC_LTDCCLKSOURCE_PLLSAI2_DIV4;
	PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_SYSCLK;
 8011038:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 801103c:	9337      	str	r3, [sp, #220]	; 0xdc
	PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLP;
 801103e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8011042:	9335      	str	r3, [sp, #212]	; 0xd4


  PeriphClkInit.PLLSAI2.PLLSAI2Source = RCC_PLLSOURCE_HSE;
	PeriphClkInit.PLLSAI2.PLLSAI2M = 2;
  PeriphClkInit.PLLSAI2.PLLSAI2N = 9;
 8011044:	2309      	movs	r3, #9
 8011046:	9321      	str	r3, [sp, #132]	; 0x84
  PeriphClkInit.PLLSAI2.PLLSAI2P = RCC_PLLP_DIV2;
  PeriphClkInit.PLLSAI2.PLLSAI2R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI2.PLLSAI2Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI2.PLLSAI2ClockOut = RCC_PLLSAI2_LTDCCLK;
 8011048:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 801104c:	9325      	str	r3, [sp, #148]	; 0x94

	PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 2;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
 801104e:	230c      	movs	r3, #12
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8011050:	902c      	str	r0, [sp, #176]	; 0xb0
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
 8011052:	931a      	str	r3, [sp, #104]	; 0x68
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8011054:	a817      	add	r0, sp, #92	; 0x5c
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8011056:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
	PeriphClkInit.PLLSAI2.PLLSAI2M = 2;
 801105a:	9420      	str	r4, [sp, #128]	; 0x80
  PeriphClkInit.PLLSAI2.PLLSAI2P = RCC_PLLP_DIV2;
 801105c:	9422      	str	r4, [sp, #136]	; 0x88
  PeriphClkInit.PLLSAI2.PLLSAI2R = RCC_PLLR_DIV2;
 801105e:	9424      	str	r4, [sp, #144]	; 0x90
  PeriphClkInit.PLLSAI2.PLLSAI2Q = RCC_PLLQ_DIV2;
 8011060:	9423      	str	r4, [sp, #140]	; 0x8c
  PeriphClkInit.PLLSAI1.PLLSAI1M = 2;
 8011062:	9419      	str	r4, [sp, #100]	; 0x64
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV2;
 8011064:	941b      	str	r4, [sp, #108]	; 0x6c
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8011066:	941c      	str	r4, [sp, #112]	; 0x70
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8011068:	941d      	str	r4, [sp, #116]	; 0x74
	PeriphClkInit.LtdcClockSelection = RCC_LTDCCLKSOURCE_PLLSAI2_DIV4;
 801106a:	963a      	str	r6, [sp, #232]	; 0xe8
  PeriphClkInit.PLLSAI2.PLLSAI2Source = RCC_PLLSOURCE_HSE;
 801106c:	951f      	str	r5, [sp, #124]	; 0x7c
	PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
 801106e:	9518      	str	r5, [sp, #96]	; 0x60
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8011070:	931e      	str	r3, [sp, #120]	; 0x78
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8011072:	f7f2 fded 	bl	8003c50 <HAL_RCCEx_PeriphCLKConfig>
 8011076:	4604      	mov	r4, r0
 8011078:	b100      	cbz	r0, 801107c <SystemClock_Config+0xac>
 801107a:	e7fe      	b.n	801107a <SystemClock_Config+0xaa>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 801107c:	f7f2 fcae 	bl	80039dc <HAL_RCC_GetHCLKFreq>
 8011080:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8011084:	fbb0 f0f3 	udiv	r0, r0, r3
 8011088:	f7f0 fc9a 	bl	80019c0 <HAL_SYSTICK_Config>

    /**Configure the Systick
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 801108c:	2004      	movs	r0, #4
 801108e:	f7f0 fcbb 	bl	8001a08 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8011092:	4622      	mov	r2, r4
 8011094:	4621      	mov	r1, r4
 8011096:	f04f 30ff 	mov.w	r0, #4294967295
 801109a:	f7f0 fc43 	bl	8001924 <HAL_NVIC_SetPriority>

}
 801109e:	b03f      	add	sp, #252	; 0xfc
 80110a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80110a2:	bf00      	nop
 80110a4:	00486060 	.word	0x00486060

080110a8 <main>:
{
 80110a8:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80110ac:	b09d      	sub	sp, #116	; 0x74
  HAL_Init();
 80110ae:	f7ef ff61 	bl	8000f74 <HAL_Init>
  SystemClock_Config();
 80110b2:	f7ff ff8d 	bl	8010fd0 <SystemClock_Config>
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 10000;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = exposure_timer_period[exp_num];
 80110b6:	4a7e      	ldr	r2, [pc, #504]	; (80112b0 <main+0x208>)
  htim2.Instance = TIM2;
 80110b8:	4e7e      	ldr	r6, [pc, #504]	; (80112b4 <main+0x20c>)
  htim2.Init.Period = exposure_timer_period[exp_num];
 80110ba:	7811      	ldrb	r1, [r2, #0]
 80110bc:	4a7e      	ldr	r2, [pc, #504]	; (80112b8 <main+0x210>)
  htim2.Init.Prescaler = 10000;
 80110be:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80110c2:	f242 7a10 	movw	sl, #10000	; 0x2710
 80110c6:	e886 0408 	stmia.w	r6, {r3, sl}
  htim2.Init.Period = exposure_timer_period[exp_num];
 80110ca:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 80110ce:	60f2      	str	r2, [r6, #12]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80110d0:	2300      	movs	r3, #0
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 80110d2:	4630      	mov	r0, r6
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80110d4:	60b3      	str	r3, [r6, #8]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80110d6:	6133      	str	r3, [r6, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80110d8:	61b3      	str	r3, [r6, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 80110da:	f7f3 fae9 	bl	80046b0 <HAL_TIM_Base_Init>
 80110de:	b100      	cbz	r0, 80110e2 <main+0x3a>
 80110e0:	e7fe      	b.n	80110e0 <main+0x38>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80110e2:	ad1c      	add	r5, sp, #112	; 0x70
 80110e4:	f44f 5980 	mov.w	r9, #4096	; 0x1000
 80110e8:	f845 9d34 	str.w	r9, [r5, #-52]!
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 80110ec:	4630      	mov	r0, r6
 80110ee:	4629      	mov	r1, r5
 80110f0:	f7f3 fb9a 	bl	8004828 <HAL_TIM_ConfigClockSource>
 80110f4:	b100      	cbz	r0, 80110f8 <main+0x50>
 80110f6:	e7fe      	b.n	80110f6 <main+0x4e>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 80110f8:	f04f 0820 	mov.w	r8, #32
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80110fc:	900d      	str	r0, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80110fe:	a90b      	add	r1, sp, #44	; 0x2c
 8011100:	4630      	mov	r0, r6
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8011102:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8011106:	f7f3 fc93 	bl	8004a30 <HAL_TIMEx_MasterConfigSynchronization>
 801110a:	b100      	cbz	r0, 801110e <main+0x66>
 801110c:	e7fe      	b.n	801110c <main+0x64>

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim4.Instance = TIM4;
 801110e:	4c6b      	ldr	r4, [pc, #428]	; (80112bc <main+0x214>)
  htim4.Init.Prescaler = 100;
 8011110:	4b6b      	ldr	r3, [pc, #428]	; (80112c0 <main+0x218>)
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011112:	60a0      	str	r0, [r4, #8]
  htim4.Init.Prescaler = 100;
 8011114:	f04f 0c64 	mov.w	ip, #100	; 0x64
  htim4.Init.Period = 2000;
 8011118:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801111c:	6120      	str	r0, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801111e:	61a0      	str	r0, [r4, #24]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 8011120:	4620      	mov	r0, r4
  htim4.Init.Prescaler = 100;
 8011122:	e884 1008 	stmia.w	r4, {r3, ip}
  htim4.Init.Period = 2000;
 8011126:	60e7      	str	r7, [r4, #12]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 8011128:	f7f3 fac2 	bl	80046b0 <HAL_TIM_Base_Init>
 801112c:	b100      	cbz	r0, 8011130 <main+0x88>
 801112e:	e7fe      	b.n	801112e <main+0x86>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8011130:	a90b      	add	r1, sp, #44	; 0x2c
 8011132:	4630      	mov	r0, r6
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011134:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8011138:	f7f3 fb76 	bl	8004828 <HAL_TIM_ConfigClockSource>
 801113c:	b100      	cbz	r0, 8011140 <main+0x98>
 801113e:	e7fe      	b.n	801113e <main+0x96>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

	 if (HAL_TIM_OC_Init(&htim4) != HAL_OK)
 8011140:	4620      	mov	r0, r4
 8011142:	f7f3 facf 	bl	80046e4 <HAL_TIM_OC_Init>
 8011146:	b100      	cbz	r0, 801114a <main+0xa2>
 8011148:	e7fe      	b.n	8011148 <main+0xa0>
    _Error_Handler(__FILE__, __LINE__);
  }


  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801114a:	900a      	str	r0, [sp, #40]	; 0x28
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801114c:	a908      	add	r1, sp, #32
 801114e:	4620      	mov	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8011150:	f8cd 8020 	str.w	r8, [sp, #32]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 8011154:	f7f3 fc6c 	bl	8004a30 <HAL_TIMEx_MasterConfigSynchronization>
 8011158:	4602      	mov	r2, r0
 801115a:	b100      	cbz	r0, 801115e <main+0xb6>
 801115c:	e7fe      	b.n	801115c <main+0xb4>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

	sConfigOC.OCMode = TIM_OCMODE_TIMING;
 801115e:	900f      	str	r0, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 1000; //more cnt - zero; 1000 - 50%
 8011160:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8011164:	9011      	str	r0, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8011166:	9013      	str	r0, [sp, #76]	; 0x4c
  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011168:	4629      	mov	r1, r5
 801116a:	4620      	mov	r0, r4
  sConfigOC.Pulse = 1000; //more cnt - zero; 1000 - 50%
 801116c:	9310      	str	r3, [sp, #64]	; 0x40
  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801116e:	f7f3 fb19 	bl	80047a4 <HAL_TIM_OC_ConfigChannel>
 8011172:	b100      	cbz	r0, 8011176 <main+0xce>
 8011174:	e7fe      	b.n	8011174 <main+0xcc>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

	sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8011176:	900f      	str	r0, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 2000;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8011178:	9011      	str	r0, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801117a:	9013      	str	r0, [sp, #76]	; 0x4c

  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801117c:	2204      	movs	r2, #4
 801117e:	4629      	mov	r1, r5
 8011180:	4620      	mov	r0, r4
  sConfigOC.Pulse = 2000;
 8011182:	9710      	str	r7, [sp, #64]	; 0x40
  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8011184:	f7f3 fb0e 	bl	80047a4 <HAL_TIM_OC_ConfigChannel>
 8011188:	b100      	cbz	r0, 801118c <main+0xe4>
 801118a:	e7fe      	b.n	801118a <main+0xe2>
  htim5.Instance = TIM5;
 801118c:	4b4d      	ldr	r3, [pc, #308]	; (80112c4 <main+0x21c>)
  htim5.Init.Prescaler = 2;
 801118e:	4a4e      	ldr	r2, [pc, #312]	; (80112c8 <main+0x220>)
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011190:	6098      	str	r0, [r3, #8]
  htim5.Init.Prescaler = 2;
 8011192:	f04f 0e02 	mov.w	lr, #2
 8011196:	e883 4004 	stmia.w	r3, {r2, lr}
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801119a:	6118      	str	r0, [r3, #16]
  htim5.Init.Period = 30;
 801119c:	221e      	movs	r2, #30
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801119e:	6198      	str	r0, [r3, #24]
  if (HAL_TIM_OC_Init(&htim5) != HAL_OK)
 80111a0:	4618      	mov	r0, r3
  htim5.Init.Period = 30;
 80111a2:	60da      	str	r2, [r3, #12]
  if (HAL_TIM_OC_Init(&htim5) != HAL_OK)
 80111a4:	f7f3 fa9e 	bl	80046e4 <HAL_TIM_OC_Init>
 80111a8:	b100      	cbz	r0, 80111ac <main+0x104>
 80111aa:	e7fe      	b.n	80111aa <main+0x102>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80111ac:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 80111ae:	a90b      	add	r1, sp, #44	; 0x2c
 80111b0:	4844      	ldr	r0, [pc, #272]	; (80112c4 <main+0x21c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80111b2:	930b      	str	r3, [sp, #44]	; 0x2c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80111b4:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 80111b6:	f7f3 fc3b 	bl	8004a30 <HAL_TIMEx_MasterConfigSynchronization>
 80111ba:	4602      	mov	r2, r0
 80111bc:	b100      	cbz	r0, 80111c0 <main+0x118>
 80111be:	e7fe      	b.n	80111be <main+0x116>
  sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
 80111c0:	2330      	movs	r3, #48	; 0x30
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80111c2:	9011      	str	r0, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80111c4:	9013      	str	r0, [sp, #76]	; 0x4c
  sConfigOC.Pulse = 5;
 80111c6:	f04f 0805 	mov.w	r8, #5
  if (HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80111ca:	4629      	mov	r1, r5
 80111cc:	483d      	ldr	r0, [pc, #244]	; (80112c4 <main+0x21c>)
  sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
 80111ce:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 5;
 80111d0:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  if (HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80111d4:	f7f3 fae6 	bl	80047a4 <HAL_TIM_OC_ConfigChannel>
 80111d8:	4606      	mov	r6, r0
 80111da:	b100      	cbz	r0, 80111de <main+0x136>
 80111dc:	e7fe      	b.n	80111dc <main+0x134>
  HAL_TIM_MspPostInit(&htim5);
 80111de:	4839      	ldr	r0, [pc, #228]	; (80112c4 <main+0x21c>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM6_Init 1 */

  /* USER CODE END TIM6_Init 1 */
  htim6.Instance = TIM6;
 80111e0:	4c3a      	ldr	r4, [pc, #232]	; (80112cc <main+0x224>)
  HAL_TIM_MspPostInit(&htim5);
 80111e2:	f000 fd85 	bl	8011cf0 <HAL_TIM_MspPostInit>
  htim6.Init.Prescaler = 48000;
 80111e6:	4b3a      	ldr	r3, [pc, #232]	; (80112d0 <main+0x228>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80111e8:	960f      	str	r6, [sp, #60]	; 0x3c
  htim6.Init.Prescaler = 48000;
 80111ea:	f64b 3780 	movw	r7, #48000	; 0xbb80
 80111ee:	e884 0088 	stmia.w	r4, {r3, r7}
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.Period = 3800;
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 80111f2:	4620      	mov	r0, r4
  htim6.Init.Period = 3800;
 80111f4:	f640 63d8 	movw	r3, #3800	; 0xed8
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80111f8:	606e      	str	r6, [r5, #4]
 80111fa:	60ae      	str	r6, [r5, #8]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80111fc:	60a6      	str	r6, [r4, #8]
  htim6.Init.Period = 3800;
 80111fe:	60e3      	str	r3, [r4, #12]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8011200:	61a6      	str	r6, [r4, #24]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 8011202:	f7f3 fa55 	bl	80046b0 <HAL_TIM_Base_Init>
 8011206:	b100      	cbz	r0, 801120a <main+0x162>
 8011208:	e7fe      	b.n	8011208 <main+0x160>
  {
	  _Error_Handler(__FILE__, __LINE__);
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801120a:	900f      	str	r0, [sp, #60]	; 0x3c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801120c:	9011      	str	r0, [sp, #68]	; 0x44
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 801120e:	4629      	mov	r1, r5
 8011210:	4620      	mov	r0, r4
 8011212:	f7f3 fc0d 	bl	8004a30 <HAL_TIMEx_MasterConfigSynchronization>
 8011216:	b100      	cbz	r0, 801121a <main+0x172>
 8011218:	e7fe      	b.n	8011218 <main+0x170>
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM7_Init 1 */

  /* USER CODE END TIM7_Init 1 */
  htim7.Instance = TIM7;
 801121a:	4c2e      	ldr	r4, [pc, #184]	; (80112d4 <main+0x22c>)
  htim7.Init.Prescaler = 60000;
 801121c:	4b2e      	ldr	r3, [pc, #184]	; (80112d8 <main+0x230>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801121e:	6028      	str	r0, [r5, #0]
  htim7.Init.Prescaler = 60000;
 8011220:	f64e 2660 	movw	r6, #60000	; 0xea60
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011224:	6068      	str	r0, [r5, #4]
 8011226:	60a8      	str	r0, [r5, #8]
  htim7.Init.Prescaler = 60000;
 8011228:	e884 0048 	stmia.w	r4, {r3, r6}
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 801122c:	60a0      	str	r0, [r4, #8]
  htim7.Init.Period = 200;
 801122e:	23c8      	movs	r3, #200	; 0xc8
  htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8011230:	61a0      	str	r0, [r4, #24]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 8011232:	4620      	mov	r0, r4
  htim7.Init.Period = 200;
 8011234:	60e3      	str	r3, [r4, #12]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 8011236:	f7f3 fa3b 	bl	80046b0 <HAL_TIM_Base_Init>
 801123a:	b100      	cbz	r0, 801123e <main+0x196>
 801123c:	e7fe      	b.n	801123c <main+0x194>
  {
	  _Error_Handler(__FILE__, __LINE__);
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801123e:	900f      	str	r0, [sp, #60]	; 0x3c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8011240:	9011      	str	r0, [sp, #68]	; 0x44
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 8011242:	4629      	mov	r1, r5
 8011244:	4620      	mov	r0, r4
 8011246:	f7f3 fbf3 	bl	8004a30 <HAL_TIMEx_MasterConfigSynchronization>
 801124a:	b100      	cbz	r0, 801124e <main+0x1a6>
 801124c:	e7fe      	b.n	801124c <main+0x1a4>
  hadc1.Instance = ADC1;
 801124e:	4c23      	ldr	r4, [pc, #140]	; (80112dc <main+0x234>)
 8011250:	9001      	str	r0, [sp, #4]
  HAL_Delay(1);
 8011252:	2001      	movs	r0, #1
 8011254:	f7ef feac 	bl	8000fb0 <HAL_Delay>
  hadc1.Init.ContinuousConvMode = ENABLE;
 8011258:	2701      	movs	r7, #1
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 801125a:	9b01      	ldr	r3, [sp, #4]
  hadc1.Instance = ADC1;
 801125c:	4a20      	ldr	r2, [pc, #128]	; (80112e0 <main+0x238>)
 801125e:	6022      	str	r2, [r4, #0]
  hadc1.Init.Resolution = ADC_RESOLUTION_8B;
 8011260:	f04f 0910 	mov.w	r9, #16
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8011264:	2604      	movs	r6, #4
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8011266:	4620      	mov	r0, r4
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8011268:	6063      	str	r3, [r4, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_8B;
 801126a:	f8c4 9008 	str.w	r9, [r4, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 801126e:	60e3      	str	r3, [r4, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8011270:	6123      	str	r3, [r4, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8011272:	6166      	str	r6, [r4, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8011274:	61a3      	str	r3, [r4, #24]
  hadc1.Init.ContinuousConvMode = ENABLE;
 8011276:	61e7      	str	r7, [r4, #28]
  hadc1.Init.NbrOfConversion = 1;
 8011278:	6227      	str	r7, [r4, #32]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 801127a:	6263      	str	r3, [r4, #36]	; 0x24
  hadc1.Init.NbrOfDiscConversion = 1;
 801127c:	62a7      	str	r7, [r4, #40]	; 0x28
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 801127e:	62e3      	str	r3, [r4, #44]	; 0x2c
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8011280:	6323      	str	r3, [r4, #48]	; 0x30
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8011282:	6363      	str	r3, [r4, #52]	; 0x34
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8011284:	63a3      	str	r3, [r4, #56]	; 0x38
  hadc1.Init.OversamplingMode = DISABLE;
 8011286:	63e3      	str	r3, [r4, #60]	; 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8011288:	f7ef fec8 	bl	800101c <HAL_ADC_Init>
 801128c:	b100      	cbz	r0, 8011290 <main+0x1e8>
 801128e:	e7fe      	b.n	801128e <main+0x1e6>
  sConfig.Channel = ADC_CHANNEL_3;
 8011290:	4b14      	ldr	r3, [pc, #80]	; (80112e4 <main+0x23c>)
 8011292:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8011294:	2306      	movs	r3, #6
 8011296:	9310      	str	r3, [sp, #64]	; 0x40
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8011298:	9011      	str	r0, [sp, #68]	; 0x44
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 801129a:	237f      	movs	r3, #127	; 0x7f
  sConfig.Offset = 0;
 801129c:	9014      	str	r0, [sp, #80]	; 0x50
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 801129e:	4629      	mov	r1, r5
 80112a0:	4620      	mov	r0, r4
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 80112a2:	9312      	str	r3, [sp, #72]	; 0x48
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 80112a4:	9613      	str	r6, [sp, #76]	; 0x4c
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80112a6:	f7ef ffd9 	bl	800125c <HAL_ADC_ConfigChannel>
 80112aa:	4604      	mov	r4, r0
 80112ac:	b1e0      	cbz	r0, 80112e8 <main+0x240>
 80112ae:	e7fe      	b.n	80112ae <main+0x206>
 80112b0:	20084b4c 	.word	0x20084b4c
 80112b4:	20085d74 	.word	0x20085d74
 80112b8:	0801f576 	.word	0x0801f576
 80112bc:	2008599c 	.word	0x2008599c
 80112c0:	40000800 	.word	0x40000800
 80112c4:	20085a34 	.word	0x20085a34
 80112c8:	40000c00 	.word	0x40000c00
 80112cc:	20085c60 	.word	0x20085c60
 80112d0:	40001000 	.word	0x40001000
 80112d4:	20085dc0 	.word	0x20085dc0
 80112d8:	40001400 	.word	0x40001400
 80112dc:	20085bdc 	.word	0x20085bdc
 80112e0:	50040000 	.word	0x50040000
 80112e4:	0c900008 	.word	0x0c900008
	__HAL_RCC_GPIOE_CLK_ENABLE();
 80112e8:	4bab      	ldr	r3, [pc, #684]	; (8011598 <main+0x4f0>)
 80112ea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80112ec:	f042 0210 	orr.w	r2, r2, #16
 80112f0:	64da      	str	r2, [r3, #76]	; 0x4c
 80112f2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80112f4:	f002 0210 	and.w	r2, r2, #16
 80112f8:	9202      	str	r2, [sp, #8]
 80112fa:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOF_CLK_ENABLE();
 80112fc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80112fe:	f042 0220 	orr.w	r2, r2, #32
 8011302:	64da      	str	r2, [r3, #76]	; 0x4c
 8011304:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011306:	f002 0220 	and.w	r2, r2, #32
 801130a:	9203      	str	r2, [sp, #12]
 801130c:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 801130e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011310:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8011314:	64da      	str	r2, [r3, #76]	; 0x4c
 8011316:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011318:	f002 0280 	and.w	r2, r2, #128	; 0x80
 801131c:	9204      	str	r2, [sp, #16]
 801131e:	9a04      	ldr	r2, [sp, #16]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8011320:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011322:	f042 0201 	orr.w	r2, r2, #1
 8011326:	64da      	str	r2, [r3, #76]	; 0x4c
 8011328:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801132a:	f002 0201 	and.w	r2, r2, #1
 801132e:	9205      	str	r2, [sp, #20]
 8011330:	9a05      	ldr	r2, [sp, #20]
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8011332:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011334:	f042 0204 	orr.w	r2, r2, #4
 8011338:	64da      	str	r2, [r3, #76]	; 0x4c
 801133a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801133c:	f002 0204 	and.w	r2, r2, #4
 8011340:	9206      	str	r2, [sp, #24]
 8011342:	9a06      	ldr	r2, [sp, #24]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 8011344:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011346:	f042 0202 	orr.w	r2, r2, #2
 801134a:	64da      	str	r2, [r3, #76]	; 0x4c
 801134c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801134e:	f002 0202 	and.w	r2, r2, #2
 8011352:	9207      	str	r2, [sp, #28]
 8011354:	9a07      	ldr	r2, [sp, #28]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 8011356:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011358:	f042 0208 	orr.w	r2, r2, #8
 801135c:	64da      	str	r2, [r3, #76]	; 0x4c
 801135e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011360:	f002 0208 	and.w	r2, r2, #8
 8011364:	9208      	str	r2, [sp, #32]
 8011366:	9a08      	ldr	r2, [sp, #32]
	__HAL_RCC_GPIOG_CLK_ENABLE();
 8011368:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801136a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801136e:	64da      	str	r2, [r3, #76]	; 0x4c
 8011370:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011372:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011376:	930b      	str	r3, [sp, #44]	; 0x2c
 8011378:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	  HAL_PWREx_EnableVddIO2();
 801137a:	f7f1 ff4f 	bl	800321c <HAL_PWREx_EnableVddIO2>
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13|GPIO_PIN_4, GPIO_PIN_RESET);
 801137e:	4622      	mov	r2, r4
 8011380:	f242 0110 	movw	r1, #8208	; 0x2010
 8011384:	4885      	ldr	r0, [pc, #532]	; (801159c <main+0x4f4>)
 8011386:	f7f0 fe67 	bl	8002058 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_5, GPIO_PIN_RESET);
 801138a:	4622      	mov	r2, r4
 801138c:	2120      	movs	r1, #32
 801138e:	4884      	ldr	r0, [pc, #528]	; (80115a0 <main+0x4f8>)
 8011390:	f7f0 fe62 	bl	8002058 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 8011394:	f04f 0a20 	mov.w	sl, #32
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011398:	4629      	mov	r1, r5
 801139a:	4881      	ldr	r0, [pc, #516]	; (80115a0 <main+0x4f8>)
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 801139c:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80113a0:	9710      	str	r7, [sp, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80113a2:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80113a4:	9412      	str	r4, [sp, #72]	; 0x48
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80113a6:	f7f0 fce7 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_5, GPIO_PIN_SET); //VIDEO_GAIN OFF
 80113aa:	463a      	mov	r2, r7
 80113ac:	4651      	mov	r1, sl
 80113ae:	487c      	ldr	r0, [pc, #496]	; (80115a0 <main+0x4f8>)
 80113b0:	f7f0 fe52 	bl	8002058 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_4;
 80113b4:	f242 0310 	movw	r3, #8208	; 0x2010
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80113b8:	4629      	mov	r1, r5
 80113ba:	4878      	ldr	r0, [pc, #480]	; (801159c <main+0x4f4>)
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_4;
 80113bc:	930f      	str	r3, [sp, #60]	; 0x3c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80113be:	9710      	str	r7, [sp, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80113c0:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80113c2:	9412      	str	r4, [sp, #72]	; 0x48
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80113c4:	f7f0 fcd8 	bl	8001d78 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);		//ST init HIGH
 80113c8:	463a      	mov	r2, r7
 80113ca:	4649      	mov	r1, r9
 80113cc:	4873      	ldr	r0, [pc, #460]	; (801159c <main+0x4f4>)
 80113ce:	f7f0 fe43 	bl	8002058 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);	//Laser init OFF
 80113d2:	4622      	mov	r2, r4
 80113d4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80113d8:	4870      	ldr	r0, [pc, #448]	; (801159c <main+0x4f4>)
 80113da:	f7f0 fe3d 	bl	8002058 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80113de:	2380      	movs	r3, #128	; 0x80
 80113e0:	930f      	str	r3, [sp, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80113e2:	4629      	mov	r1, r5
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 80113e4:	4b6f      	ldr	r3, [pc, #444]	; (80115a4 <main+0x4fc>)
 80113e6:	9310      	str	r3, [sp, #64]	; 0x40
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80113e8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80113ec:	9411      	str	r4, [sp, #68]	; 0x44
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80113ee:	f7f0 fcc3 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_2, GPIO_PIN_RESET);
 80113f2:	4622      	mov	r2, r4
 80113f4:	4631      	mov	r1, r6
 80113f6:	486a      	ldr	r0, [pc, #424]	; (80115a0 <main+0x4f8>)
 80113f8:	f7f0 fe2e 	bl	8002058 <HAL_GPIO_WritePin>
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80113fc:	4629      	mov	r1, r5
 80113fe:	4868      	ldr	r0, [pc, #416]	; (80115a0 <main+0x4f8>)
  GPIO_InitStruct.Pin = GPIO_PIN_2;
 8011400:	960f      	str	r6, [sp, #60]	; 0x3c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8011402:	9710      	str	r7, [sp, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011404:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011406:	9412      	str	r4, [sp, #72]	; 0x48
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011408:	f7f0 fcb6 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_2, GPIO_PIN_SET);
 801140c:	4631      	mov	r1, r6
 801140e:	463a      	mov	r2, r7
 8011410:	4863      	ldr	r0, [pc, #396]	; (80115a0 <main+0x4f8>)
 8011412:	f7f0 fe21 	bl	8002058 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_1, GPIO_PIN_RESET);
 8011416:	4622      	mov	r2, r4
 8011418:	2102      	movs	r1, #2
 801141a:	4861      	ldr	r0, [pc, #388]	; (80115a0 <main+0x4f8>)
 801141c:	f7f0 fe1c 	bl	8002058 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_1;
 8011420:	f04f 0b02 	mov.w	fp, #2
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011424:	4629      	mov	r1, r5
 8011426:	485e      	ldr	r0, [pc, #376]	; (80115a0 <main+0x4f8>)
  GPIO_InitStruct.Pin = GPIO_PIN_1;
 8011428:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801142c:	9710      	str	r7, [sp, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801142e:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011430:	9412      	str	r4, [sp, #72]	; 0x48
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011432:	f7f0 fca1 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_1, GPIO_PIN_SET);
 8011436:	463a      	mov	r2, r7
 8011438:	4659      	mov	r1, fp
 801143a:	4859      	ldr	r0, [pc, #356]	; (80115a0 <main+0x4f8>)
 801143c:	f7f0 fe0c 	bl	8002058 <HAL_GPIO_WritePin>
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8011440:	f44f 6600 	mov.w	r6, #2048	; 0x800
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011444:	4629      	mov	r1, r5
 8011446:	4856      	ldr	r0, [pc, #344]	; (80115a0 <main+0x4f8>)
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8011448:	960f      	str	r6, [sp, #60]	; 0x3c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801144a:	9710      	str	r7, [sp, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801144c:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801144e:	9412      	str	r4, [sp, #72]	; 0x48
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011450:	f7f0 fc92 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_11, GPIO_PIN_SET);
 8011454:	463a      	mov	r2, r7
 8011456:	4631      	mov	r1, r6
 8011458:	4851      	ldr	r0, [pc, #324]	; (80115a0 <main+0x4f8>)
 801145a:	f7f0 fdfd 	bl	8002058 <HAL_GPIO_WritePin>
	HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801145e:	4629      	mov	r1, r5
 8011460:	4851      	ldr	r0, [pc, #324]	; (80115a8 <main+0x500>)
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8011462:	960f      	str	r6, [sp, #60]	; 0x3c
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8011464:	9710      	str	r7, [sp, #64]	; 0x40
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011466:	9411      	str	r4, [sp, #68]	; 0x44
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011468:	9412      	str	r4, [sp, #72]	; 0x48
	HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801146a:	f7f0 fc85 	bl	8001d78 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_SET);
 801146e:	463a      	mov	r2, r7
 8011470:	4631      	mov	r1, r6
 8011472:	484d      	ldr	r0, [pc, #308]	; (80115a8 <main+0x500>)
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8011474:	4e4d      	ldr	r6, [pc, #308]	; (80115ac <main+0x504>)
	HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_SET);
 8011476:	f7f0 fdef 	bl	8002058 <HAL_GPIO_WritePin>
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 801147a:	f04f 0a08 	mov.w	sl, #8
	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801147e:	4629      	mov	r1, r5
 8011480:	4847      	ldr	r0, [pc, #284]	; (80115a0 <main+0x4f8>)
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8011482:	9610      	str	r6, [sp, #64]	; 0x40
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8011484:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011488:	9411      	str	r4, [sp, #68]	; 0x44
	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801148a:	f7f0 fc75 	bl	8001d78 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = GPIO_PIN_15;
 801148e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011492:	4629      	mov	r1, r5
 8011494:	4841      	ldr	r0, [pc, #260]	; (801159c <main+0x4f4>)
	GPIO_InitStruct.Pin = GPIO_PIN_15;
 8011496:	930f      	str	r3, [sp, #60]	; 0x3c
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8011498:	9610      	str	r6, [sp, #64]	; 0x40
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 801149a:	9411      	str	r4, [sp, #68]	; 0x44
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801149c:	f7f0 fc6c 	bl	8001d78 <HAL_GPIO_Init>
	HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 2); //SDO IRQ
 80114a0:	465a      	mov	r2, fp
 80114a2:	4621      	mov	r1, r4
 80114a4:	2017      	movs	r0, #23
 80114a6:	f7f0 fa3d 	bl	8001924 <HAL_NVIC_SetPriority>
	HAL_NVIC_SetPriority(EXTI3_IRQn, 2, 0); //Touchscreen IRQ
 80114aa:	4622      	mov	r2, r4
 80114ac:	4659      	mov	r1, fp
 80114ae:	2009      	movs	r0, #9
 80114b0:	f7f0 fa38 	bl	8001924 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 80114b4:	2017      	movs	r0, #23
 80114b6:	f7f0 fa69 	bl	800198c <HAL_NVIC_EnableIRQ>
	HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 80114ba:	2009      	movs	r0, #9
 80114bc:	f7f0 fa66 	bl	800198c <HAL_NVIC_EnableIRQ>
  hspi1.Instance = SPI1;
 80114c0:	4e3b      	ldr	r6, [pc, #236]	; (80115b0 <main+0x508>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80114c2:	483c      	ldr	r0, [pc, #240]	; (80115b4 <main+0x50c>)
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80114c4:	60b4      	str	r4, [r6, #8]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80114c6:	f44f 7382 	mov.w	r3, #260	; 0x104
 80114ca:	e886 0009 	stmia.w	r6, {r0, r3}
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80114ce:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 80114d2:	60f3      	str	r3, [r6, #12]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80114d4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80114d8:	61b3      	str	r3, [r6, #24]
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 80114da:	4630      	mov	r0, r6
  hspi1.Init.CRCPolynomial = 7;
 80114dc:	2307      	movs	r3, #7
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 80114de:	f8c6 b010 	str.w	fp, [r6, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
 80114e2:	6177      	str	r7, [r6, #20]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;//SPI_BAUDRATEPRESCALER_2
 80114e4:	f8c6 a01c 	str.w	sl, [r6, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80114e8:	6234      	str	r4, [r6, #32]
  hspi1.Init.TIMode = SPI_TIMODE_ENABLE;
 80114ea:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80114ee:	62b4      	str	r4, [r6, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 80114f0:	62f3      	str	r3, [r6, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80114f2:	6334      	str	r4, [r6, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 80114f4:	6374      	str	r4, [r6, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 80114f6:	f7f2 fe0f 	bl	8004118 <HAL_SPI_Init>
 80114fa:	b100      	cbz	r0, 80114fe <main+0x456>
 80114fc:	e7fe      	b.n	80114fc <main+0x454>
	__HAL_SPI_ENABLE(&hspi1);
 80114fe:	6832      	ldr	r2, [r6, #0]
 8011500:	6813      	ldr	r3, [r2, #0]
 8011502:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011506:	6013      	str	r3, [r2, #0]
  hltdc.Instance = LTDC;
 8011508:	4b2b      	ldr	r3, [pc, #172]	; (80115b8 <main+0x510>)
 801150a:	4a2c      	ldr	r2, [pc, #176]	; (80115bc <main+0x514>)
 801150c:	601a      	str	r2, [r3, #0]
  hltdc.Init.VerticalSync = 30;
 801150e:	221e      	movs	r2, #30
 8011510:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 40;
 8011512:	2228      	movs	r2, #40	; 0x28
 8011514:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedActiveW = 520;
 8011516:	f44f 7202 	mov.w	r2, #520	; 0x208
 801151a:	625a      	str	r2, [r3, #36]	; 0x24
  hltdc.Init.AccumulatedActiveH = 280;
 801151c:	f44f 728c 	mov.w	r2, #280	; 0x118
 8011520:	629a      	str	r2, [r3, #40]	; 0x28
  hltdc.Init.TotalWidth = 525;
 8011522:	f240 220d 	movw	r2, #525	; 0x20d
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 8011526:	6058      	str	r0, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 8011528:	6098      	str	r0, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 801152a:	60d8      	str	r0, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 801152c:	6118      	str	r0, [r3, #16]
  hltdc.Init.TotalWidth = 525;
 801152e:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc.Init.Backcolor.Blue = 0;
 8011530:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
  hltdc.Init.TotalHeigh = 288;
 8011534:	f44f 7290 	mov.w	r2, #288	; 0x120
  hltdc.Init.Backcolor.Green = 0;
 8011538:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
  hltdc.Init.Backcolor.Red = 0;
 801153c:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 8011540:	4618      	mov	r0, r3
  hltdc.Init.HorizontalSync = 5;
 8011542:	f8c3 8014 	str.w	r8, [r3, #20]
  hltdc.Init.AccumulatedVBP = 8;
 8011546:	f8c3 a020 	str.w	sl, [r3, #32]
  hltdc.Init.TotalHeigh = 288;
 801154a:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 801154c:	f7f1 f88a 	bl	8002664 <HAL_LTDC_Init>
 8011550:	b100      	cbz	r0, 8011554 <main+0x4ac>
 8011552:	e7fe      	b.n	8011552 <main+0x4aa>
  pLayerCfg.WindowX1 = 480;
 8011554:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
  pLayerCfg.WindowY1 = 272;
 8011558:	f44f 7188 	mov.w	r1, #272	; 0x110
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 801155c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  pLayerCfg.WindowX0 = 0;
 8011560:	2200      	movs	r2, #0
  pLayerCfg.Alpha = 255;
 8011562:	23ff      	movs	r3, #255	; 0xff
  pLayerCfg.WindowX1 = 480;
 8011564:	9010      	str	r0, [sp, #64]	; 0x40
  pLayerCfg.WindowY1 = 272;
 8011566:	9112      	str	r1, [sp, #72]	; 0x48
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 8011568:	2602      	movs	r6, #2
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 801156a:	9416      	str	r4, [sp, #88]	; 0x58
  pLayerCfg.ImageWidth = 480;
 801156c:	9019      	str	r0, [sp, #100]	; 0x64
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 801156e:	2407      	movs	r4, #7
  pLayerCfg.ImageHeight = 272;
 8011570:	911a      	str	r1, [sp, #104]	; 0x68
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8011572:	4811      	ldr	r0, [pc, #68]	; (80115b8 <main+0x510>)
  pLayerCfg.WindowX0 = 0;
 8011574:	920f      	str	r2, [sp, #60]	; 0x3c
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8011576:	4629      	mov	r1, r5
  pLayerCfg.WindowY0 = 0;
 8011578:	9211      	str	r2, [sp, #68]	; 0x44
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 801157a:	9613      	str	r6, [sp, #76]	; 0x4c
  pLayerCfg.Alpha = 255;
 801157c:	9314      	str	r3, [sp, #80]	; 0x50
  pLayerCfg.Alpha0 = 0;
 801157e:	9215      	str	r2, [sp, #84]	; 0x54
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8011580:	9417      	str	r4, [sp, #92]	; 0x5c
  pLayerCfg.FBStartAdress = 0;
 8011582:	9218      	str	r2, [sp, #96]	; 0x60
  pLayerCfg.Backcolor.Blue = 255;
 8011584:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
  pLayerCfg.Backcolor.Green = 255;
 8011588:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
  pLayerCfg.Backcolor.Red = 255;
 801158c:	f88d 306e 	strb.w	r3, [sp, #110]	; 0x6e
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8011590:	f7f1 f8d4 	bl	800273c <HAL_LTDC_ConfigLayer>
 8011594:	b1a0      	cbz	r0, 80115c0 <main+0x518>
 8011596:	e7fe      	b.n	8011596 <main+0x4ee>
 8011598:	40021000 	.word	0x40021000
 801159c:	48000800 	.word	0x48000800
 80115a0:	48001400 	.word	0x48001400
 80115a4:	10210000 	.word	0x10210000
 80115a8:	48001800 	.word	0x48001800
 80115ac:	10110000 	.word	0x10110000
 80115b0:	20085d0c 	.word	0x20085d0c
 80115b4:	40013000 	.word	0x40013000
 80115b8:	20085b20 	.word	0x20085b20
 80115bc:	40016800 	.word	0x40016800
  hdma2d.Instance = DMA2D;
 80115c0:	4c57      	ldr	r4, [pc, #348]	; (8011720 <main+0x678>)
  hdma2d.Init.Mode = DMA2D_R2M;
 80115c2:	4958      	ldr	r1, [pc, #352]	; (8011724 <main+0x67c>)
  hdma2d.Init.OutputOffset = 0;
 80115c4:	60e0      	str	r0, [r4, #12]
  hdma2d.Init.Mode = DMA2D_R2M;
 80115c6:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80115ca:	e884 000a 	stmia.w	r4, {r1, r3}
  hdma2d.LayerCfg[0].InputAlpha =125;
 80115ce:	237d      	movs	r3, #125	; 0x7d
	hdma2d.LayerCfg[0].InputOffset = 0;
 80115d0:	62a0      	str	r0, [r4, #40]	; 0x28
  hdma2d.LayerCfg[0].AlphaMode = DMA2D_NO_MODIF_ALPHA;
 80115d2:	6320      	str	r0, [r4, #48]	; 0x30
  hdma2d.LayerCfg[1].InputOffset = 0;
 80115d4:	6420      	str	r0, [r4, #64]	; 0x40
  hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
 80115d6:	64a0      	str	r0, [r4, #72]	; 0x48
  hdma2d.LayerCfg[0].InputColorMode = DMA2D_INPUT_RGB565;
 80115d8:	62e6      	str	r6, [r4, #44]	; 0x2c
  hdma2d.LayerCfg[0].InputAlpha =125;
 80115da:	6363      	str	r3, [r4, #52]	; 0x34
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
 80115dc:	6466      	str	r6, [r4, #68]	; 0x44
  hdma2d.LayerCfg[1].InputAlpha = 125;
 80115de:	64e3      	str	r3, [r4, #76]	; 0x4c
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 80115e0:	4620      	mov	r0, r4
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
 80115e2:	60a6      	str	r6, [r4, #8]
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 80115e4:	f7f0 fa36 	bl	8001a54 <HAL_DMA2D_Init>
 80115e8:	b100      	cbz	r0, 80115ec <main+0x544>
 80115ea:	e7fe      	b.n	80115ea <main+0x542>
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
 80115ec:	2101      	movs	r1, #1
 80115ee:	4620      	mov	r0, r4
 80115f0:	f7f0 fb16 	bl	8001c20 <HAL_DMA2D_ConfigLayer>
 80115f4:	b100      	cbz	r0, 80115f8 <main+0x550>
 80115f6:	e7fe      	b.n	80115f6 <main+0x54e>
  hi2c1.Instance = I2C1;
 80115f8:	4c4b      	ldr	r4, [pc, #300]	; (8011728 <main+0x680>)
 80115fa:	4b4c      	ldr	r3, [pc, #304]	; (801172c <main+0x684>)
 80115fc:	6023      	str	r3, [r4, #0]
  hi2c1.Init.Timing = 0x307075B1;
 80115fe:	f1a3 6378 	sub.w	r3, r3, #260046848	; 0xf800000
 8011602:	f5a3 237d 	sub.w	r3, r3, #1036288	; 0xfd000
 8011606:	f6a3 634f 	subw	r3, r3, #3663	; 0xe4f
 801160a:	6063      	str	r3, [r4, #4]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 801160c:	6120      	str	r0, [r4, #16]
  hi2c1.Init.OwnAddress1 = 112;
 801160e:	2370      	movs	r3, #112	; 0x70
  hi2c1.Init.OwnAddress2 = 0;
 8011610:	6160      	str	r0, [r4, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8011612:	61a0      	str	r0, [r4, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8011614:	61e0      	str	r0, [r4, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8011616:	6220      	str	r0, [r4, #32]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8011618:	2601      	movs	r6, #1
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 801161a:	4620      	mov	r0, r4
  hi2c1.Init.OwnAddress1 = 112;
 801161c:	60a3      	str	r3, [r4, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801161e:	60e6      	str	r6, [r4, #12]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8011620:	f7f0 fe3f 	bl	80022a2 <HAL_I2C_Init>
 8011624:	4601      	mov	r1, r0
 8011626:	b100      	cbz	r0, 801162a <main+0x582>
 8011628:	e7fe      	b.n	8011628 <main+0x580>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801162a:	4620      	mov	r0, r4
 801162c:	f7f0 ff48 	bl	80024c0 <HAL_I2CEx_ConfigAnalogFilter>
 8011630:	4601      	mov	r1, r0
 8011632:	b100      	cbz	r0, 8011636 <main+0x58e>
 8011634:	e7fe      	b.n	8011634 <main+0x58c>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8011636:	4620      	mov	r0, r4
 8011638:	f7f0 ff68 	bl	800250c <HAL_I2CEx_ConfigDigitalFilter>
 801163c:	4605      	mov	r5, r0
 801163e:	b100      	cbz	r0, 8011642 <main+0x59a>
 8011640:	e7fe      	b.n	8011640 <main+0x598>
  HAL_Delay(1);
 8011642:	4630      	mov	r0, r6
 8011644:	f7ef fcb4 	bl	8000fb0 <HAL_Delay>
	hlpuart1.Instance = LPUART1;
 8011648:	4c39      	ldr	r4, [pc, #228]	; (8011730 <main+0x688>)
  hlpuart1.Init.BaudRate = 9600;
 801164a:	4a3a      	ldr	r2, [pc, #232]	; (8011734 <main+0x68c>)
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
 801164c:	60a5      	str	r5, [r4, #8]
  hlpuart1.Init.BaudRate = 9600;
 801164e:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8011652:	e884 000c 	stmia.w	r4, {r2, r3}
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
 8011656:	4620      	mov	r0, r4
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 8011658:	230c      	movs	r3, #12
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
 801165a:	60e5      	str	r5, [r4, #12]
  hlpuart1.Init.Parity = UART_PARITY_NONE;
 801165c:	6125      	str	r5, [r4, #16]
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 801165e:	6163      	str	r3, [r4, #20]
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8011660:	61a5      	str	r5, [r4, #24]
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8011662:	6225      	str	r5, [r4, #32]
  hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8011664:	6265      	str	r5, [r4, #36]	; 0x24
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8011666:	62a5      	str	r5, [r4, #40]	; 0x28
  hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
 8011668:	66a5      	str	r5, [r4, #104]	; 0x68
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
 801166a:	f7f3 fcc3 	bl	8004ff4 <HAL_UART_Init>
 801166e:	4601      	mov	r1, r0
 8011670:	b100      	cbz	r0, 8011674 <main+0x5cc>
 8011672:	e7fe      	b.n	8011672 <main+0x5ca>
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8011674:	4620      	mov	r0, r4
 8011676:	f7f3 fd33 	bl	80050e0 <HAL_UARTEx_SetTxFifoThreshold>
 801167a:	4601      	mov	r1, r0
 801167c:	b100      	cbz	r0, 8011680 <main+0x5d8>
 801167e:	e7fe      	b.n	801167e <main+0x5d6>
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8011680:	4620      	mov	r0, r4
 8011682:	f7f3 fd51 	bl	8005128 <HAL_UARTEx_SetRxFifoThreshold>
 8011686:	4604      	mov	r4, r0
 8011688:	b100      	cbz	r0, 801168c <main+0x5e4>
 801168a:	e7fe      	b.n	801168a <main+0x5e2>
  HAL_Delay(1);
 801168c:	4630      	mov	r0, r6
 801168e:	f7ef fc8f 	bl	8000fb0 <HAL_Delay>
  MX_USB_DEVICE_Init();
 8011692:	f000 fbe9 	bl	8011e68 <MX_USB_DEVICE_Init>
  HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);  //Booster
 8011696:	4622      	mov	r2, r4
 8011698:	4631      	mov	r1, r6
 801169a:	201e      	movs	r0, #30
 801169c:	f7f0 f942 	bl	8001924 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM4_IRQn);
 80116a0:	201e      	movs	r0, #30
 80116a2:	f7f0 f973 	bl	800198c <HAL_NVIC_EnableIRQ>
  HAL_TIM_Base_Start(&htim4);
 80116a6:	4824      	ldr	r0, [pc, #144]	; (8011738 <main+0x690>)
 80116a8:	f7f2 feb4 	bl	8004414 <HAL_TIM_Base_Start>
  HAL_TIM_OC_Start_IT(&htim4, TIM_CHANNEL_1);
 80116ac:	4621      	mov	r1, r4
 80116ae:	4822      	ldr	r0, [pc, #136]	; (8011738 <main+0x690>)
 80116b0:	f7f3 f9bc 	bl	8004a2c <HAL_TIM_OC_Start_IT>
  HAL_TIM_OC_Start_IT(&htim4, TIM_CHANNEL_2);
 80116b4:	2104      	movs	r1, #4
 80116b6:	4820      	ldr	r0, [pc, #128]	; (8011738 <main+0x690>)
 80116b8:	f7f3 f9b8 	bl	8004a2c <HAL_TIM_OC_Start_IT>
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 80116bc:	2036      	movs	r0, #54	; 0x36
 80116be:	f7f0 f965 	bl	800198c <HAL_NVIC_EnableIRQ>
  HAL_TIM_Base_Start_IT(&htim6);
 80116c2:	481e      	ldr	r0, [pc, #120]	; (801173c <main+0x694>)
 80116c4:	f7f2 fec0 	bl	8004448 <HAL_TIM_Base_Start_IT>
  HAL_NVIC_SetPriority(TIM2_IRQn, 0, 1);  //ST Signal
 80116c8:	4632      	mov	r2, r6
 80116ca:	4621      	mov	r1, r4
 80116cc:	201c      	movs	r0, #28
 80116ce:	f7f0 f929 	bl	8001924 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
 80116d2:	201c      	movs	r0, #28
 80116d4:	f7f0 f95a 	bl	800198c <HAL_NVIC_EnableIRQ>
  HAL_TIM_Base_Start_IT(&htim2);
 80116d8:	4819      	ldr	r0, [pc, #100]	; (8011740 <main+0x698>)
 80116da:	f7f2 feb5 	bl	8004448 <HAL_TIM_Base_Start_IT>
  HAL_LTDC_SetAddress(&hltdc,(uint32_t) &RGB565_480x272,0);
 80116de:	4622      	mov	r2, r4
 80116e0:	4918      	ldr	r1, [pc, #96]	; (8011744 <main+0x69c>)
 80116e2:	4819      	ldr	r0, [pc, #100]	; (8011748 <main+0x6a0>)
 80116e4:	f7f1 f853 	bl	800278e <HAL_LTDC_SetAddress>
  Touch_Ini();
 80116e8:	f7fe feef 	bl	80104ca <Touch_Ini>
  if (USBD_LL_BatteryCharging(&hUsbDeviceFS) != USBD_OK) {
 80116ec:	4817      	ldr	r0, [pc, #92]	; (801174c <main+0x6a4>)
 80116ee:	f000 fd78 	bl	80121e2 <USBD_LL_BatteryCharging>
 80116f2:	b110      	cbz	r0, 80116fa <main+0x652>
    USBD_Start(&hUsbDeviceFS);
 80116f4:	4815      	ldr	r0, [pc, #84]	; (801174c <main+0x6a4>)
 80116f6:	f7f4 fa32 	bl	8005b5e <USBD_Start>
  Get_Battery_Level();
 80116fa:	f7ff fc39 	bl	8010f70 <Get_Battery_Level>
  HAL_Delay(1);
 80116fe:	2001      	movs	r0, #1
 8011700:	f7ef fc56 	bl	8000fb0 <HAL_Delay>
  GUI_Title_Screen();
 8011704:	f7f4 fee0 	bl	80064c8 <GUI_Title_Screen>
  HAL_Delay(1000);
 8011708:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801170c:	f7ef fc50 	bl	8000fb0 <HAL_Delay>
  GUI_screen_state = Measure_Screen;
 8011710:	4b0f      	ldr	r3, [pc, #60]	; (8011750 <main+0x6a8>)
 8011712:	2201      	movs	r2, #1
 8011714:	701a      	strb	r2, [r3, #0]
  GUI_Measure_Screen();
 8011716:	f7f5 f9d9 	bl	8006acc <GUI_Measure_Screen>
	  GUI_Display_Refresh();
 801171a:	f7f6 f8cf 	bl	80078bc <GUI_Display_Refresh>
 801171e:	e7fc      	b.n	801171a <main+0x672>
 8011720:	20085cac 	.word	0x20085cac
 8011724:	4002b000 	.word	0x4002b000
 8011728:	200859dc 	.word	0x200859dc
 801172c:	40005400 	.word	0x40005400
 8011730:	20085a98 	.word	0x20085a98
 8011734:	40008000 	.word	0x40008000
 8011738:	2008599c 	.word	0x2008599c
 801173c:	20085c60 	.word	0x20085c60
 8011740:	20085d74 	.word	0x20085d74
 8011744:	20002318 	.word	0x20002318
 8011748:	20085b20 	.word	0x20085b20
 801174c:	20085e04 	.word	0x20085e04
 8011750:	200002b9 	.word	0x200002b9

08011754 <TIM4_IRQHandler>:
}


/*Timer TFT_booster SHDN PWM mode*/
void TIM4_IRQHandler(void)
{
 8011754:	b508      	push	{r3, lr}

	HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_11);
 8011756:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801175a:	4805      	ldr	r0, [pc, #20]	; (8011770 <TIM4_IRQHandler+0x1c>)
 801175c:	f7f0 fc81 	bl	8002062 <HAL_GPIO_TogglePin>


	HAL_NVIC_ClearPendingIRQ(TIM4_IRQn);
 8011760:	201e      	movs	r0, #30
 8011762:	f7f0 f943 	bl	80019ec <HAL_NVIC_ClearPendingIRQ>
	HAL_TIM_IRQHandler(&htim4);
 8011766:	4803      	ldr	r0, [pc, #12]	; (8011774 <TIM4_IRQHandler+0x20>)
}
 8011768:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	HAL_TIM_IRQHandler(&htim4);
 801176c:	f7f2 be89 	b.w	8004482 <HAL_TIM_IRQHandler>
 8011770:	48001800 	.word	0x48001800
 8011774:	2008599c 	.word	0x2008599c

08011778 <TIM6_DAC_IRQHandler>:

/* Get battery lvl */
void TIM6_DAC_IRQHandler(void)
{
 8011778:	b508      	push	{r3, lr}
	pause_button = 0;
 801177a:	4b06      	ldr	r3, [pc, #24]	; (8011794 <TIM6_DAC_IRQHandler+0x1c>)
 801177c:	2200      	movs	r2, #0
 801177e:	701a      	strb	r2, [r3, #0]
  /* USER CODE BEGIN TIM6_IRQn 0 */
	Get_Battery_Level();
 8011780:	f7ff fbf6 	bl	8010f70 <Get_Battery_Level>

	/* USER CODE END TIM6_IRQn 0 */
	HAL_NVIC_ClearPendingIRQ(TIM6_DAC_IRQn);
 8011784:	2036      	movs	r0, #54	; 0x36
 8011786:	f7f0 f931 	bl	80019ec <HAL_NVIC_ClearPendingIRQ>
  HAL_TIM_IRQHandler(&htim6);
 801178a:	4803      	ldr	r0, [pc, #12]	; (8011798 <TIM6_DAC_IRQHandler+0x20>)

}
 801178c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_IRQHandler(&htim6);
 8011790:	f7f2 be77 	b.w	8004482 <HAL_TIM_IRQHandler>
 8011794:	20084b50 	.word	0x20084b50
 8011798:	20085c60 	.word	0x20085c60

0801179c <TIM2_IRQHandler>:

/*ST signal generator*/
void TIM2_IRQHandler(void)
{
 801179c:	b538      	push	{r3, r4, r5, lr}

	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
 801179e:	4d0c      	ldr	r5, [pc, #48]	; (80117d0 <TIM2_IRQHandler+0x34>)
 80117a0:	2200      	movs	r2, #0
 80117a2:	4628      	mov	r0, r5
 80117a4:	2110      	movs	r1, #16
 80117a6:	f7f0 fc57 	bl	8002058 <HAL_GPIO_WritePin>
//	DWT_Delay(10);
	i = 0;
 80117aa:	4b0a      	ldr	r3, [pc, #40]	; (80117d4 <TIM2_IRQHandler+0x38>)
 80117ac:	2400      	movs	r4, #0
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
 80117ae:	4628      	mov	r0, r5
 80117b0:	2201      	movs	r2, #1
 80117b2:	2110      	movs	r1, #16
	i = 0;
 80117b4:	801c      	strh	r4, [r3, #0]
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
 80117b6:	f7f0 fc4f 	bl	8002058 <HAL_GPIO_WritePin>

  cnt_delay_bar = 0;
 80117ba:	4b07      	ldr	r3, [pc, #28]	; (80117d8 <TIM2_IRQHandler+0x3c>)

	HAL_NVIC_ClearPendingIRQ(TIM2_IRQn);
 80117bc:	201c      	movs	r0, #28
  cnt_delay_bar = 0;
 80117be:	801c      	strh	r4, [r3, #0]
	HAL_NVIC_ClearPendingIRQ(TIM2_IRQn);
 80117c0:	f7f0 f914 	bl	80019ec <HAL_NVIC_ClearPendingIRQ>
	HAL_TIM_IRQHandler(&htim2);
 80117c4:	4805      	ldr	r0, [pc, #20]	; (80117dc <TIM2_IRQHandler+0x40>)
}
 80117c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	HAL_TIM_IRQHandler(&htim2);
 80117ca:	f7f2 be5a 	b.w	8004482 <HAL_TIM_IRQHandler>
 80117ce:	bf00      	nop
 80117d0:	48000800 	.word	0x48000800
 80117d4:	20084b4e 	.word	0x20084b4e
 80117d8:	20084b1c 	.word	0x20084b1c
 80117dc:	20085d74 	.word	0x20085d74

080117e0 <EXTI3_IRQHandler>:



/*Touch_screen interrupt*/
void EXTI3_IRQHandler(void)
{
 80117e0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	cnt_touch_delay = cnt_touch_delay + 1;
 80117e4:	4d52      	ldr	r5, [pc, #328]	; (8011930 <EXTI3_IRQHandler+0x150>)
 80117e6:	682b      	ldr	r3, [r5, #0]

	uint16_t Touch_x = 0, Touch_y = 0;
 80117e8:	aa02      	add	r2, sp, #8
	cnt_touch_delay = cnt_touch_delay + 1;
 80117ea:	3301      	adds	r3, #1
 80117ec:	602b      	str	r3, [r5, #0]
	uint16_t Touch_x = 0, Touch_y = 0;
 80117ee:	2300      	movs	r3, #0
 80117f0:	f822 3d02 	strh.w	r3, [r2, #-2]!
	TS_Get_XY1(TS_I2C_ADDRESS, &Touch_x, &Touch_y);
 80117f4:	a901      	add	r1, sp, #4
 80117f6:	2070      	movs	r0, #112	; 0x70
	uint16_t Touch_x = 0, Touch_y = 0;
 80117f8:	f8ad 3004 	strh.w	r3, [sp, #4]
	TS_Get_XY1(TS_I2C_ADDRESS, &Touch_x, &Touch_y);
 80117fc:	f7fe fe6e 	bl	80104dc <TS_Get_XY1>



	if((!TFT_ON_OFF) && (cnt_touch_delay >= 50))
 8011800:	4b4c      	ldr	r3, [pc, #304]	; (8011934 <EXTI3_IRQHandler+0x154>)
 8011802:	7819      	ldrb	r1, [r3, #0]
 8011804:	462c      	mov	r4, r5
 8011806:	461a      	mov	r2, r3
 8011808:	b9b1      	cbnz	r1, 8011838 <EXTI3_IRQHandler+0x58>
 801180a:	6829      	ldr	r1, [r5, #0]
 801180c:	2931      	cmp	r1, #49	; 0x31
 801180e:	d913      	bls.n	8011838 <EXTI3_IRQHandler+0x58>
	{
			TFT_ON_OFF = 0x01;
 8011810:	2401      	movs	r4, #1
			HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_SET);//TFT_booster SHDN on
 8011812:	4622      	mov	r2, r4
 8011814:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8011818:	4847      	ldr	r0, [pc, #284]	; (8011938 <EXTI3_IRQHandler+0x158>)
			TFT_ON_OFF = 0x01;
 801181a:	701c      	strb	r4, [r3, #0]
			HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_SET);//TFT_booster SHDN on
 801181c:	f7f0 fc1c 	bl	8002058 <HAL_GPIO_WritePin>
			HAL_NVIC_EnableIRQ(TIM4_IRQn); //TFT_booster SHDN on
 8011820:	201e      	movs	r0, #30
 8011822:	f7f0 f8b3 	bl	800198c <HAL_NVIC_EnableIRQ>
			HAL_GPIO_WritePin(GPIOF, GPIO_PIN_11, GPIO_PIN_SET); //LTDC_En on
 8011826:	4622      	mov	r2, r4
 8011828:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801182c:	4843      	ldr	r0, [pc, #268]	; (801193c <EXTI3_IRQHandler+0x15c>)
 801182e:	f7f0 fc13 	bl	8002058 <HAL_GPIO_WritePin>
		}

		HAL_NVIC_ClearPendingIRQ(EXTI3_IRQn);
		HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
	}
}
 8011832:	b002      	add	sp, #8
 8011834:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if(TFT_ON_OFF && (cnt_touch_delay >= 0x08)){
 8011838:	7813      	ldrb	r3, [r2, #0]
 801183a:	2b00      	cmp	r3, #0
 801183c:	d062      	beq.n	8011904 <EXTI3_IRQHandler+0x124>
 801183e:	6823      	ldr	r3, [r4, #0]
 8011840:	2b07      	cmp	r3, #7
 8011842:	d95f      	bls.n	8011904 <EXTI3_IRQHandler+0x124>
			if((Mode_EL == 0x00) && ((Touch_x >= 109*TS_Callib & Touch_x <= (109+54)*TS_Callib & Touch_y >=426*TS_Callib & Touch_y <=(426+54)*TS_Callib)))
 8011844:	4b3e      	ldr	r3, [pc, #248]	; (8011940 <EXTI3_IRQHandler+0x160>)
 8011846:	781b      	ldrb	r3, [r3, #0]
 8011848:	2b00      	cmp	r3, #0
 801184a:	d157      	bne.n	80118fc <EXTI3_IRQHandler+0x11c>
 801184c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8011850:	f7ee fe78 	bl	8000544 <__aeabi_i2d>
 8011854:	4680      	mov	r8, r0
 8011856:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801185a:	4689      	mov	r9, r1
 801185c:	f7ee fe72 	bl	8000544 <__aeabi_i2d>
 8011860:	a32d      	add	r3, pc, #180	; (adr r3, 8011918 <EXTI3_IRQHandler+0x138>)
 8011862:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011866:	4606      	mov	r6, r0
 8011868:	460f      	mov	r7, r1
 801186a:	4640      	mov	r0, r8
 801186c:	4649      	mov	r1, r9
 801186e:	f04f 0501 	mov.w	r5, #1
 8011872:	f7ef f953 	bl	8000b1c <__aeabi_dcmpge>
 8011876:	b900      	cbnz	r0, 801187a <EXTI3_IRQHandler+0x9a>
 8011878:	4605      	mov	r5, r0
 801187a:	a329      	add	r3, pc, #164	; (adr r3, 8011920 <EXTI3_IRQHandler+0x140>)
 801187c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011880:	4640      	mov	r0, r8
 8011882:	4649      	mov	r1, r9
 8011884:	f04f 0a01 	mov.w	sl, #1
 8011888:	f7ef f93e 	bl	8000b08 <__aeabi_dcmple>
 801188c:	b900      	cbnz	r0, 8011890 <EXTI3_IRQHandler+0xb0>
 801188e:	4682      	mov	sl, r0
 8011890:	a325      	add	r3, pc, #148	; (adr r3, 8011928 <EXTI3_IRQHandler+0x148>)
 8011892:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011896:	4630      	mov	r0, r6
 8011898:	4639      	mov	r1, r7
 801189a:	ea05 050a 	and.w	r5, r5, sl
 801189e:	f04f 0801 	mov.w	r8, #1
 80118a2:	f7ef f93b 	bl	8000b1c <__aeabi_dcmpge>
 80118a6:	b900      	cbnz	r0, 80118aa <EXTI3_IRQHandler+0xca>
 80118a8:	4680      	mov	r8, r0
 80118aa:	ea05 0508 	and.w	r5, r5, r8
 80118ae:	07eb      	lsls	r3, r5, #31
 80118b0:	d524      	bpl.n	80118fc <EXTI3_IRQHandler+0x11c>
 80118b2:	2200      	movs	r2, #0
 80118b4:	4b23      	ldr	r3, [pc, #140]	; (8011944 <EXTI3_IRQHandler+0x164>)
 80118b6:	4630      	mov	r0, r6
 80118b8:	4639      	mov	r1, r7
 80118ba:	f04f 0501 	mov.w	r5, #1
 80118be:	f7ef f923 	bl	8000b08 <__aeabi_dcmple>
 80118c2:	b900      	cbnz	r0, 80118c6 <EXTI3_IRQHandler+0xe6>
 80118c4:	4605      	mov	r5, r0
 80118c6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80118ca:	d017      	beq.n	80118fc <EXTI3_IRQHandler+0x11c>
				pause_button++;
 80118cc:	4d1e      	ldr	r5, [pc, #120]	; (8011948 <EXTI3_IRQHandler+0x168>)
 80118ce:	782b      	ldrb	r3, [r5, #0]
 80118d0:	3301      	adds	r3, #1
 80118d2:	b2db      	uxtb	r3, r3
				if(pause_button > 3)
 80118d4:	2b03      	cmp	r3, #3
				pause_button++;
 80118d6:	702b      	strb	r3, [r5, #0]
				if(pause_button > 3)
 80118d8:	d910      	bls.n	80118fc <EXTI3_IRQHandler+0x11c>
					LaserOnOff = !LaserOnOff;
 80118da:	4a1c      	ldr	r2, [pc, #112]	; (801194c <EXTI3_IRQHandler+0x16c>)
 80118dc:	7813      	ldrb	r3, [r2, #0]
 80118de:	fab3 f383 	clz	r3, r3
 80118e2:	095b      	lsrs	r3, r3, #5
 80118e4:	7013      	strb	r3, [r2, #0]
					LaserOnOff ? HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET):HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
 80118e6:	7813      	ldrb	r3, [r2, #0]
 80118e8:	b19b      	cbz	r3, 8011912 <EXTI3_IRQHandler+0x132>
 80118ea:	2200      	movs	r2, #0
 80118ec:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80118f0:	4817      	ldr	r0, [pc, #92]	; (8011950 <EXTI3_IRQHandler+0x170>)
 80118f2:	f7f0 fbb1 	bl	8002058 <HAL_GPIO_WritePin>
					cnt_touch_delay = 0;
 80118f6:	2300      	movs	r3, #0
 80118f8:	6023      	str	r3, [r4, #0]
					pause_button = 0;
 80118fa:	702b      	strb	r3, [r5, #0]
				GUI_Touch_Processing();
 80118fc:	f7f6 f840 	bl	8007980 <GUI_Touch_Processing>
				cnt_touch_delay = 0;
 8011900:	2300      	movs	r3, #0
 8011902:	6023      	str	r3, [r4, #0]
		HAL_NVIC_ClearPendingIRQ(EXTI3_IRQn);
 8011904:	2009      	movs	r0, #9
 8011906:	f7f0 f871 	bl	80019ec <HAL_NVIC_ClearPendingIRQ>
		HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 801190a:	2008      	movs	r0, #8
 801190c:	f7f0 fbae 	bl	800206c <HAL_GPIO_EXTI_IRQHandler>
}
 8011910:	e78f      	b.n	8011832 <EXTI3_IRQHandler+0x52>
					LaserOnOff ? HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET):HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
 8011912:	2201      	movs	r2, #1
 8011914:	e7ea      	b.n	80118ec <EXTI3_IRQHandler+0x10c>
 8011916:	bf00      	nop
 8011918:	99999999 	.word	0x99999999
 801191c:	40720d99 	.word	0x40720d99
 8011920:	33333333 	.word	0x33333333
 8011924:	407aff33 	.word	0x407aff33
 8011928:	99999999 	.word	0x99999999
 801192c:	4091a399 	.word	0x4091a399
 8011930:	20084b20 	.word	0x20084b20
 8011934:	2000019d 	.word	0x2000019d
 8011938:	48001800 	.word	0x48001800
 801193c:	48001400 	.word	0x48001400
 8011940:	2000019c 	.word	0x2000019c
 8011944:	4093e000 	.word	0x4093e000
 8011948:	20084b50 	.word	0x20084b50
 801194c:	20002314 	.word	0x20002314
 8011950:	48000800 	.word	0x48000800

08011954 <_Error_Handler>:
//	HAL_NVIC_ClearPendingIRQ(TIM7_IRQn);
//	HAL_TIM_IRQHandler(&htim7);
//}

void _Error_Handler(char *file, int line)
{
 8011954:	e7fe      	b.n	8011954 <_Error_Handler>
	...

08011958 <HAL_MspInit>:
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

	
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8011958:	4b21      	ldr	r3, [pc, #132]	; (80119e0 <HAL_MspInit+0x88>)
{
 801195a:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801195c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 801195e:	f042 0201 	orr.w	r2, r2, #1
 8011962:	661a      	str	r2, [r3, #96]	; 0x60
 8011964:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8011966:	f002 0201 	and.w	r2, r2, #1
 801196a:	9200      	str	r2, [sp, #0]
 801196c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 801196e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011970:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8011974:	659a      	str	r2, [r3, #88]	; 0x58
 8011976:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011978:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801197c:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 801197e:	2003      	movs	r0, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8011980:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8011982:	f7ef ffbd 	bl	8001900 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8011986:	2200      	movs	r2, #0
 8011988:	4611      	mov	r1, r2
 801198a:	f06f 000b 	mvn.w	r0, #11
 801198e:	f7ef ffc9 	bl	8001924 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8011992:	2200      	movs	r2, #0
 8011994:	4611      	mov	r1, r2
 8011996:	f06f 000a 	mvn.w	r0, #10
 801199a:	f7ef ffc3 	bl	8001924 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 801199e:	2200      	movs	r2, #0
 80119a0:	4611      	mov	r1, r2
 80119a2:	f06f 0009 	mvn.w	r0, #9
 80119a6:	f7ef ffbd 	bl	8001924 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80119aa:	2200      	movs	r2, #0
 80119ac:	4611      	mov	r1, r2
 80119ae:	f06f 0004 	mvn.w	r0, #4
 80119b2:	f7ef ffb7 	bl	8001924 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80119b6:	2200      	movs	r2, #0
 80119b8:	4611      	mov	r1, r2
 80119ba:	f06f 0003 	mvn.w	r0, #3
 80119be:	f7ef ffb1 	bl	8001924 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 80119c2:	2200      	movs	r2, #0
 80119c4:	4611      	mov	r1, r2
 80119c6:	f06f 0001 	mvn.w	r0, #1
 80119ca:	f7ef ffab 	bl	8001924 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80119ce:	2200      	movs	r2, #0
 80119d0:	4611      	mov	r1, r2
 80119d2:	f04f 30ff 	mov.w	r0, #4294967295
 80119d6:	f7ef ffa5 	bl	8001924 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80119da:	b003      	add	sp, #12
 80119dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80119e0:	40021000 	.word	0x40021000

080119e4 <HAL_LTDC_MspInit>:

void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
 80119e4:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hltdc->Instance==LTDC)
 80119e6:	6802      	ldr	r2, [r0, #0]
 80119e8:	4b31      	ldr	r3, [pc, #196]	; (8011ab0 <HAL_LTDC_MspInit+0xcc>)
 80119ea:	429a      	cmp	r2, r3
{
 80119ec:	b08a      	sub	sp, #40	; 0x28
  if(hltdc->Instance==LTDC)
 80119ee:	d15d      	bne.n	8011aac <HAL_LTDC_MspInit+0xc8>
  {
  /* USER CODE BEGIN LTDC_MspInit 0 */

  /* USER CODE END LTDC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
 80119f0:	f503 4328 	add.w	r3, r3, #43008	; 0xa800
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
                          |GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9
                          |GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13
                          |GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80119f4:	2400      	movs	r4, #0
    __HAL_RCC_LTDC_CLK_ENABLE();
 80119f6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80119f8:	482e      	ldr	r0, [pc, #184]	; (8011ab4 <HAL_LTDC_MspInit+0xd0>)
    __HAL_RCC_LTDC_CLK_ENABLE();
 80119fa:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80119fe:	661a      	str	r2, [r3, #96]	; 0x60
 8011a00:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8011a02:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8011a06:	9200      	str	r2, [sp, #0]
 8011a08:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8011a0a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a0c:	f042 0210 	orr.w	r2, r2, #16
 8011a10:	64da      	str	r2, [r3, #76]	; 0x4c
 8011a12:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a14:	f002 0210 	and.w	r2, r2, #16
 8011a18:	9201      	str	r2, [sp, #4]
 8011a1a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8011a1c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a1e:	f042 0202 	orr.w	r2, r2, #2
 8011a22:	64da      	str	r2, [r3, #76]	; 0x4c
 8011a24:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a26:	f002 0202 	and.w	r2, r2, #2
 8011a2a:	9202      	str	r2, [sp, #8]
 8011a2c:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOF_CLK_ENABLE();
 8011a2e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a30:	f042 0220 	orr.w	r2, r2, #32
 8011a34:	64da      	str	r2, [r3, #76]	; 0x4c
 8011a36:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a38:	f002 0220 	and.w	r2, r2, #32
 8011a3c:	9203      	str	r2, [sp, #12]
 8011a3e:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8011a40:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011a42:	f042 0208 	orr.w	r2, r2, #8
 8011a46:	64da      	str	r2, [r3, #76]	; 0x4c
 8011a48:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011a4a:	9407      	str	r4, [sp, #28]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8011a4c:	f003 0308 	and.w	r3, r3, #8
 8011a50:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011a52:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
 8011a54:	260b      	movs	r6, #11
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8011a56:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011a58:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
 8011a5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8011a5e:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
 8011a60:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011a62:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
 8011a64:	9609      	str	r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8011a66:	f7f0 f987 	bl	8001d78 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8011a6a:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011a6c:	a905      	add	r1, sp, #20
 8011a6e:	4812      	ldr	r0, [pc, #72]	; (8011ab8 <HAL_LTDC_MspInit+0xd4>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8011a70:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011a72:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011a74:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011a76:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
 8011a78:	9609      	str	r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011a7a:	f7f0 f97d 	bl	8001d78 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8011a7e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8011a82:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011a84:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 8011a86:	2309      	movs	r3, #9
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011a88:	480c      	ldr	r0, [pc, #48]	; (8011abc <HAL_LTDC_MspInit+0xd8>)
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 8011a8a:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011a8c:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011a8e:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011a90:	9408      	str	r4, [sp, #32]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011a92:	f7f0 f971 	bl	8001d78 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8011a96:	f64d 730b 	movw	r3, #57099	; 0xdf0b
                          |GPIO_PIN_1|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8011a9a:	a905      	add	r1, sp, #20
 8011a9c:	4808      	ldr	r0, [pc, #32]	; (8011ac0 <HAL_LTDC_MspInit+0xdc>)
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8011a9e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011aa0:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011aa2:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011aa4:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF11_LTDC;
 8011aa6:	9609      	str	r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8011aa8:	f7f0 f966 	bl	8001d78 <HAL_GPIO_Init>
  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }

}
 8011aac:	b00a      	add	sp, #40	; 0x28
 8011aae:	bd70      	pop	{r4, r5, r6, pc}
 8011ab0:	40016800 	.word	0x40016800
 8011ab4:	48001000 	.word	0x48001000
 8011ab8:	48000400 	.word	0x48000400
 8011abc:	48001400 	.word	0x48001400
 8011ac0:	48000c00 	.word	0x48000c00

08011ac4 <HAL_SPI_MspInit>:
  }

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8011ac4:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8011ac6:	6802      	ldr	r2, [r0, #0]
 8011ac8:	4b13      	ldr	r3, [pc, #76]	; (8011b18 <HAL_SPI_MspInit+0x54>)
 8011aca:	429a      	cmp	r2, r3
{
 8011acc:	b086      	sub	sp, #24
  if(hspi->Instance==SPI1)
 8011ace:	d121      	bne.n	8011b14 <HAL_SPI_MspInit+0x50>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8011ad0:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    PA1     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ad4:	2400      	movs	r4, #0
    __HAL_RCC_SPI1_CLK_ENABLE();
 8011ad6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8011ad8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8011adc:	661a      	str	r2, [r3, #96]	; 0x60
 8011ade:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ae0:	9403      	str	r4, [sp, #12]
    __HAL_RCC_SPI1_CLK_ENABLE();
 8011ae2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8011ae6:	9300      	str	r3, [sp, #0]
 8011ae8:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_6;
 8011aea:	2342      	movs	r3, #66	; 0x42
 8011aec:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011aee:	2302      	movs	r3, #2
 8011af0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011af2:	2303      	movs	r3, #3
 8011af4:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011af6:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8011af8:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011afa:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8011afe:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011b00:	f7f0 f93a 	bl	8001d78 <HAL_GPIO_Init>

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 0, 0);
 8011b04:	2023      	movs	r0, #35	; 0x23
 8011b06:	4622      	mov	r2, r4
 8011b08:	4621      	mov	r1, r4
 8011b0a:	f7ef ff0b 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 8011b0e:	2023      	movs	r0, #35	; 0x23
 8011b10:	f7ef ff3c 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8011b14:	b006      	add	sp, #24
 8011b16:	bd10      	pop	{r4, pc}
 8011b18:	40013000 	.word	0x40013000

08011b1c <HAL_UART_MspInit>:


void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8011b1c:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==LPUART1)
 8011b1e:	6802      	ldr	r2, [r0, #0]
 8011b20:	4b12      	ldr	r3, [pc, #72]	; (8011b6c <HAL_UART_MspInit+0x50>)
 8011b22:	429a      	cmp	r2, r3
{
 8011b24:	b086      	sub	sp, #24
  if(huart->Instance==LPUART1)
 8011b26:	d11f      	bne.n	8011b68 <HAL_UART_MspInit+0x4c>
  {
  /* USER CODE BEGIN LPUART1_MspInit 0 */

  /* USER CODE END LPUART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();
 8011b28:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
    PC0     ------> LPUART1_RX
    PC1     ------> LPUART1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011b2c:	2400      	movs	r4, #0
    __HAL_RCC_LPUART1_CLK_ENABLE();
 8011b2e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011b30:	480f      	ldr	r0, [pc, #60]	; (8011b70 <HAL_UART_MspInit+0x54>)
    __HAL_RCC_LPUART1_CLK_ENABLE();
 8011b32:	f042 0201 	orr.w	r2, r2, #1
 8011b36:	65da      	str	r2, [r3, #92]	; 0x5c
 8011b38:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011b3a:	9403      	str	r4, [sp, #12]
    __HAL_RCC_LPUART1_CLK_ENABLE();
 8011b3c:	f003 0301 	and.w	r3, r3, #1
 8011b40:	9300      	str	r3, [sp, #0]
 8011b42:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8011b44:	2303      	movs	r3, #3
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011b46:	2202      	movs	r2, #2
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8011b48:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011b4a:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011b4c:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 8011b4e:	2308      	movs	r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011b50:	9202      	str	r2, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 8011b52:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011b54:	f7f0 f910 	bl	8001d78 <HAL_GPIO_Init>

    /* LPUART1 interrupt Init */
    HAL_NVIC_SetPriority(LPUART1_IRQn, 0, 0);
 8011b58:	2046      	movs	r0, #70	; 0x46
 8011b5a:	4622      	mov	r2, r4
 8011b5c:	4621      	mov	r1, r4
 8011b5e:	f7ef fee1 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LPUART1_IRQn);
 8011b62:	2046      	movs	r0, #70	; 0x46
 8011b64:	f7ef ff12 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN LPUART1_MspInit 1 */

  /* USER CODE END LPUART1_MspInit 1 */
  }

}
 8011b68:	b006      	add	sp, #24
 8011b6a:	bd10      	pop	{r4, pc}
 8011b6c:	40008000 	.word	0x40008000
 8011b70:	48000800 	.word	0x48000800

08011b74 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
 8011b74:	b508      	push	{r3, lr}

  if(huart->Instance==LPUART1)
 8011b76:	6802      	ldr	r2, [r0, #0]
 8011b78:	4b08      	ldr	r3, [pc, #32]	; (8011b9c <HAL_UART_MspDeInit+0x28>)
 8011b7a:	429a      	cmp	r2, r3
 8011b7c:	d10d      	bne.n	8011b9a <HAL_UART_MspDeInit+0x26>
  {
  /* USER CODE BEGIN LPUART1_MspDeInit 0 */

  /* USER CODE END LPUART1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_LPUART1_CLK_DISABLE();
 8011b7e:	4a08      	ldr	r2, [pc, #32]	; (8011ba0 <HAL_UART_MspDeInit+0x2c>)

    /**LPUART1 GPIO Configuration
    PC0     ------> LPUART1_RX
    PC1     ------> LPUART1_TX
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0|GPIO_PIN_1);
 8011b80:	4808      	ldr	r0, [pc, #32]	; (8011ba4 <HAL_UART_MspDeInit+0x30>)
    __HAL_RCC_LPUART1_CLK_DISABLE();
 8011b82:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 8011b84:	f023 0301 	bic.w	r3, r3, #1
 8011b88:	65d3      	str	r3, [r2, #92]	; 0x5c
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0|GPIO_PIN_1);
 8011b8a:	2103      	movs	r1, #3
 8011b8c:	f7f0 f9cc 	bl	8001f28 <HAL_GPIO_DeInit>

    /* LPUART1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
 8011b90:	2046      	movs	r0, #70	; 0x46
  /* USER CODE BEGIN LPUART1_MspDeInit 1 */

  /* USER CODE END LPUART1_MspDeInit 1 */
  }

}
 8011b92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
 8011b96:	f7ef bf05 	b.w	80019a4 <HAL_NVIC_DisableIRQ>
 8011b9a:	bd08      	pop	{r3, pc}
 8011b9c:	40008000 	.word	0x40008000
 8011ba0:	40021000 	.word	0x40021000
 8011ba4:	48000800 	.word	0x48000800

08011ba8 <HAL_ADC_MspInit>:



void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8011ba8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hadc->Instance==ADC1)
 8011baa:	6802      	ldr	r2, [r0, #0]
 8011bac:	4b0e      	ldr	r3, [pc, #56]	; (8011be8 <HAL_ADC_MspInit+0x40>)
 8011bae:	429a      	cmp	r2, r3
 8011bb0:	d116      	bne.n	8011be0 <HAL_ADC_MspInit+0x38>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 8011bb2:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8011bb6:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
    PC2     ------> ADC1_IN3
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011bba:	a901      	add	r1, sp, #4
    __HAL_RCC_ADC_CLK_ENABLE();
 8011bbc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011bbe:	480b      	ldr	r0, [pc, #44]	; (8011bec <HAL_ADC_MspInit+0x44>)
    __HAL_RCC_ADC_CLK_ENABLE();
 8011bc0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8011bc4:	64da      	str	r2, [r3, #76]	; 0x4c
 8011bc6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011bc8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8011bcc:	9300      	str	r3, [sp, #0]
 8011bce:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8011bd0:	2304      	movs	r3, #4
 8011bd2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 8011bd4:	230b      	movs	r3, #11
 8011bd6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011bd8:	2300      	movs	r3, #0
 8011bda:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011bdc:	f7f0 f8cc 	bl	8001d78 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 8011be0:	b007      	add	sp, #28
 8011be2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011be6:	bf00      	nop
 8011be8:	50040000 	.word	0x50040000
 8011bec:	48000800 	.word	0x48000800

08011bf0 <HAL_TIM_Base_MspInit>:
  }

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8011bf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  if(htim_base->Instance==TIM2)
 8011bf2:	6803      	ldr	r3, [r0, #0]
 8011bf4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
{
 8011bf8:	4604      	mov	r4, r0
  if(htim_base->Instance==TIM2)
 8011bfa:	d112      	bne.n	8011c22 <HAL_TIM_Base_MspInit+0x32>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8011bfc:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8011c00:	201c      	movs	r0, #28
    __HAL_RCC_TIM2_CLK_ENABLE();
 8011c02:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011c04:	f042 0201 	orr.w	r2, r2, #1
 8011c08:	659a      	str	r2, [r3, #88]	; 0x58
 8011c0a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8011c0c:	2200      	movs	r2, #0
    __HAL_RCC_TIM2_CLK_ENABLE();
 8011c0e:	f003 0301 	and.w	r3, r3, #1
 8011c12:	9300      	str	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8011c14:	4611      	mov	r1, r2
    __HAL_RCC_TIM2_CLK_ENABLE();
 8011c16:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8011c18:	f7ef fe84 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8011c1c:	201c      	movs	r0, #28
 8011c1e:	f7ef feb5 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

	if(htim_base->Instance==TIM7)
 8011c22:	6822      	ldr	r2, [r4, #0]
 8011c24:	4b20      	ldr	r3, [pc, #128]	; (8011ca8 <HAL_TIM_Base_MspInit+0xb8>)
 8011c26:	429a      	cmp	r2, r3
 8011c28:	d10d      	bne.n	8011c46 <HAL_TIM_Base_MspInit+0x56>
  {
  /* USER CODE BEGIN TIM7_MspInit 0 */

  /* USER CODE END TIM7_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
 8011c2a:	f503 33fe 	add.w	r3, r3, #130048	; 0x1fc00
		HAL_NVIC_EnableIRQ(TIM7_IRQn);
 8011c2e:	2037      	movs	r0, #55	; 0x37
    __HAL_RCC_TIM7_CLK_ENABLE();
 8011c30:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011c32:	f042 0220 	orr.w	r2, r2, #32
 8011c36:	659a      	str	r2, [r3, #88]	; 0x58
 8011c38:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011c3a:	f003 0320 	and.w	r3, r3, #32
 8011c3e:	9301      	str	r3, [sp, #4]
 8011c40:	9b01      	ldr	r3, [sp, #4]
		HAL_NVIC_EnableIRQ(TIM7_IRQn);
 8011c42:	f7ef fea3 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }

	 if(htim_base->Instance==TIM4)
 8011c46:	6822      	ldr	r2, [r4, #0]
 8011c48:	4b18      	ldr	r3, [pc, #96]	; (8011cac <HAL_TIM_Base_MspInit+0xbc>)
 8011c4a:	429a      	cmp	r2, r3
 8011c4c:	d112      	bne.n	8011c74 <HAL_TIM_Base_MspInit+0x84>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM4_CLK_ENABLE();
 8011c4e:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
 8011c52:	201e      	movs	r0, #30
    __HAL_RCC_TIM4_CLK_ENABLE();
 8011c54:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011c56:	f042 0204 	orr.w	r2, r2, #4
 8011c5a:	659a      	str	r2, [r3, #88]	; 0x58
 8011c5c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
 8011c5e:	2200      	movs	r2, #0
    __HAL_RCC_TIM4_CLK_ENABLE();
 8011c60:	f003 0304 	and.w	r3, r3, #4
 8011c64:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
 8011c66:	4611      	mov	r1, r2
    __HAL_RCC_TIM4_CLK_ENABLE();
 8011c68:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
 8011c6a:	f7ef fe5b 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM4_IRQn);
 8011c6e:	201e      	movs	r0, #30
 8011c70:	f7ef fe8c 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
	}
		if(htim_base->Instance==TIM6)
 8011c74:	6822      	ldr	r2, [r4, #0]
 8011c76:	4b0e      	ldr	r3, [pc, #56]	; (8011cb0 <HAL_TIM_Base_MspInit+0xc0>)
 8011c78:	429a      	cmp	r2, r3
 8011c7a:	d112      	bne.n	8011ca2 <HAL_TIM_Base_MspInit+0xb2>
  {
  /* USER CODE BEGIN TIM6_MspInit 0 */

  /* USER CODE END TIM6_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
 8011c7c:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 3, 0);
 8011c80:	2036      	movs	r0, #54	; 0x36
    __HAL_RCC_TIM6_CLK_ENABLE();
 8011c82:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011c84:	f042 0210 	orr.w	r2, r2, #16
 8011c88:	659a      	str	r2, [r3, #88]	; 0x58
 8011c8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011c8c:	f003 0310 	and.w	r3, r3, #16
 8011c90:	9303      	str	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 3, 0);
 8011c92:	2200      	movs	r2, #0
 8011c94:	2103      	movs	r1, #3
    __HAL_RCC_TIM6_CLK_ENABLE();
 8011c96:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 3, 0);
 8011c98:	f7ef fe44 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8011c9c:	2036      	movs	r0, #54	; 0x36
 8011c9e:	f7ef fe75 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }

}
 8011ca2:	b004      	add	sp, #16
 8011ca4:	bd10      	pop	{r4, pc}
 8011ca6:	bf00      	nop
 8011ca8:	40001400 	.word	0x40001400
 8011cac:	40000800 	.word	0x40000800
 8011cb0:	40001000 	.word	0x40001000

08011cb4 <HAL_TIM_OC_MspInit>:


void HAL_TIM_OC_MspInit(TIM_HandleTypeDef* htim_oc)
{
 8011cb4:	b507      	push	{r0, r1, r2, lr}

  if(htim_oc->Instance==TIM5)
 8011cb6:	4b0d      	ldr	r3, [pc, #52]	; (8011cec <HAL_TIM_OC_MspInit+0x38>)
 8011cb8:	6802      	ldr	r2, [r0, #0]
 8011cba:	429a      	cmp	r2, r3
 8011cbc:	d112      	bne.n	8011ce4 <HAL_TIM_OC_MspInit+0x30>
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
 8011cbe:	f503 3301 	add.w	r3, r3, #132096	; 0x20400
    /* TIM5 interrupt Init */
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8011cc2:	2032      	movs	r0, #50	; 0x32
    __HAL_RCC_TIM5_CLK_ENABLE();
 8011cc4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011cc6:	f042 0208 	orr.w	r2, r2, #8
 8011cca:	659a      	str	r2, [r3, #88]	; 0x58
 8011ccc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8011cce:	2200      	movs	r2, #0
    __HAL_RCC_TIM5_CLK_ENABLE();
 8011cd0:	f003 0308 	and.w	r3, r3, #8
 8011cd4:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8011cd6:	4611      	mov	r1, r2
    __HAL_RCC_TIM5_CLK_ENABLE();
 8011cd8:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8011cda:	f7ef fe23 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8011cde:	2032      	movs	r0, #50	; 0x32
 8011ce0:	f7ef fe54 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}
 8011ce4:	b003      	add	sp, #12
 8011ce6:	f85d fb04 	ldr.w	pc, [sp], #4
 8011cea:	bf00      	nop
 8011cec:	40000c00 	.word	0x40000c00

08011cf0 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8011cf0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM5)
 8011cf2:	6802      	ldr	r2, [r0, #0]
 8011cf4:	4b09      	ldr	r3, [pc, #36]	; (8011d1c <HAL_TIM_MspPostInit+0x2c>)
 8011cf6:	429a      	cmp	r2, r3
 8011cf8:	d10c      	bne.n	8011d14 <HAL_TIM_MspPostInit+0x24>
  /* USER CODE END TIM5_MspPostInit 0 */

    /**TIM5 GPIO Configuration
    PA0     ------> TIM5_CH1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8011cfa:	2301      	movs	r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011cfc:	2200      	movs	r2, #0
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8011cfe:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011d00:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011d02:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011d04:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011d08:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011d0a:	9203      	str	r2, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011d0c:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8011d0e:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011d10:	f7f0 f832 	bl	8001d78 <HAL_GPIO_Init>

  /* USER CODE BEGIN TIM5_MspPostInit 1 */

  /* USER CODE END TIM5_MspPostInit 1 */
  }
}
 8011d14:	b007      	add	sp, #28
 8011d16:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d1a:	bf00      	nop
 8011d1c:	40000c00 	.word	0x40000c00

08011d20 <HAL_DMA2D_MspInit>:
  /* USER CODE END TIM6_MspDeInit 1 */
  }
}

void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
{
 8011d20:	b507      	push	{r0, r1, r2, lr}

  if(hdma2d->Instance==DMA2D)
 8011d22:	4b0d      	ldr	r3, [pc, #52]	; (8011d58 <HAL_DMA2D_MspInit+0x38>)
 8011d24:	6802      	ldr	r2, [r0, #0]
 8011d26:	429a      	cmp	r2, r3
 8011d28:	d112      	bne.n	8011d50 <HAL_DMA2D_MspInit+0x30>
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8011d2a:	f5a3 4320 	sub.w	r3, r3, #40960	; 0xa000
    /* DMA2D interrupt Init */
    HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8011d2e:	205a      	movs	r0, #90	; 0x5a
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8011d30:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8011d32:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8011d36:	649a      	str	r2, [r3, #72]	; 0x48
 8011d38:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8011d3a:	2200      	movs	r2, #0
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8011d3c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8011d40:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8011d42:	4611      	mov	r1, r2
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8011d44:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8011d46:	f7ef fded 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8011d4a:	205a      	movs	r0, #90	; 0x5a
 8011d4c:	f7ef fe1e 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }

}
 8011d50:	b003      	add	sp, #12
 8011d52:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d56:	bf00      	nop
 8011d58:	4002b000 	.word	0x4002b000

08011d5c <HAL_I2C_MspInit>:
  }

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8011d5c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hi2c->Instance==I2C1)
 8011d5e:	6802      	ldr	r2, [r0, #0]
 8011d60:	4b17      	ldr	r3, [pc, #92]	; (8011dc0 <HAL_I2C_MspInit+0x64>)
 8011d62:	429a      	cmp	r2, r3
 8011d64:	d128      	bne.n	8011db8 <HAL_I2C_MspInit+0x5c>
  
    /**I2C1 GPIO Configuration    
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8011d66:	23c0      	movs	r3, #192	; 0xc0
 8011d68:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8011d6a:	2312      	movs	r3, #18
 8011d6c:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8011d6e:	2301      	movs	r3, #1
 8011d70:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011d72:	2303      	movs	r3, #3
 8011d74:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8011d76:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011d78:	eb0d 0103 	add.w	r1, sp, r3
 8011d7c:	4811      	ldr	r0, [pc, #68]	; (8011dc4 <HAL_I2C_MspInit+0x68>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8011d7e:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011d80:	f7ef fffa 	bl	8001d78 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8011d84:	4b10      	ldr	r3, [pc, #64]	; (8011dc8 <HAL_I2C_MspInit+0x6c>)
 8011d86:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011d88:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8011d8c:	659a      	str	r2, [r3, #88]	; 0x58
 8011d8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 8011d90:	2200      	movs	r2, #0
    __HAL_RCC_I2C1_CLK_ENABLE();
 8011d92:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 8011d96:	4611      	mov	r1, r2
    __HAL_RCC_I2C1_CLK_ENABLE();
 8011d98:	9300      	str	r3, [sp, #0]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 8011d9a:	201f      	movs	r0, #31
    __HAL_RCC_I2C1_CLK_ENABLE();
 8011d9c:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 8011d9e:	f7ef fdc1 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 8011da2:	201f      	movs	r0, #31
 8011da4:	f7ef fdf2 	bl	800198c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 0, 0);
 8011da8:	2200      	movs	r2, #0
 8011daa:	2020      	movs	r0, #32
 8011dac:	4611      	mov	r1, r2
 8011dae:	f7ef fdb9 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 8011db2:	2020      	movs	r0, #32
 8011db4:	f7ef fdea 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 8011db8:	b007      	add	sp, #28
 8011dba:	f85d fb04 	ldr.w	pc, [sp], #4
 8011dbe:	bf00      	nop
 8011dc0:	40005400 	.word	0x40005400
 8011dc4:	48000400 	.word	0x48000400
 8011dc8:	40021000 	.word	0x40021000

08011dcc <NMI_Handler>:
 8011dcc:	4770      	bx	lr

08011dce <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8011dce:	e7fe      	b.n	8011dce <HardFault_Handler>

08011dd0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8011dd0:	e7fe      	b.n	8011dd0 <MemManage_Handler>

08011dd2 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8011dd2:	e7fe      	b.n	8011dd2 <BusFault_Handler>

08011dd4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8011dd4:	e7fe      	b.n	8011dd4 <UsageFault_Handler>

08011dd6 <SVC_Handler>:
 8011dd6:	4770      	bx	lr

08011dd8 <DebugMon_Handler>:
 8011dd8:	4770      	bx	lr

08011dda <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8011dda:	4770      	bx	lr

08011ddc <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8011ddc:	f7ef b8da 	b.w	8000f94 <HAL_IncTick>

08011de0 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8011de0:	4801      	ldr	r0, [pc, #4]	; (8011de8 <OTG_FS_IRQHandler+0x8>)
 8011de2:	f7f0 bd87 	b.w	80028f4 <HAL_PCD_IRQHandler>
 8011de6:	bf00      	nop
 8011de8:	200860a0 	.word	0x200860a0

08011dec <_sbrk>:
	}
	return len;
}

caddr_t _sbrk(int incr)
{
 8011dec:	b508      	push	{r3, lr}
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8011dee:	4b0a      	ldr	r3, [pc, #40]	; (8011e18 <_sbrk+0x2c>)
 8011df0:	6819      	ldr	r1, [r3, #0]
{
 8011df2:	4602      	mov	r2, r0
	if (heap_end == 0)
 8011df4:	b909      	cbnz	r1, 8011dfa <_sbrk+0xe>
		heap_end = &end;
 8011df6:	4909      	ldr	r1, [pc, #36]	; (8011e1c <_sbrk+0x30>)
 8011df8:	6019      	str	r1, [r3, #0]

	prev_heap_end = heap_end;
 8011dfa:	6818      	ldr	r0, [r3, #0]
	if (heap_end + incr > stack_ptr)
 8011dfc:	4669      	mov	r1, sp
 8011dfe:	4402      	add	r2, r0
 8011e00:	428a      	cmp	r2, r1
 8011e02:	d906      	bls.n	8011e12 <_sbrk+0x26>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8011e04:	f000 fa8c 	bl	8012320 <__errno>
 8011e08:	230c      	movs	r3, #12
 8011e0a:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 8011e0c:	f04f 30ff 	mov.w	r0, #4294967295
 8011e10:	bd08      	pop	{r3, pc}
	}

	heap_end += incr;
 8011e12:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 8011e14:	bd08      	pop	{r3, pc}
 8011e16:	bf00      	nop
 8011e18:	20084b54 	.word	0x20084b54
 8011e1c:	200866ac 	.word	0x200866ac

08011e20 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8011e20:	490f      	ldr	r1, [pc, #60]	; (8011e60 <SystemInit+0x40>)
 8011e22:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8011e26:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8011e2a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8011e2e:	4b0d      	ldr	r3, [pc, #52]	; (8011e64 <SystemInit+0x44>)
 8011e30:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8011e32:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 8011e34:	f042 0201 	orr.w	r2, r2, #1
 8011e38:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 8011e3a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8011e3c:	681a      	ldr	r2, [r3, #0]
 8011e3e:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8011e42:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8011e46:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8011e48:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011e4c:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8011e4e:	681a      	ldr	r2, [r3, #0]
 8011e50:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8011e54:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8011e56:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8011e58:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8011e5c:	608b      	str	r3, [r1, #8]
 8011e5e:	4770      	bx	lr
 8011e60:	e000ed00 	.word	0xe000ed00
 8011e64:	40021000 	.word	0x40021000

08011e68 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8011e68:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8011e6a:	2200      	movs	r2, #0
 8011e6c:	490a      	ldr	r1, [pc, #40]	; (8011e98 <MX_USB_DEVICE_Init+0x30>)
 8011e6e:	480b      	ldr	r0, [pc, #44]	; (8011e9c <MX_USB_DEVICE_Init+0x34>)
 8011e70:	f7f3 fe59 	bl	8005b26 <USBD_Init>
  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CUSTOM_HID);
 8011e74:	490a      	ldr	r1, [pc, #40]	; (8011ea0 <MX_USB_DEVICE_Init+0x38>)
 8011e76:	4809      	ldr	r0, [pc, #36]	; (8011e9c <MX_USB_DEVICE_Init+0x34>)
 8011e78:	f7f3 fe6a 	bl	8005b50 <USBD_RegisterClass>
  USBD_CUSTOM_HID_RegisterInterface(&hUsbDeviceFS, &USBD_CustomHID_fops_FS);
 8011e7c:	4909      	ldr	r1, [pc, #36]	; (8011ea4 <MX_USB_DEVICE_Init+0x3c>)
 8011e7e:	4807      	ldr	r0, [pc, #28]	; (8011e9c <MX_USB_DEVICE_Init+0x34>)
 8011e80:	f7f3 fe4a 	bl	8005b18 <USBD_CUSTOM_HID_RegisterInterface>
  /* Verify if the Battery Charging Detection mode (BCD) is used : */
  /* If yes, the USB device is started in the HAL_PCDEx_BCD_Callback */
  /* upon reception of PCD_BCD_DISCOVERY_COMPLETED message. */
  /* If no, the USB device is started now. */
  if (USBD_LL_BatteryCharging(&hUsbDeviceFS) != USBD_OK) {
 8011e84:	4805      	ldr	r0, [pc, #20]	; (8011e9c <MX_USB_DEVICE_Init+0x34>)
 8011e86:	f000 f9ac 	bl	80121e2 <USBD_LL_BatteryCharging>
 8011e8a:	b120      	cbz	r0, 8011e96 <MX_USB_DEVICE_Init+0x2e>
  USBD_Start(&hUsbDeviceFS);
 8011e8c:	4803      	ldr	r0, [pc, #12]	; (8011e9c <MX_USB_DEVICE_Init+0x34>)
  }
  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8011e8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  USBD_Start(&hUsbDeviceFS);
 8011e92:	f7f3 be64 	b.w	8005b5e <USBD_Start>
 8011e96:	bd08      	pop	{r3, pc}
 8011e98:	200001d8 	.word	0x200001d8
 8011e9c:	20085e04 	.word	0x20085e04
 8011ea0:	20000000 	.word	0x20000000
 8011ea4:	200001c8 	.word	0x200001c8

08011ea8 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8011ea8:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8011eaa:	6803      	ldr	r3, [r0, #0]
 8011eac:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
{
 8011eb0:	b088      	sub	sp, #32
  if(pcdHandle->Instance==USB_OTG_FS)
 8011eb2:	d133      	bne.n	8011f1c <HAL_PCD_MspInit+0x74>
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8011eb4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8011eb8:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011eba:	2302      	movs	r3, #2
 8011ebc:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ebe:	2300      	movs	r3, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8011ec0:	4c19      	ldr	r4, [pc, #100]	; (8011f28 <HAL_PCD_MspInit+0x80>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ec2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011ec4:	2303      	movs	r3, #3
 8011ec6:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011ec8:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8011eca:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011ecc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8011ed0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011ed2:	f7ef ff51 	bl	8001d78 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8011ed6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8011ed8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8011edc:	64e3      	str	r3, [r4, #76]	; 0x4c
 8011ede:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8011ee0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8011ee4:	9301      	str	r3, [sp, #4]
 8011ee6:	9b01      	ldr	r3, [sp, #4]

    /* Enable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8011ee8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8011eea:	00db      	lsls	r3, r3, #3
 8011eec:	d418      	bmi.n	8011f20 <HAL_PCD_MspInit+0x78>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8011eee:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8011ef0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011ef4:	65a3      	str	r3, [r4, #88]	; 0x58
 8011ef6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8011ef8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8011efc:	9302      	str	r3, [sp, #8]
 8011efe:	9b02      	ldr	r3, [sp, #8]
      HAL_PWREx_EnableVddUSB();
 8011f00:	f7f1 f984 	bl	800320c <HAL_PWREx_EnableVddUSB>
      __HAL_RCC_PWR_CLK_DISABLE();
 8011f04:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8011f06:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8011f0a:	65a3      	str	r3, [r4, #88]	; 0x58
    {
      HAL_PWREx_EnableVddUSB();
    }

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8011f0c:	2200      	movs	r2, #0
 8011f0e:	2043      	movs	r0, #67	; 0x43
 8011f10:	4611      	mov	r1, r2
 8011f12:	f7ef fd07 	bl	8001924 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8011f16:	2043      	movs	r0, #67	; 0x43
 8011f18:	f7ef fd38 	bl	800198c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8011f1c:	b008      	add	sp, #32
 8011f1e:	bd10      	pop	{r4, pc}
      HAL_PWREx_EnableVddUSB();
 8011f20:	f7f1 f974 	bl	800320c <HAL_PWREx_EnableVddUSB>
 8011f24:	e7f2      	b.n	8011f0c <HAL_PCD_MspInit+0x64>
 8011f26:	bf00      	nop
 8011f28:	40021000 	.word	0x40021000

08011f2c <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8011f2c:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 8011f30:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f34:	f7f3 be2a 	b.w	8005b8c <USBD_LL_SetupStage>

08011f38 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8011f38:	231c      	movs	r3, #28
 8011f3a:	fb03 0301 	mla	r3, r3, r1, r0
 8011f3e:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f42:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 8011f46:	f7f3 be4e 	b.w	8005be6 <USBD_LL_DataOutStage>

08011f4a <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8011f4a:	231c      	movs	r3, #28
 8011f4c:	fb03 0301 	mla	r3, r3, r1, r0
 8011f50:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f54:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8011f56:	f7f3 be7e 	b.w	8005c56 <USBD_LL_DataInStage>

08011f5a <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8011f5a:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f5e:	f7f3 bf0f 	b.w	8005d80 <USBD_LL_SOF>

08011f62 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8011f62:	b510      	push	{r4, lr}
 8011f64:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8011f66:	2101      	movs	r1, #1
 8011f68:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f6c:	f7f3 fef6 	bl	8005d5c <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8011f70:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
}
 8011f74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8011f78:	f7f3 bec9 	b.w	8005d0e <USBD_LL_Reset>

08011f7c <HAL_PCD_SuspendCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8011f7c:	6802      	ldr	r2, [r0, #0]
 8011f7e:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
{
 8011f82:	b510      	push	{r4, lr}
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8011f84:	f043 0301 	orr.w	r3, r3, #1
{
 8011f88:	4604      	mov	r4, r0
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8011f8a:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8011f8e:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011f92:	f7f3 fee6 	bl	8005d62 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8011f96:	6a23      	ldr	r3, [r4, #32]
 8011f98:	b123      	cbz	r3, 8011fa4 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8011f9a:	4a03      	ldr	r2, [pc, #12]	; (8011fa8 <HAL_PCD_SuspendCallback+0x2c>)
 8011f9c:	6913      	ldr	r3, [r2, #16]
 8011f9e:	f043 0306 	orr.w	r3, r3, #6
 8011fa2:	6113      	str	r3, [r2, #16]
 8011fa4:	bd10      	pop	{r4, pc}
 8011fa6:	bf00      	nop
 8011fa8:	e000ed00 	.word	0xe000ed00

08011fac <HAL_PCD_ResumeCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8011fac:	6802      	ldr	r2, [r0, #0]
 8011fae:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8011fb2:	f023 0301 	bic.w	r3, r3, #1
{
 8011fb6:	b510      	push	{r4, lr}
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8011fb8:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00

  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
 8011fbc:	6a03      	ldr	r3, [r0, #32]
{
 8011fbe:	4604      	mov	r4, r0
  if (hpcd->Init.low_power_enable)
 8011fc0:	b133      	cbz	r3, 8011fd0 <HAL_PCD_ResumeCallback+0x24>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8011fc2:	4a06      	ldr	r2, [pc, #24]	; (8011fdc <HAL_PCD_ResumeCallback+0x30>)
 8011fc4:	6913      	ldr	r3, [r2, #16]
 8011fc6:	f023 0306 	bic.w	r3, r3, #6
 8011fca:	6113      	str	r3, [r2, #16]
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
  SystemClock_Config();
 8011fcc:	f7ff f800 	bl	8010fd0 <SystemClock_Config>
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8011fd0:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
}
 8011fd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8011fd8:	f7f3 becc 	b.w	8005d74 <USBD_LL_Resume>
 8011fdc:	e000ed00 	.word	0xe000ed00

08011fe0 <HAL_PCD_ISOOUTIncompleteCallback>:
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8011fe0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011fe4:	f7f3 beda 	b.w	8005d9c <USBD_LL_IsoOUTIncomplete>

08011fe8 <HAL_PCD_ISOINIncompleteCallback>:
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8011fe8:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011fec:	f7f3 bed4 	b.w	8005d98 <USBD_LL_IsoINIncomplete>

08011ff0 <HAL_PCD_ConnectCallback>:
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8011ff0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011ff4:	f7f3 bed4 	b.w	8005da0 <USBD_LL_DevConnected>

08011ff8 <HAL_PCD_DisconnectCallback>:
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8011ff8:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8011ffc:	f7f3 bed2 	b.w	8005da4 <USBD_LL_DevDisconnected>

08012000 <USBD_LL_Init>:
{
 8012000:	b508      	push	{r3, lr}
  if (pdev->id == DEVICE_FS) {
 8012002:	7802      	ldrb	r2, [r0, #0]
 8012004:	bb4a      	cbnz	r2, 801205a <USBD_LL_Init+0x5a>
  hpcd_USB_OTG_FS.pData = pdev;
 8012006:	4b16      	ldr	r3, [pc, #88]	; (8012060 <USBD_LL_Init+0x60>)
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8012008:	2106      	movs	r1, #6
  hpcd_USB_OTG_FS.pData = pdev;
 801200a:	f8c3 0404 	str.w	r0, [r3, #1028]	; 0x404
  pdev->pData = &hpcd_USB_OTG_FS;
 801200e:	f8c0 3298 	str.w	r3, [r0, #664]	; 0x298
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8012012:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8012016:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 801201a:	2102      	movs	r1, #2
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 801201c:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 801201e:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8012020:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8012022:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8012024:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8012026:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
 8012028:	629a      	str	r2, [r3, #40]	; 0x28
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 801202a:	631a      	str	r2, [r3, #48]	; 0x30
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 801202c:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 801202e:	f7f0 fbce 	bl	80027ce <HAL_PCD_Init>
 8012032:	b120      	cbz	r0, 801203e <USBD_LL_Init+0x3e>
	  _Error_Handler(__FILE__, __LINE__);
 8012034:	f240 116b 	movw	r1, #363	; 0x16b
 8012038:	480a      	ldr	r0, [pc, #40]	; (8012064 <USBD_LL_Init+0x64>)
 801203a:	f7ff fc8b 	bl	8011954 <_Error_Handler>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 801203e:	2180      	movs	r1, #128	; 0x80
 8012040:	4807      	ldr	r0, [pc, #28]	; (8012060 <USBD_LL_Init+0x60>)
 8012042:	f7f1 f855 	bl	80030f0 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8012046:	2240      	movs	r2, #64	; 0x40
 8012048:	2100      	movs	r1, #0
 801204a:	4805      	ldr	r0, [pc, #20]	; (8012060 <USBD_LL_Init+0x60>)
 801204c:	f7f1 f82f 	bl	80030ae <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8012050:	2280      	movs	r2, #128	; 0x80
 8012052:	2101      	movs	r1, #1
 8012054:	4802      	ldr	r0, [pc, #8]	; (8012060 <USBD_LL_Init+0x60>)
 8012056:	f7f1 f82a 	bl	80030ae <HAL_PCDEx_SetTxFiFo>
}
 801205a:	2000      	movs	r0, #0
 801205c:	bd08      	pop	{r3, pc}
 801205e:	bf00      	nop
 8012060:	200860a0 	.word	0x200860a0
 8012064:	0801f5d8 	.word	0x0801f5d8

08012068 <USBD_LL_Start>:
{
 8012068:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 801206a:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 801206e:	f7f0 fc2b 	bl	80028c8 <HAL_PCD_Start>
 8012072:	2803      	cmp	r0, #3
 8012074:	bf9a      	itte	ls
 8012076:	4b02      	ldrls	r3, [pc, #8]	; (8012080 <USBD_LL_Start+0x18>)
 8012078:	5c18      	ldrbls	r0, [r3, r0]
 801207a:	2002      	movhi	r0, #2
}
 801207c:	bd08      	pop	{r3, pc}
 801207e:	bf00      	nop
 8012080:	0801f5d4 	.word	0x0801f5d4

08012084 <USBD_LL_OpenEP>:
{
 8012084:	b510      	push	{r4, lr}
 8012086:	461c      	mov	r4, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8012088:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 801208c:	4613      	mov	r3, r2
 801208e:	4622      	mov	r2, r4
 8012090:	f7f0 ff0a 	bl	8002ea8 <HAL_PCD_EP_Open>
 8012094:	2803      	cmp	r0, #3
 8012096:	bf9a      	itte	ls
 8012098:	4b01      	ldrls	r3, [pc, #4]	; (80120a0 <USBD_LL_OpenEP+0x1c>)
 801209a:	5c18      	ldrbls	r0, [r3, r0]
 801209c:	2002      	movhi	r0, #2
}
 801209e:	bd10      	pop	{r4, pc}
 80120a0:	0801f5d4 	.word	0x0801f5d4

080120a4 <USBD_LL_CloseEP>:
{
 80120a4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 80120a6:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80120aa:	f7f0 ff32 	bl	8002f12 <HAL_PCD_EP_Close>
 80120ae:	2803      	cmp	r0, #3
 80120b0:	bf9a      	itte	ls
 80120b2:	4b02      	ldrls	r3, [pc, #8]	; (80120bc <USBD_LL_CloseEP+0x18>)
 80120b4:	5c18      	ldrbls	r0, [r3, r0]
 80120b6:	2002      	movhi	r0, #2
}
 80120b8:	bd08      	pop	{r3, pc}
 80120ba:	bf00      	nop
 80120bc:	0801f5d4 	.word	0x0801f5d4

080120c0 <USBD_LL_StallEP>:
{
 80120c0:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80120c2:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80120c6:	f7f0 ff87 	bl	8002fd8 <HAL_PCD_EP_SetStall>
 80120ca:	2803      	cmp	r0, #3
 80120cc:	bf9a      	itte	ls
 80120ce:	4b02      	ldrls	r3, [pc, #8]	; (80120d8 <USBD_LL_StallEP+0x18>)
 80120d0:	5c18      	ldrbls	r0, [r3, r0]
 80120d2:	2002      	movhi	r0, #2
}
 80120d4:	bd08      	pop	{r3, pc}
 80120d6:	bf00      	nop
 80120d8:	0801f5d4 	.word	0x0801f5d4

080120dc <USBD_LL_ClearStallEP>:
{
 80120dc:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 80120de:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 80120e2:	f7f0 ffb2 	bl	800304a <HAL_PCD_EP_ClrStall>
 80120e6:	2803      	cmp	r0, #3
 80120e8:	bf9a      	itte	ls
 80120ea:	4b02      	ldrls	r3, [pc, #8]	; (80120f4 <USBD_LL_ClearStallEP+0x18>)
 80120ec:	5c18      	ldrbls	r0, [r3, r0]
 80120ee:	2002      	movhi	r0, #2
}
 80120f0:	bd08      	pop	{r3, pc}
 80120f2:	bf00      	nop
 80120f4:	0801f5d4 	.word	0x0801f5d4

080120f8 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 80120f8:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 80120fc:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 8012100:	f04f 021c 	mov.w	r2, #28
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8012104:	bf1b      	ittet	ne
 8012106:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 801210a:	fb02 3101 	mlane	r1, r2, r1, r3
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 801210e:	fb02 3101 	mlaeq	r1, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8012112:	f891 003e 	ldrbne.w	r0, [r1, #62]	; 0x3e
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8012116:	bf08      	it	eq
 8012118:	f891 01fe 	ldrbeq.w	r0, [r1, #510]	; 0x1fe
}
 801211c:	4770      	bx	lr
	...

08012120 <USBD_LL_SetUSBAddress>:
{
 8012120:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8012122:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8012126:	f7f0 feab 	bl	8002e80 <HAL_PCD_SetAddress>
 801212a:	2803      	cmp	r0, #3
 801212c:	bf9a      	itte	ls
 801212e:	4b02      	ldrls	r3, [pc, #8]	; (8012138 <USBD_LL_SetUSBAddress+0x18>)
 8012130:	5c18      	ldrbls	r0, [r3, r0]
 8012132:	2002      	movhi	r0, #2
}
 8012134:	bd08      	pop	{r3, pc}
 8012136:	bf00      	nop
 8012138:	0801f5d4 	.word	0x0801f5d4

0801213c <USBD_LL_Transmit>:
{
 801213c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 801213e:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8012142:	f7f0 ff2e 	bl	8002fa2 <HAL_PCD_EP_Transmit>
 8012146:	2803      	cmp	r0, #3
 8012148:	bf9a      	itte	ls
 801214a:	4b02      	ldrls	r3, [pc, #8]	; (8012154 <USBD_LL_Transmit+0x18>)
 801214c:	5c18      	ldrbls	r0, [r3, r0]
 801214e:	2002      	movhi	r0, #2
}
 8012150:	bd08      	pop	{r3, pc}
 8012152:	bf00      	nop
 8012154:	0801f5d4 	.word	0x0801f5d4

08012158 <USBD_LL_PrepareReceive>:
{
 8012158:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 801215a:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 801215e:	f7f0 ff02 	bl	8002f66 <HAL_PCD_EP_Receive>
 8012162:	2803      	cmp	r0, #3
 8012164:	bf9a      	itte	ls
 8012166:	4b02      	ldrls	r3, [pc, #8]	; (8012170 <USBD_LL_PrepareReceive+0x18>)
 8012168:	5c18      	ldrbls	r0, [r3, r0]
 801216a:	2002      	movhi	r0, #2
}
 801216c:	bd08      	pop	{r3, pc}
 801216e:	bf00      	nop
 8012170:	0801f5d4 	.word	0x0801f5d4

08012174 <HAL_PCDEx_LPM_Callback>:
{
 8012174:	b510      	push	{r4, lr}
 8012176:	4604      	mov	r4, r0
  switch (msg)
 8012178:	b111      	cbz	r1, 8012180 <HAL_PCDEx_LPM_Callback+0xc>
 801217a:	2901      	cmp	r1, #1
 801217c:	d016      	beq.n	80121ac <HAL_PCDEx_LPM_Callback+0x38>
 801217e:	bd10      	pop	{r4, pc}
    if (hpcd->Init.low_power_enable)
 8012180:	6a03      	ldr	r3, [r0, #32]
 8012182:	b133      	cbz	r3, 8012192 <HAL_PCDEx_LPM_Callback+0x1e>
      SystemClock_Config();
 8012184:	f7fe ff24 	bl	8010fd0 <SystemClock_Config>
      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8012188:	4a12      	ldr	r2, [pc, #72]	; (80121d4 <HAL_PCDEx_LPM_Callback+0x60>)
 801218a:	6913      	ldr	r3, [r2, #16]
 801218c:	f023 0306 	bic.w	r3, r3, #6
 8012190:	6113      	str	r3, [r2, #16]
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8012192:	6822      	ldr	r2, [r4, #0]
    USBD_LL_Resume(hpcd->pData);
 8012194:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8012198:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 801219c:	f023 0301 	bic.w	r3, r3, #1
 80121a0:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
}
 80121a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBD_LL_Resume(hpcd->pData);
 80121a8:	f7f3 bde4 	b.w	8005d74 <USBD_LL_Resume>
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80121ac:	6802      	ldr	r2, [r0, #0]
    USBD_LL_Suspend(hpcd->pData);
 80121ae:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80121b2:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80121b6:	f043 0301 	orr.w	r3, r3, #1
 80121ba:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    USBD_LL_Suspend(hpcd->pData);
 80121be:	f7f3 fdd0 	bl	8005d62 <USBD_LL_Suspend>
    if (hpcd->Init.low_power_enable)
 80121c2:	6a23      	ldr	r3, [r4, #32]
 80121c4:	b123      	cbz	r3, 80121d0 <HAL_PCDEx_LPM_Callback+0x5c>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80121c6:	4a03      	ldr	r2, [pc, #12]	; (80121d4 <HAL_PCDEx_LPM_Callback+0x60>)
 80121c8:	6913      	ldr	r3, [r2, #16]
 80121ca:	f043 0306 	orr.w	r3, r3, #6
 80121ce:	6113      	str	r3, [r2, #16]
 80121d0:	bd10      	pop	{r4, pc}
 80121d2:	bf00      	nop
 80121d4:	e000ed00 	.word	0xe000ed00

080121d8 <USBD_static_malloc>:
}
 80121d8:	4800      	ldr	r0, [pc, #0]	; (80121dc <USBD_static_malloc+0x4>)
 80121da:	4770      	bx	lr
 80121dc:	20084b58 	.word	0x20084b58

080121e0 <USBD_static_free>:
{
 80121e0:	4770      	bx	lr

080121e2 <USBD_LL_BatteryCharging>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_BatteryCharging(USBD_HandleTypeDef *pdev)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*)pdev->pData;
  if (hpcd->Init.battery_charging_enable == ENABLE)
 80121e2:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 80121e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80121e8:	2b01      	cmp	r3, #1
  }
  else
  {
    return USBD_FAIL;
  }
}
 80121ea:	bf14      	ite	ne
 80121ec:	2002      	movne	r0, #2
 80121ee:	2000      	moveq	r0, #0
 80121f0:	4770      	bx	lr

080121f2 <CUSTOM_HID_DeInit_FS>:
static int8_t CUSTOM_HID_DeInit_FS(void)
{
  /* USER CODE BEGIN 5 */
  return (USBD_OK);
  /* USER CODE END 5 */
}
 80121f2:	2000      	movs	r0, #0
 80121f4:	4770      	bx	lr
	...

080121f8 <CUSTOM_HID_OutEvent_FS>:
  * @param  state: Event state
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)
{
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)hUsbDeviceFS.pClassData;;  
 80121f8:	4b05      	ldr	r3, [pc, #20]	; (8012210 <CUSTOM_HID_OutEvent_FS+0x18>)
 
  for (uint8_t i = 0; i < 12; i++)
  {
    dataToReceive[i] = hhid->Report_buf[i];
 80121fa:	4a06      	ldr	r2, [pc, #24]	; (8012214 <CUSTOM_HID_OutEvent_FS+0x1c>)
  USBD_CUSTOM_HID_HandleTypeDef     *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)hUsbDeviceFS.pClassData;;  
 80121fc:	f8d3 0290 	ldr.w	r0, [r3, #656]	; 0x290
 8012200:	2300      	movs	r3, #0
    dataToReceive[i] = hhid->Report_buf[i];
 8012202:	5cc1      	ldrb	r1, [r0, r3]
 8012204:	5499      	strb	r1, [r3, r2]
 8012206:	3301      	adds	r3, #1
  for (uint8_t i = 0; i < 12; i++)
 8012208:	2b0c      	cmp	r3, #12
 801220a:	d1fa      	bne.n	8012202 <CUSTOM_HID_OutEvent_FS+0xa>
  }
 
 
  return (USBD_OK);
}
 801220c:	2000      	movs	r0, #0
 801220e:	4770      	bx	lr
 8012210:	20085e04 	.word	0x20085e04
 8012214:	20084b40 	.word	0x20084b40

08012218 <CUSTOM_HID_Init_FS>:
 8012218:	2000      	movs	r0, #0
 801221a:	4770      	bx	lr

0801221c <USBD_FS_DeviceDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 801221c:	2312      	movs	r3, #18
 801221e:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8012220:	4800      	ldr	r0, [pc, #0]	; (8012224 <USBD_FS_DeviceDescriptor+0x8>)
 8012222:	4770      	bx	lr
 8012224:	20000204 	.word	0x20000204

08012228 <USBD_FS_LangIDStrDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 8012228:	2304      	movs	r3, #4
 801222a:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 801222c:	4800      	ldr	r0, [pc, #0]	; (8012230 <USBD_FS_LangIDStrDescriptor+0x8>)
 801222e:	4770      	bx	lr
 8012230:	20000218 	.word	0x20000218

08012234 <USBD_FS_USR_BOSDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_USR_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_BOSDesc);
 8012234:	230c      	movs	r3, #12
 8012236:	800b      	strh	r3, [r1, #0]
  return (uint8_t*)USBD_FS_BOSDesc;
}
 8012238:	4800      	ldr	r0, [pc, #0]	; (801223c <USBD_FS_USR_BOSDescriptor+0x8>)
 801223a:	4770      	bx	lr
 801223c:	200001f8 	.word	0x200001f8

08012240 <USBD_FS_ManufacturerStrDescriptor>:
{
 8012240:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8012242:	4c04      	ldr	r4, [pc, #16]	; (8012254 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8012244:	4804      	ldr	r0, [pc, #16]	; (8012258 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8012246:	460a      	mov	r2, r1
 8012248:	4621      	mov	r1, r4
 801224a:	f7f3 ffb7 	bl	80061bc <USBD_GetString>
}
 801224e:	4620      	mov	r0, r4
 8012250:	bd10      	pop	{r4, pc}
 8012252:	bf00      	nop
 8012254:	200864a8 	.word	0x200864a8
 8012258:	0801f612 	.word	0x0801f612

0801225c <USBD_FS_ProductStrDescriptor>:
{
 801225c:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 801225e:	4c04      	ldr	r4, [pc, #16]	; (8012270 <USBD_FS_ProductStrDescriptor+0x14>)
 8012260:	4804      	ldr	r0, [pc, #16]	; (8012274 <USBD_FS_ProductStrDescriptor+0x18>)
 8012262:	460a      	mov	r2, r1
 8012264:	4621      	mov	r1, r4
 8012266:	f7f3 ffa9 	bl	80061bc <USBD_GetString>
}
 801226a:	4620      	mov	r0, r4
 801226c:	bd10      	pop	{r4, pc}
 801226e:	bf00      	nop
 8012270:	200864a8 	.word	0x200864a8
 8012274:	0801f619 	.word	0x0801f619

08012278 <USBD_FS_SerialStrDescriptor>:
{
 8012278:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 801227a:	4c04      	ldr	r4, [pc, #16]	; (801228c <USBD_FS_SerialStrDescriptor+0x14>)
 801227c:	4804      	ldr	r0, [pc, #16]	; (8012290 <USBD_FS_SerialStrDescriptor+0x18>)
 801227e:	460a      	mov	r2, r1
 8012280:	4621      	mov	r1, r4
 8012282:	f7f3 ff9b 	bl	80061bc <USBD_GetString>
}
 8012286:	4620      	mov	r0, r4
 8012288:	bd10      	pop	{r4, pc}
 801228a:	bf00      	nop
 801228c:	200864a8 	.word	0x200864a8
 8012290:	0801f637 	.word	0x0801f637

08012294 <USBD_FS_ConfigStrDescriptor>:
{
 8012294:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8012296:	4c04      	ldr	r4, [pc, #16]	; (80122a8 <USBD_FS_ConfigStrDescriptor+0x14>)
 8012298:	4804      	ldr	r0, [pc, #16]	; (80122ac <USBD_FS_ConfigStrDescriptor+0x18>)
 801229a:	460a      	mov	r2, r1
 801229c:	4621      	mov	r1, r4
 801229e:	f7f3 ff8d 	bl	80061bc <USBD_GetString>
}
 80122a2:	4620      	mov	r0, r4
 80122a4:	bd10      	pop	{r4, pc}
 80122a6:	bf00      	nop
 80122a8:	200864a8 	.word	0x200864a8
 80122ac:	0801f5eb 	.word	0x0801f5eb

080122b0 <USBD_FS_InterfaceStrDescriptor>:
{
 80122b0:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80122b2:	4c04      	ldr	r4, [pc, #16]	; (80122c4 <USBD_FS_InterfaceStrDescriptor+0x14>)
 80122b4:	4804      	ldr	r0, [pc, #16]	; (80122c8 <USBD_FS_InterfaceStrDescriptor+0x18>)
 80122b6:	460a      	mov	r2, r1
 80122b8:	4621      	mov	r1, r4
 80122ba:	f7f3 ff7f 	bl	80061bc <USBD_GetString>
}
 80122be:	4620      	mov	r0, r4
 80122c0:	bd10      	pop	{r4, pc}
 80122c2:	bf00      	nop
 80122c4:	200864a8 	.word	0x200864a8
 80122c8:	0801f5fd 	.word	0x0801f5fd

080122cc <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80122cc:	f8df d034 	ldr.w	sp, [pc, #52]	; 8012304 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80122d0:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80122d2:	e003      	b.n	80122dc <LoopCopyDataInit>

080122d4 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80122d4:	4b0c      	ldr	r3, [pc, #48]	; (8012308 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80122d6:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80122d8:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80122da:	3104      	adds	r1, #4

080122dc <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80122dc:	480b      	ldr	r0, [pc, #44]	; (801230c <LoopForever+0xa>)
	ldr	r3, =_edata
 80122de:	4b0c      	ldr	r3, [pc, #48]	; (8012310 <LoopForever+0xe>)
	adds	r2, r0, r1
 80122e0:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80122e2:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80122e4:	d3f6      	bcc.n	80122d4 <CopyDataInit>
	ldr	r2, =_sbss
 80122e6:	4a0b      	ldr	r2, [pc, #44]	; (8012314 <LoopForever+0x12>)
	b	LoopFillZerobss
 80122e8:	e002      	b.n	80122f0 <LoopFillZerobss>

080122ea <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80122ea:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80122ec:	f842 3b04 	str.w	r3, [r2], #4

080122f0 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80122f0:	4b09      	ldr	r3, [pc, #36]	; (8012318 <LoopForever+0x16>)
	cmp	r2, r3
 80122f2:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80122f4:	d3f9      	bcc.n	80122ea <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80122f6:	f7ff fd93 	bl	8011e20 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80122fa:	f000 f817 	bl	801232c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80122fe:	f7fe fed3 	bl	80110a8 <main>

08012302 <LoopForever>:

LoopForever:
    b LoopForever
 8012302:	e7fe      	b.n	8012302 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8012304:	200a0000 	.word	0x200a0000
	ldr	r3, =_sidata
 8012308:	0801f688 	.word	0x0801f688
	ldr	r0, =_sdata
 801230c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8012310:	20000280 	.word	0x20000280
	ldr	r2, =_sbss
 8012314:	20000280 	.word	0x20000280
	ldr	r3, = _ebss
 8012318:	200866ac 	.word	0x200866ac

0801231c <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 801231c:	e7fe      	b.n	801231c <ADC1_IRQHandler>
	...

08012320 <__errno>:
 8012320:	4b01      	ldr	r3, [pc, #4]	; (8012328 <__errno+0x8>)
 8012322:	6818      	ldr	r0, [r3, #0]
 8012324:	4770      	bx	lr
 8012326:	bf00      	nop
 8012328:	2000021c 	.word	0x2000021c

0801232c <__libc_init_array>:
 801232c:	b570      	push	{r4, r5, r6, lr}
 801232e:	4e0d      	ldr	r6, [pc, #52]	; (8012364 <__libc_init_array+0x38>)
 8012330:	4c0d      	ldr	r4, [pc, #52]	; (8012368 <__libc_init_array+0x3c>)
 8012332:	1ba4      	subs	r4, r4, r6
 8012334:	10a4      	asrs	r4, r4, #2
 8012336:	2500      	movs	r5, #0
 8012338:	42a5      	cmp	r5, r4
 801233a:	d109      	bne.n	8012350 <__libc_init_array+0x24>
 801233c:	4e0b      	ldr	r6, [pc, #44]	; (801236c <__libc_init_array+0x40>)
 801233e:	4c0c      	ldr	r4, [pc, #48]	; (8012370 <__libc_init_array+0x44>)
 8012340:	f000 fc36 	bl	8012bb0 <_init>
 8012344:	1ba4      	subs	r4, r4, r6
 8012346:	10a4      	asrs	r4, r4, #2
 8012348:	2500      	movs	r5, #0
 801234a:	42a5      	cmp	r5, r4
 801234c:	d105      	bne.n	801235a <__libc_init_array+0x2e>
 801234e:	bd70      	pop	{r4, r5, r6, pc}
 8012350:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8012354:	4798      	blx	r3
 8012356:	3501      	adds	r5, #1
 8012358:	e7ee      	b.n	8012338 <__libc_init_array+0xc>
 801235a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801235e:	4798      	blx	r3
 8012360:	3501      	adds	r5, #1
 8012362:	e7f2      	b.n	801234a <__libc_init_array+0x1e>
 8012364:	0801f680 	.word	0x0801f680
 8012368:	0801f680 	.word	0x0801f680
 801236c:	0801f680 	.word	0x0801f680
 8012370:	0801f684 	.word	0x0801f684

08012374 <memcpy>:
 8012374:	b510      	push	{r4, lr}
 8012376:	1e43      	subs	r3, r0, #1
 8012378:	440a      	add	r2, r1
 801237a:	4291      	cmp	r1, r2
 801237c:	d100      	bne.n	8012380 <memcpy+0xc>
 801237e:	bd10      	pop	{r4, pc}
 8012380:	f811 4b01 	ldrb.w	r4, [r1], #1
 8012384:	f803 4f01 	strb.w	r4, [r3, #1]!
 8012388:	e7f7      	b.n	801237a <memcpy+0x6>
	...

0801238c <siprintf>:
 801238c:	b40e      	push	{r1, r2, r3}
 801238e:	b500      	push	{lr}
 8012390:	b09c      	sub	sp, #112	; 0x70
 8012392:	f44f 7102 	mov.w	r1, #520	; 0x208
 8012396:	ab1d      	add	r3, sp, #116	; 0x74
 8012398:	f8ad 1014 	strh.w	r1, [sp, #20]
 801239c:	9002      	str	r0, [sp, #8]
 801239e:	9006      	str	r0, [sp, #24]
 80123a0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80123a4:	480a      	ldr	r0, [pc, #40]	; (80123d0 <siprintf+0x44>)
 80123a6:	9104      	str	r1, [sp, #16]
 80123a8:	9107      	str	r1, [sp, #28]
 80123aa:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80123ae:	f853 2b04 	ldr.w	r2, [r3], #4
 80123b2:	f8ad 1016 	strh.w	r1, [sp, #22]
 80123b6:	6800      	ldr	r0, [r0, #0]
 80123b8:	9301      	str	r3, [sp, #4]
 80123ba:	a902      	add	r1, sp, #8
 80123bc:	f000 f866 	bl	801248c <_svfiprintf_r>
 80123c0:	9b02      	ldr	r3, [sp, #8]
 80123c2:	2200      	movs	r2, #0
 80123c4:	701a      	strb	r2, [r3, #0]
 80123c6:	b01c      	add	sp, #112	; 0x70
 80123c8:	f85d eb04 	ldr.w	lr, [sp], #4
 80123cc:	b003      	add	sp, #12
 80123ce:	4770      	bx	lr
 80123d0:	2000021c 	.word	0x2000021c

080123d4 <__ssputs_r>:
 80123d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80123d8:	688e      	ldr	r6, [r1, #8]
 80123da:	429e      	cmp	r6, r3
 80123dc:	4682      	mov	sl, r0
 80123de:	460c      	mov	r4, r1
 80123e0:	4691      	mov	r9, r2
 80123e2:	4698      	mov	r8, r3
 80123e4:	d835      	bhi.n	8012452 <__ssputs_r+0x7e>
 80123e6:	898a      	ldrh	r2, [r1, #12]
 80123e8:	f412 6f90 	tst.w	r2, #1152	; 0x480
 80123ec:	d031      	beq.n	8012452 <__ssputs_r+0x7e>
 80123ee:	6825      	ldr	r5, [r4, #0]
 80123f0:	6909      	ldr	r1, [r1, #16]
 80123f2:	1a6f      	subs	r7, r5, r1
 80123f4:	6965      	ldr	r5, [r4, #20]
 80123f6:	2302      	movs	r3, #2
 80123f8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80123fc:	fb95 f5f3 	sdiv	r5, r5, r3
 8012400:	f108 0301 	add.w	r3, r8, #1
 8012404:	443b      	add	r3, r7
 8012406:	429d      	cmp	r5, r3
 8012408:	bf38      	it	cc
 801240a:	461d      	movcc	r5, r3
 801240c:	0553      	lsls	r3, r2, #21
 801240e:	d531      	bpl.n	8012474 <__ssputs_r+0xa0>
 8012410:	4629      	mov	r1, r5
 8012412:	f000 fb2d 	bl	8012a70 <_malloc_r>
 8012416:	4606      	mov	r6, r0
 8012418:	b950      	cbnz	r0, 8012430 <__ssputs_r+0x5c>
 801241a:	230c      	movs	r3, #12
 801241c:	f8ca 3000 	str.w	r3, [sl]
 8012420:	89a3      	ldrh	r3, [r4, #12]
 8012422:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012426:	81a3      	strh	r3, [r4, #12]
 8012428:	f04f 30ff 	mov.w	r0, #4294967295
 801242c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012430:	463a      	mov	r2, r7
 8012432:	6921      	ldr	r1, [r4, #16]
 8012434:	f7ff ff9e 	bl	8012374 <memcpy>
 8012438:	89a3      	ldrh	r3, [r4, #12]
 801243a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801243e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012442:	81a3      	strh	r3, [r4, #12]
 8012444:	6126      	str	r6, [r4, #16]
 8012446:	6165      	str	r5, [r4, #20]
 8012448:	443e      	add	r6, r7
 801244a:	1bed      	subs	r5, r5, r7
 801244c:	6026      	str	r6, [r4, #0]
 801244e:	60a5      	str	r5, [r4, #8]
 8012450:	4646      	mov	r6, r8
 8012452:	4546      	cmp	r6, r8
 8012454:	bf28      	it	cs
 8012456:	4646      	movcs	r6, r8
 8012458:	4632      	mov	r2, r6
 801245a:	4649      	mov	r1, r9
 801245c:	6820      	ldr	r0, [r4, #0]
 801245e:	f000 fa9f 	bl	80129a0 <memmove>
 8012462:	68a3      	ldr	r3, [r4, #8]
 8012464:	1b9b      	subs	r3, r3, r6
 8012466:	60a3      	str	r3, [r4, #8]
 8012468:	6823      	ldr	r3, [r4, #0]
 801246a:	441e      	add	r6, r3
 801246c:	6026      	str	r6, [r4, #0]
 801246e:	2000      	movs	r0, #0
 8012470:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012474:	462a      	mov	r2, r5
 8012476:	f000 fb59 	bl	8012b2c <_realloc_r>
 801247a:	4606      	mov	r6, r0
 801247c:	2800      	cmp	r0, #0
 801247e:	d1e1      	bne.n	8012444 <__ssputs_r+0x70>
 8012480:	6921      	ldr	r1, [r4, #16]
 8012482:	4650      	mov	r0, sl
 8012484:	f000 faa6 	bl	80129d4 <_free_r>
 8012488:	e7c7      	b.n	801241a <__ssputs_r+0x46>
	...

0801248c <_svfiprintf_r>:
 801248c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012490:	b09d      	sub	sp, #116	; 0x74
 8012492:	4680      	mov	r8, r0
 8012494:	9303      	str	r3, [sp, #12]
 8012496:	898b      	ldrh	r3, [r1, #12]
 8012498:	061c      	lsls	r4, r3, #24
 801249a:	460d      	mov	r5, r1
 801249c:	4616      	mov	r6, r2
 801249e:	d50f      	bpl.n	80124c0 <_svfiprintf_r+0x34>
 80124a0:	690b      	ldr	r3, [r1, #16]
 80124a2:	b96b      	cbnz	r3, 80124c0 <_svfiprintf_r+0x34>
 80124a4:	2140      	movs	r1, #64	; 0x40
 80124a6:	f000 fae3 	bl	8012a70 <_malloc_r>
 80124aa:	6028      	str	r0, [r5, #0]
 80124ac:	6128      	str	r0, [r5, #16]
 80124ae:	b928      	cbnz	r0, 80124bc <_svfiprintf_r+0x30>
 80124b0:	230c      	movs	r3, #12
 80124b2:	f8c8 3000 	str.w	r3, [r8]
 80124b6:	f04f 30ff 	mov.w	r0, #4294967295
 80124ba:	e0c5      	b.n	8012648 <_svfiprintf_r+0x1bc>
 80124bc:	2340      	movs	r3, #64	; 0x40
 80124be:	616b      	str	r3, [r5, #20]
 80124c0:	2300      	movs	r3, #0
 80124c2:	9309      	str	r3, [sp, #36]	; 0x24
 80124c4:	2320      	movs	r3, #32
 80124c6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80124ca:	2330      	movs	r3, #48	; 0x30
 80124cc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80124d0:	f04f 0b01 	mov.w	fp, #1
 80124d4:	4637      	mov	r7, r6
 80124d6:	463c      	mov	r4, r7
 80124d8:	f814 3b01 	ldrb.w	r3, [r4], #1
 80124dc:	2b00      	cmp	r3, #0
 80124de:	d13c      	bne.n	801255a <_svfiprintf_r+0xce>
 80124e0:	ebb7 0a06 	subs.w	sl, r7, r6
 80124e4:	d00b      	beq.n	80124fe <_svfiprintf_r+0x72>
 80124e6:	4653      	mov	r3, sl
 80124e8:	4632      	mov	r2, r6
 80124ea:	4629      	mov	r1, r5
 80124ec:	4640      	mov	r0, r8
 80124ee:	f7ff ff71 	bl	80123d4 <__ssputs_r>
 80124f2:	3001      	adds	r0, #1
 80124f4:	f000 80a3 	beq.w	801263e <_svfiprintf_r+0x1b2>
 80124f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80124fa:	4453      	add	r3, sl
 80124fc:	9309      	str	r3, [sp, #36]	; 0x24
 80124fe:	783b      	ldrb	r3, [r7, #0]
 8012500:	2b00      	cmp	r3, #0
 8012502:	f000 809c 	beq.w	801263e <_svfiprintf_r+0x1b2>
 8012506:	2300      	movs	r3, #0
 8012508:	f04f 32ff 	mov.w	r2, #4294967295
 801250c:	9304      	str	r3, [sp, #16]
 801250e:	9307      	str	r3, [sp, #28]
 8012510:	9205      	str	r2, [sp, #20]
 8012512:	9306      	str	r3, [sp, #24]
 8012514:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8012518:	931a      	str	r3, [sp, #104]	; 0x68
 801251a:	2205      	movs	r2, #5
 801251c:	7821      	ldrb	r1, [r4, #0]
 801251e:	4850      	ldr	r0, [pc, #320]	; (8012660 <_svfiprintf_r+0x1d4>)
 8012520:	f7ed fe6e 	bl	8000200 <memchr>
 8012524:	1c67      	adds	r7, r4, #1
 8012526:	9b04      	ldr	r3, [sp, #16]
 8012528:	b9d8      	cbnz	r0, 8012562 <_svfiprintf_r+0xd6>
 801252a:	06d9      	lsls	r1, r3, #27
 801252c:	bf44      	itt	mi
 801252e:	2220      	movmi	r2, #32
 8012530:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8012534:	071a      	lsls	r2, r3, #28
 8012536:	bf44      	itt	mi
 8012538:	222b      	movmi	r2, #43	; 0x2b
 801253a:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 801253e:	7822      	ldrb	r2, [r4, #0]
 8012540:	2a2a      	cmp	r2, #42	; 0x2a
 8012542:	d016      	beq.n	8012572 <_svfiprintf_r+0xe6>
 8012544:	9a07      	ldr	r2, [sp, #28]
 8012546:	2100      	movs	r1, #0
 8012548:	200a      	movs	r0, #10
 801254a:	4627      	mov	r7, r4
 801254c:	3401      	adds	r4, #1
 801254e:	783b      	ldrb	r3, [r7, #0]
 8012550:	3b30      	subs	r3, #48	; 0x30
 8012552:	2b09      	cmp	r3, #9
 8012554:	d951      	bls.n	80125fa <_svfiprintf_r+0x16e>
 8012556:	b1c9      	cbz	r1, 801258c <_svfiprintf_r+0x100>
 8012558:	e011      	b.n	801257e <_svfiprintf_r+0xf2>
 801255a:	2b25      	cmp	r3, #37	; 0x25
 801255c:	d0c0      	beq.n	80124e0 <_svfiprintf_r+0x54>
 801255e:	4627      	mov	r7, r4
 8012560:	e7b9      	b.n	80124d6 <_svfiprintf_r+0x4a>
 8012562:	4a3f      	ldr	r2, [pc, #252]	; (8012660 <_svfiprintf_r+0x1d4>)
 8012564:	1a80      	subs	r0, r0, r2
 8012566:	fa0b f000 	lsl.w	r0, fp, r0
 801256a:	4318      	orrs	r0, r3
 801256c:	9004      	str	r0, [sp, #16]
 801256e:	463c      	mov	r4, r7
 8012570:	e7d3      	b.n	801251a <_svfiprintf_r+0x8e>
 8012572:	9a03      	ldr	r2, [sp, #12]
 8012574:	1d11      	adds	r1, r2, #4
 8012576:	6812      	ldr	r2, [r2, #0]
 8012578:	9103      	str	r1, [sp, #12]
 801257a:	2a00      	cmp	r2, #0
 801257c:	db01      	blt.n	8012582 <_svfiprintf_r+0xf6>
 801257e:	9207      	str	r2, [sp, #28]
 8012580:	e004      	b.n	801258c <_svfiprintf_r+0x100>
 8012582:	4252      	negs	r2, r2
 8012584:	f043 0302 	orr.w	r3, r3, #2
 8012588:	9207      	str	r2, [sp, #28]
 801258a:	9304      	str	r3, [sp, #16]
 801258c:	783b      	ldrb	r3, [r7, #0]
 801258e:	2b2e      	cmp	r3, #46	; 0x2e
 8012590:	d10e      	bne.n	80125b0 <_svfiprintf_r+0x124>
 8012592:	787b      	ldrb	r3, [r7, #1]
 8012594:	2b2a      	cmp	r3, #42	; 0x2a
 8012596:	f107 0101 	add.w	r1, r7, #1
 801259a:	d132      	bne.n	8012602 <_svfiprintf_r+0x176>
 801259c:	9b03      	ldr	r3, [sp, #12]
 801259e:	1d1a      	adds	r2, r3, #4
 80125a0:	681b      	ldr	r3, [r3, #0]
 80125a2:	9203      	str	r2, [sp, #12]
 80125a4:	2b00      	cmp	r3, #0
 80125a6:	bfb8      	it	lt
 80125a8:	f04f 33ff 	movlt.w	r3, #4294967295
 80125ac:	3702      	adds	r7, #2
 80125ae:	9305      	str	r3, [sp, #20]
 80125b0:	4c2c      	ldr	r4, [pc, #176]	; (8012664 <_svfiprintf_r+0x1d8>)
 80125b2:	7839      	ldrb	r1, [r7, #0]
 80125b4:	2203      	movs	r2, #3
 80125b6:	4620      	mov	r0, r4
 80125b8:	f7ed fe22 	bl	8000200 <memchr>
 80125bc:	b138      	cbz	r0, 80125ce <_svfiprintf_r+0x142>
 80125be:	2340      	movs	r3, #64	; 0x40
 80125c0:	1b00      	subs	r0, r0, r4
 80125c2:	fa03 f000 	lsl.w	r0, r3, r0
 80125c6:	9b04      	ldr	r3, [sp, #16]
 80125c8:	4303      	orrs	r3, r0
 80125ca:	9304      	str	r3, [sp, #16]
 80125cc:	3701      	adds	r7, #1
 80125ce:	7839      	ldrb	r1, [r7, #0]
 80125d0:	4825      	ldr	r0, [pc, #148]	; (8012668 <_svfiprintf_r+0x1dc>)
 80125d2:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80125d6:	2206      	movs	r2, #6
 80125d8:	1c7e      	adds	r6, r7, #1
 80125da:	f7ed fe11 	bl	8000200 <memchr>
 80125de:	2800      	cmp	r0, #0
 80125e0:	d035      	beq.n	801264e <_svfiprintf_r+0x1c2>
 80125e2:	4b22      	ldr	r3, [pc, #136]	; (801266c <_svfiprintf_r+0x1e0>)
 80125e4:	b9fb      	cbnz	r3, 8012626 <_svfiprintf_r+0x19a>
 80125e6:	9b03      	ldr	r3, [sp, #12]
 80125e8:	3307      	adds	r3, #7
 80125ea:	f023 0307 	bic.w	r3, r3, #7
 80125ee:	3308      	adds	r3, #8
 80125f0:	9303      	str	r3, [sp, #12]
 80125f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80125f4:	444b      	add	r3, r9
 80125f6:	9309      	str	r3, [sp, #36]	; 0x24
 80125f8:	e76c      	b.n	80124d4 <_svfiprintf_r+0x48>
 80125fa:	fb00 3202 	mla	r2, r0, r2, r3
 80125fe:	2101      	movs	r1, #1
 8012600:	e7a3      	b.n	801254a <_svfiprintf_r+0xbe>
 8012602:	2300      	movs	r3, #0
 8012604:	9305      	str	r3, [sp, #20]
 8012606:	4618      	mov	r0, r3
 8012608:	240a      	movs	r4, #10
 801260a:	460f      	mov	r7, r1
 801260c:	3101      	adds	r1, #1
 801260e:	783a      	ldrb	r2, [r7, #0]
 8012610:	3a30      	subs	r2, #48	; 0x30
 8012612:	2a09      	cmp	r2, #9
 8012614:	d903      	bls.n	801261e <_svfiprintf_r+0x192>
 8012616:	2b00      	cmp	r3, #0
 8012618:	d0ca      	beq.n	80125b0 <_svfiprintf_r+0x124>
 801261a:	9005      	str	r0, [sp, #20]
 801261c:	e7c8      	b.n	80125b0 <_svfiprintf_r+0x124>
 801261e:	fb04 2000 	mla	r0, r4, r0, r2
 8012622:	2301      	movs	r3, #1
 8012624:	e7f1      	b.n	801260a <_svfiprintf_r+0x17e>
 8012626:	ab03      	add	r3, sp, #12
 8012628:	9300      	str	r3, [sp, #0]
 801262a:	462a      	mov	r2, r5
 801262c:	4b10      	ldr	r3, [pc, #64]	; (8012670 <_svfiprintf_r+0x1e4>)
 801262e:	a904      	add	r1, sp, #16
 8012630:	4640      	mov	r0, r8
 8012632:	f3af 8000 	nop.w
 8012636:	f1b0 3fff 	cmp.w	r0, #4294967295
 801263a:	4681      	mov	r9, r0
 801263c:	d1d9      	bne.n	80125f2 <_svfiprintf_r+0x166>
 801263e:	89ab      	ldrh	r3, [r5, #12]
 8012640:	065b      	lsls	r3, r3, #25
 8012642:	f53f af38 	bmi.w	80124b6 <_svfiprintf_r+0x2a>
 8012646:	9809      	ldr	r0, [sp, #36]	; 0x24
 8012648:	b01d      	add	sp, #116	; 0x74
 801264a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801264e:	ab03      	add	r3, sp, #12
 8012650:	9300      	str	r3, [sp, #0]
 8012652:	462a      	mov	r2, r5
 8012654:	4b06      	ldr	r3, [pc, #24]	; (8012670 <_svfiprintf_r+0x1e4>)
 8012656:	a904      	add	r1, sp, #16
 8012658:	4640      	mov	r0, r8
 801265a:	f000 f881 	bl	8012760 <_printf_i>
 801265e:	e7ea      	b.n	8012636 <_svfiprintf_r+0x1aa>
 8012660:	0801f644 	.word	0x0801f644
 8012664:	0801f64a 	.word	0x0801f64a
 8012668:	0801f64e 	.word	0x0801f64e
 801266c:	00000000 	.word	0x00000000
 8012670:	080123d5 	.word	0x080123d5

08012674 <_printf_common>:
 8012674:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8012678:	4691      	mov	r9, r2
 801267a:	461f      	mov	r7, r3
 801267c:	688a      	ldr	r2, [r1, #8]
 801267e:	690b      	ldr	r3, [r1, #16]
 8012680:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8012684:	4293      	cmp	r3, r2
 8012686:	bfb8      	it	lt
 8012688:	4613      	movlt	r3, r2
 801268a:	f8c9 3000 	str.w	r3, [r9]
 801268e:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8012692:	4606      	mov	r6, r0
 8012694:	460c      	mov	r4, r1
 8012696:	b112      	cbz	r2, 801269e <_printf_common+0x2a>
 8012698:	3301      	adds	r3, #1
 801269a:	f8c9 3000 	str.w	r3, [r9]
 801269e:	6823      	ldr	r3, [r4, #0]
 80126a0:	0699      	lsls	r1, r3, #26
 80126a2:	bf42      	ittt	mi
 80126a4:	f8d9 3000 	ldrmi.w	r3, [r9]
 80126a8:	3302      	addmi	r3, #2
 80126aa:	f8c9 3000 	strmi.w	r3, [r9]
 80126ae:	6825      	ldr	r5, [r4, #0]
 80126b0:	f015 0506 	ands.w	r5, r5, #6
 80126b4:	d107      	bne.n	80126c6 <_printf_common+0x52>
 80126b6:	f104 0a19 	add.w	sl, r4, #25
 80126ba:	68e3      	ldr	r3, [r4, #12]
 80126bc:	f8d9 2000 	ldr.w	r2, [r9]
 80126c0:	1a9b      	subs	r3, r3, r2
 80126c2:	429d      	cmp	r5, r3
 80126c4:	db29      	blt.n	801271a <_printf_common+0xa6>
 80126c6:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80126ca:	6822      	ldr	r2, [r4, #0]
 80126cc:	3300      	adds	r3, #0
 80126ce:	bf18      	it	ne
 80126d0:	2301      	movne	r3, #1
 80126d2:	0692      	lsls	r2, r2, #26
 80126d4:	d42e      	bmi.n	8012734 <_printf_common+0xc0>
 80126d6:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80126da:	4639      	mov	r1, r7
 80126dc:	4630      	mov	r0, r6
 80126de:	47c0      	blx	r8
 80126e0:	3001      	adds	r0, #1
 80126e2:	d021      	beq.n	8012728 <_printf_common+0xb4>
 80126e4:	6823      	ldr	r3, [r4, #0]
 80126e6:	68e5      	ldr	r5, [r4, #12]
 80126e8:	f8d9 2000 	ldr.w	r2, [r9]
 80126ec:	f003 0306 	and.w	r3, r3, #6
 80126f0:	2b04      	cmp	r3, #4
 80126f2:	bf08      	it	eq
 80126f4:	1aad      	subeq	r5, r5, r2
 80126f6:	68a3      	ldr	r3, [r4, #8]
 80126f8:	6922      	ldr	r2, [r4, #16]
 80126fa:	bf0c      	ite	eq
 80126fc:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8012700:	2500      	movne	r5, #0
 8012702:	4293      	cmp	r3, r2
 8012704:	bfc4      	itt	gt
 8012706:	1a9b      	subgt	r3, r3, r2
 8012708:	18ed      	addgt	r5, r5, r3
 801270a:	f04f 0900 	mov.w	r9, #0
 801270e:	341a      	adds	r4, #26
 8012710:	454d      	cmp	r5, r9
 8012712:	d11b      	bne.n	801274c <_printf_common+0xd8>
 8012714:	2000      	movs	r0, #0
 8012716:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801271a:	2301      	movs	r3, #1
 801271c:	4652      	mov	r2, sl
 801271e:	4639      	mov	r1, r7
 8012720:	4630      	mov	r0, r6
 8012722:	47c0      	blx	r8
 8012724:	3001      	adds	r0, #1
 8012726:	d103      	bne.n	8012730 <_printf_common+0xbc>
 8012728:	f04f 30ff 	mov.w	r0, #4294967295
 801272c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012730:	3501      	adds	r5, #1
 8012732:	e7c2      	b.n	80126ba <_printf_common+0x46>
 8012734:	18e1      	adds	r1, r4, r3
 8012736:	1c5a      	adds	r2, r3, #1
 8012738:	2030      	movs	r0, #48	; 0x30
 801273a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801273e:	4422      	add	r2, r4
 8012740:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8012744:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8012748:	3302      	adds	r3, #2
 801274a:	e7c4      	b.n	80126d6 <_printf_common+0x62>
 801274c:	2301      	movs	r3, #1
 801274e:	4622      	mov	r2, r4
 8012750:	4639      	mov	r1, r7
 8012752:	4630      	mov	r0, r6
 8012754:	47c0      	blx	r8
 8012756:	3001      	adds	r0, #1
 8012758:	d0e6      	beq.n	8012728 <_printf_common+0xb4>
 801275a:	f109 0901 	add.w	r9, r9, #1
 801275e:	e7d7      	b.n	8012710 <_printf_common+0x9c>

08012760 <_printf_i>:
 8012760:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012764:	4617      	mov	r7, r2
 8012766:	7e0a      	ldrb	r2, [r1, #24]
 8012768:	b085      	sub	sp, #20
 801276a:	2a6e      	cmp	r2, #110	; 0x6e
 801276c:	4698      	mov	r8, r3
 801276e:	4606      	mov	r6, r0
 8012770:	460c      	mov	r4, r1
 8012772:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012774:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 8012778:	f000 80bc 	beq.w	80128f4 <_printf_i+0x194>
 801277c:	d81a      	bhi.n	80127b4 <_printf_i+0x54>
 801277e:	2a63      	cmp	r2, #99	; 0x63
 8012780:	d02e      	beq.n	80127e0 <_printf_i+0x80>
 8012782:	d80a      	bhi.n	801279a <_printf_i+0x3a>
 8012784:	2a00      	cmp	r2, #0
 8012786:	f000 80c8 	beq.w	801291a <_printf_i+0x1ba>
 801278a:	2a58      	cmp	r2, #88	; 0x58
 801278c:	f000 808a 	beq.w	80128a4 <_printf_i+0x144>
 8012790:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8012794:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 8012798:	e02a      	b.n	80127f0 <_printf_i+0x90>
 801279a:	2a64      	cmp	r2, #100	; 0x64
 801279c:	d001      	beq.n	80127a2 <_printf_i+0x42>
 801279e:	2a69      	cmp	r2, #105	; 0x69
 80127a0:	d1f6      	bne.n	8012790 <_printf_i+0x30>
 80127a2:	6821      	ldr	r1, [r4, #0]
 80127a4:	681a      	ldr	r2, [r3, #0]
 80127a6:	f011 0f80 	tst.w	r1, #128	; 0x80
 80127aa:	d023      	beq.n	80127f4 <_printf_i+0x94>
 80127ac:	1d11      	adds	r1, r2, #4
 80127ae:	6019      	str	r1, [r3, #0]
 80127b0:	6813      	ldr	r3, [r2, #0]
 80127b2:	e027      	b.n	8012804 <_printf_i+0xa4>
 80127b4:	2a73      	cmp	r2, #115	; 0x73
 80127b6:	f000 80b4 	beq.w	8012922 <_printf_i+0x1c2>
 80127ba:	d808      	bhi.n	80127ce <_printf_i+0x6e>
 80127bc:	2a6f      	cmp	r2, #111	; 0x6f
 80127be:	d02a      	beq.n	8012816 <_printf_i+0xb6>
 80127c0:	2a70      	cmp	r2, #112	; 0x70
 80127c2:	d1e5      	bne.n	8012790 <_printf_i+0x30>
 80127c4:	680a      	ldr	r2, [r1, #0]
 80127c6:	f042 0220 	orr.w	r2, r2, #32
 80127ca:	600a      	str	r2, [r1, #0]
 80127cc:	e003      	b.n	80127d6 <_printf_i+0x76>
 80127ce:	2a75      	cmp	r2, #117	; 0x75
 80127d0:	d021      	beq.n	8012816 <_printf_i+0xb6>
 80127d2:	2a78      	cmp	r2, #120	; 0x78
 80127d4:	d1dc      	bne.n	8012790 <_printf_i+0x30>
 80127d6:	2278      	movs	r2, #120	; 0x78
 80127d8:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 80127dc:	496e      	ldr	r1, [pc, #440]	; (8012998 <_printf_i+0x238>)
 80127de:	e064      	b.n	80128aa <_printf_i+0x14a>
 80127e0:	681a      	ldr	r2, [r3, #0]
 80127e2:	f101 0542 	add.w	r5, r1, #66	; 0x42
 80127e6:	1d11      	adds	r1, r2, #4
 80127e8:	6019      	str	r1, [r3, #0]
 80127ea:	6813      	ldr	r3, [r2, #0]
 80127ec:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80127f0:	2301      	movs	r3, #1
 80127f2:	e0a3      	b.n	801293c <_printf_i+0x1dc>
 80127f4:	f011 0f40 	tst.w	r1, #64	; 0x40
 80127f8:	f102 0104 	add.w	r1, r2, #4
 80127fc:	6019      	str	r1, [r3, #0]
 80127fe:	d0d7      	beq.n	80127b0 <_printf_i+0x50>
 8012800:	f9b2 3000 	ldrsh.w	r3, [r2]
 8012804:	2b00      	cmp	r3, #0
 8012806:	da03      	bge.n	8012810 <_printf_i+0xb0>
 8012808:	222d      	movs	r2, #45	; 0x2d
 801280a:	425b      	negs	r3, r3
 801280c:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8012810:	4962      	ldr	r1, [pc, #392]	; (801299c <_printf_i+0x23c>)
 8012812:	220a      	movs	r2, #10
 8012814:	e017      	b.n	8012846 <_printf_i+0xe6>
 8012816:	6820      	ldr	r0, [r4, #0]
 8012818:	6819      	ldr	r1, [r3, #0]
 801281a:	f010 0f80 	tst.w	r0, #128	; 0x80
 801281e:	d003      	beq.n	8012828 <_printf_i+0xc8>
 8012820:	1d08      	adds	r0, r1, #4
 8012822:	6018      	str	r0, [r3, #0]
 8012824:	680b      	ldr	r3, [r1, #0]
 8012826:	e006      	b.n	8012836 <_printf_i+0xd6>
 8012828:	f010 0f40 	tst.w	r0, #64	; 0x40
 801282c:	f101 0004 	add.w	r0, r1, #4
 8012830:	6018      	str	r0, [r3, #0]
 8012832:	d0f7      	beq.n	8012824 <_printf_i+0xc4>
 8012834:	880b      	ldrh	r3, [r1, #0]
 8012836:	4959      	ldr	r1, [pc, #356]	; (801299c <_printf_i+0x23c>)
 8012838:	2a6f      	cmp	r2, #111	; 0x6f
 801283a:	bf14      	ite	ne
 801283c:	220a      	movne	r2, #10
 801283e:	2208      	moveq	r2, #8
 8012840:	2000      	movs	r0, #0
 8012842:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8012846:	6865      	ldr	r5, [r4, #4]
 8012848:	60a5      	str	r5, [r4, #8]
 801284a:	2d00      	cmp	r5, #0
 801284c:	f2c0 809c 	blt.w	8012988 <_printf_i+0x228>
 8012850:	6820      	ldr	r0, [r4, #0]
 8012852:	f020 0004 	bic.w	r0, r0, #4
 8012856:	6020      	str	r0, [r4, #0]
 8012858:	2b00      	cmp	r3, #0
 801285a:	d13f      	bne.n	80128dc <_printf_i+0x17c>
 801285c:	2d00      	cmp	r5, #0
 801285e:	f040 8095 	bne.w	801298c <_printf_i+0x22c>
 8012862:	4675      	mov	r5, lr
 8012864:	2a08      	cmp	r2, #8
 8012866:	d10b      	bne.n	8012880 <_printf_i+0x120>
 8012868:	6823      	ldr	r3, [r4, #0]
 801286a:	07da      	lsls	r2, r3, #31
 801286c:	d508      	bpl.n	8012880 <_printf_i+0x120>
 801286e:	6923      	ldr	r3, [r4, #16]
 8012870:	6862      	ldr	r2, [r4, #4]
 8012872:	429a      	cmp	r2, r3
 8012874:	bfde      	ittt	le
 8012876:	2330      	movle	r3, #48	; 0x30
 8012878:	f805 3c01 	strble.w	r3, [r5, #-1]
 801287c:	f105 35ff 	addle.w	r5, r5, #4294967295
 8012880:	ebae 0305 	sub.w	r3, lr, r5
 8012884:	6123      	str	r3, [r4, #16]
 8012886:	f8cd 8000 	str.w	r8, [sp]
 801288a:	463b      	mov	r3, r7
 801288c:	aa03      	add	r2, sp, #12
 801288e:	4621      	mov	r1, r4
 8012890:	4630      	mov	r0, r6
 8012892:	f7ff feef 	bl	8012674 <_printf_common>
 8012896:	3001      	adds	r0, #1
 8012898:	d155      	bne.n	8012946 <_printf_i+0x1e6>
 801289a:	f04f 30ff 	mov.w	r0, #4294967295
 801289e:	b005      	add	sp, #20
 80128a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80128a4:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 80128a8:	493c      	ldr	r1, [pc, #240]	; (801299c <_printf_i+0x23c>)
 80128aa:	6822      	ldr	r2, [r4, #0]
 80128ac:	6818      	ldr	r0, [r3, #0]
 80128ae:	f012 0f80 	tst.w	r2, #128	; 0x80
 80128b2:	f100 0504 	add.w	r5, r0, #4
 80128b6:	601d      	str	r5, [r3, #0]
 80128b8:	d001      	beq.n	80128be <_printf_i+0x15e>
 80128ba:	6803      	ldr	r3, [r0, #0]
 80128bc:	e002      	b.n	80128c4 <_printf_i+0x164>
 80128be:	0655      	lsls	r5, r2, #25
 80128c0:	d5fb      	bpl.n	80128ba <_printf_i+0x15a>
 80128c2:	8803      	ldrh	r3, [r0, #0]
 80128c4:	07d0      	lsls	r0, r2, #31
 80128c6:	bf44      	itt	mi
 80128c8:	f042 0220 	orrmi.w	r2, r2, #32
 80128cc:	6022      	strmi	r2, [r4, #0]
 80128ce:	b91b      	cbnz	r3, 80128d8 <_printf_i+0x178>
 80128d0:	6822      	ldr	r2, [r4, #0]
 80128d2:	f022 0220 	bic.w	r2, r2, #32
 80128d6:	6022      	str	r2, [r4, #0]
 80128d8:	2210      	movs	r2, #16
 80128da:	e7b1      	b.n	8012840 <_printf_i+0xe0>
 80128dc:	4675      	mov	r5, lr
 80128de:	fbb3 f0f2 	udiv	r0, r3, r2
 80128e2:	fb02 3310 	mls	r3, r2, r0, r3
 80128e6:	5ccb      	ldrb	r3, [r1, r3]
 80128e8:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80128ec:	4603      	mov	r3, r0
 80128ee:	2800      	cmp	r0, #0
 80128f0:	d1f5      	bne.n	80128de <_printf_i+0x17e>
 80128f2:	e7b7      	b.n	8012864 <_printf_i+0x104>
 80128f4:	6808      	ldr	r0, [r1, #0]
 80128f6:	681a      	ldr	r2, [r3, #0]
 80128f8:	6949      	ldr	r1, [r1, #20]
 80128fa:	f010 0f80 	tst.w	r0, #128	; 0x80
 80128fe:	d004      	beq.n	801290a <_printf_i+0x1aa>
 8012900:	1d10      	adds	r0, r2, #4
 8012902:	6018      	str	r0, [r3, #0]
 8012904:	6813      	ldr	r3, [r2, #0]
 8012906:	6019      	str	r1, [r3, #0]
 8012908:	e007      	b.n	801291a <_printf_i+0x1ba>
 801290a:	f010 0f40 	tst.w	r0, #64	; 0x40
 801290e:	f102 0004 	add.w	r0, r2, #4
 8012912:	6018      	str	r0, [r3, #0]
 8012914:	6813      	ldr	r3, [r2, #0]
 8012916:	d0f6      	beq.n	8012906 <_printf_i+0x1a6>
 8012918:	8019      	strh	r1, [r3, #0]
 801291a:	2300      	movs	r3, #0
 801291c:	6123      	str	r3, [r4, #16]
 801291e:	4675      	mov	r5, lr
 8012920:	e7b1      	b.n	8012886 <_printf_i+0x126>
 8012922:	681a      	ldr	r2, [r3, #0]
 8012924:	1d11      	adds	r1, r2, #4
 8012926:	6019      	str	r1, [r3, #0]
 8012928:	6815      	ldr	r5, [r2, #0]
 801292a:	6862      	ldr	r2, [r4, #4]
 801292c:	2100      	movs	r1, #0
 801292e:	4628      	mov	r0, r5
 8012930:	f7ed fc66 	bl	8000200 <memchr>
 8012934:	b108      	cbz	r0, 801293a <_printf_i+0x1da>
 8012936:	1b40      	subs	r0, r0, r5
 8012938:	6060      	str	r0, [r4, #4]
 801293a:	6863      	ldr	r3, [r4, #4]
 801293c:	6123      	str	r3, [r4, #16]
 801293e:	2300      	movs	r3, #0
 8012940:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8012944:	e79f      	b.n	8012886 <_printf_i+0x126>
 8012946:	6923      	ldr	r3, [r4, #16]
 8012948:	462a      	mov	r2, r5
 801294a:	4639      	mov	r1, r7
 801294c:	4630      	mov	r0, r6
 801294e:	47c0      	blx	r8
 8012950:	3001      	adds	r0, #1
 8012952:	d0a2      	beq.n	801289a <_printf_i+0x13a>
 8012954:	6823      	ldr	r3, [r4, #0]
 8012956:	079b      	lsls	r3, r3, #30
 8012958:	d507      	bpl.n	801296a <_printf_i+0x20a>
 801295a:	2500      	movs	r5, #0
 801295c:	f104 0919 	add.w	r9, r4, #25
 8012960:	68e3      	ldr	r3, [r4, #12]
 8012962:	9a03      	ldr	r2, [sp, #12]
 8012964:	1a9b      	subs	r3, r3, r2
 8012966:	429d      	cmp	r5, r3
 8012968:	db05      	blt.n	8012976 <_printf_i+0x216>
 801296a:	68e0      	ldr	r0, [r4, #12]
 801296c:	9b03      	ldr	r3, [sp, #12]
 801296e:	4298      	cmp	r0, r3
 8012970:	bfb8      	it	lt
 8012972:	4618      	movlt	r0, r3
 8012974:	e793      	b.n	801289e <_printf_i+0x13e>
 8012976:	2301      	movs	r3, #1
 8012978:	464a      	mov	r2, r9
 801297a:	4639      	mov	r1, r7
 801297c:	4630      	mov	r0, r6
 801297e:	47c0      	blx	r8
 8012980:	3001      	adds	r0, #1
 8012982:	d08a      	beq.n	801289a <_printf_i+0x13a>
 8012984:	3501      	adds	r5, #1
 8012986:	e7eb      	b.n	8012960 <_printf_i+0x200>
 8012988:	2b00      	cmp	r3, #0
 801298a:	d1a7      	bne.n	80128dc <_printf_i+0x17c>
 801298c:	780b      	ldrb	r3, [r1, #0]
 801298e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8012992:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8012996:	e765      	b.n	8012864 <_printf_i+0x104>
 8012998:	0801f666 	.word	0x0801f666
 801299c:	0801f655 	.word	0x0801f655

080129a0 <memmove>:
 80129a0:	4288      	cmp	r0, r1
 80129a2:	b510      	push	{r4, lr}
 80129a4:	eb01 0302 	add.w	r3, r1, r2
 80129a8:	d803      	bhi.n	80129b2 <memmove+0x12>
 80129aa:	1e42      	subs	r2, r0, #1
 80129ac:	4299      	cmp	r1, r3
 80129ae:	d10c      	bne.n	80129ca <memmove+0x2a>
 80129b0:	bd10      	pop	{r4, pc}
 80129b2:	4298      	cmp	r0, r3
 80129b4:	d2f9      	bcs.n	80129aa <memmove+0xa>
 80129b6:	1881      	adds	r1, r0, r2
 80129b8:	1ad2      	subs	r2, r2, r3
 80129ba:	42d3      	cmn	r3, r2
 80129bc:	d100      	bne.n	80129c0 <memmove+0x20>
 80129be:	bd10      	pop	{r4, pc}
 80129c0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80129c4:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80129c8:	e7f7      	b.n	80129ba <memmove+0x1a>
 80129ca:	f811 4b01 	ldrb.w	r4, [r1], #1
 80129ce:	f802 4f01 	strb.w	r4, [r2, #1]!
 80129d2:	e7eb      	b.n	80129ac <memmove+0xc>

080129d4 <_free_r>:
 80129d4:	b538      	push	{r3, r4, r5, lr}
 80129d6:	4605      	mov	r5, r0
 80129d8:	2900      	cmp	r1, #0
 80129da:	d045      	beq.n	8012a68 <_free_r+0x94>
 80129dc:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80129e0:	1f0c      	subs	r4, r1, #4
 80129e2:	2b00      	cmp	r3, #0
 80129e4:	bfb8      	it	lt
 80129e6:	18e4      	addlt	r4, r4, r3
 80129e8:	f000 f8d6 	bl	8012b98 <__malloc_lock>
 80129ec:	4a1f      	ldr	r2, [pc, #124]	; (8012a6c <_free_r+0x98>)
 80129ee:	6813      	ldr	r3, [r2, #0]
 80129f0:	4610      	mov	r0, r2
 80129f2:	b933      	cbnz	r3, 8012a02 <_free_r+0x2e>
 80129f4:	6063      	str	r3, [r4, #4]
 80129f6:	6014      	str	r4, [r2, #0]
 80129f8:	4628      	mov	r0, r5
 80129fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80129fe:	f000 b8cc 	b.w	8012b9a <__malloc_unlock>
 8012a02:	42a3      	cmp	r3, r4
 8012a04:	d90c      	bls.n	8012a20 <_free_r+0x4c>
 8012a06:	6821      	ldr	r1, [r4, #0]
 8012a08:	1862      	adds	r2, r4, r1
 8012a0a:	4293      	cmp	r3, r2
 8012a0c:	bf04      	itt	eq
 8012a0e:	681a      	ldreq	r2, [r3, #0]
 8012a10:	685b      	ldreq	r3, [r3, #4]
 8012a12:	6063      	str	r3, [r4, #4]
 8012a14:	bf04      	itt	eq
 8012a16:	1852      	addeq	r2, r2, r1
 8012a18:	6022      	streq	r2, [r4, #0]
 8012a1a:	6004      	str	r4, [r0, #0]
 8012a1c:	e7ec      	b.n	80129f8 <_free_r+0x24>
 8012a1e:	4613      	mov	r3, r2
 8012a20:	685a      	ldr	r2, [r3, #4]
 8012a22:	b10a      	cbz	r2, 8012a28 <_free_r+0x54>
 8012a24:	42a2      	cmp	r2, r4
 8012a26:	d9fa      	bls.n	8012a1e <_free_r+0x4a>
 8012a28:	6819      	ldr	r1, [r3, #0]
 8012a2a:	1858      	adds	r0, r3, r1
 8012a2c:	42a0      	cmp	r0, r4
 8012a2e:	d10b      	bne.n	8012a48 <_free_r+0x74>
 8012a30:	6820      	ldr	r0, [r4, #0]
 8012a32:	4401      	add	r1, r0
 8012a34:	1858      	adds	r0, r3, r1
 8012a36:	4282      	cmp	r2, r0
 8012a38:	6019      	str	r1, [r3, #0]
 8012a3a:	d1dd      	bne.n	80129f8 <_free_r+0x24>
 8012a3c:	6810      	ldr	r0, [r2, #0]
 8012a3e:	6852      	ldr	r2, [r2, #4]
 8012a40:	605a      	str	r2, [r3, #4]
 8012a42:	4401      	add	r1, r0
 8012a44:	6019      	str	r1, [r3, #0]
 8012a46:	e7d7      	b.n	80129f8 <_free_r+0x24>
 8012a48:	d902      	bls.n	8012a50 <_free_r+0x7c>
 8012a4a:	230c      	movs	r3, #12
 8012a4c:	602b      	str	r3, [r5, #0]
 8012a4e:	e7d3      	b.n	80129f8 <_free_r+0x24>
 8012a50:	6820      	ldr	r0, [r4, #0]
 8012a52:	1821      	adds	r1, r4, r0
 8012a54:	428a      	cmp	r2, r1
 8012a56:	bf04      	itt	eq
 8012a58:	6811      	ldreq	r1, [r2, #0]
 8012a5a:	6852      	ldreq	r2, [r2, #4]
 8012a5c:	6062      	str	r2, [r4, #4]
 8012a5e:	bf04      	itt	eq
 8012a60:	1809      	addeq	r1, r1, r0
 8012a62:	6021      	streq	r1, [r4, #0]
 8012a64:	605c      	str	r4, [r3, #4]
 8012a66:	e7c7      	b.n	80129f8 <_free_r+0x24>
 8012a68:	bd38      	pop	{r3, r4, r5, pc}
 8012a6a:	bf00      	nop
 8012a6c:	20084b7c 	.word	0x20084b7c

08012a70 <_malloc_r>:
 8012a70:	b570      	push	{r4, r5, r6, lr}
 8012a72:	1ccd      	adds	r5, r1, #3
 8012a74:	f025 0503 	bic.w	r5, r5, #3
 8012a78:	3508      	adds	r5, #8
 8012a7a:	2d0c      	cmp	r5, #12
 8012a7c:	bf38      	it	cc
 8012a7e:	250c      	movcc	r5, #12
 8012a80:	2d00      	cmp	r5, #0
 8012a82:	4606      	mov	r6, r0
 8012a84:	db01      	blt.n	8012a8a <_malloc_r+0x1a>
 8012a86:	42a9      	cmp	r1, r5
 8012a88:	d903      	bls.n	8012a92 <_malloc_r+0x22>
 8012a8a:	230c      	movs	r3, #12
 8012a8c:	6033      	str	r3, [r6, #0]
 8012a8e:	2000      	movs	r0, #0
 8012a90:	bd70      	pop	{r4, r5, r6, pc}
 8012a92:	f000 f881 	bl	8012b98 <__malloc_lock>
 8012a96:	4a23      	ldr	r2, [pc, #140]	; (8012b24 <_malloc_r+0xb4>)
 8012a98:	6814      	ldr	r4, [r2, #0]
 8012a9a:	4621      	mov	r1, r4
 8012a9c:	b991      	cbnz	r1, 8012ac4 <_malloc_r+0x54>
 8012a9e:	4c22      	ldr	r4, [pc, #136]	; (8012b28 <_malloc_r+0xb8>)
 8012aa0:	6823      	ldr	r3, [r4, #0]
 8012aa2:	b91b      	cbnz	r3, 8012aac <_malloc_r+0x3c>
 8012aa4:	4630      	mov	r0, r6
 8012aa6:	f000 f867 	bl	8012b78 <_sbrk_r>
 8012aaa:	6020      	str	r0, [r4, #0]
 8012aac:	4629      	mov	r1, r5
 8012aae:	4630      	mov	r0, r6
 8012ab0:	f000 f862 	bl	8012b78 <_sbrk_r>
 8012ab4:	1c43      	adds	r3, r0, #1
 8012ab6:	d126      	bne.n	8012b06 <_malloc_r+0x96>
 8012ab8:	230c      	movs	r3, #12
 8012aba:	6033      	str	r3, [r6, #0]
 8012abc:	4630      	mov	r0, r6
 8012abe:	f000 f86c 	bl	8012b9a <__malloc_unlock>
 8012ac2:	e7e4      	b.n	8012a8e <_malloc_r+0x1e>
 8012ac4:	680b      	ldr	r3, [r1, #0]
 8012ac6:	1b5b      	subs	r3, r3, r5
 8012ac8:	d41a      	bmi.n	8012b00 <_malloc_r+0x90>
 8012aca:	2b0b      	cmp	r3, #11
 8012acc:	d90f      	bls.n	8012aee <_malloc_r+0x7e>
 8012ace:	600b      	str	r3, [r1, #0]
 8012ad0:	50cd      	str	r5, [r1, r3]
 8012ad2:	18cc      	adds	r4, r1, r3
 8012ad4:	4630      	mov	r0, r6
 8012ad6:	f000 f860 	bl	8012b9a <__malloc_unlock>
 8012ada:	f104 000b 	add.w	r0, r4, #11
 8012ade:	1d23      	adds	r3, r4, #4
 8012ae0:	f020 0007 	bic.w	r0, r0, #7
 8012ae4:	1ac3      	subs	r3, r0, r3
 8012ae6:	d01b      	beq.n	8012b20 <_malloc_r+0xb0>
 8012ae8:	425a      	negs	r2, r3
 8012aea:	50e2      	str	r2, [r4, r3]
 8012aec:	bd70      	pop	{r4, r5, r6, pc}
 8012aee:	428c      	cmp	r4, r1
 8012af0:	bf0d      	iteet	eq
 8012af2:	6863      	ldreq	r3, [r4, #4]
 8012af4:	684b      	ldrne	r3, [r1, #4]
 8012af6:	6063      	strne	r3, [r4, #4]
 8012af8:	6013      	streq	r3, [r2, #0]
 8012afa:	bf18      	it	ne
 8012afc:	460c      	movne	r4, r1
 8012afe:	e7e9      	b.n	8012ad4 <_malloc_r+0x64>
 8012b00:	460c      	mov	r4, r1
 8012b02:	6849      	ldr	r1, [r1, #4]
 8012b04:	e7ca      	b.n	8012a9c <_malloc_r+0x2c>
 8012b06:	1cc4      	adds	r4, r0, #3
 8012b08:	f024 0403 	bic.w	r4, r4, #3
 8012b0c:	42a0      	cmp	r0, r4
 8012b0e:	d005      	beq.n	8012b1c <_malloc_r+0xac>
 8012b10:	1a21      	subs	r1, r4, r0
 8012b12:	4630      	mov	r0, r6
 8012b14:	f000 f830 	bl	8012b78 <_sbrk_r>
 8012b18:	3001      	adds	r0, #1
 8012b1a:	d0cd      	beq.n	8012ab8 <_malloc_r+0x48>
 8012b1c:	6025      	str	r5, [r4, #0]
 8012b1e:	e7d9      	b.n	8012ad4 <_malloc_r+0x64>
 8012b20:	bd70      	pop	{r4, r5, r6, pc}
 8012b22:	bf00      	nop
 8012b24:	20084b7c 	.word	0x20084b7c
 8012b28:	20084b80 	.word	0x20084b80

08012b2c <_realloc_r>:
 8012b2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012b2e:	4607      	mov	r7, r0
 8012b30:	4614      	mov	r4, r2
 8012b32:	460e      	mov	r6, r1
 8012b34:	b921      	cbnz	r1, 8012b40 <_realloc_r+0x14>
 8012b36:	4611      	mov	r1, r2
 8012b38:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8012b3c:	f7ff bf98 	b.w	8012a70 <_malloc_r>
 8012b40:	b922      	cbnz	r2, 8012b4c <_realloc_r+0x20>
 8012b42:	f7ff ff47 	bl	80129d4 <_free_r>
 8012b46:	4625      	mov	r5, r4
 8012b48:	4628      	mov	r0, r5
 8012b4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012b4c:	f000 f826 	bl	8012b9c <_malloc_usable_size_r>
 8012b50:	4284      	cmp	r4, r0
 8012b52:	d90f      	bls.n	8012b74 <_realloc_r+0x48>
 8012b54:	4621      	mov	r1, r4
 8012b56:	4638      	mov	r0, r7
 8012b58:	f7ff ff8a 	bl	8012a70 <_malloc_r>
 8012b5c:	4605      	mov	r5, r0
 8012b5e:	2800      	cmp	r0, #0
 8012b60:	d0f2      	beq.n	8012b48 <_realloc_r+0x1c>
 8012b62:	4631      	mov	r1, r6
 8012b64:	4622      	mov	r2, r4
 8012b66:	f7ff fc05 	bl	8012374 <memcpy>
 8012b6a:	4631      	mov	r1, r6
 8012b6c:	4638      	mov	r0, r7
 8012b6e:	f7ff ff31 	bl	80129d4 <_free_r>
 8012b72:	e7e9      	b.n	8012b48 <_realloc_r+0x1c>
 8012b74:	4635      	mov	r5, r6
 8012b76:	e7e7      	b.n	8012b48 <_realloc_r+0x1c>

08012b78 <_sbrk_r>:
 8012b78:	b538      	push	{r3, r4, r5, lr}
 8012b7a:	4c06      	ldr	r4, [pc, #24]	; (8012b94 <_sbrk_r+0x1c>)
 8012b7c:	2300      	movs	r3, #0
 8012b7e:	4605      	mov	r5, r0
 8012b80:	4608      	mov	r0, r1
 8012b82:	6023      	str	r3, [r4, #0]
 8012b84:	f7ff f932 	bl	8011dec <_sbrk>
 8012b88:	1c43      	adds	r3, r0, #1
 8012b8a:	d102      	bne.n	8012b92 <_sbrk_r+0x1a>
 8012b8c:	6823      	ldr	r3, [r4, #0]
 8012b8e:	b103      	cbz	r3, 8012b92 <_sbrk_r+0x1a>
 8012b90:	602b      	str	r3, [r5, #0]
 8012b92:	bd38      	pop	{r3, r4, r5, pc}
 8012b94:	200866a8 	.word	0x200866a8

08012b98 <__malloc_lock>:
 8012b98:	4770      	bx	lr

08012b9a <__malloc_unlock>:
 8012b9a:	4770      	bx	lr

08012b9c <_malloc_usable_size_r>:
 8012b9c:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8012ba0:	2800      	cmp	r0, #0
 8012ba2:	f1a0 0004 	sub.w	r0, r0, #4
 8012ba6:	bfbc      	itt	lt
 8012ba8:	580b      	ldrlt	r3, [r1, r0]
 8012baa:	18c0      	addlt	r0, r0, r3
 8012bac:	4770      	bx	lr
	...

08012bb0 <_init>:
 8012bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012bb2:	bf00      	nop
 8012bb4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8012bb6:	bc08      	pop	{r3}
 8012bb8:	469e      	mov	lr, r3
 8012bba:	4770      	bx	lr

08012bbc <_fini>:
 8012bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012bbe:	bf00      	nop
 8012bc0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8012bc2:	bc08      	pop	{r3}
 8012bc4:	469e      	mov	lr, r3
 8012bc6:	4770      	bx	lr
